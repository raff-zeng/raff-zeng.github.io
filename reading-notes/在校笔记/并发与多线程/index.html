<!DOCTYPE html>
<html lang="zh" dir="ltr">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="并发与多线程 笔记参考: https://blog.csdn.net/qq_38231713/article/details/106091597\n代码参考: https://github.com/yunxijun/cpp11_multithread/blob/master/main.cpp\nB站https://www.bilibili.com/video/BV1Yb411L7ak?p=1&amp;vd_source=f8705e057957dafd33c98d31eb54e3cd\n第一节 并发基本概念及实现，进程、线程基本概念 （1）并发、进程、线程的基本概念和综述 并发，线程，进程要求必须掌握\n1.1 并发 两个或者更多的任务（独立的活动）同时发生（进行）：一个程序同时执行多个独立的任务；\n以往计算机，单核cpu（中央处理器）：某一个时刻只能执行一个任务，由操作系统调度，每秒钟进行多次所谓的“任务切换”。\n并发的假象（不是真正的并发），切换（上下文切换）时要保存变量的状态、执行进度等，切换回来时需要复原存在时间开销；\n随着硬件发展，出现了多处理器计算机：用于服务器和高性能计算领域。台式机：在一块芯片上有多核（一个CPU内有多个运算核心，对于操作系统来说，每个核心都是作为单独的CPU对待的）：双核，4核，8核，10核（自己的笔记本是4核8线程的）。能够实现真正的并行执行多个任务（硬件并发）\n使用并发的原因：可以同时干多个事，提高性能\n1.2 可执行程序 磁盘上的一个文件，windows下，扩展名为.exe；linux下，ls -la，rwx（可读可写可执行）\n1.3 进程 运行一个可执行程序，在windows下，可双击；在linux下，./文件名\n进程，一个可执行程序运行起来了，就叫创建了一个进程。进程就是运行起来的可执行程序。\n1.4 线程 a)每个进程（执行起来的可执行程序），都有唯一的一个主线程 b)当执行可执行程序时，产生一个进程后，这个主线程就随着这个进程默默启动起来了\nctrl+F5运行这个程序的时候，实际上是进程的主线程来执行（调用）这个main函数中的代码。主线程和进程同时存在\n线程：用来执行代码的。线程这个东西，可以理解为一条代码的执行通路\n除了主线程之外，可以通过写代码来创建其他线程，其他线程走的是别的道路，甚至去不同的地方\n每创建一个新线程，就可以在同一时刻，多干一个不同的事（多走一条不同的代码执行路径）\n多线程（并发） 线程并不是越多越好，每个线程，都需要一个独立的堆栈空间（大约1M），线程之间的切换要保存很多中间状态，切换也会耗费本该属于程序运行的时间 必须使用多线程的案例\n总结线程: a)线程是用来执行代码的;\nb)把线程这个东西理解成一条代码的执行通路 (道路)，一个新线程代表-条新的通路。\nc)一个进程自动包含一个主线程，主线程随着进程默默的启动并运行，我们可以通过编码来创建多个其他线程(非主线程)\n但是创建的数量最大都不建议超过200-300个， 至于到底多少个合适，大家在实际的项目中可以不断调整和优化，有的时候进程太多的时候效率反而会降低\n">
<title>并发与多线程 学习笔记</title>

<link rel='canonical' href='http://localhost:1313/reading-notes/%E5%9C%A8%E6%A0%A1%E7%AC%94%E8%AE%B0/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/'>

<link rel="stylesheet" href="/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css"><meta property='og:title' content="并发与多线程 学习笔记">
<meta property='og:description' content="并发与多线程 笔记参考: https://blog.csdn.net/qq_38231713/article/details/106091597\n代码参考: https://github.com/yunxijun/cpp11_multithread/blob/master/main.cpp\nB站https://www.bilibili.com/video/BV1Yb411L7ak?p=1&amp;vd_source=f8705e057957dafd33c98d31eb54e3cd\n第一节 并发基本概念及实现，进程、线程基本概念 （1）并发、进程、线程的基本概念和综述 并发，线程，进程要求必须掌握\n1.1 并发 两个或者更多的任务（独立的活动）同时发生（进行）：一个程序同时执行多个独立的任务；\n以往计算机，单核cpu（中央处理器）：某一个时刻只能执行一个任务，由操作系统调度，每秒钟进行多次所谓的“任务切换”。\n并发的假象（不是真正的并发），切换（上下文切换）时要保存变量的状态、执行进度等，切换回来时需要复原存在时间开销；\n随着硬件发展，出现了多处理器计算机：用于服务器和高性能计算领域。台式机：在一块芯片上有多核（一个CPU内有多个运算核心，对于操作系统来说，每个核心都是作为单独的CPU对待的）：双核，4核，8核，10核（自己的笔记本是4核8线程的）。能够实现真正的并行执行多个任务（硬件并发）\n使用并发的原因：可以同时干多个事，提高性能\n1.2 可执行程序 磁盘上的一个文件，windows下，扩展名为.exe；linux下，ls -la，rwx（可读可写可执行）\n1.3 进程 运行一个可执行程序，在windows下，可双击；在linux下，./文件名\n进程，一个可执行程序运行起来了，就叫创建了一个进程。进程就是运行起来的可执行程序。\n1.4 线程 a)每个进程（执行起来的可执行程序），都有唯一的一个主线程 b)当执行可执行程序时，产生一个进程后，这个主线程就随着这个进程默默启动起来了\nctrl+F5运行这个程序的时候，实际上是进程的主线程来执行（调用）这个main函数中的代码。主线程和进程同时存在\n线程：用来执行代码的。线程这个东西，可以理解为一条代码的执行通路\n除了主线程之外，可以通过写代码来创建其他线程，其他线程走的是别的道路，甚至去不同的地方\n每创建一个新线程，就可以在同一时刻，多干一个不同的事（多走一条不同的代码执行路径）\n多线程（并发） 线程并不是越多越好，每个线程，都需要一个独立的堆栈空间（大约1M），线程之间的切换要保存很多中间状态，切换也会耗费本该属于程序运行的时间 必须使用多线程的案例\n总结线程: a)线程是用来执行代码的;\nb)把线程这个东西理解成一条代码的执行通路 (道路)，一个新线程代表-条新的通路。\nc)一个进程自动包含一个主线程，主线程随着进程默默的启动并运行，我们可以通过编码来创建多个其他线程(非主线程)\n但是创建的数量最大都不建议超过200-300个， 至于到底多少个合适，大家在实际的项目中可以不断调整和优化，有的时候进程太多的时候效率反而会降低\n">
<meta property='og:url' content='http://localhost:1313/reading-notes/%E5%9C%A8%E6%A0%A1%E7%AC%94%E8%AE%B0/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/'>
<meta property='og:site_name' content='raff Site'>
<meta property='og:type' content='article'><meta property='article:section' content='Reading-Notes' /><meta property='article:published_time' content='2024-12-16T21:11:00&#43;08:00'/><meta property='article:modified_time' content='2024-12-16T21:11:00&#43;08:00'/>
<meta name="twitter:title" content="并发与多线程 学习笔记">
<meta name="twitter:description" content="并发与多线程 笔记参考: https://blog.csdn.net/qq_38231713/article/details/106091597\n代码参考: https://github.com/yunxijun/cpp11_multithread/blob/master/main.cpp\nB站https://www.bilibili.com/video/BV1Yb411L7ak?p=1&amp;vd_source=f8705e057957dafd33c98d31eb54e3cd\n第一节 并发基本概念及实现，进程、线程基本概念 （1）并发、进程、线程的基本概念和综述 并发，线程，进程要求必须掌握\n1.1 并发 两个或者更多的任务（独立的活动）同时发生（进行）：一个程序同时执行多个独立的任务；\n以往计算机，单核cpu（中央处理器）：某一个时刻只能执行一个任务，由操作系统调度，每秒钟进行多次所谓的“任务切换”。\n并发的假象（不是真正的并发），切换（上下文切换）时要保存变量的状态、执行进度等，切换回来时需要复原存在时间开销；\n随着硬件发展，出现了多处理器计算机：用于服务器和高性能计算领域。台式机：在一块芯片上有多核（一个CPU内有多个运算核心，对于操作系统来说，每个核心都是作为单独的CPU对待的）：双核，4核，8核，10核（自己的笔记本是4核8线程的）。能够实现真正的并行执行多个任务（硬件并发）\n使用并发的原因：可以同时干多个事，提高性能\n1.2 可执行程序 磁盘上的一个文件，windows下，扩展名为.exe；linux下，ls -la，rwx（可读可写可执行）\n1.3 进程 运行一个可执行程序，在windows下，可双击；在linux下，./文件名\n进程，一个可执行程序运行起来了，就叫创建了一个进程。进程就是运行起来的可执行程序。\n1.4 线程 a)每个进程（执行起来的可执行程序），都有唯一的一个主线程 b)当执行可执行程序时，产生一个进程后，这个主线程就随着这个进程默默启动起来了\nctrl+F5运行这个程序的时候，实际上是进程的主线程来执行（调用）这个main函数中的代码。主线程和进程同时存在\n线程：用来执行代码的。线程这个东西，可以理解为一条代码的执行通路\n除了主线程之外，可以通过写代码来创建其他线程，其他线程走的是别的道路，甚至去不同的地方\n每创建一个新线程，就可以在同一时刻，多干一个不同的事（多走一条不同的代码执行路径）\n多线程（并发） 线程并不是越多越好，每个线程，都需要一个独立的堆栈空间（大约1M），线程之间的切换要保存很多中间状态，切换也会耗费本该属于程序运行的时间 必须使用多线程的案例\n总结线程: a)线程是用来执行代码的;\nb)把线程这个东西理解成一条代码的执行通路 (道路)，一个新线程代表-条新的通路。\nc)一个进程自动包含一个主线程，主线程随着进程默默的启动并运行，我们可以通过编码来创建多个其他线程(非主线程)\n但是创建的数量最大都不建议超过200-300个， 至于到底多少个合适，大家在实际的项目中可以不断调整和优化，有的时候进程太多的时候效率反而会降低\n">
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column compact"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu5202140483351697843.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">raff Site</a></h1>
            <h2 class="site-description"></h2>
        </div>
    </header><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/tech-blogs/' >
                
                
                
                <span>技术博客</span>
            </a>
        </li>
        
        
        <li >
            <a href='/reading-notes/' >
                
                
                
                <span>读书笔记</span>
            </a>
        </li>
        
        
        <li >
            <a href='/robot-notes/' >
                
                
                
                <span>机器人笔记</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>Dark Mode</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    

            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/reading-notes/%E5%9C%A8%E6%A0%A1%E7%AC%94%E8%AE%B0/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/">并发与多线程 学习笔记</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Dec 16, 2024</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    15 minute read
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="并发与多线程">并发与多线程
</h1><p>笔记参考: <a class="link" href="https://blog.csdn.net/qq_38231713/article/details/106091597"  target="_blank" rel="noopener"
    >https://blog.csdn.net/qq_38231713/article/details/106091597</a></p>
<p>代码参考: <a class="link" href="https://github.com/yunxijun/cpp11_multithread/blob/master/main.cpp"  target="_blank" rel="noopener"
    >https://github.com/yunxijun/cpp11_multithread/blob/master/main.cpp</a></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><img src="/reading-notes/%e5%9c%a8%e6%a0%a1%e7%ac%94%e8%ae%b0/multi_thread1.jpg"
	
	
	
	loading="lazy"
	
	
>
<img src="/reading-notes/%e5%9c%a8%e6%a0%a1%e7%ac%94%e8%ae%b0/imgs/%e5%b9%b6%e5%8f%91%e4%b8%8e%e5%a4%9a%e7%ba%bf%e7%a8%8b/multi_thread1.jpg"
	
	
	
	loading="lazy"
	
	
></p>
<p>B站https://www.bilibili.com/video/BV1Yb411L7ak?p=1&amp;vd_source=f8705e057957dafd33c98d31eb54e3cd</p>
<h2 id="第一节-并发基本概念及实现进程线程基本概念">第一节 并发基本概念及实现，进程、线程基本概念
</h2><h3 id="1并发进程线程的基本概念和综述">（1）并发、进程、线程的基本概念和综述
</h3><p>并发，线程，进程要求必须掌握</p>
<h4 id="11-并发">1.1 并发
</h4><ul>
<li>
<p>两个或者更多的任务（独立的活动）同时发生（进行）：一个程序同时执行多个独立的任务；</p>
</li>
<li>
<p>以往计算机，单核cpu（中央处理器）：某一个时刻只能执行一个任务，由操作系统调度，每秒钟进行多次所谓的“任务切换”。</p>
<p>并发的假象（不是真正的并发），切换（上下文切换）时要保存变量的状态、执行进度等，切换回来时需要复原存在时间开销；</p>
</li>
<li>
<p>随着硬件发展，出现了多处理器计算机：用于服务器和高性能计算领域。台式机：在一块芯片上有多核（一个CPU内有多个运算核心，对于操作系统来说，每个核心都是作为单独的CPU对待的）：双核，4核，8核，10核（自己的笔记本是4核8线程的）。能够实现真正的并行执行多个任务（硬件并发）</p>
</li>
<li>
<p>使用并发的原因：可以同时干多个事，提高性能</p>
</li>
</ul>
<h4 id="12-可执行程序">1.2 可执行程序
</h4><p>磁盘上的一个文件，windows下，扩展名为.exe；linux下，ls -la，rwx（可读可写可执行）</p>
<h4 id="13-进程">1.3 进程
</h4><p>运行一个可执行程序，在windows下，可双击；在linux下，./文件名</p>
<p>进程，一个可执行程序运行起来了，就叫创建了一个进程。进程就是运行起来的可执行程序。</p>
<h4 id="14-线程">1.4 线程
</h4><p>a)每个进程（执行起来的可执行程序），都有唯一的一个主线程
b)当执行可执行程序时，产生一个进程后，这个主线程就随着这个进程默默启动起来了</p>
<p>ctrl+F5运行这个程序的时候，实际上是进程的主线程来执行（调用）这个main函数中的代码。主线程和进程同时存在</p>
<p>线程：用来执行代码的。线程这个东西，可以理解为一条代码的执行通路</p>
<!-- raw HTML omitted -->
<p>除了主线程之外，可以通过写代码来创建其他线程，其他线程走的是别的道路，甚至去不同的地方</p>
<p>每创建一个新线程，就可以在同一时刻，多干一个不同的事（多走一条不同的代码执行路径）</p>
<p>多线程（并发）
线程并不是越多越好，每个线程，都需要一个独立的堆栈空间（大约1M），线程之间的切换要保存很多中间状态，切换也会耗费本该属于程序运行的时间
必须使用多线程的案例</p>
<!-- raw HTML omitted -->
<h4 id="总结线程">总结线程:
</h4><p>a)线程是用来执行代码的;</p>
<p>b)把线程这个东西理解成一条代码的执行通路 (道路)，一个新线程代表-条新的通路。</p>
<p>c)一个进程自动包含一个主线程，主线程随着进程默默的启动并运行，我们可以通过编码来创建多个其他线程(非主线程)</p>
<p>但是创建的数量最大都不建议超过200-300个， 至于到底多少个合适，大家在实际的项目中可以不断调整和优化，有的时候进程太多的时候效率反而会降低</p>
<p>d)因为主线程是自动启动的，所以一个进程中最少也是有一个线程(主线程)。</p>
<p>e)说白了:多线程程序可以同时干多个事，所以运行效率高。但是到底有多高，并不是一个很容易评估和量化的东西。</p>
<h4 id="15-学习心得">1.5 学习心得
</h4><ul>
<li>开发多线程程序：一个是实力的体现，一个是商用的必须需求</li>
<li>线程开发有一定难度</li>
<li>C++线程会设计很多新概念</li>
<li>网络方向：网络通讯、网络服务器，多线程是绝对绕不开的</li>
</ul>
<h3 id="2并发的实现方法">（2）并发的实现方法
</h3><p>两个或者更多的任务（独立的活动）同时发生（进行）</p>
<p>实现并发的手段：</p>
<p>a）通过多个进程实现并发</p>
<p>b）在单独的进程中，写代码创建除了主线程之外的其他线程来实现并发</p>
<h4 id="21-多进程并发">2.1 多进程并发
</h4><p>比如账号服务器一个进程，游戏逻辑服务器一个进程。</p>
<p>进程之间通信（同一个电脑上：管道，文件，消息队列，共享内存）；（不同电脑上：socket通信技术）</p>
<h4 id="22-多线程并发">2.2 多线程并发
</h4><ul>
<li>
<p>线程：感觉像是轻量级的进程。每个进程有自己独立的运行路径，但<strong>一个进程中的所有线程共享地址空间</strong>（共享内存），全局变量、全局内存、全局指针、全局引用都可以在线程之间传递，所以多线程开销远远小于多进程</p>
<p>共享内存带来新问题，数据一致性问题：线程A和线程B同时写会发生错误。</p>
</li>
<li>
<p>多进程并发和多线程并发可以混合使用，但建议优先考虑多线程技术</p>
</li>
<li>
<p>本课程中只讲多线程并发技术</p>
</li>
</ul>
<h4 id="23-总结">2.3 总结
</h4><p>和进程比，线程如下优点:</p>
<p>(1)线程启动速度更快，更轻量级;</p>
<p>(2)系统资源开销更少，执行速度更快，比如共享内存这种通信方式比任何其他的通信方式都快;</p>
<p>缺点:</p>
<p>(1)使用有-定难度，要小心处理数据的一致性问题;</p>
<h3 id="3c11新标准线程库">（3）C++11新标准线程库
</h3><p>以往</p>
<ul>
<li>
<p>windows：<code>CreateThread(), _beginthread(),_beginthreadexe()</code>创建线程；</p>
<p>linux：<code>pthread_create()</code>创建线程；</p>
<p>以往的多线程代码不能跨平台运行</p>
</li>
<li>
<p>临界区，互斥量</p>
</li>
<li>
<p>POSIX thread(pthread)库:跨平台，但要做一番配置，也不方便</p>
</li>
</ul>
<p>C++11</p>
<ul>
<li>从C++11新标准，C++语言本身增加对多线程的支持，意味着可移植性（跨平台），这大大减少开发人员的工作量</li>
</ul>
<h2 id="第二节-线程启动结束创建线程多法joindetach">第二节 线程启动、结束，创建线程多法、join，detach
</h2><h3 id="1范例演示线程运行的开始">（1）范例演示线程运行的开始
</h3><ul>
<li>程序运行起来，生成一个进程，该进程所属的主线程开始自动运行；当主线程从main（）函数返回，则整个进程执行完毕</li>
<li>主线程从main（）开始执行，那么我们自己创建的线程，也需要从一个函数开始运行（初始函数），一旦这个函数运行完毕，线程也结束运行</li>
<li>整个进程是否执行完毕的标志是：主线程是否执行完，如果主线程执行完毕了，就代表整个进程执行完毕了，此时如果其他子线程还没有执行完，也会被强行终止【此条有例外，以后会解释】</li>
</ul>
<p>创建一个线程：</p>
<ol>
<li>包含头文件thread</li>
<li>写初始函数</li>
<li>在main中创建thread</li>
</ol>
<p>必须要明白：有两个线程在跑，相当于整个程序中有两条线在同时走，即使一条被阻塞，另一条也能运行</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">myPrint</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;我的线程开始运行&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//-------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//-------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;我的线程运行完毕&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//(1)创建了线程，线程执行起点（入口）是myPrint；(2)执行线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">thread</span> myThread(myPrint);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//(2)阻塞主线程并等待myPrint执行完，当myPrint执行完毕，join()就执行完毕，主线程继续往下执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//join意为汇合。阻塞主线程，让主线程等待子线程执行完毕，然后子线程和主线程汇合
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	myThread.join();
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//如果主线程执行完毕了，但子线程没执行完毕，该程序不稳定。应该主线程等待子线程执行完毕后，自己才能最终退出。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//设置断点可看到主线程等待子线程的过程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//F11逐语句，就是每z次执行一行语句，如果碰到函数调用，它就会进入到函数里面
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//F10逐过程，碰到函数时，不进入函数，把函数调用当成一条语句执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//(3)传统多线程程序中，主线程要等待子线程执行完毕，然后自己才能向下执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//detach:分离，主线程不再与子线程汇合，不再等待子线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//detach后，子线程和主线程失去关联，驻留在后台，由C++运行时库接管（守护线程）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//一旦用了detach(),就不能再用join()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//myThread.detach();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//(4)joinable()判断是否可以成功使用join()或者detach()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//如果返回true，证明可以调用join()或者detach()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//如果返回false，证明调用过join()或者detach()，join()和detach()都不能再调用了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (myThread.joinable())
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;可以调用可以调用join()或者detach()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;不能调用可以调用join()或者detach()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Hello World!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>重要补充：</strong>
线程类参数是一个可调用对象。</p>
<p>一组可执行的语句称为可调用对象，c++中的可调用对象可以是<strong>函数、函数指针、lambda表达式、bind创建的对象或者重载了函数调用运算符的类对象</strong>。</p>
<p>用detach</p>
<p>​	不可以使用主线程中局部变量的引用</p>
<p>​	主线程的对象会被拷贝到子线程</p>
<p>二、其他创建线程的方法</p>
<p>①创建一个类，并编写圆括号重载函数，初始化一个该类的对象，把该对象作为线程入口地址</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Ta</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span>()() <span style="color:#75715e">//不能带参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	{
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;我的线程开始运行&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//-------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">//-------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;我的线程运行完毕&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//main函数里的：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	Ta ta;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">thread</span> <span style="color:#a6e22e">myThread</span>(ta);
</span></span><span style="display:flex;"><span>	myThread.join();
</span></span></code></pre></div><p>②lambda表达式创建线程</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//main函数中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> lambdaThread <span style="color:#f92672">=</span> [] {
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;我的线程开始执行了&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//-------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">//-------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;我的线程开始执行了&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">thread</span> <span style="color:#a6e22e">myThread</span>(lambdaThread);
</span></span><span style="display:flex;"><span>	myThread.join();
</span></span></code></pre></div><p>③把某个类中的某个函数作为线程的入口地址</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Data_</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> GetMsg(){}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">SaveMsh</span>(){}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">//main函数里
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Data_ s;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//第一个&amp;意思是取址，第二个&amp;意思是引用，相当于std::ref(s)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//thread oneobj(&amp;Data_::SaveMsh,s)传值也是可以的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//在其他的构造函数中&amp;obj是不会代表引用的，会被当成取地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//调用方式：对象成员函数地址，类实例，[成员函数参数]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//第二个参数可以传递对象s，也可以传递引用std::ref(s)或&amp;s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//传递s，会调用拷贝构造函数在子线程中生成一个新的对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//传递&amp;，子线程中还是用的原来的对象，所以就不能detach，因为主线程运行完毕会把该对象释放掉
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">thread</span> <span style="color:#a6e22e">oneobj</span>(<span style="color:#f92672">&amp;</span>Data_<span style="color:#f92672">::</span>SaveMsh,<span style="color:#f92672">&amp;</span>s);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">thread</span> <span style="color:#a6e22e">twoobj</span>(<span style="color:#f92672">&amp;</span>Data_<span style="color:#f92672">::</span>GetMsg,<span style="color:#f92672">&amp;</span>s);
</span></span><span style="display:flex;"><span>    oneobj.join();
</span></span><span style="display:flex;"><span>    twoobj.join();
</span></span></code></pre></div><h2 id="第三节-线程传参详解detach大坑成员函数做线程函数">第三节 线程传参详解，detach()大坑，成员函数做线程函数
</h2><blockquote>
<p>(1)传递临时对象作为线程参数</p>
<p>​	(1.1)要避免的陷阱(解释1)</p>
<p>​	(1.2)要避免的陷阱(解释2)</p>
<p>​	(1.3)总结</p>
<p>(2)临时对象作为线程参数继续讲</p>
<p>​	(2.1)线程id概念</p>
<p>​	(2.2)临时对象构造时机抓捕</p>
<p>(3)传递类对象、智能指针作为线程参数</p>
<p>(4)用成员函数指针做线程函数</p>
</blockquote>
<h3 id="一传递临时对象作为线程参数">一、传递临时对象作为线程参数
</h3><h4 id="11要避免的陷阱1">1.1要避免的陷阱1
</h4><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">myPrint</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>i, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> pmybuf)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//如果线程从主线程detach了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//i不是mvar真正的引用，实际上值传递，即使主线程中detach了子线程主线程结束了，子线程用i仍然是安全的，但仍不推荐传递引用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//绝不推荐用指针，detach子线程时一定有问题
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//推荐改为const int i
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//pmybuf还是指向原来的字符串，所以这么写是不安全的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> pmybuf <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> mvar <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> mvary <span style="color:#f92672">=</span> mvar;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> mybuf[] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;this is a test&#34;</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">thread</span> myThread(myPrint, mvar, mybuf);<span style="color:#75715e">//第一个参数是函数名，后两个参数是函数的参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	myThread.join();
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//myThread.detach();	//子线程和主线程分别执行。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Hello World!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="12要避免的陷阱2">1.2要避免的陷阱2：
</h4><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">myPrint</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> pmybuf)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> pmybuf <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> mvar <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> mvary <span style="color:#f92672">=</span> mvar;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> mybuf[] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;this is a test&#34;</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//如果detach了，这样仍然是不安全的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//因为存在主线程运行完了，mybuf被回收了，系统采用mybuf隐式类型转换成string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//推荐先创建一个临时对象thread myThread(myPrint, mvar, string(mybuf));就绝对安全了。。。。直接将mybuf转换成string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">thread</span> myThread(myPrint, mvar, mybuf);
</span></span><span style="display:flex;"><span>	myThread.join();
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//myThread.detach();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Hello World!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>notes：</p>
<ul>
<li>main函数执行完之后才执行类的构造函数（20行）</li>
<li>若构造临时对象（19行），则在detach之前会执行构造函数和拷贝构造函数。</li>
</ul>
<p>只要用临时构造的对象作为参数传递给线程，就能够在主线程执行完毕前把线程函数的第二个参数构建出来，确保即便detach()子线程也安全运行</p>
<h4 id="13总结">1.3总结
</h4><ul>
<li>如果传递int这种简单类型，推荐使用<strong>值传递</strong>（<code>const int i</code>），不要用引用</li>
<li>如果传递类对象，避免使用隐式类型转换，全部都在<strong>创建线程这一行就创建出临时对象</strong>，然后在函数参数里，用引用来接，否则还会创建出一个对象</li>
<li>终极结论：建议不使用<code>detach()</code>，只使用<code>join()</code></li>
</ul>
<h3 id="二临时对象作为线程参数继续讲">二、临时对象作为线程参数继续讲
</h3><h4 id="21线程id概念">2.1线程id概念
</h4><ul>
<li>id是个数字，每个线程（不管是主线程还是子线程）实际上都对应着一个数字，而且每个线程对应的这个数字都不一样</li>
<li>线程id可以用C++标准库里的函数来<strong>获取</strong>。<code>std::this_thread::get_id()</code>来获取</li>
</ul>
<h3 id="三传递类对象智能指针作为线程参数">三、传递类对象、智能指针作为线程参数
</h3><h4 id="31">3.1
</h4><p>使用<code>std::ref</code>修改子线程中对象的值就会影响到主线程</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">mutable</span> <span style="color:#66d9ef">int</span> m_i; <span style="color:#75715e">//m_i即使实在const中也可以被修改
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	A(<span style="color:#66d9ef">int</span> i) <span style="color:#f92672">:</span>m_i(i) {}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">myPrint</span>(<span style="color:#66d9ef">const</span> A<span style="color:#f92672">&amp;</span> pmybuf)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	pmybuf.m_i <span style="color:#f92672">=</span> <span style="color:#ae81ff">199</span>;
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;子线程myPrint的参数地址是&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">&amp;</span>pmybuf <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;thread = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	A myObj(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//myPrint(const A&amp; pmybuf)中引用不能去掉，如果去掉会多创建一个对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//const也不能去掉，去掉会出错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//即使是传递的const引用，但在子线程中还是会调用拷贝构造函数构造一个新的对象，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//所以在子线程中修改m_i的值不会影响到主线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//如果希望子线程中修改m_i的值影响到主线程，可以用thread myThread(myPrint, std::ref(myObj));
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//这样const就是真的引用了，myPrint定义中的const就可以去掉了，类A定义中的mutable也可以去掉了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">thread</span> myThread(myPrint, myObj);
</span></span><span style="display:flex;"><span>	myThread.join();
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//myThread.detach();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Hello World!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="32"><em>3.2</em>
</h4><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;memory&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">myPrint</span>(unique_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> pzn)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;thread = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	unique_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> myp(<span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">10</span>));
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//独占式指针只能通过std::move()才可以传递给另一个指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//传递后myp就指向空，新的pzn指向原来的内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//所以这时就不能用detach了，因为如果主线程先执行完，pzn指向的对象就被释放了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">thread</span> myThread(myPrint, std<span style="color:#f92672">::</span>move(up));
</span></span><span style="display:flex;"><span>	myThread.join();
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//myThread.detach();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="四用成员函数指针做线程函数"><strong>四、用成员函数指针做线程函数</strong>
</h3><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> thread_work(<span style="color:#66d9ef">int</span> num)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;子线程thread_work执行&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;thread = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    A myobj(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> mytobj(<span style="color:#f92672">&amp;</span>A<span style="color:#f92672">::</span>thread_work,<span style="color:#f92672">&amp;</span>myobj,<span style="color:#ae81ff">15</span>);
</span></span><span style="display:flex;"><span>    mytobj.join();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="第四节-创建多个线程数据共享问题分析案例代码">第四节 创建多个线程、数据共享问题分析、案例代码
</h2><!-- raw HTML omitted -->
<h3 id="一创建和等待多个线程"><strong>一、创建和等待多个线程</strong>
</h3><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;map&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;list&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mutex&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">myprint</span>(<span style="color:#66d9ef">int</span> inum)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;myprint线程开始执行了，线程id= &#34;</span> <span style="color:#f92672">&lt;&lt;</span> inum <span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;myprint线程结束执行了，线程id= &#34;</span> <span style="color:#f92672">&lt;&lt;</span> inum <span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">thread</span><span style="color:#f92672">&gt;</span> mythreads;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        mythreads.push_back(<span style="color:#66d9ef">thread</span>(myprint,i))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> iter <span style="color:#f92672">=</span> mythreads.begin(); iter <span style="color:#f92672">!=</span> mythreads.end() ; iter<span style="color:#f92672">++</span>) 
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        iter.join();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;I love china&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>把thread对象放入到容器中管理，看起来像个thread对象数组，对一次创建大量的线程并对大量线程进行管理有好处</li>
<li>多个线程执行顺序是乱的，跟操作系统内部对线程的运行调度机制有关</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">TextThread</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>     cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;我是线程&#34;</span> <span style="color:#f92672">&lt;&lt;</span> this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">/*  …  */</span>
</span></span><span style="display:flex;"><span>     cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;线程&#34;</span> <span style="color:#f92672">&lt;&lt;</span> this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;执行结束&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> <span style="color:#75715e">//main函数里     vector threadagg;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>     {
</span></span><span style="display:flex;"><span>         threadagg.push_back(<span style="color:#66d9ef">thread</span>(TextThread));
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>     {
</span></span><span style="display:flex;"><span>         threadagg[i].join();
</span></span><span style="display:flex;"><span>     }
</span></span></code></pre></div><h3 id="二数据共享问题分析"><strong>二：数据共享问题分析</strong>
</h3><h4 id="21-只读的数据">2.1 只读的数据
</h4><ul>
<li>是安全稳定的，不需要特别处理，直接读就可以。</li>
</ul>
<h4 id="22-有读有写">2.2 有读有写
</h4><ul>
<li>
<p>若不加处理，就会出错</p>
</li>
<li>
<p>最简单的防止崩溃方法：<strong>读的时候不能写，写的时候不能读</strong>。</p>
<p>2个线程写，8个线程读时。2个线程不能同时写，8个线程不能同时读</p>
</li>
<li>
<p>写的动作分10小步，由于任务切换，导致各种诡异的事情发生（最可能的还是崩溃）</p>
</li>
<li>
<p><input checked="" disabled="" type="checkbox"> list：频繁的按顺序插入和删除数据时效率高。vector：随机的插入和删除数据效率高。</p>
</li>
</ul>
<h2 id="第五节-互斥量概念用法死锁演示及解决详解">第五节 互斥量概念、用法、死锁演示及解决详解
</h2><!-- raw HTML omitted -->
<p>保护共享数据，操作时，某个线程用代码把共享数据锁住、操作数据、解锁，</p>
<p>​		其他想操作共享数据的线程必须等待解锁，锁定住，操作，解锁。</p>
<h3 id="一互斥量mutex的基本概念">一、互斥量（mutex）的基本概念
</h3><ul>
<li>互斥量就是个<strong>类对象</strong>，可以理解为一把锁，多个线程尝试用<code>lock()</code>成员函数来加锁，只有一个线程能锁定成功（成功的标志是<code>lock()</code>函数返回），如果没有锁成功，那么流程将卡在<code>lock()</code>这里不断尝试去锁定。</li>
<li>互斥量使用要小心，保护数据不多也不少，少了达不到效果，多了影响效率。</li>
</ul>
<h3 id="二互斥量的用法">二、互斥量的用法
</h3><p>包含<code>#include &lt;mutex&gt;</code>头文件</p>
<h4 id="21-lockunlock">2.1 lock()，unlock()
</h4><ul>
<li>步骤：1.<code>lock()</code>，2.操作共享数据，3.<code>unlock()</code>。</li>
<li><code>lock()</code>和<code>unlock()</code>要成对使用，代码的每一个分支都要有<code>unlock()</code></li>
<li>防止忘记<code>unlock()</code>，引入<code>lock_guard()</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;map&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;list&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mutex&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> inMsgRecvQueue()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10000</span>; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;inMsgRecvQueue()执行，插入一个元素&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				std<span style="color:#f92672">::</span>lock_guard<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> myguard(my_mutex);
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">//my_mutex.lock();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				msgRecvQueue.push_back(i);
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//my_mutex.unlock();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">outMsgNULLProc</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>command)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		std<span style="color:#f92672">::</span>lock_guard<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> myguard(my_mutex);<span style="color:#75715e">//构造函数执行mutex::lock();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>								<span style="color:#75715e">//在作用域结束时，调用析构函数，执行mutex::unlock()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">//my_mutex.lock();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>msgRecvQueue.empty())
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//消息不为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			command <span style="color:#f92672">=</span> msgRecvQueue.front();
</span></span><span style="display:flex;"><span>			msgRecvQueue.pop_front();
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//my_mutex.unlock();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//my_mutex.unlock();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">outMsgRecvQueue</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> command <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10000</span>; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">bool</span> result <span style="color:#f92672">=</span> outMsgNULLProc(command);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (result <span style="color:#f92672">==</span> true)
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;outMsgRecvQueue()执行，取出一个元素&#34;</span> <span style="color:#f92672">&lt;&lt;</span> command <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">//数据处理代码...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;outMsgRecvQueue()执行，但目前消息队列中为空&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;end&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> msgRecvQueue;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>mutex my_mutex;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	A myobja;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> myOutMsgObj(<span style="color:#f92672">&amp;</span>A<span style="color:#f92672">::</span>outMsgRecvQueue, <span style="color:#f92672">&amp;</span>myobja);
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> myInMsgObj(<span style="color:#f92672">&amp;</span>A<span style="color:#f92672">::</span>inMsgRecvQueue, <span style="color:#f92672">&amp;</span>myobja);
</span></span><span style="display:flex;"><span>	myOutMsgObj.join();
</span></span><span style="display:flex;"><span>	myInMsgObj.join();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="22-lock_guard模板">2.2 lock_guard模板
</h4><ul>
<li><code>lock_guard&lt;mutex&gt; sbguard(myMutex);</code>取代<code>lock()</code>和<code>unlock()</code></li>
<li>lock_guard构造函数执行了<code>mutex::lock()</code>;在作用域结束时，调用析构函数，执行<code>mutex::unlock()</code></li>
</ul>
<h3 id="三死锁">三、死锁
</h3><p>死锁问题至少有两个互斥量才能产生。</p>
<h4 id="31-死锁演示">3.1 死锁演示
</h4><p>死锁至少有两个互斥量mutex1，mutex2。</p>
<ul>
<li>a.线程A执行时，这个线程先锁mutex1，并且锁成功了，然后去锁mutex2的时候，出现了上下文切换，mutex2没锁成功。</li>
<li>b.线程B执行，这个线程先锁mutex2，因为mutex2没有被锁，即mutex2可以被锁成功，然后线程B要去锁mutex1.</li>
<li>c.此时，死锁产生了，A锁着mutex1，需要锁mutex2，B锁着mutex2，需要锁mutex1，两个线程没办法继续运行下去。。。</li>
</ul>
<h4 id="32-死锁的一般解决方案">3.2 死锁的一般解决方案：
</h4><p>只要保证多个互斥量上锁的顺序一样就不会造成死锁。</p>
<h4 id="33-stdlock函数模板">3.3 std::lock()函数模板
</h4><ul>
<li><code>std::lock(mutex1,mutex2……);</code> 一次锁定多个互斥量（一般这种情况很少），用于处理多个互斥量。</li>
<li>如果互斥量中一个没锁住，它就等着，等所有互斥量都锁住，才能继续执行。如果有一个没锁住，就会把已经锁住的释放掉（要么互斥量都锁住，要么都没锁住，防止死锁）</li>
</ul>
<h4 id="34-stdlock_guard的stdadopt_lock参数">3.4 std::lock_guard的std::adopt_lock参数
</h4><ul>
<li>
<p><code>std::lock_guardstd::mutex my_guard(my_mutex,std::adopt_lock);</code></p>
<p>加入adopt_lock后，在调用lock_guard的构造函数时，不再进行lock();</p>
</li>
<li>
<p>adopt_guard为结构体对象，起一个标记作用，表示这个互斥量已经lock()，不需要在lock()。（必须把互斥量提前lock，否则会报异常。）</p>
</li>
<li>
<p>建议一个一个锁</p>
</li>
</ul>
<h2 id="第六节-unique_lock详解">第六节 unique_lock详解
</h2><!-- raw HTML omitted -->
<h3 id="1unique_lock取代lock_guard">1.unique_lock取代lock_guard
</h3><p>unique_lock是个类模板，工作中一般使用lock_guard。</p>
<p>unique_lock比lock_guard灵活很多（多出来很多用法），效率差一点，内存占用多一点。</p>
<p><code>unique_lock&lt;std::mutex&gt; myUniLock(myMutex);</code></p>
<h3 id="2unique_lock的第二个参数">2.unique_lock的第二个参数
</h3><h4 id="21-参数stdadopt_lock">2.1 参数std::adopt_lock：
</h4><ul>
<li>表示<strong>这个互斥量已经被lock()，即不需要在构造函数中lock这个互斥量了</strong>。</li>
<li>前提：必须提前lock，否则会报异常。</li>
<li>unique_lock中也可以用这个参数</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>milliseconds dura(<span style="color:#ae81ff">20000</span>);
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>sleep_for(dura); <span style="color:#75715e">//等待20秒
</span></span></span></code></pre></div><h4 id="22-参数stdtry_to_lock">2.2 参数std::try_to_lock：
</h4><ul>
<li>尝试用mutex的lock()去锁定这个mutex，但如果没有锁定成功，会立即返回，不会阻塞在那里；</li>
<li>使用try_to_lock的原因是<strong>防止其他的线程锁定mutex太长时间，导致本线程一直阻塞在lock这个地方</strong></li>
<li>前提：不能提前<code>lock()</code>;</li>
<li><code>owns_lock()</code>方法判断是否拿到锁，如拿到返回true</li>
</ul>
<h4 id="23-参数stddefer_lock">2.3 参数std::defer_lock：
</h4><ul>
<li>如果没有第二个参数就对mutex进行加锁，加上defer_lock是初始化了一个没有加锁的mutex</li>
<li>不给它加锁的目的是以后可以调用unique_lock的一些方法</li>
<li>前提：不能提前lock</li>
</ul>
<h3 id="3unique_lock的成员函数前三个与stddefer_lock联合使用">3.unique_lock的成员函数（前三个与std::defer_lock联合使用）
</h3><h4 id="31-lock加锁">3.1 lock()：加锁。
</h4><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>unique_lock<span style="color:#f92672">&lt;</span>mutex<span style="color:#f92672">&gt;</span> myUniLock(myMutex<span style="color:#960050;background-color:#1e0010">，</span> defer_lock);
</span></span><span style="display:flex;"><span>myUniLock.lock();
</span></span></code></pre></div><p>不用自己unlock();</p>
<h4 id="32-unlock解锁">3.2 unlock()：解锁。
</h4><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>unique_lock<span style="color:#f92672">&lt;</span>mutex<span style="color:#f92672">&gt;</span> myUniLock(myMutex<span style="color:#960050;background-color:#1e0010">，</span> defer_lock);
</span></span><span style="display:flex;"><span>myUniLock.lock();
</span></span><span style="display:flex;"><span><span style="color:#75715e">//处理一些共享代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>myUniLock.unlock();
</span></span><span style="display:flex;"><span><span style="color:#75715e">//处理一些非共享代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>myUniLock.lock();
</span></span><span style="display:flex;"><span><span style="color:#75715e">//处理一些共享代码
</span></span></span></code></pre></div><p>因为一些非共享代码要处理，可以暂时先unlock()，用其他线程把它们处理了，处理完后再lock()。</p>
<h4 id="33-try_lock尝试给互斥量加锁">3.3 try_lock()：尝试给互斥量加锁
</h4><p>如果拿不到锁，返回false，否则返回true。</p>
<h4 id="34-release">3.4 release()：
</h4><ul>
<li><code>unique_lock&lt;mutex&gt; myUniLock(myMutex);</code>相当于把myMutex和myUniLock绑定在了一起，release()就是解除绑定，返回它所管理的mutex对象的指针，并释放所有权</li>
<li><code>mutex* ptx = myUniLock.release();</code>所有权由ptx接管，如果原来mutex对象处理加锁状态，就需要ptx在以后进行解锁了(<code>ptx-&gt;unlock()</code>)。</li>
</ul>
<p>为什么需要unlock，因为lock的代码段越少，执行越快，整个程序的运行效率越高。</p>
<p>锁住的多少 称为代码的粗细。</p>
<p>​	a.锁住的代码少，叫做粒度细，执行效率高；
​	b.锁住的代码多，叫做粒度粗，执行效率低；</p>
<h3 id="4unique_lock所有权的传递">4.unique_lock所有权的传递
</h3><p><code>unique_lock&lt;mutex&gt; myUniLock(myMutex);</code>把myMutex和myUniLock绑定在了一起，也就是myUniLock拥有myMutex的所有权</p>
<h4 id="1使用move转移">1.使用move转移
</h4><ul>
<li>myUniLock拥有myMutex的所有权，myUniLock可以把自己对myMutex的所有权转移，但是不能复制。</li>
<li><code>unique_lock&lt;mutex&gt; myUniLock2(std::move(myUniLock));</code>
现在myUniLock2拥有myMutex的所有权。</li>
</ul>
<h4 id="2在函数中return一个临时变量即可以实现转移">2.在函数中return一个临时变量，即可以实现转移
</h4><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>unique_lock<span style="color:#f92672">&lt;</span>mutex<span style="color:#f92672">&gt;</span> rtn_unique_lock()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    unique_lock<span style="color:#f92672">&lt;</span>mutex<span style="color:#f92672">&gt;</span> tempUniLock(myMutex);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//移动构造函数那里讲从函数返回一个局部的unique_lock对象是可以的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//返回这种局部对象会导致系统生成临时的unique_lock对象，并调用unique_lock的移动构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> myUniLock;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 然后就可以在外层调用，在sbguard具有对myMutex的所有权
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>unique_lock<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> sbguard <span style="color:#f92672">=</span> rtn_unique_lock();
</span></span></code></pre></div><h2 id="第七节-单例设计模式共享数据分析解决call_once">第七节 单例设计模式共享数据分析、解决，call_once
</h2><!-- raw HTML omitted -->
<h3 id="1设计模式">1.设计模式
</h3><p>“设计模式”：代码的一些写法</p>
<ul>
<li>程序灵活，维护起来可能方便，用设计模式理念写出来的代码很晦涩，但是别人接管、阅读代码都会很痛苦</li>
<li>老外应付特别大的项目时，把项目的开发经验、模块划分经验，总结整理成设计模式（先有开发需求，后有理论总结和整理）</li>
<li>中国零几年设计模式刚开始火时，总喜欢拿一个设计模式往上套，导致一个小小的项目总要加几个设计模式，本末倒置</li>
<li>设计模式有其独特的优点，要活学活用，不要深陷其中，生搬硬套</li>
</ul>
<h4 id="2单例设计模式">2.单例设计模式：
</h4><p>单例设计模式使用频率比较高。</p>
<p>整个项目中，有某个或者某些特殊的类，只能创建一个属于该类的对象。</p>
<p>单例类：只能生成一个对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;map&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;list&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mutex&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyCAS</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	MyCAS() {}	<span style="color:#75715e">//私有化构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">static</span> MyCAS <span style="color:#f92672">*</span>m_instance;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">static</span> MyCAS <span style="color:#f92672">*</span>GetInstance()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 这里多线程下不安全
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (m_instance <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 两个线程可能同时执行到这里，这样不好
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			m_instance <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyCAS();
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 创建一个静态类对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">static</span> GarbageCollection c;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> m_instance;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;test&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 引入一个类，对new的对象进行回收
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GarbageCollection</span>
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">~</span>GarbageCollection()
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (MyCAS<span style="color:#f92672">::</span>m_instance)
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// 连个线程可能同时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#66d9ef">delete</span> MyCAS<span style="color:#f92672">::</span>m_instance;
</span></span><span style="display:flex;"><span>				MyCAS<span style="color:#f92672">::</span>m_instance <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//类静态变量初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>MyCAS <span style="color:#f92672">*</span>MyCAS<span style="color:#f92672">::</span>m_instance <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	MyCAS <span style="color:#f92672">*</span>p_a <span style="color:#f92672">=</span> MyCAS<span style="color:#f92672">::</span>GetInstance();
</span></span><span style="display:flex;"><span>	p_a<span style="color:#f92672">-&gt;</span>func();
</span></span><span style="display:flex;"><span>	MyCAS<span style="color:#f92672">::</span>GetInstance()<span style="color:#f92672">-&gt;</span>func();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	system(<span style="color:#e6db74">&#34;pause&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="3单例设计模式共享数据分析解决">3.单例设计模式共享数据分析、解决
</h4><p>面临问题：需要在自己创建的线程中来创建单例类的对象，这种线程可能不止一个。我们可能面临GetInstance()这种成员函数需要互斥。</p>
<p>可以在加锁前判断m_instance是否为空，否则每次调用Singleton::getInstance()都要加锁，十分影响效率。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;map&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;list&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mutex&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>mutex resource_mutex;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyCAS</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	MyCAS() {}	<span style="color:#75715e">//私有化构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">static</span> MyCAS <span style="color:#f92672">*</span>m_instance;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">static</span> MyCAS <span style="color:#f92672">*</span>GetInstance()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//提高效率
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">//如果if(m_instance != NULL)，条件成立，则肯定表示m_instance已经被new过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">//如果if(m_instance == NULL)，条件成立，不代表m_instance一定没被new过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">//双重锁定
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (m_instance <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			std<span style="color:#f92672">::</span>unique_lock<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> mymutex(resource_mutex);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (m_instance <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// 两个线程可能同时执行到这里，这样不好
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				m_instance <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyCAS();
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// 创建一个静态类对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#66d9ef">static</span> GarbageCollection c;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> m_instance;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;test&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 引入一个类，对new的对象进行回收
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GarbageCollection</span>
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">~</span>GarbageCollection()
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (MyCAS<span style="color:#f92672">::</span>m_instance)
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// 连个线程可能同时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#66d9ef">delete</span> MyCAS<span style="color:#f92672">::</span>m_instance;
</span></span><span style="display:flex;"><span>				MyCAS<span style="color:#f92672">::</span>m_instance <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//类静态变量初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>MyCAS <span style="color:#f92672">*</span>MyCAS<span style="color:#f92672">::</span>m_instance <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	MyCAS <span style="color:#f92672">*</span>p_a <span style="color:#f92672">=</span> MyCAS<span style="color:#f92672">::</span>GetInstance();
</span></span><span style="display:flex;"><span>	p_a<span style="color:#f92672">-&gt;</span>func();
</span></span><span style="display:flex;"><span>	MyCAS<span style="color:#f92672">::</span>GetInstance()<span style="color:#f92672">-&gt;</span>func();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	system(<span style="color:#e6db74">&#34;pause&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果觉得在单例模式new了一个对象，而没有自己delete掉，这样不合理。可以增加一个类中类CGarhuishou，new一个单例类时创建一个静态的CGarhuishou对象，这样在程序结束时会调用CGarhuishou的析构函数，释放掉new出来的单例对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Singelton</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">static</span> Singleton <span style="color:#f92672">*</span> getInstance() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (instance <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		    <span style="color:#66d9ef">static</span> CGarhuishou huishou;
</span></span><span style="display:flex;"><span>		    instance <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Singelton;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> instance;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CGarhuishou</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">~</span>CGarhuishou()
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (Singleton<span style="color:#f92672">::</span>instance)
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">delete</span> Singleton<span style="color:#f92672">::</span>instance;
</span></span><span style="display:flex;"><span>				Singleton<span style="color:#f92672">::</span>instance <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	Singleton() {}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">static</span> Singleton <span style="color:#f92672">*</span>instance;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>Singleton <span style="color:#f92672">*</span> Singleton<span style="color:#f92672">::</span>instance <span style="color:#f92672">=</span> NULL;
</span></span></code></pre></div><h3 id="4stdcall_once">4.std::call_once()：
</h3><p>函数模板，该函数的第一个参数为标记，第二个参数是一个函数名（如a()）。</p>
<ul>
<li>
<p>功能：能够保证函数a()只被调用一次。</p>
</li>
<li>
<p>具备互斥量的能力，而且比互斥量消耗的资源更少，更高效。</p>
</li>
<li>
<p>call_once()需要与一个标记结合使用，这个标记为<strong>std::once_flag</strong>；其实once_flag是一个结构;</p>
<p>call_once()就是通过标记来决定函数是否执行，调用成功后，就把标记设置为一种已调用状态。</p>
</li>
</ul>
<p>多个线程同时执行时，一个线程会等待另一个线程先执行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>once_flag g_flag;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Singleton</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> CreateInstance()<span style="color:#75715e">//call_once保证其只被调用一次
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {
</span></span><span style="display:flex;"><span>        instance <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Singleton;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//两个线程同时执行到这里，其中一个线程要等另外一个线程执行完毕
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">static</span> Singleton <span style="color:#f92672">*</span> <span style="color:#a6e22e">getInstance</span>() 
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>         call_once(g_flag, CreateInstance);
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">return</span> instance;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	Singleton() {}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">static</span> Singleton <span style="color:#f92672">*</span>instance;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>Singleton <span style="color:#f92672">*</span> Singleton<span style="color:#f92672">::</span>instance <span style="color:#f92672">=</span> NULL;
</span></span></code></pre></div><h2 id="第八节-condition_variablewaitnotify_onenotify_all">第八节 condition_variable、wait、notify_one、notify_all
</h2><!-- raw HTML omitted -->
<h3 id="一条件变量condition_variablewaitnotify_onenotify_all">一、条件变量condition_variable、wait、notify_one、notify_all
</h3><p>std::condition_variable实际上是一个类，是一个和条件相关的类，说白了就是等待一个条件达成。
需要和互斥量来配合工作，用的时候需要生成这个类的对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;map&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;list&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mutex&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> inMsgRecvQueue()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10000</span>; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;inMsgRecvQueue()执行，插入一个元素&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			std<span style="color:#f92672">::</span>lock_guard<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> myguard(my_mutex);
</span></span><span style="display:flex;"><span>			msgRecvQueue.push_back(i);
</span></span><span style="display:flex;"><span>			my_cond.notify_one();	<span style="color:#75715e">//把wait()的线程唤醒
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">outMsgRecvQueue</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> command <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> (true)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			std<span style="color:#f92672">::</span>unique_lock<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> myguard1(my_mutex);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//wait()用来等一个东西
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">//如果第二个参数 lambda表达式返回值为true，那么wait()直接返回并继续执行。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">//如果第二个参数 lambda表达式返回值为false，那么wait()将解锁互斥量，并堵塞到本行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>					<span style="color:#75715e">//堵塞到其他某个线程调用notify_one()成员函数为止
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">//如果wait()没有第二个参数，my_cond.wait(myguard1);那么就跟第二个参数lambda表达式返回false效果一样
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>					<span style="color:#75715e">//wait()将解锁互斥量，并堵塞到本行，堵塞到其他某个线程调用notify_one()成员函数为止
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			my_cond.wait(myguard1, [<span style="color:#66d9ef">this</span>] {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>msgRecvQueue.empty())
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>			});
</span></span><span style="display:flex;"><span>			command <span style="color:#f92672">=</span> msgRecvQueue.front();	<span style="color:#75715e">//返回第一个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			msgRecvQueue.pop_front();	<span style="color:#75715e">//移除第一个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			myguard1.unlock();	<span style="color:#75715e">//因为unique_lock的灵活性，所以我们可以随时解锁，以免锁住太长时间。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;outMsgRecvQueue()执行，取出一个元素&#34;</span> <span style="color:#f92672">&lt;&lt;</span> command <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> msgRecvQueue;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>mutex my_mutex;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>condition_variable my_cond;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	A myobja;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> myOutMsgObj(<span style="color:#f92672">&amp;</span>A<span style="color:#f92672">::</span>outMsgRecvQueue, <span style="color:#f92672">&amp;</span>myobja);
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> myInMsgObj(<span style="color:#f92672">&amp;</span>A<span style="color:#f92672">::</span>inMsgRecvQueue, <span style="color:#f92672">&amp;</span>myobja);
</span></span><span style="display:flex;"><span>	myOutMsgObj.join();
</span></span><span style="display:flex;"><span>	myInMsgObj.join();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>
<p>wait()用来等一个东西</p>
</li>
<li>
<p>如果第二个参数的lambda表达式返回值是false，那么wait()将解锁互斥量，并阻塞到本行
如果第二个参数的lambda表达式返回值是true，那么wait()直接返回并继续执行。</p>
</li>
<li>
<p>阻塞到什么时候为止呢？阻塞到其他某个线程调用notify_one()成员函数为止；</p>
</li>
<li>
<p>如果没有第二个参数，那么效果跟第二个参数lambda表达式返回false效果一样</p>
<p>wait()将解锁互斥量，并阻塞到本行，阻塞到其他某个线程调用notify_one()成员函数为止。</p>
</li>
<li>
<p>当其他线程用notify_one()将本线程wait()唤醒后，这个wait恢复后。wait()不断尝试获取互斥量锁，如果获取不到那么流程就卡在wait()这里等待获取，如果获取到了，那么wait()就继续执行，获取到了锁</p>
</li>
</ul>
<p>wait被唤醒后，输入和输出队列都尝试获取锁，谁获得锁不确定。</p>
<p>若outMsgRecvQueue()正在处理一个事务，需要一段时间，而不是正卡在wait()等待被唤醒，那么此时这个notify_once无效。</p>
<h4 id="21如果wait有第二个参数就判断这个lambda表达式">2.1、如果wait有第二个参数就判断这个lambda表达式。
</h4><ul>
<li>a)如果表达式为false，那wait又对互斥量解锁，然后又休眠，等待再次被notify_one()唤醒</li>
<li>b)如果lambda表达式为true，则wait返回，流程可以继续执行（此时互斥量已被锁住）。</li>
</ul>
<h4 id="22如果wait没有第二个参数则wait返回流程走下去">2.2、如果wait没有第二个参数，则wait返回，流程走下去。
</h4><p>流程只要走到了wait()下面则互斥量一定被锁住了。</p>
<h3 id="二深入思考">二、深入思考
</h3><p>上面的代码可能导致出现一种情况：</p>
<p>因为outMsgRecvQueue()与inMsgRecvQueue()并不是一对一执行的，所以当程序循环执行很多次以后，可能在msgRecvQueue 中已经有了很多消息，但是，outMsgRecvQueue还是被唤醒一次只处理一条数据。这时可以考虑把outMsgRecvQueue多执行几次，或者对inMsgRecvQueue进行限流。</p>
<h3 id="三notify_all">三、notify_all()
</h3><p>notify_one()：通知一个线程的wait()</p>
<p>notify_all()：通知所有线程的wait()</p>
<h2 id="第九节asyncfuturepackaged_taskpromise">第九节、async、future、packaged_task、promise
</h2><!-- raw HTML omitted -->
<p>本节内容需要包含头文件<code>#include &lt;future&gt;</code></p>
<h3 id="一stdasyncstdfuture创建后台任务并返回值">一、std::async、std::future创建后台任务并返回值
</h3><p>std::async是一个<strong>函数模板</strong>，用来启动一个异步任务，启动起来一个异步任务之后，它返回一个std::future对象，这个对象是个<strong>类模板</strong>。</p>
<p><strong>什么叫“启动一个异步任务”？</strong></p>
<p>​		就是自动创建一个线程，并开始 执行对应的线程入口函数，它返回一个std::future对象，这个std::future对象中就含有线程入口函数所返回的结果，我们可以通过调用future对象的成员函数get()来获取结果。</p>
<p>“future”将来的意思，也有人称呼std::future提供了一种访问异步操作结果的机制，就是说这个结果你可能没办法马上拿到，在这个线程执行完毕的时候，就能够拿到结果了，所以大家这么理解：future中保存着一个值，这个值是在将来的某个时刻能够拿到。</p>
<p>std::future对象的<strong>get()成员函数</strong>会等待线程执行结束并返回结果，拿不到结果它就会一直等待，感觉有点像join()。但是，它是可以获取结果的。</p>
<ul>
<li>get()只能调用一次，不能调用多次</li>
</ul>
<p>std::future对象的<strong>wait()成员函数</strong>，用于等待线程返回，本身并不返回结果，这个效果和 std::thread 的join()更像。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;future&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> mythread(<span style="color:#66d9ef">int</span> mypar) {
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> mypar <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> mypar;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">mythread</span>() {
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;mythread() start&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threadid = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>milliseconds dura(<span style="color:#ae81ff">5000</span>);
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>sleep_for(dura);
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;mythread() end&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threadid = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	A a;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>;
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;main&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threadid = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>future<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result1 <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>async(mythread);
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;continue........&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> result1.get() <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">//卡在这里等待mythread()执行完毕，拿到结果   等待拿到返回值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//类成员函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	std<span style="color:#f92672">::</span>future<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result2 <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>async(<span style="color:#f92672">&amp;</span>A<span style="color:#f92672">::</span>mythread, <span style="color:#f92672">&amp;</span>a, tmp); <span style="color:#75715e">//第二个参数是对象引用才能保证线程里执行的是同一个对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> result2.get() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">//或者result2.wait();  //等待线程返回，但不返回结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;good luck&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们通过向std::async()传递一个参数，该参数是std::launch类型（枚举类型），来达到一些特殊的目的：</p>
<h4 id="1stdlaunchdeferred">1、std::launch::deferred：
</h4><p>（defer推迟，延期）表示线程入口函数的调用会被延迟，一直到std::future的wait()或者get()函数被调用时（由主线程调用）才会执行；</p>
<p>如果wait()或者get()没有被调用，则不会执行。</p>
<p>实际上根本就没有创建新线程。std::launch::deferred意思时延迟调用，并没有创建新线程，是<strong>在主线程中调用的线程入口函数</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;future&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">mythread</span>() {
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;mythread() start&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threadid = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>milliseconds dura(<span style="color:#ae81ff">5000</span>);
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>sleep_for(dura);
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;mythread() end&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threadid = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;main&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threadid = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>future<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result1 <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>async(std<span style="color:#f92672">::</span>launch<span style="color:#f92672">::</span>deferred ,mythread);
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;continue........&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> result1.get() <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">//卡在这里等待mythread()执行完毕，拿到结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;good luck&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<p>永远都会先打印出continue…，然后才会打印出mythread() start和mythread() end等信息。</p>
<h4 id="2stdlaunchasync在调用async函数的时候就开始创建新线程">2、std::launch::async，在调用async函数的时候就开始创建新线程。
</h4><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;main&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threadid = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>future<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result1 <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>async(std<span style="color:#f92672">::</span>launch<span style="color:#f92672">::</span>async ,mythread);
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;continue........&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> result1.get() <span style="color:#f92672">&lt;&lt;</span> endl; 
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;good luck&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="二stdpackaged_task打包任务把任务包装起来">二、std::packaged_task：打包任务，把任务包装起来。
</h3><p>类模板，它的模板参数是各种可调用对象，通过packaged_task把各种可调用对象包装起来，方便将来作为线程入口函数来调用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;future&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">mythread</span>(<span style="color:#66d9ef">int</span> mypar) {
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> mypar <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;mythread() start&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threadid = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>milliseconds dura(<span style="color:#ae81ff">5000</span>);
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>sleep_for(dura);
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;mythread() end&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threadid = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;main&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threadid = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//我们把函数mythread通过packaged_task包装起来
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//参数是一个int，返回值类型是int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>packaged_task<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>(<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&gt;</span> mypt(mythread);
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t1(std<span style="color:#f92672">::</span>ref(mypt), <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	t1.join();
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>future<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result <span style="color:#f92672">=</span> mypt.get_future(); 
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//std::future对象里包含有线程入口函数的返回结果，这里result保存mythread返回的结果。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> result.get() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><em>可调用对象可由函数换成lambda表达式</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;main&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threadid = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>packaged_task<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>(<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&gt;</span> mypt([](<span style="color:#66d9ef">int</span> mypar) {
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> mypar <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;mythread() start&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threadid = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>		std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>milliseconds dura(<span style="color:#ae81ff">5000</span>);
</span></span><span style="display:flex;"><span>		std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>sleep_for(dura);
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;mythread() end&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threadid = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>	}); 
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t1(std<span style="color:#f92672">::</span>ref(mypt), <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	t1.join();
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>future<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result <span style="color:#f92672">=</span> mypt.get_future(); 
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//std::future对象里包含有线程入口函数的返回结果，这里result保存mythread返回的结果。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> result.get() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;good luck&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>packaged_task包装起来的可调用对象还可以直接调用，从这个角度来讲，packaged_task对象也是一个可调用对象
<em>lambda的直接调用</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;main&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threadid = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>packaged_task<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>(<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&gt;</span> mypt([](<span style="color:#66d9ef">int</span> mypar) {
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> mypar <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;mythread() start&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threadid = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>		std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>milliseconds dura(<span style="color:#ae81ff">5000</span>);
</span></span><span style="display:flex;"><span>		std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>sleep_for(dura);
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;mythread() end&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threadid = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>	}); 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	mypt(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>future<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result <span style="color:#f92672">=</span> mypt.get_future();
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> result.get() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><em>std::promise，类模板</em>
我们能够在某个线程中给它赋值，然后我们可以在其他线程中，把这个值取出来</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;future&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mythread</span>(std<span style="color:#f92672">::</span>promise<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>tmp, <span style="color:#66d9ef">int</span> clac) {
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;mythread() start&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threadid = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>milliseconds dura(<span style="color:#ae81ff">5000</span>);
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>sleep_for(dura);
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;mythread() end&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threadid = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> clac;
</span></span><span style="display:flex;"><span>	tmp.set_value(result); <span style="color:#75715e">//结果保存到了tmp这个对象中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>packaged_task<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>(<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&gt;&gt;</span> task_vec;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>promise<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> myprom;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t1(mythread, std<span style="color:#f92672">::</span>ref(myprom), <span style="color:#ae81ff">180</span>);
</span></span><span style="display:flex;"><span>	t1.join(); <span style="color:#75715e">//在这里线程已经执行完了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	std<span style="color:#f92672">::</span>future<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> fu1 <span style="color:#f92672">=</span> myprom.get_future(); <span style="color:#75715e">//promise和future绑定，用于获取线程返回值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">auto</span> result <span style="color:#f92672">=</span> fu1.get();
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;result = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> result <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>**总结：**通过promise保存一个值，在将来某个时刻我们通过把一个future绑定到这个promise上，来得到绑定的值</p>
<p>注意：使用thread时，必须 join() 或者 detach() 否则程序会报异常</p>
<p><strong>小结：</strong></p>
<p>我们学习这些东西的目的并不是，要把他们都用到实际开发中。</p>
<p>相反，如果我们能够用最少的东西写出一个稳定的，高效的多线程程序，更值得赞赏。</p>
<p>我们为了成长必须阅读一些高手写的代码，从而实现自己代码的积累；</p>
<h2 id="第十节-future其他成员函数shared_futureatomic">第十节 future其他成员函数、shared_future、atomic
</h2><h3 id="一stdfuture-的成员函数">一、std::future 的成员函数
</h3><p>1、<code>std::future_status status = result.wait_for(std::chrono::seconds(2));</code>
卡住当前流程，等待std::async()的异步任务运行一段时间，然后返回其状态std::future_status。如果std::async()的参数是std::launch::deferred（延迟执行），则不会卡住主流程。
std::future_status是枚举类型，表示异步任务的执行状态。类型的取值有
std::future_status::timeout
std::future_status::ready
std::future_status::deferred</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;future&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">mythread</span>() {
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;mythread() start&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threadid = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>milliseconds dura(<span style="color:#ae81ff">5000</span>);
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>sleep_for(dura);
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;mythread() end&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threadid = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;main&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threadid = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>future<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>async(mythread);
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;continue........&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//cout &lt;&lt; result1.get() &lt;&lt; endl; //卡在这里等待mythread()执行完毕，拿到结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//等待1秒
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>future_status status <span style="color:#f92672">=</span> result.wait_for(std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>seconds(<span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (status <span style="color:#f92672">==</span> std<span style="color:#f92672">::</span>future_status<span style="color:#f92672">::</span>timeout) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//超时：表示线程还没有执行完
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;超时了，线程还没有执行完&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//类成员函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;future&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">mythread</span>() {
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;mythread() start&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threadid = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//std::chrono::milliseconds dura(5000);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//std::this_thread::sleep_for(dura);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;mythread() end&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threadid = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;main&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threadid = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>future<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>async(std<span style="color:#f92672">::</span>launch<span style="color:#f92672">::</span>deferred, mythread);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//std::future&lt;int&gt; result = std::async(mythread);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;continue........&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//cout &lt;&lt; result1.get() &lt;&lt; endl; //卡在这里等待mythread()执行完毕，拿到结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	std<span style="color:#f92672">::</span>future_status status <span style="color:#f92672">=</span> result.wait_for(std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>seconds(<span style="color:#ae81ff">6</span>));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (status <span style="color:#f92672">==</span> std<span style="color:#f92672">::</span>future_status<span style="color:#f92672">::</span>timeout) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//超时：表示线程还没有执行完
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;超时了，线程还没有执行完&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (status <span style="color:#f92672">==</span> std<span style="color:#f92672">::</span>future_status<span style="color:#f92672">::</span>ready) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//表示线程成功返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;线程执行成功，返回&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> result.get() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (status <span style="color:#f92672">==</span> std<span style="color:#f92672">::</span>future_status<span style="color:#f92672">::</span>deferred) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//如果设置 std::future&lt;int&gt; result = std::async(std::launch::deferred, mythread);，则本条件成立
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;线程延迟执行&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> result.get() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;good luck&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>get()只能使用一次，比如如果</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> a <span style="color:#f92672">=</span> result.get();
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> result.get() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span></code></pre></div><p>就会报告异常
因为std::future中的get()函数的设计是一个<strong>移动语义</strong>，相当于将result中的值移动到了a中，再次get就报告了异常。</p>
<h3 id="二stdshared_future也是个类模板">二、std::shared_future：也是个类模板
</h3><p>std::future的 get() 成员函数是转移数据</p>
<p>std::shared_future 的 get()成员函数是复制数据</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;future&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">mythread</span>() {
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;mythread() start&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threadid = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>milliseconds dura(<span style="color:#ae81ff">5000</span>);
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>sleep_for(dura);
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;mythread() end&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threadid = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;main&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threadid = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>packaged_task<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>()<span style="color:#f92672">&gt;</span> mypt(mythread);
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t1(std<span style="color:#f92672">::</span>ref(mypt));
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>future<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result <span style="color:#f92672">=</span> mypt.get_future();
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> ifcanget <span style="color:#f92672">=</span> result.valid(); <span style="color:#75715e">//判断future中的值是不是一个有效值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	std<span style="color:#f92672">::</span>shared_future<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result_s(result.share()); <span style="color:#75715e">//执行完毕后result_s里有值，而result里空了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//std::shared_future&lt;int&gt; result_s(std::move(result));
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//通过get_future返回值直接构造一个shared_future对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//std::shared_future&lt;int&gt; result_s(mypt.get_future());
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    t1.join();
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">auto</span> myresult1 <span style="color:#f92672">=</span> result_s.get();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">auto</span> myresult2 <span style="color:#f92672">=</span> result_s.get();
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;good luck&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="三stdatomic原子操作">三、std::atomic原子操作
</h3><h4 id="31-原子操作概念引出范例">3.1 原子操作概念引出范例：
</h4><p>互斥量：多线程编程中 用于保护共享数据：先锁住， 操作共享数据， 解锁。</p>
<p>有两个线程，对一个变量进行操作，一个线程读这个变量的值，一个线程往这个变量中写值。</p>
<p>即使是一个简单变量的读取和写入操作，如果不加锁，也有可能会导致读写值混乱（一条C语句会被拆成3、4条汇编语句来执行，所以仍然有可能混乱）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> g_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mythread1</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1000000</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		g_count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t1(mythread1);
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t2(mythread1);
</span></span><span style="display:flex;"><span>	t1.join();
</span></span><span style="display:flex;"><span>	t2.join();
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;正常情况下结果应该是200 0000次，实际是&#34;</span> <span style="color:#f92672">&lt;&lt;</span> g_count <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<p>使用mutex解决这个问题（但是速度变慢）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mutex&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> g_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>mutex mymutex;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mythread1</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1000000</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		std<span style="color:#f92672">::</span>unique_lock<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> u1(mymutex);
</span></span><span style="display:flex;"><span>		g_count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t1(mythread1);
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t2(mythread1);
</span></span><span style="display:flex;"><span>	t1.join();
</span></span><span style="display:flex;"><span>	t2.join();
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;正常情况下结果应该是200 0000次，实际是&#34;</span> <span style="color:#f92672">&lt;&lt;</span> g_count <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<h4 id="32-基本的stdatomic用法范例">3.2 基本的std::atomic用法范例
</h4><p>可以把原子操作理解成一种：不需要用到互斥量加锁（无锁）技术的多线程并发编程方式。</p>
<p>原子操作：在多线程中不会被打断的程序执行片段。</p>
<p>从效率上来说，原子操作要比互斥量的方式效率要高。</p>
<p>互斥量的加锁一般是<strong>针对一个代码段</strong>，而原子操作<strong>针对</strong>的一般都是<strong>一个变量</strong>。</p>
<p>原子操作，一般都是指“不可分割的操作”；也就是说这种操作状态要么是完成的，要么是没完成的，不可能出现半完成状态。</p>
<p>std::atomic来代表原子操作，是个<strong>类模板</strong>。其实std::atomic是用来封装某个类型的值的</p>
<p>需要添加<code>#include &lt;atomic&gt;</code>头文件</p>
<p>范例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;atomic&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>atomic<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> g_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">//封装了一个类型为int的 对象（值）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mythread1</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1000000</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		g_count<span style="color:#f92672">++</span>;	<span style="color:#75715e">//对应的操作是原子操作（不会被打断）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t1(mythread1);
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t2(mythread1);
</span></span><span style="display:flex;"><span>	t1.join();
</span></span><span style="display:flex;"><span>	t2.join();
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;正常情况下结果应该是200 0000次，实际是&#34;</span> <span style="color:#f92672">&lt;&lt;</span> g_count <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;atomic&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>atomic<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> g_ifEnd <span style="color:#f92672">=</span> false; <span style="color:#75715e">//封装了一个类型为bool的 对象（值）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mythread</span>() {
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>milliseconds dura(<span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (g_ifEnd <span style="color:#f92672">==</span> false) {
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;thread id = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;运行中&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>		std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>sleep_for(dura);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;thread id = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;运行结束&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t1(mythread);
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t2(mythread);
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>milliseconds dura(<span style="color:#ae81ff">5000</span>);
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>sleep_for(dura);
</span></span><span style="display:flex;"><span>	g_ifEnd <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;程序执行完毕&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	t1.join();
</span></span><span style="display:flex;"><span>	t2.join();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<h3 id="总结"><strong>总结：</strong>
</h3><p>1、原子操作一般用于计数或者统计（如累计发送多少个数据包，累计接收到了多少个数据包），多个线程一起统计，这种情况如果不使用原子操作会导致统计发生混乱。</p>
<p>2、写商业代码时，如果不确定结果的影响，最好自己先写一小段代码调试。或者不要使用。</p>
<h2 id="第十一节-stdatomic续谈stdasync深入谈">第十一节 std::atomic续谈、std::async深入谈
</h2><!-- raw HTML omitted -->
<h3 id="一stdatomic续谈">一、std::atomic续谈
</h3><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;atomic&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>atomic<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> g_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">//封装了一个类型为int的 对象（值）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mythread1</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1000000</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		 <span style="color:#75715e">//虽然g_count使用了原子操作模板，但是这种写法既读又写，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		 <span style="color:#75715e">//会导致计数错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>         g_count <span style="color:#f92672">=</span> g_count <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t1(mythread1);
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t2(mythread1);
</span></span><span style="display:flex;"><span>	t1.join();
</span></span><span style="display:flex;"><span>	t2.join();
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;正常情况下结果应该是200 0000次，实际是&#34;</span> <span style="color:#f92672">&lt;&lt;</span> g_count <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<p>一般atomic原子操作，针对<code>++，--，+=，-=，&amp;=，|=，^=</code>是支持的，其他操作不一定支持。</p>
<h3 id="二stdasync深入理解">二、std::async深入理解
</h3><h4 id="21-stdasync参数详述async-用来创建一个异步任务">2.1 std::async参数详述，async 用来创建一个异步任务
</h4><ul>
<li>延迟调用参数 std::launch::deferred【延迟调用】，std::launch::async【强制创建一个线程】</li>
<li><code>std::thread()</code> 如果系统资源紧张，那么创建线程可能失败，那么执行<code>std::thread()</code>时整个程序可能崩溃。</li>
<li>std::async()我们一般不叫创建线程（他能够创建线程），一般叫它创建一个异步任务。</li>
<li>std::async和std::thread最明显的不同，就是 async 有时候并不创建新线程。</li>
</ul>
<p>①如果用std::launch::deferred 来调用async？</p>
<ul>
<li>延迟到调用 <code>get()</code> 或者 <code>wait()</code> 时执行，如果不调用就不会执行</li>
</ul>
<p>②如果用std::launch::async来调用async？</p>
<ul>
<li>强制这个异步任务在新线程上执行，这意味着，系统必须要创建出新线程来运行入口函数。</li>
</ul>
<p>③如果同时用 std::launch::async | std::launch::deferred</p>
<p>这里这个 | 意味着async的行为可能是 std::launch::async 创建新线程立即执行， 也可能是 std::launch::deferred 没有创建新线程并且延迟到调用get()执行，由<strong>系统根据实际情况来决定</strong>采取哪种方案</p>
<p>④不带额外参数 std::async(mythread)，只给async 一个入口函数名，此时的系统给的默认值是 std::launch::async | std::launch::deferred 和 ③ 一样，有系统自行决定异步还是同步运行。</p>
<h4 id="22-stdasync和stdthread区别">2.2 std::async和std::thread()区别：
</h4><p>std::thread()如果系统资源紧张可能出现创建线程失败的情况，如果创建线程失败那么程序就可能崩溃，而且不容易拿到函数返回值（不是拿不到）</p>
<p>std::async()创建异步任务。可能创建线程也可能不创建线程，并且容易拿到线程入口函数的返回值；</p>
<p>由于系统资源限制：
①如果用std::thread创建的线程太多，则可能创建失败，系统报告异常，崩溃。</p>
<p>②如果用std::async，一般就不会报异常，因为如果系统资源紧张，无法创建新线程的时候，async不加额外参数的调用方式就不会创建新线程。而是在后续调用get()请求结果时执行在这个调用get()的线程上。</p>
<p>如果你强制async一定要创建新线程就要使用 std::launch::async 标记。承受的代价是，系统资源紧张时可能崩溃。</p>
<p>③根据经验，一个程序中线程数量 不宜超过100~200 。</p>
<h4 id="23-async不确定性问题的解决">2.3 async不确定性问题的解决
</h4><p>不加额外参数的async调用时让系统自行决定，是否创建新线程。</p>
<p><code>std::future&lt;int&gt; result = std::async(mythread);</code>
问题焦点在于这个写法，任务到底有没有被推迟执行。</p>
<p>通过wait_for返回状态来判断：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>future_status status <span style="color:#f92672">=</span> result.wait_for(std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>seconds(<span style="color:#ae81ff">6</span>));
</span></span><span style="display:flex;"><span><span style="color:#75715e">//std::future_status status = result.wait_for(6s);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (status <span style="color:#f92672">==</span> std<span style="color:#f92672">::</span>future_status<span style="color:#f92672">::</span>timeout) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//超时：表示线程还没有执行完
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;超时了，线程还没有执行完&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (status <span style="color:#f92672">==</span> std<span style="color:#f92672">::</span>future_status<span style="color:#f92672">::</span>ready) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//表示线程成功放回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;线程执行成功，返回&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> result.get() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (status <span style="color:#f92672">==</span> std<span style="color:#f92672">::</span>future_status<span style="color:#f92672">::</span>deferred) {
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;线程延迟执行&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> result.get() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><h2 id="第十二节-windows临界区其他各种mutex互斥量">第十二节 windows临界区、其他各种mutex互斥量
</h2><!-- raw HTML omitted -->
<h3 id="一和二windows临界区">一和二、windows临界区
</h3><p>Windows临界区，同一个线程是可以重复进入的，但是进入的次数与离开的次数必须相等。
C++互斥量则不允许同一个线程重复加锁。</p>
<p>windows临界区是在windows编程中的内容，了解一下即可，效果几乎可以等同于c++11的mutex</p>
<p>包含<code>#include &lt;windows.h&gt;</code></p>
<p>windows中的临界区同mutex一样，可以保护一个代码段。但windows的临界区可以进入多次，离开多次，但是进入的次数与离开的次数必须相等，不会引起程序报异常出错。</p>
<p>而C++11中不允许一次性lock()两次，会报异常。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;list&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mutex&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define __WINDOWSJQ_
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 把收到的消息传入队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> inMsgRecvQueue()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1000</span>; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;收到消息，并放入队列 &#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef  __WINDOWSJQ_
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			EnterCriticalSection(<span style="color:#f92672">&amp;</span>my_winsec);	<span style="color:#75715e">//	进入临界区
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">//EnterCriticalSection(&amp;my_winsec);	//	可以再次进入临界区,程序不会出错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			msgRecvQueue.push_back(i);
</span></span><span style="display:flex;"><span>			LeaveCriticalSection(<span style="color:#f92672">&amp;</span>my_winsec);	<span style="color:#75715e">//	离开临界区
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">//LeaveCriticalSection(&amp;my_winsec);	//	如果进入两次，必须离开两次不会报错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#elif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			my_mutex.lock();
</span></span><span style="display:flex;"><span>			msgRecvQueue.push_back(i);
</span></span><span style="display:flex;"><span>			my_mutex.unlock();
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">//  __WINDOWSJQ_
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;消息入队结束&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 从队列中取出消息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">outMsgRecvQueue</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1000</span>; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef  __WINDOWSJQ_
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			EnterCriticalSection(<span style="color:#f92672">&amp;</span>my_winsec);	<span style="color:#75715e">//	进入临界区
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>msgRecvQueue.empty())
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// 队列不为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#66d9ef">int</span> num <span style="color:#f92672">=</span> msgRecvQueue.front();
</span></span><span style="display:flex;"><span>				cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;从消息队列中取出 &#34;</span> <span style="color:#f92672">&lt;&lt;</span> num <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>				msgRecvQueue.pop_front();
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// 消息队列为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;消息队列为空 &#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			LeaveCriticalSection(<span style="color:#f92672">&amp;</span>my_winsec);	<span style="color:#75715e">//	离开临界区
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#elif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			my_mutex.lock();
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>msgRecvQueue.empty())
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// 队列不为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#66d9ef">int</span> num <span style="color:#f92672">=</span> msgRecvQueue.front();
</span></span><span style="display:flex;"><span>				cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;从消息队列中取出 &#34;</span> <span style="color:#f92672">&lt;&lt;</span> num <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>				msgRecvQueue.pop_front();
</span></span><span style="display:flex;"><span>				my_mutex.unlock();
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// 消息队列为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;消息队列为空 &#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>				my_mutex.unlock();
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">//  __WINDOWSJQ_
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;消息出队结束&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	A()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef __WINDOWSJQ_
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		InitializeCriticalSection(<span style="color:#f92672">&amp;</span>my_winsec);	<span style="color:#75715e">//	用临界区之前要初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif </span><span style="color:#75715e">// __WINDOWSJQ_
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> msgRecvQueue;
</span></span><span style="display:flex;"><span>	mutex my_mutex;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef __WINDOWSJQ_
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	CRITICAL_SECTION my_winsec;	<span style="color:#75715e">//	windows中的临界区，非常类似C++11中的mutex
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif </span><span style="color:#75715e">// __WINDOWSJQ_
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	A myobj;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">thread</span>	myInMsgObj(<span style="color:#f92672">&amp;</span>A<span style="color:#f92672">::</span>inMsgRecvQueue, <span style="color:#f92672">&amp;</span>myobj);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">thread</span>	myOutMsgObj(<span style="color:#f92672">&amp;</span>A<span style="color:#f92672">::</span>outMsgRecvQueue, <span style="color:#f92672">&amp;</span>myobj);
</span></span><span style="display:flex;"><span>	myInMsgObj.join();
</span></span><span style="display:flex;"><span>	myOutMsgObj.join();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	getchar();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="三自动析构技术"><strong>三、自动析构技术</strong>
</h3><p>C++：lock_guard防止忘了释放信号量，自动释放
windows：可以写个类自动释放临界区：</p>
<p>上述这种类<strong>RAII类</strong>（Resource Acquisition is initialization），即<strong>资源获取及初始化</strong>。容器，智能指针属于这种类。</p>
<h3 id="四递归独占互斥量-stdrecursive_mutex">四、递归独占互斥量 std::recursive_mutex
</h3><p>std::mutex 独占式互斥量</p>
<p>std::recursive_mutex：允许在同一个线程中同一个互斥量多次被 lock() ，（但是递归加锁的次数是有限制的，太多可能会报异常），效率要比mutex低。</p>
<p>如果你真的用了 recursive_mutex 要考虑代码是否有优化空间，如果能调用一次 lock()就不要调用多次。</p>
<h3 id="五带超时的互斥量-stdtimed_mutex-和-stdrecursive_timed_mutex">五、带超时的互斥量 std::timed_mutex 和 std::recursive_timed_mutex
</h3><h4 id="51-stdtimed_mutex是待超时的独占互斥量">5.1 std::timed_mutex：是待超时的独占互斥量
</h4><p>try_lock_for()：
等待一段时间，如果拿到了锁，或者超时了未拿到锁，就继续执行（有选择执行）如下:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>milliseconds timeout(<span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (my_mymutex.try_lock_for(timeout)){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//......拿到锁返回ture
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//做一些操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    my_mymutex.unlock();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>{			<span style="color:#75715e">//拿不到锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>milliseconds sleeptime(<span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>sleep_for(sleeptime);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>try_lock_until()：</li>
</ul>
<p>参数是一个未来的时间点，在这个未来的时间没到的时间内，如果拿到了锁头，流程就走下来，如果时间到了没拿到锁，流程也可以走下来。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>milliseconds timeout(<span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (my_mymutex.try_lock_until(chrono<span style="color:#f92672">::</span>steady_clock<span style="color:#f92672">::</span>now() <span style="color:#f92672">+</span> timeout)){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//......拿到锁返回ture
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>milliseconds sleeptime(<span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>sleep_for(sleeptime);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>两者的区别就是一个参数是时间段，一个参数是时间点</p>
<h4 id="52-stdrecursive_timed_mutex是待超时的递归独占互斥量">5.2 std::recursive_timed_mutex：是待超时的递归独占互斥量
</h4><h2 id="第十三章-补充知识线程池浅谈数量谈总结">第十三章 补充知识、线程池浅谈、数量谈、总结
</h2><!-- raw HTML omitted -->
<h3 id="一补充一些知识点">一、补充一些知识点
</h3><h4 id="11-虚假唤醒">1.1 虚假唤醒：
</h4><p>notify_one或者notify_all唤醒wait()后，实际有些线程可能不满足唤醒的条件，就会造成虚假唤醒，可以在wait中再次进行判断解决虚假唤醒。
解决：wait中要有第二个参数（lambda），并且这个lambda中要正确判断所处理的公共数据是否存在。</p>
<h4 id="22-atomic">2.2 atomic：
</h4><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>atomic<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> atm <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> atm <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span></code></pre></div><p>这里只有读取atm是原子操作，但是整个这一行代码 cout &laquo; atm &laquo; endl; 并不是原子操作，导致最终显示在屏幕上的值是一个“曾经值”。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>atomic<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> atm <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> atm2 <span style="color:#f92672">=</span> atm; <span style="color:#75715e">//原子量的赋值不允许
</span></span></span></code></pre></div><p>这种拷贝初始化不可以，会报错。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>atomic<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> atm2(atm.load());
</span></span></code></pre></div><p>load()：以原子方式读atomic对象的值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>atm2.store(<span style="color:#ae81ff">12</span>);
</span></span></code></pre></div><p>原子操作实质上是：不允许在进行原子对象操作时进行CPU的上下文切换。</p>
<h3 id="二浅谈线程池">二、浅谈线程池：
</h3><p>场景设想：服务器程序， 每来一个客户端，就创建一个新线程为这个客户提供服务。</p>
<p>问题：</p>
<p>1、2万个玩家，不可能给每个玩家创建一个新线程，此程序写法在这种场景下不通。</p>
<p>2、程序稳定性问题：编写代码中，“时不时地突然”创建一个线程，这种写法，一般情况下不会出错，但是不稳定的；</p>
<p>**线程池：**把一堆线程弄到一起，统一管理。这种统一管理调度，循环利用的方式，就叫做线程池。</p>
<p>**实现方式：**程序启动时，一次性创建好一定数量的线程。这种方式让人更放心，觉得程序代码更稳定。</p>
<h3 id="三线程创建数量谈">三、线程创建数量谈：
</h3><p>1、线程创建的数量极限的问题</p>
<p>一般来讲，2000个线程基本就是极限；再创建就会崩溃。</p>
<p>2、线程创建数量建议</p>
<p>a、采用某些计数开发程序提供的建议，遵照建议和指示来确保程序高效执行。</p>
<p>b、创建多线程完成业务；考虑可能被阻塞的线程数量，创建多余最大被阻塞线程数量的线程，如100个线程被阻塞再充值业务，开110个线程就是很合适的</p>
<p>c、线程创建数量尽量不要超过500个，尽量控制在200个之内；</p>

</section>


    <footer class="article-footer">
    

    </footer>


    
</article>

    

    

     
    
        
    <script src="https://utteranc.es/client.js" 
        repo="pikapika-zrf/pikapika-zrf.github.io"
        issue-term="pathname"
        
        label="comment"
        
        crossorigin="anonymous"
        async
        >
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    let utterancesLoaded = false;

    function setUtterancesTheme(theme) {
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${theme}`
                },
                'https://utteranc.es'
            );
        }
    }

    addEventListener('message', event => {
        if (event.origin !== 'https://utteranc.es') return;

        
        utterancesLoaded = true;
        setUtterancesTheme(document.documentElement.dataset.scheme)
    });

    window.addEventListener('onColorSchemeChange', (e) => {
        if (!utterancesLoaded) return;
        setUtterancesTheme(e.detail)
    })
</script>


    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2024 raff
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.29.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.3d77866ec2ca96ed309ef0db701e98ee686f9a7761045fe1a6fe807e12eacc91.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
