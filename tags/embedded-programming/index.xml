<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Embedded Programming on </title>
        <link>https://raff-zeng.github.io/tags/embedded-programming/</link>
        <description>Recent content in Embedded Programming on </description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>raff</copyright>
        <lastBuildDate>Sun, 01 Jan 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://raff-zeng.github.io/tags/embedded-programming/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>嵌入式面试</title>
        <link>https://raff-zeng.github.io/post/reading-notes/notes-at-school/embedinterview/</link>
        <pubDate>Sun, 01 Jan 2023 00:00:00 +0000</pubDate>
        
        <guid>https://raff-zeng.github.io/post/reading-notes/notes-at-school/embedinterview/</guid>
        <description>&lt;h1 id=&#34;c-八股&#34;&gt;C 八股
&lt;/h1&gt;&lt;h3 id=&#34;1关键字register&#34;&gt;1、关键字register
&lt;/h3&gt;&lt;p&gt;（1）作用：编译器会将register修饰的变量尽可能地放在CPU的寄存器中，以加快其存取速度，一般用于频繁使用的变量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;register变量可能不存放在内存中，所以不能用&amp;amp;来获取该变量的地址；&lt;/li&gt;
&lt;li&gt;只有局部变量和形参可以作为register变量；&lt;/li&gt;
&lt;li&gt;寄存器数量有限，不能定义过多register变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2volatile和extern分别在哪个阶段起作用&#34;&gt;2、volatile和extern分别在哪个阶段起作用？
&lt;/h3&gt;&lt;p&gt;**答案：**volatile在编译阶段，extern在链接阶段。&lt;/p&gt;
&lt;h3 id=&#34;4用变量a给出下面的定义&#34;&gt;4、用变量a给出下面的定义
&lt;/h3&gt;&lt;p&gt;（1）一个有10个整型数的数组 ：&lt;code&gt;int a[10]&lt;/code&gt;。
（2）一个有10个指针的数组，这10个指针是指向整型数的（指针数组）： &lt;code&gt;int *a[10]&lt;/code&gt;。
（3）一个指向有10个整型数数组的指针（数组指针）：&lt;code&gt;int (*a)[10]&lt;/code&gt;。
（4）一个指向函数的指针，该函数有一个整型参数并返回一个整型数（函数指针）：&lt;code&gt;int (*a)(int)&lt;/code&gt;。
（5）一个有10个指针的数组，这10个指针均指向函数，该函数有一个整型参数并返回一   个整型数（函数指针数组）： &lt;code&gt;int (*a[10])(int)&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;5下面的代码输出是什么为什么&#34;&gt;5、下面的代码输出是什么，为什么？
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;gt; 6&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34; &amp;lt;= 6&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;**答案：**输出是 “&amp;gt;6”。&lt;/p&gt;
&lt;p&gt;**解读：**当运算表达式中存在有符号数和无符号数时，&lt;strong&gt;有符号数隐式转换成了无符号数&lt;/strong&gt;（即底层的补码不变，但是此数从有符号数变成了无符号数）。注意，正数的补码为其本身，负数的补码为其反码+1。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果 ”&amp;gt;6”。&lt;/p&gt;
&lt;h3 id=&#34;6写出float-x与零值比较的if语句&#34;&gt;6、写出float x与“零值”比较的if语句。
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.000001&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.000001&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;因为计算机在处理浮点数的时候是有误差的，所以不能将浮点型变量用“==”或“！=”与数字比较，应该设法转化成“&amp;gt;”或“&amp;lt;”此类形式。&lt;/p&gt;
&lt;h3 id=&#34;8结构体内存对齐的原因&#34;&gt;8、结构体内存对齐的原因？
&lt;/h3&gt;&lt;p&gt;（1）平台原因：&lt;strong&gt;不是所有的硬件平台都能访问任意地址上的任意数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（2）性能原因：数据结构应该尽可能地&lt;strong&gt;在自然边界上对齐&lt;/strong&gt;，因为&lt;strong&gt;访问未对齐的内存，处理器需要做两次内存访问&lt;/strong&gt;，而&lt;strong&gt;访问对齐的内存仅需要一次&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;9结构体struct和联合体union的区别&#34;&gt;9、结构体struct和联合体union的区别？
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;结构体各成员拥有自己的内存，互不干涉，遵循内存对齐原则。&lt;/li&gt;
&lt;li&gt;联合体所有成员共用一块内存空间，同时只有一个成员可以得到这块内存的使用权。一个联合体变量的总长度应至少能容纳最大的成员变量，且需要进行内存补齐。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt;&lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;union&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Un1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//1个char类型占1字节，5个占5字节
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//4字节
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;union&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Un2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;short&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//1个short类型占2字节，7个占14字节
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//4字节
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;union&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Un1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//打印8
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;union&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Un2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//打印16
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;10gcc编译过程-从c到可执行文件&#34;&gt;10、&lt;strong&gt;gcc编译过程 从.c到可执行文件&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;gcc 是 GNU Compiler Collection 的缩写，是一种广泛使用的 C/C++ 编译器。gcc 的编译过程一般包括以下几个步骤，从 .c 文件到可执行文件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;预处理：&lt;strong&gt;头文件、宏展开&lt;/strong&gt;；&lt;strong&gt;条件编译保留或移除&lt;/strong&gt;；&lt;strong&gt;去除注释&lt;/strong&gt;。结果以 .i 扩展名命名。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译：将预处理后的源代码&lt;strong&gt;转换为汇编代码&lt;/strong&gt;。&lt;strong&gt;词法分析；语法分析；语义分析；代码生成&lt;/strong&gt;。编译后的汇编代码以 .s 扩展名命名。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;汇编：将汇编代码&lt;strong&gt;转换为机器代码&lt;/strong&gt;。词法分析；语法分析；代码生成。汇编后的机器代码以 .o 扩展名命名。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;链接：目标文件&lt;strong&gt;和其他库文件链接在一起，生成可执行文件&lt;/strong&gt;。符号解析；重定位；可执行文件生成。最终生成的可执行文件保存在当前目录下，可以直接运行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要注意的是，gcc 的编译过程可以通过命令行参数控制编译过程的细节，包括指定输出文件名、优化选项、调试信息等。常用的 gcc 命令行参数包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-c：仅编译，不链接，生成目标文件；&lt;/li&gt;
&lt;li&gt;-o：指定输出文件名；&lt;/li&gt;
&lt;li&gt;-Wall：打开所有警告；&lt;/li&gt;
&lt;li&gt;-Werror：将所有警告视为错误；&lt;/li&gt;
&lt;li&gt;-g：生成调试信息；&lt;/li&gt;
&lt;li&gt;-O0/-O1/-O2/-O3：控制优化级别；&lt;/li&gt;
&lt;li&gt;-I：指定头文件搜索路径；&lt;/li&gt;
&lt;li&gt;-L：指定库文件搜索路径；&lt;/li&gt;
&lt;li&gt;-l：指定需要链接的库文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;c-八股-1&#34;&gt;C++ 八股
&lt;/h1&gt;&lt;h2 id=&#34;一基本语法&#34;&gt;一、基本语法
&lt;/h2&gt;&lt;h3 id=&#34;1常量指针与指针常量&#34;&gt;1、常量指针与指针常量
&lt;/h3&gt;&lt;p&gt;指针常量（底层const&lt;code&gt;指针所指的对象是个常量&lt;/code&gt;） 指向的对象的值不可变&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;const 数据类型 *指针变量 = 变量名
数据类型 const *指针变量 = 变量名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;常量指针（顶层const&lt;code&gt;指针本身是个常量&lt;/code&gt;）  指向的内存地址不可变&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数据类型 * const 指针变量=变量名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;若要修改const修饰的变量的值，需要加上关键字volatile；&lt;/p&gt;
&lt;p&gt;若想要修改const成员函数中某些与类状态⽆关的数据成员，可以使用mutable关键字来修饰这个数据成员&lt;/p&gt;
&lt;h3 id=&#34;2definetypedef函数&#34;&gt;2、define、typedef、函数
&lt;/h3&gt;&lt;p&gt;define&lt;/p&gt;
&lt;p&gt;宏定义在编译的预处理阶段被处理，属于文本插入替换，用于定义常量和书写复杂的内容。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;只是简单的字符替换，没有类型检查，不安全。&lt;/li&gt;
&lt;li&gt;宏替换不占运行时间，只占编译时间&lt;/li&gt;
&lt;li&gt;带参宏在处理时不分配内存&lt;/li&gt;
&lt;li&gt;宏不存在类型问题，宏名无类型，它的参数也是无类型的；而函数中的实参和形参都要定义类型，二者的类型要求一致。&lt;/li&gt;
&lt;li&gt;使用宏定义次数多时，宏替换后源程序会变长&lt;/li&gt;
&lt;li&gt;可以用来防止头文件重复引用&lt;/li&gt;
&lt;li&gt;不需要在最后加分号&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;typedef&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;有对应的数据类型，是要进行判断的&lt;/li&gt;
&lt;li&gt;是在编译、运行时候起作用&lt;/li&gt;
&lt;li&gt;在静态存储区中分配空间，在程序运行过程中内存中只有⼀个拷贝&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;函数&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;函数在运行时进行调用和返回&lt;/li&gt;
&lt;li&gt;函数调用则占运行时间（分配单元、保留现场、值传递、返回）&lt;/li&gt;
&lt;li&gt;函数调用会分配临时内存&lt;/li&gt;
&lt;li&gt;函数中的实参和形参都要定义类型，二者的类型要求一致&lt;/li&gt;
&lt;li&gt;函数调用不使源程序变长&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;宏展开中的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;宏展开错误主要是由于运算符优先级等原因，使得宏展开后的语义与预想发生偏差。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在宏定义中，最好将参数加上括号。在替换时保证括号内的表达式优先运算。&lt;/li&gt;
&lt;li&gt;利用括号将整个宏定义的内容括起来。保证整个宏定义中的表达式优先运算。&lt;/li&gt;
&lt;li&gt;尽量不要使用++x这类表达式作为内联函数参数，由于同一个参数在宏展开时进行了两次替换，程序结果与预期不符。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3重写override-和-重载overload&#34;&gt;3、重写override 和 重载overload
&lt;/h3&gt;&lt;p&gt;1、override是&lt;strong&gt;子类&lt;/strong&gt;中存在重新定义的函数。&lt;/p&gt;
&lt;p&gt;以实现不同的功能，用于子类在继承父类时，重写父类方法&lt;/p&gt;
&lt;p&gt;规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。&lt;strong&gt;只有函数体不同&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;调用过程中根据对象的类型，调用相应类中的函数。&lt;/li&gt;
&lt;li&gt;重写的&lt;strong&gt;基类中&lt;/strong&gt;被重写的函数&lt;strong&gt;必须有virtual&lt;/strong&gt;修饰。&lt;/li&gt;
&lt;li&gt;静态方法不能被重写为非静态的方法&lt;/li&gt;
&lt;li&gt;重写方法的访问修饰符⼀定要⼤于被重写方法的访问修饰符
（public&amp;gt;protected&amp;gt;default&amp;gt;private）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2、overload是重载，这些方法的名称相同而参数形式不同&lt;/p&gt;
&lt;p&gt;重载函数：同一作用域内的&lt;strong&gt;函数名字相同&lt;/strong&gt;但&lt;strong&gt;形参列表不同&lt;/strong&gt;（数量或者类型不同）&lt;/p&gt;
&lt;p&gt;规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不同的参数类型可以是不同的参数类型，不同的参数个数，不同的参数顺序（参数类型必须不⼀样）&lt;/li&gt;
&lt;li&gt;不能通过访问权限、返回类型、抛出的异常进行重载&lt;/li&gt;
&lt;li&gt;方法的异常类型和数目不会对重载造成影响&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用多态是为了避免在父类里⼤量重载引起代码臃肿且难于维护。&lt;/p&gt;
&lt;p&gt;重写与重载的本质区别是,加⼊了override的修饰符的方法,此方法始终只有⼀个被你使用的方法。&lt;/p&gt;
&lt;p&gt;tips：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;顶层const不能重载，底层可以。参数本身是不是const对函数重载没有影响。&lt;/li&gt;
&lt;li&gt;C++在编译过程中对函数重命名的规则保证了重载函数在重命名后函数名的唯一性。C语言在编译过程中不会对函数重命名。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4const和constexpr&#34;&gt;4、const和constexpr
&lt;/h3&gt;&lt;p&gt;const 表示“只读”的语义，constexpr 表示“常量”的语义&lt;/p&gt;
&lt;p&gt;constexpr 只能定义编译期常量，而 const 可以定义编译期常量，也可以定义运行期常量。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;constexpr的好处&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为⼀些不能修改数据提供保障，写成变量则就有被意外修改的风险。&lt;/li&gt;
&lt;li&gt;有些场景，编译器可以在编译期对constexpr的代码进行优化，提⾼效率。&lt;/li&gt;
&lt;li&gt;相比宏来说，没有额外的开销，但更安全可靠。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;5前置和后置&#34;&gt;5、前置++和后置++
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;self&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;self&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tmp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;++*&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tmp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;后置返回对象，而不是引用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么后置前⾯也要加const
其实也可以不加，但是为了&lt;strong&gt;防止使用i++++&lt;/strong&gt;,连续两次的调用后置++重载符&lt;/p&gt;
&lt;p&gt;原因：
它与内置类型行为不⼀致；你⽆法活得你所期望的结果，因为第⼀次返回的是旧值，而不是原对象，你调用两次后置++，结果只累加了⼀次，所以我们必须⼿动禁⽌其合法化，就要在前⾯加上const。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;处理用户的⾃定义类型
最好使用前置++，因为他不会创建临时对象，进而不会带来构造和析构而造成的格外开销&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;6运算符重载&#34;&gt;6、运算符重载
&lt;/h3&gt;&lt;p&gt;重载运算符函数，本质还是函数调用，所以重载后&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以是和调用运算符的方式调用，data1+data2&lt;/li&gt;
&lt;li&gt;也可以是调用函数的方式，operator+(data1, data2)，这就要注意运算符函数的名字是“operator运算符”&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不能重载：&lt;code&gt;. 、 * 、 :: 、 sizeof 、 条件运算符?: &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;运算符重载的方式有两种：&lt;strong&gt;类成员函数&lt;/strong&gt;和&lt;strong&gt;友元函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;tips：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对单目运算符进行重载时使用类成员函数&lt;/li&gt;
&lt;li&gt;对双目运算符进行重载时使用友元函数&lt;/li&gt;
&lt;li&gt;(),[]重载时必须使用类成员函数，&amp;laquo;,&amp;raquo;重载时必须使用友元函数&lt;/li&gt;
&lt;li&gt;当重载的运算符是成员函数时，this绑定到左侧运算符对象。成员运算符函数的参数数量比运算符对象的数量少一个&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;7模板全特化和偏特化&#34;&gt;7、模板全特化和偏特化
&lt;/h3&gt;&lt;p&gt;模板分为&lt;strong&gt;类模板与函数模板&lt;/strong&gt;，特化分为&lt;strong&gt;特例化（全特化）&lt;strong&gt;和&lt;/strong&gt;部分特例化（偏特化）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对函数模板：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;模板和特例化版本应该声明在同⼀头文件，所有同名模板的声明应放在前⾯，接着是特例化版本。&lt;/li&gt;
&lt;li&gt;⼀个模板被称为全特化的条件：1.必须有⼀个主模板类 2.模板类型被全部明确化。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对主版本模板类、全特化类、偏特化类的调用优先级从⾼到低进行排序是：全特化类&amp;gt;偏特化类&amp;gt;主版本模板类。&lt;/p&gt;
&lt;h3 id=&#34;8浅拷贝与深拷贝&#34;&gt;8、浅拷贝与深拷贝
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;浅拷贝&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深拷贝：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。&lt;/p&gt;
&lt;h3 id=&#34;9野指针和悬空指针&#34;&gt;9、野指针和悬空指针
&lt;/h3&gt;&lt;p&gt;都是是指向无效内存区域(这里的无效指的是&amp;quot;不安全不可控&amp;quot;)的指针，访问行为将会导致未定义行为。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;野指针&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;野指针，指的是没有被初始化过的指针。&lt;/li&gt;
&lt;li&gt;为了防止出错，及时初始化或者赋值为 &lt;code&gt;nullptr&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;悬空指针&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;悬空指针，指针最初指向的内存已经被释放了的一种指针。&lt;/li&gt;
&lt;li&gt;释放操作后立即置空。&lt;/li&gt;
&lt;li&gt;C++智能指针的本质就是避免悬空指针的产生。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另一个说法（统称为野指针）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;指针未初始化&lt;/li&gt;
&lt;li&gt;指针指向的变量被free或delete后没有置为NULL&lt;/li&gt;
&lt;li&gt;指针操作超过所指向变量的生存期&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;10内联函数&#34;&gt;10、内联函数
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销，并且进行参数类型检查。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作为类的成员函数时，可以访问类的所有成员，也有this指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内联函数一定要在函数定义时使用inline关键字，在函数声明中使用inline是没有效果的。函数的使用者不需要知道函数是否是内联函数，inline关键字不应该出现在声明中。&lt;/p&gt;
&lt;p&gt;【如果在函数声明的同时给出函数定义，编译器会自动将函数识别为内联函数。不推荐使用。】&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;inline是先将内联函数编译完成⽣成了函数体直接插⼊被调⽤的地方，减少了压栈，跳转和返回的操作。没有普通函数调⽤时的额外开销；&lt;/li&gt;
&lt;li&gt;内联函数是⼀种特殊的函数，会进行类型检查；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;p&gt;​	会使程序的代码量增大，消耗更多内存空间&lt;/p&gt;
&lt;p&gt;适用场景：&lt;strong&gt;函数体内没有循环（执行时间短）且代码简短（占用内存空间小）&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;C++中inline编译限制：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不能存在任何形式的循环语句&lt;/li&gt;
&lt;li&gt;不能存在过多的条件判断语句&lt;/li&gt;
&lt;li&gt;函数体不能过于庞⼤&lt;/li&gt;
&lt;li&gt;内联函数声明必须在调⽤语句之前&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;内联函数和宏定义的区别&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;都能节省频繁的函数调用产生的时间和空间的开销，提高程序执行的效率。二者都是将函数调用替换成完整的函数体&lt;/li&gt;
&lt;li&gt;宏定义是字符串替换。内联函数是个函数，具有函数的基本性质。&lt;/li&gt;
&lt;li&gt;宏定义展开在预处理阶段，内联函数展开在编译阶段。&lt;/li&gt;
&lt;li&gt;内联函数作为类的成员函数时，可以访问类的所有成员，也有this指针。宏定义没有。&lt;/li&gt;
&lt;li&gt;内联函数可以完全替代宏定义&lt;/li&gt;
&lt;li&gt;使用内联函数需要注意代码膨胀问题，如果内联函数体非常庞大，且在程序各处都会调用该内联函数，代码展开后的内联函数内嵌到程序各处，造成程序代码体积极度增长。因此定义内联函数时要确保内联函数的函数体十分简单。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;11大小端存储&#34;&gt;11、大小端存储
&lt;/h3&gt;&lt;p&gt;大端存储：字数据的高字节存储在低地址中&lt;/p&gt;
&lt;p&gt;小端存储：字数据的低字节存储在低地址中&lt;/p&gt;
&lt;h3 id=&#34;12volatilemutable和explicit关键字&#34;&gt;12、volatile、mutable和explicit关键字
&lt;/h3&gt;&lt;h4 id=&#34;1volatile&#34;&gt;(1)volatile
&lt;/h4&gt;&lt;p&gt;类型修饰符。用该关键字声明的变量表示该变量随时可能发⽣变化，与该变量有关的运算，不要进行编译优化；每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。&lt;/p&gt;
&lt;p&gt;**作用：**确保本条指令不会因编译器的优化而省略，且要求每次直接读值，保证对特殊地址的稳定访问&lt;/p&gt;
&lt;p&gt;**使用场合：**在中断服务程序和cpu相关寄存器的定义 。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;①并行设备的硬件寄存器（如：状态寄存器）。&lt;/p&gt;
&lt;p&gt;②中断服务程序中共享变量和状态标志。&lt;/p&gt;
&lt;p&gt;③多线程中的共享变量（防止死锁）。&lt;/p&gt;
&lt;h4 id=&#34;2mutable&#34;&gt;（2）mutable
&lt;/h4&gt;&lt;p&gt;被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。&lt;/p&gt;
&lt;h4 id=&#34;3explicit&#34;&gt;（3）explicit
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;explicit 关键字用于类内部的构造函数声明上&lt;/li&gt;
&lt;li&gt;被explicit修饰的构造函数的类，不能发生相应的隐式类型转换，只能以&lt;strong&gt;显式的方式进行类型转换&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;13异常处理&#34;&gt;13、异常处理
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;常见的异常有：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组下标越界&lt;/li&gt;
&lt;li&gt;除法计算时除数为0&lt;/li&gt;
&lt;li&gt;动态分配空间时空间不足&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;异常处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）try、throw和catch关键字&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;C++中的异常处理机制主要使用&lt;strong&gt;try&lt;/strong&gt;、&lt;strong&gt;throw&lt;/strong&gt;和&lt;strong&gt;catch&lt;/strong&gt;三个关键字，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）函数的异常声明列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表，写法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fun&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){...};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这种写法表名函数可能会抛出int,double型或者A、B、C三种类型的异常，如果throw中为空，表明不会抛出任何异常，如果没有throw则可能抛出任何异常&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）C++标准异常类 exception&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;C++ 标准库中有一些类代表异常，这些类都是从 exception 类派生而来的。&lt;/p&gt;
&lt;h3 id=&#34;14string与c语言中的-char-有什么区别&#34;&gt;14、string与C语言中的 char *有什么区别
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据类型&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;string&lt;/code&gt; 是C++标准库中的字符串类。它是一个类，包含了一组方法和属性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char*&lt;/code&gt; 是C-style字符串，是一种基本数据类型，用于存储字符串的内存地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内存管理&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;string&lt;/code&gt; 类自动处理内存管理。它会自动分配和释放内存，无需手动管理字符串的大小或内存释放。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char*&lt;/code&gt; 需要手动管理内存。你需要分配足够的内存来存储字符串，并在不再需要时手动释放内存。这容易导致内存泄漏或释放未分配的内存等问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可变性&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;string&lt;/code&gt; 是可变的。你可以通过调用成员函数来修改字符串的内容。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char*&lt;/code&gt; 本身是可变的，但指向的字符串内容可能是不可变的，具体取决于如何声明和使用 &lt;code&gt;char*&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;字符串操作&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;string&lt;/code&gt; 类提供了丰富的字符串操作函数，如拼接、查找、替换、子串提取等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char*&lt;/code&gt; 需要使用标准库函数或自己编写代码来执行这些操作，操作起来更繁琐。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;安全性&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;string&lt;/code&gt; 对象提供了一定程度的安全性，因为它包含了长度信息，可以避免缓冲区溢出。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char*&lt;/code&gt; 需要特别小心，容易导致缓冲区溢出和其他内存错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;它是如何实现的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2*n），然后将原字符串拷贝过去，并加上新增的内容。&lt;/p&gt;
&lt;h3 id=&#34;15extern&#34;&gt;15、extern
&lt;/h3&gt;&lt;p&gt;用于跨文件引用全局变量，即在本文件中引用一个已经在其他文件中定义的全局变量。&lt;/p&gt;
&lt;p&gt;**定义：**声明外部变量【在函数或者文件外部定义的全局变量】&lt;/p&gt;
&lt;p&gt;（1）注意引用时不能初始化，如extern var，而不能是extern var = 0。&lt;/p&gt;
&lt;p&gt;（2）另外，函数默认是extern类型的，表明是整个程序（工程）可见的，加不加都一样。&lt;/p&gt;
&lt;h3 id=&#34;16externc的作用&#34;&gt;&lt;strong&gt;16、extern”C”的作用？&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;extern &amp;ldquo;C&amp;rdquo; 是 C++ 提供的一个关键字，主要是用于在 C++ 中调用 C 语言函数。在 C++ 中，函数名的重载、命名空间等特性会使得 C++ 编译器对函数名的处理与 C 语言不同，导致在 C++ 中调用 C 函数时出现编译错误。&lt;/p&gt;
&lt;p&gt;使用 extern &amp;ldquo;C&amp;rdquo; 可以解决这个问题，它告诉编译器这个函数应该按照 C 语言的规则来编译和链接，从而可以正确地调用 C 函数。同时，extern &amp;ldquo;C&amp;rdquo; 也可以用于解决 C++ 代码中的函数重载问题。&lt;/p&gt;
&lt;p&gt;（1）在C++代码中调用C函数，用法：extern “C”{C函数库头文件/函数声明}。&lt;/p&gt;
&lt;p&gt;（2）在C代码中调用C++函数，用法：在C++的头文件中加extern“C”{头文件/函数声明}。&lt;/p&gt;
&lt;p&gt;tips：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;extern “C”只能用于C++文件中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;17指针和引用的区别&#34;&gt;17、指针和引用的区别
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;指针是变量的地址，引用是变量的别名&lt;/li&gt;
&lt;li&gt;指针可以不初始化，引用必须初始化绑定到一个变量中&lt;/li&gt;
&lt;li&gt;指针变量可以指向NULL，引用不能为NULL&lt;/li&gt;
&lt;li&gt;指针在初始化后可以更改指向，引用初始化后就不能够更改了&lt;/li&gt;
&lt;li&gt;指针可以由多级，引用只能够有一级&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;左值和右值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在赋值语句中，只能出现在等号右边的是右值。既能出现在等号左边又能出现在等号右边的是左值&lt;/p&gt;
&lt;h3 id=&#34;18static&#34;&gt;18、static
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;静态局部变量&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;改变了其存储位置，存储在静态区；&lt;/li&gt;
&lt;li&gt;局部静态变量的生命周期从其第一次初始化开始，直到程序结束。它在函数内部的作用域之外也是可见的，但只能在函数内部访问。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;静态全局变量&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;全局静态变量的生命周期从程序开始时初始化开始，直到程序结束。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作用域在文件内部。&lt;/p&gt;
&lt;p&gt;普通全局变量的作用域是整个工程。在头文件声明中使用&lt;code&gt;extern&lt;/code&gt;声明普通全局变量，其他文件使用#include包含该文件，就可以在当前文件中使用普通全局变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通常情况下，静态全局变量的声明和定义放在源文件中。如果在头文件中声明静态全局变量，静态全局变量在声明的同时会被初始化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果多个源文件包含了定义了某个静态全局变量的头文件，该静态全局变量在各个源文件中都有一份单独的拷贝。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;静态成员变量&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;静态成员变量属于整个类，不属于某个对象，只有唯一的一份拷贝，所有对象共享类中的静态数据成员。&lt;/li&gt;
&lt;li&gt;必须在类内声明，在类外部初始化。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;静态成员函数&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;没有this指针&lt;/li&gt;
&lt;li&gt;无法访问类对象的非static成员变量和非static成员函数&lt;/li&gt;
&lt;li&gt;静态函数的作用域限定在其所属的类命名空间内。&lt;/li&gt;
&lt;li&gt;不依赖于类。&lt;/li&gt;
&lt;li&gt;不能被声明为const、虚函数和volatile&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;19关键字auto的作用是什么&#34;&gt;19、&lt;strong&gt;关键字auto的作用是什么？&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;用来定义自动局部变量，自动局部变量在进入声明该变量的语句块时被建立，退出语句块时被注销，仅在语句块内部使用。&lt;/p&gt;
&lt;h3 id=&#34;20结构体数据对齐&#34;&gt;20、结构体数据对齐
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;成员在内存中的起始地址编码必须是成员类型所占字节数的整数倍。&lt;/li&gt;
&lt;li&gt;结构体占用的空间是结构体中占用空间最多的成员所占空间的整数倍&lt;/li&gt;
&lt;li&gt;分配内存的顺序是按照声明的顺序&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;添加了#pragma pack(n)后规则就变成：&lt;/p&gt;
&lt;p&gt;1、 偏移量要是n和当前变量大小中较小值的整数倍&lt;/p&gt;
&lt;p&gt;2、 整体大小要是n和最大变量大小中较小值的整数倍&lt;/p&gt;
&lt;p&gt;3、 n值必须为1,2,4,8…，为其他值时就按照默认的分配规则&lt;/p&gt;
&lt;h3 id=&#34;lambda表达式&#34;&gt;Lambda表达式
&lt;/h3&gt;&lt;p&gt;Lambda表达式是C++11中引入的一种匿名函数定义方式，它可以用于创建临时函数对象，不需要显式定义函数名称。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;表⽰⼀个可调用的代码单元，没有命名的内联函数。不需要函数名，因为我们⼀次性的使用它，不需要其他地方调用它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由以下几个部分组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;[捕获列表]：捕获Lambda表达式所在作用域内的变量，捕获变量可以是值捕获或引用捕获。&lt;/li&gt;
&lt;li&gt;(参数列表)：定义Lambda表达式的参数列表。&lt;/li&gt;
&lt;li&gt;mutable：用于指定是否可以修改Lambda表达式所在作用域内的变量。&lt;/li&gt;
&lt;li&gt;-&amp;gt; 返回值类型：指定Lambda表达式的返回值类型，可以省略。&lt;/li&gt;
&lt;li&gt;{函数体}：Lambda表达式的函数体。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;capture&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;parameter&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// [捕获列表] (参数列表) -&amp;gt; 返回类型 {函数体 }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 只有 [capture list] 捕获列表和 {function body } 函数体是必选的
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lam&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Hello, World!&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;88&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lam&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 输出88
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;strcpy和strncpy的区别&#34;&gt;strcpy和strncpy的区别
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;strcpy&lt;/code&gt;和&lt;code&gt;strncpy&lt;/code&gt;都是C语言中的字符串操作函数，其区别如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;函数原型不同&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;strcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;src&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;strncpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;src&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;strncpy&lt;/code&gt;需要指定需要拷贝的字符串长度。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;处理方式不同&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;strcpy&lt;/code&gt;的处理方式是将源字符串一直拷贝到遇到&amp;rsquo;\0&amp;rsquo;为止，会导致堆栈溢出等问题。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strncpy&lt;/code&gt;的处理方式是将源字符串拷贝到指定长度或遇到&amp;rsquo;\0&amp;rsquo;为止。如果目标字符串长度小于指定长度，则会用空字符填充目标字符串直至指定长度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;面向对象和面向过程的区别&#34;&gt;面向对象和面向过程的区别
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;从设计思路来看&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;面向过程程序设计的重点是分析问题解决的步骤，明确每个步骤的输入和输出以及完成各步骤的流程，是一种结构化的自上而下的程序设计方法。&lt;/p&gt;
&lt;p&gt;面向对象程序设计的重点是把构成问题的事务分解成对象，从局部着手，通过迭代的方法逐步构建出整个程序，是一种以数据为核心，以类设计为主要工作的自下而上的程序设计方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从适用范围来看&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;面向过程的程序性能更高，由于不涉及实例化对象等操作，系统开销更小。&lt;/p&gt;
&lt;p&gt;面向对象由于其抽象封装继承多态的特性，使得系统具有更好的可扩展性、可复用性、可维护性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从代码复用来看&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然都可以代码复用，但是面向过程重用的是函数，面向对象重用的是类。&lt;/p&gt;
&lt;h3 id=&#34;include和include的区别&#34;&gt;#include&amp;lt;&amp;gt;和#include””的区别
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;#include&amp;lt;&amp;gt;&lt;/code&gt;搜索时从编译器指定的路径处搜索，如果找不到，程序直接报错。系统提供的头文件使用&lt;code&gt;#include&amp;lt;&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#include&amp;quot;&amp;quot;&lt;/code&gt;先从运行程序当前目录中进行搜索，如果搜索失败再从编译器指定的路径搜索，如果仍然搜索失败，则程序报错。用户自定义的头文件使用&lt;code&gt;#include&amp;quot;&amp;quot;&lt;/code&gt;引入。&lt;/p&gt;
&lt;h3 id=&#34;和在define中的作用&#34;&gt;#和##在define中的作用
&lt;/h3&gt;&lt;p&gt;宏定义中的#运算符将其后面的参数转换成字符串&lt;/p&gt;
&lt;p&gt;宏定义中的##运算符将前后的参数进行字符串连接&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#define PRINTCUBE(x) cout&amp;lt;&amp;lt;&amp;#34;cube(&amp;#34;&amp;lt;&amp;lt;#x&amp;lt;&amp;lt;&amp;#34;)=&amp;#34; &amp;lt;&amp;lt;(x)*(x)*(x)&amp;lt;&amp;lt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#define LINK3(x,y,z) x##y##z
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PRINTCUBE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;LINK3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;C&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;+&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;+&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;cube(&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;)=&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;输出&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;cube&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;125&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;C++&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;assert断言&#34;&gt;assert断言
&lt;/h3&gt;&lt;p&gt;assert用于在程序的DEBUG版本中检测条件表达式，如果结果为假，则输出诊断信息并终止程序运行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最好在每个assert中只检测一个条件。否则断言失败无法判断是哪个条件出错。&lt;/li&gt;
&lt;li&gt;不要在assert中修改条件变量的值&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;类型转换符&#34;&gt;类型转换符
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;static_cast&lt;/code&gt;、&lt;code&gt;dynamic_cast&lt;/code&gt;、&lt;code&gt;const_cast&lt;/code&gt;、&lt;code&gt;reinterpret_cast&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;static_cast&lt;/code&gt;可以&lt;strong&gt;完全代替C风格的类型转换&lt;/strong&gt;。在对象指针之间的类型转换时，&lt;strong&gt;可以将父类指针转换成子类指针，也可以将子类指针转换为父类指针。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;父类指针指向父类对象，用&lt;code&gt;static_cast&lt;/code&gt;将父类指针转换为子类指针时，不安全。如果父类指针原本就指向一个子类对象，则不存在安全性问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把空指针转换成目标类型的空指针&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把任何类型的表达式转换成void类型&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;比C语言中的转换强在哪里&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;​	a. 更加安全&lt;/p&gt;
&lt;p&gt;​	b. 更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;&lt;strong&gt;只能用于对象指针之间的类型转换&lt;/strong&gt;，父类指针转换为子类指针，也可以见子类指针转换为父类指针。转换过程中需要对对象类型进行检查，以保证类型完全匹配。&lt;/p&gt;
&lt;p&gt;只有当父类指针指向子类对象，并且父类中包含虚函数时，使用&lt;code&gt;dynamic_cast&lt;/code&gt;将父类指针转换成子类指针才会成功，否则返回空指针，如果是引用则抛出异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;const_cast&lt;/code&gt;增加或删除const属性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt;将一种类型的指针直接转换为另一种类型的指针，不论两个类型之间是否有继承关系。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;sizeof&#34;&gt;sizeof
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;sizeof是单目运算符，不是一个函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作数可以是类型名，也可以是表达式。类型名，则获得该类型的字节数。表达式，先分析表达式结果的类型，再确定所占用字节数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将数组名作为sizeof运算符的操作数可以获得整个数组所占的空间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以对函数调用表达式进行sizeof运算，会计算函数返回类型所占用的空间。而函数名、没有返回值或返回值为void就不用使用sizeof。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;数组和指针的区别&#34;&gt;数组和指针的区别
&lt;/h3&gt;&lt;p&gt;数组名等价于数组首元素的地址。数组名作为函数参数时，相当于传递了数组首元素的地址。&lt;/p&gt;
&lt;p&gt;tips：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;字符数组不同于字符串，末尾不会自动加上字符串提示符\0&lt;/li&gt;
&lt;li&gt;当定义一个没有显式指明大小的数组时，必须在定义的同时初始化。&lt;/li&gt;
&lt;li&gt;(const函数形参)如果指针参数的值不应该在函数调用过程中被修改，可在函数指针形参前面加上const修饰符。这样在函数中一旦有对指针的值进行修改，编译器会报错。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;指针数组和数组指针&#34;&gt;指针数组和数组指针
&lt;/h3&gt;&lt;p&gt;指针数组：指向变量类型 *数组名称 [数组长度]		&lt;code&gt;int *p[3]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;数组指针：数组元素类型 (* 指针名称) [数组长度]  	&lt;code&gt;int (*p)[3]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;tips：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;[]优先级高于*&lt;/li&gt;
&lt;li&gt;数组指针p指向的是整个数组a，而非数组a的首元素&lt;/li&gt;
&lt;li&gt;数组地址&lt;code&gt;&amp;amp;a&lt;/code&gt;和数组首元素地址&lt;code&gt;&amp;amp;a[0]&lt;/code&gt;只是在数值上相等。数组地址&lt;code&gt;&amp;amp;a&lt;/code&gt;解引用成为&lt;code&gt;&amp;amp;a[0]&lt;/code&gt;，数组首元素地址&lt;code&gt;&amp;amp;a[0]&lt;/code&gt;解引用后成为&lt;code&gt;a[0]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int a[2][3]={{1,2,3},{4,5,6}}&lt;/code&gt;中函数名a等价于&lt;code&gt;a[0]&lt;/code&gt;的地址，类型是&lt;code&gt;int *&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;函数指针与指针函数&#34;&gt;函数指针与指针函数
&lt;/h3&gt;&lt;p&gt;函数指针：可以存储函数地址的指针变量。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int (*functionPtr)(int, int);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;每个函数在内存中都占用一段存储单元，这段存储单元的首地址是函数的入口地址，指向这个函数入口地址的指针称为函数指针。&lt;/p&gt;
&lt;p&gt;函数名等价于函数的入口地址。函数的调用可以通过函数名，也可以通过指向函数的指针来调用。函数指针还允许将函数作为变元传递给其他函数；&lt;/p&gt;
&lt;p&gt;指针函数：&lt;/p&gt;
&lt;p&gt;指针函数是指一个返回指针的函数，它本身是一个函数，但返回值是一个指针。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int* createIntArray(int size);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;memcpy与strcpy的区别&#34;&gt;memcpy与strcpy的区别
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;函数strcpy主要用于标准的字符串拷贝，非标准的字符串（没有字符串结尾标志）不能使用该函数。不需要指定长度，它遇到被复制字符的串结束符&amp;quot;\0&amp;quot;才结束，容易溢出。&lt;/li&gt;
&lt;li&gt;函数memcpy主要用于内存块的整体拷贝，在使用时要指定拷贝的长度，拷贝数据的类型没有限制。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;回调函数&#34;&gt;回调函数
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数；&lt;/li&gt;
&lt;li&gt;回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。需要做三件事：&lt;strong&gt;1，声明；2，定义；3，设置触发条件&lt;/strong&gt;，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用；&lt;/li&gt;
&lt;li&gt;回调函数是一个通过函数指针调用的函数。函数指针作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数；&lt;/li&gt;
&lt;li&gt;因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;静态编译与动态编译&#34;&gt;静态编译与动态编译
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;静态编译，编译器在编译可执行文件时，把需要用到的对应动态链接库中的部分提取出来，链接到可执行文件中去，使可执行文件在运行时不需要依赖于动态链接库；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库的命令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;缩小了执行文件体积&lt;/li&gt;
&lt;li&gt;加快编译速度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;哪怕是很简单的程序，只用到了链接库的一两条命令，也需要附带一个相对庞大的链接库&lt;/li&gt;
&lt;li&gt;如果其他计算机上没有安装对应的运行库，用动态编译的可执行文件就不能运行&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;函数形参使用值传递指针或引用&#34;&gt;函数形参使用值传递、指针或引用
&lt;/h3&gt;&lt;p&gt;值传递：数据对象很小，如内置数据类型或者小型结构，&lt;/p&gt;
&lt;p&gt;const指针：如果数据对象是数组&lt;/p&gt;
&lt;p&gt;const指针或者引用：数据对象是较大的结构，提高程序的效率。这样可以节省结构所需的时间和空间；&lt;/p&gt;
&lt;p&gt;const引用：数据对象是类对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引用传参&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优点(对比值传递)：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在函数内部可以对该参数进行修改&lt;/li&gt;
&lt;li&gt;提高函数调用和运行的效率&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;限制：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不能返回局部变量的引用。&lt;/li&gt;
&lt;li&gt;不能返回函数内部new分配的内存的引用。&lt;/li&gt;
&lt;li&gt;可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;阻止一个类被实例化的方法&#34;&gt;阻止一个类被实例化的方法
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;将类定义为抽象基类或者将构造函数声明为private；&lt;/li&gt;
&lt;li&gt;不允许类外部创建类对象，只能在类内部创建对象&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;禁止程序自动生成拷贝构造函数&#34;&gt;禁止程序自动生成拷贝构造函数
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;为了阻止编译器默认生成拷贝构造函数和拷贝赋值函数，我们需要手动去重写这两个函数，某些情况﻿下，为了避免调用拷贝构造函数和﻿拷贝赋值函数，我们需要&lt;strong&gt;将他们设置成private&lt;/strong&gt;，防止被调用。&lt;/li&gt;
&lt;li&gt;类的成员函数和friend函数还是可以调用private函数，如果这个private函数只声明不定义，则会产生一个连接错误；&lt;/li&gt;
&lt;li&gt;针对上述两种情况，我们可以定一个base类，在base类中将拷贝构造函数和拷贝赋值函数设置成private,那么派生类中编译器将不会自动生成这两个函数，且由于base类中该函数是私有的，因此，派生类将阻止编译器执行相关的操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;函数调用过程栈的变化&#34;&gt;函数调用过程栈的变化
&lt;/h3&gt;&lt;p&gt;当函数从入口函数main函数开始执行时，编译器会将我们操作系统的运行状态，main函数的&lt;strong&gt;返回地址&lt;/strong&gt;、main的&lt;strong&gt;参数&lt;/strong&gt;、mian函数中的&lt;strong&gt;变量&lt;/strong&gt;、进行依次压栈；&lt;/p&gt;
&lt;p&gt;当main函数开始调用func()函数时，编译器此时会将main函数的运行状态压栈，再将func()函数的&lt;strong&gt;返回地址&lt;/strong&gt;、func()函数的&lt;strong&gt;参数&lt;/strong&gt;从右到左、func()定义&lt;strong&gt;变量&lt;/strong&gt;依次压栈；&lt;/p&gt;
&lt;p&gt;当func()调用f()的时候，编译器此时会将func()函数的运行状态进行压栈，再将的返回地址、f()函数的参数从右到左、f()定义变量依次压栈&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;var1=%d,var2=%d&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;从代码的输出结果可以看出，函数f(var1)、f(var2)依次入栈，而后先执行f(var2)，再执行f(var1)，最后打印整个字符串，将栈中的变量依次弹出，最后主函数返回。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数的调用过程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）从栈空间分配存储空间&lt;/p&gt;
&lt;p&gt;2）从实参的存储空间复制值到形参栈空间&lt;/p&gt;
&lt;p&gt;3）进行运算&lt;/p&gt;
&lt;p&gt;形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。&lt;/p&gt;
&lt;h3 id=&#34;模板类一般都是放在一个h文件中&#34;&gt;模板类一般都是放在一个h文件中
&lt;/h3&gt;&lt;p&gt;由template&amp;lt;…&amp;gt;处理的任何东西都意味着编译器在当时不为它分配存储空间，仅在需要的时候才会实例化出来。为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。&lt;/p&gt;
&lt;h3 id=&#34;重载函数的匹配原则和顺序&#34;&gt;重载函数的匹配原则和顺序
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;名字查找&lt;/li&gt;
&lt;li&gt;确定候选函数&lt;/li&gt;
&lt;li&gt;寻找最佳匹配&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;定义和声明的区别&#34;&gt;定义和声明的区别
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;如果是指变量的声明和定义：&lt;/strong&gt; 声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。而定义就是分配了内存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果是指函数的声明和定义：&lt;/strong&gt; 声明一般在头文件里，让编译器知道这个函数的存在。 定义一般在源文件里，具体就是函数的实现过程写明函数体。&lt;/p&gt;
&lt;h3 id=&#34;段错误原因解决办法&#34;&gt;段错误原因解决办法
&lt;/h3&gt;&lt;p&gt;段错误（Segmentation Fault）通常是由于程序试图访问不属于它的内存区域或者试图对只读内存进行写操作而触发的。段错误产生的原因包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;访问越界&lt;/strong&gt;：当程序尝试访问数组、指针或缓冲区之外的内存时，通常会导致段错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;对只读内存进行写操作&lt;/strong&gt;：如果程序试图写入只读内存区域（例如字符串字面量或常量），也会触发段错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;空指针引用&lt;/strong&gt;：尝试通过空指针进行读取或写入操作会导致段错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;栈溢出&lt;/strong&gt;：当递归函数调用过多或者局部变量占用的栈空间过大时，栈溢出也可能导致段错误。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;处理段错误的方法包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;检查代码&lt;/strong&gt;：首先，仔细检查程序的源代码，查找可能导致段错误的地方。特别注意数组和指针的边界问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用调试工具&lt;/strong&gt;：使用调试工具（如GDB）来分析段错误。GDB可以帮助你找到引发段错误的具体行号和上下文信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用内存检测工具&lt;/strong&gt;：工具如Valgrind可以检测内存泄漏和越界访问等问题，帮助你找到段错误的根本原因。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;避免使用未初始化的指针&lt;/strong&gt;：确保你的指针都经过正确初始化，不要让它们指向未知内存区域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;避免对只读内存进行写操作&lt;/strong&gt;：不要尝试修改只读内存区域，如字符串字面量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;栈溢出检测&lt;/strong&gt;：如果你怀疑栈溢出是问题的原因，可以增加栈的大小或者优化递归算法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;避免使用未定义行为&lt;/strong&gt;：C/C++中有一些未定义行为，尽量避免使用它们，因为它们可能导致难以预测的结果和段错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理异常&lt;/strong&gt;：在C++中，可以使用异常处理机制来捕获和处理异常，防止程序崩溃。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用合适的数据结构和算法&lt;/strong&gt;：使用标准库提供的数据结构和算法，它们经过严格测试和优化，可以减少潜在的段错误。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;二类&#34;&gt;二、类
&lt;/h2&gt;&lt;h3 id=&#34;1c三大特性&#34;&gt;1、C++三大特性
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;访问权限&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限&lt;/p&gt;
&lt;p&gt;类的内部，⽆论成员被声明为 public、protected 还是 private，都可以互相访问的。&lt;/p&gt;
&lt;p&gt;在类的外部，只能通过对象访问成员，并且通过对象只能访问 public属性的成员，不能访问 private、protected 属性的成员&lt;/p&gt;
&lt;p&gt;⽆论公有继承、私有和保护&lt;strong&gt;继承&lt;/strong&gt;，私有成员不能被“派⽣类”访问，基类中的公有和保护成员能被“派⽣类”访问。&lt;/p&gt;
&lt;p&gt;对于&lt;strong&gt;公有继承&lt;/strong&gt;，只有基类中的公有成员能被“派⽣类对象”访问，保护和私有成员不能被“派
⽣类对象”访问。对于&lt;strong&gt;私有和保护继承&lt;/strong&gt;，基类中的所有成员不能被“派⽣类对象”访问。&lt;/p&gt;
&lt;img src=&#34;imgs/embed_interview1.jpg&#34; alt=&#34;&#34; width=&#34;500&#34;&gt;
&lt;h4 id=&#34;1继承&#34;&gt;&lt;strong&gt;1.继承&lt;/strong&gt;
&lt;/h4&gt;&lt;p&gt;**定义：**让某种类型对象获得另⼀个类型对象的属性和方法
**功能：**它可以使用现有类的所有功能，并在⽆需重新编写原来的类的情况下对这些功能进行扩展&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;常见的继承有三种方式：
1、实现继承：指使用基类的属性和方法而⽆需额外编码的能⼒
2、接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力
3、可视继承：指子窗体（类）使用基窗体（类）的外观和实现代码的能力&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;2封装&#34;&gt;&lt;strong&gt;2.封装&lt;/strong&gt;
&lt;/h4&gt;&lt;p&gt;**定义：**数据和代码捆绑在⼀起，避免外界⼲扰和不确定性访问;
&lt;strong&gt;功能：把客观事物封装成抽象的类&lt;/strong&gt;。可以将公共的数据或方法使用public修饰，⽽不希望被访问的数据或方法采用private修饰。&lt;/p&gt;
&lt;h4 id=&#34;3多态&#34;&gt;&lt;strong&gt;3.多态&lt;/strong&gt;
&lt;/h4&gt;&lt;p&gt;**定义：**同⼀事物表现出不同事物的能力，即向不同对象发送同⼀消息，不同的对象在接收时会产⽣不同的行为（重载实现编译时多态，虚函数实现运行时多态）
**功能：**多态性是允许你将父对象设置成为和⼀个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作;&lt;/p&gt;
&lt;p&gt;简单⼀句话：允许将子类类型的指针赋值给父类类型的指针。&lt;/p&gt;
&lt;p&gt;实现多态有两种方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;重写（override）： 是指子类重新定义父类的虚函数的做法&lt;/li&gt;
&lt;li&gt;重载（overload）： 是指允许存在多个同名函数，⽽这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2虚继承&#34;&gt;2、虚继承
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;虚继承是为了&lt;strong&gt;解决多继承时的命名冲突和冗余数据问题&lt;/strong&gt;，可以在派⽣类中只保留⼀份间接基类的成员。多继承是指从多个直接基类中产⽣派⽣类的能⼒，多继承的派⽣类继承了所有父类的成员。&lt;/li&gt;
&lt;li&gt;虚基类就是某个类做出声明，承诺愿意共享它的基类，其中，这个被共享的基类就称为虚基类。其中A 就是⼀个虚基类。在这种机制下，&lt;strong&gt;不论虚基类在继承体系中出现了多少次，在派⽣类中都只包含⼀份虚基类的成员&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;img src=&#34;imgs/embed_interview2.jpg&#34; alt=&#34;&#34; width=&#34;500&#34;&gt;
&lt;blockquote&gt;
&lt;p&gt;C++标准库中的 iostream 类就是⼀个虚继承的实际应用案例。&lt;/p&gt;
&lt;p&gt;iostream 从 istream 和 ostream 直接继承⽽来，⽽ istream 和 ostream 又都继承⾃⼀个共同的名为 baseios 的类，是典型的菱形继承。&lt;/p&gt;
&lt;p&gt;此时 istream 和 ostream 必须采用虚继承，否则将导致 iostream 类中保留两份 baseios 类的成员。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用多继承经常出现⼆义性，必须⼗分⼩⼼；&lt;/p&gt;
&lt;p&gt;⼀般只有在比较简单和不易出现⼆义性或者实在必要情况下才使用多继承，能用单⼀继承解决问题就不要用多继承。&lt;/p&gt;
&lt;h3 id=&#34;3抽象类与接口&#34;&gt;3、抽象类与接口
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;接口描述了类的行为和功能，⽽不需要完成类的特定实现；&lt;/li&gt;
&lt;li&gt;接口是使用抽象类来实现的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1、类中⾄少有⼀个函数被声明为&lt;strong&gt;纯虚函数&lt;/strong&gt;，则这个类就是&lt;strong&gt;抽象类&lt;/strong&gt;。纯虚函数是通过在声明中使用 &amp;ldquo;= 0&amp;rdquo; 来指定的。&lt;/p&gt;
&lt;p&gt;2、设计抽象类的目的，是为了给其他类提供⼀个可以继承的适当的基类。&lt;strong&gt;抽象类不能被用于实例化对象，只能作为接口使用。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;4类内的static和const&#34;&gt;4、类内的static和const
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;静态成员变量&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;静态成员变量属于整个类，不属于某个对象，只有唯一的一份拷贝，所有对象共享类中的静态数据成员。&lt;/li&gt;
&lt;li&gt;必须在类内声明，在类外部初始化。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;静态成员函数&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;没有this指针，无法访问类对象的非static成员变量和非static成员函数；&lt;/li&gt;
&lt;li&gt;不能被声明为const、虚函数和volatile；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;**作用：**实现多个对象之间的数据共享 + 隐藏，并且使用静态成员还不会破坏隐藏原则；默认初始化为0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;const成员变量&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只能通过构造函数初始化列表进行初始化&lt;/li&gt;
&lt;li&gt;不同类对其const数据成员的值可以不同，不能在类中声明时初始化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;const成员函数&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;函数不会修改类中的数据成员。&lt;/li&gt;
&lt;li&gt;const对象只能调用类的const成员函数，不可以调用非const成员函数，非const对象都可以调用&lt;/li&gt;
&lt;li&gt;不可以改变非mutable数据的值&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;5this指针&#34;&gt;5、this指针
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;每个非静态成员函数都包含一个this指针，指向调用该函数的对象。&lt;/li&gt;
&lt;li&gt;当对象访问类中的非静态成员函数时，编译器会自动将对象的地址隐式的作为第一个参数传递给this指针。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;6友元函数&#34;&gt;6、友元函数
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;可以直接访问类的非公有成员和非公有成员函数，友元类的所有成员函数都是另一个类的友元函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;友元关系是单向的，不具有交换性。不能继承。不具有传递性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;7虚函数的实现&#34;&gt;7、虚函数的实现
&lt;/h3&gt;&lt;p&gt;在父类中定义虚函数，在子类中重写该函数。运行时，编译器根据对象的实际类型调用相应的函数。&lt;/p&gt;
&lt;p&gt;使用&lt;strong&gt;虚函数表&lt;/strong&gt;来实现。每个包含虚函数的类都有一个虚函数表，表中存储了类的虚函数指针。&lt;/p&gt;
&lt;p&gt;子类中的虚函数会覆盖父类中的虚函数，因此在子类中重写虚函数时，编译器会把子类中的虚函数地址填入虚函数表中的对应位置。&lt;/p&gt;
&lt;p&gt;对象被创建时，会分配一个指向虚函数表的指针。在调用虚函数时，编译器会查找对象指针指向的虚函数表，根据表中存储的虚函数指针调用相应的函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虚函数表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一个类中有虚函数，那么这个类就对应一个虚函数表。&lt;/p&gt;
&lt;p&gt;虚函数表中的元素是一组指向函数的指针，每一个指针指向虚函数的入口地址。在访问虚函数时，通过虚函数表进行函数调用。&lt;/p&gt;
&lt;p&gt;在含有虚函数的类对象模型中，除了对象的数据成员外，还有一个指向虚函数表的指针，称为虚指针，虚指针位于对象模型的顶部。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虚函数&lt;/strong&gt;
当基类希望派⽣类定义适合自己的版本，就将这些函数声明成虚函数（virtual）&lt;/p&gt;
&lt;p&gt;虚函数依赖虚函数表工作，表来保存虚函数地址，当我们用基类指针指向派⽣类时，虚表指针指向派⽣类的虚函数表&lt;/p&gt;
&lt;p&gt;这个机制可以保证派⽣类中的虚函数被调用到&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;动态绑定绑定的是动态类型
所对应的函数或属性依赖于对象的动态类型，发⽣在运行期。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;构造函数不能是虚函数&lt;/strong&gt;
⽽且，在构造函数中调用虚函数，实际执行的是父类的对应函数，因为⾃⼰还没有构造好,多态是被disable的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;析构函数可以是虚函数&lt;/strong&gt;，⽽且，在⼀个复杂类结构中，这往往是必须的。&lt;/li&gt;
&lt;li&gt;inline, static, constructor三种函数都不能带有virtual关键字。
（1）inline是在编译时展开，必须要有实体。
内联函数是指在编译期间用被调用函数体本⾝来代替函数的调用指令，但虚函数的多态特性需要在运行时根据对象类型才知道调用哪个虚函数，所以没法在编译时进行内联函数展开。
（2）static属于class自己的类相关，必须有实体；
static成员没有this指针。virtual函数⼀定要通过对象来调用，有隐藏的this指针，实例相关。&lt;/li&gt;
&lt;li&gt;析构函数可以是纯虚的
但纯虚析构函数必须有定义体，因为析构函数的调用是在子类中隐含的。&lt;/li&gt;
&lt;li&gt;派⽣类的override虚函数定义必须和父类完全⼀致。
除了⼀个特例，如果父类中返回值是⼀个指针或引用，子类override时可以返回这个指针（或引用）的派⽣&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;8纯虚函数与虚函数有哪些区别&#34;&gt;8、纯虚函数与虚函数有哪些区别
&lt;/h3&gt;&lt;p&gt;虚函数是在基类中声明为虚函数的成员函数，在派生类中可以重载它。当我们使用基类指针或引用调用虚函数时，程序会根据指针或引用所指向的对象的实际类型来调用相应的派生类函数。因此，虚函数允许在运行时动态绑定函数。&lt;/p&gt;
&lt;p&gt;**纯虚函数是在基类中声明的没有定义的虚函数。**它的作用是为了让派生类实现接口。我们可以将纯虚函数看做是一个抽象接口，&lt;strong&gt;派生类必须实现这个接口&lt;/strong&gt;，否则就无法编译通过。&lt;/p&gt;
&lt;p&gt;区别如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;虚函数有函数体，而纯虚函数没有函数体。&lt;/li&gt;
&lt;li&gt;虚函数可以被重载，而纯虚函数只能被实现。&lt;/li&gt;
&lt;li&gt;含有纯虚函数的类是抽象类，无法被实例化，而虚函数所在的类可以被实例化。&lt;/li&gt;
&lt;li&gt;派生类必须实现纯虚函数，否则无法编译通过。而对于虚函数，派生类可以选择性地实现或不实现。&lt;/li&gt;
&lt;li&gt;对于纯虚函数，可以通过把它定义为 protected 或 private 来防止类被实例化，而虚函数所在的类没有这个选项。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;9虚析构函数&#34;&gt;9、虚析构函数
&lt;/h3&gt;&lt;p&gt;虚析构函数是为了解决父类的指针指向子类对象，并用父类的指针删除子类对象。&lt;/p&gt;
&lt;p&gt;父类指针指向子类对象时，如果子类中有属性在堆中开辟了空间，如果父类析构函数不使用虚函数，会造成内存泄漏。&lt;/p&gt;
&lt;p&gt;这时需要把析构函数设置为虚析构函数或纯析构函数。&lt;/p&gt;
&lt;h3 id=&#34;10构造函数&#34;&gt;10、构造函数
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;构造函数是一种特殊的成员函数，&lt;/li&gt;
&lt;li&gt;在创建对象时自动调用，用于初始化对象中的数据成员。&lt;/li&gt;
&lt;li&gt;构造函数的名称必须与类名相同，并且没有返回值类型，构造函数中禁止使用return语句。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;tips：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只要用户显式地声明了一个构造函数，无论是无参的还是带参的，系统都不会再生成默认的无参构造函数。&lt;/li&gt;
&lt;li&gt;构造函数执行分为两个部分：首先执行构造函数的初始化列表，然后执行构造函数的函数体。优先使用初始化列表，避免二次赋值。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;11构造函数析构函数要设为虚函数吗为什么&#34;&gt;11、&lt;strong&gt;构造函数，析构函数要设为虚函数吗，为什么？&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;（1）析构函数
&lt;strong&gt;析构函数需要&lt;/strong&gt;。当派⽣类对象中有内存需要回收时，如果析构函数不是虚函数，不会触发动态绑定，只会调用基类析构函数，导致派⽣类资源无法释放，造成内存泄漏。
（2）构造函数
&lt;strong&gt;构造函数不需要&lt;/strong&gt;，没有意义。虚函数调用是在部分信息下完成工作的机制，允许我们只知道接口而不知道对象的确切类型。 要创建⼀个对象，你需要知道对象的完整信息。 特别是，你需要知道你想要创建的确切类型。 因此，构造函数不应该被定义为虚函数。&lt;/p&gt;
&lt;h3 id=&#34;12移动构造函数&#34;&gt;12、移动构造函数
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;对象a初始化对象b，对象a不再使用的情况下，使用移动构造函数。实际上就是&lt;strong&gt;把a对象的内容复制一份到b中，直接使用a的空间&lt;/strong&gt;。这样就避免了新的空间的分配，大大降低了构造的成本。&lt;/li&gt;
&lt;li&gt;移动构造函数中，对于&lt;strong&gt;指针，采用浅拷贝&lt;/strong&gt;。指针复制后，将第一个指针置为NULL。&lt;/li&gt;
&lt;li&gt;移动构造函数的&lt;strong&gt;参数是一个右值引用&lt;/strong&gt;。意味着，移动构造函数的参数是一个右值或者将亡值的引用。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;move语句就是将一个左值变成一个将亡值。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;MyString&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 移动构造函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;MyString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MyString&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;other&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;noexcept&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;other&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;other&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;nullptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 将other对象的资源移动，并将其置为空指针
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 构造函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;MyString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;strlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;strcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 析构函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;~&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MyString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;delete&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;13绑定&#34;&gt;13、绑定
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;多态性的原理是延迟绑定，也就是在函数调用时才绑定函数，这也是虚函数的工作原理。&lt;/li&gt;
&lt;li&gt;绑定是指将函数调用和函数体关联起来，&lt;strong&gt;早绑定是在编译或链接阶段进行绑定&lt;/strong&gt;，&lt;strong&gt;晚绑定是在程序运行阶段进行绑定&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;14成员初始化列表&#34;&gt;14、成员初始化列表
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;在类的构造函数中，不在函数体内对成员变量赋值，而是在构造函数的花括号前面使用冒号和初始化列表赋值。&lt;/li&gt;
&lt;li&gt;对象成员变量的初始化发生在进入构造函数之前。如果是在&lt;strong&gt;构造函数体内赋值是一次初始化加一次赋值&lt;/strong&gt;，而&lt;strong&gt;初始化列表只做一次赋值操作&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;三内存&#34;&gt;三、内存
&lt;/h2&gt;&lt;h3 id=&#34;1c程序内存的分配&#34;&gt;1、C++程序内存的分配
&lt;/h3&gt;&lt;img src=&#34;imgs/embed_interview3.jpg&#34; alt=&#34;&#34; width=&#34;500&#34;&gt;
&lt;p&gt;当一个程序从硬盘中加载到内存中的时候，就变成了一个进程，对于x86的系统，进程中分成了&lt;strong&gt;内核空间和用户空间&lt;/strong&gt;，内核空间占高地址的1G，用户空间占3个G，用户空间中的内存从低到高依次是**.text段（代码段）&lt;strong&gt;，&lt;/strong&gt;.data（存放初始化的全局变量和静态变量）&lt;strong&gt;，&lt;/strong&gt;.bss（存放未初始化或者初始化为0的全局或静态变量）**，&lt;strong&gt;栈（存放函数内部的局部变量）&lt;/strong&gt;，&lt;strong&gt;堆（存放用户自己用new或者malloc动态分配）&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;c编译的程序占用内存分为以下几个部分&#34;&gt;&lt;strong&gt;C++编译的程序占用内存分为以下几个部分：&lt;/strong&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;代码段：存放函数体（类成员函数和全局区）的二进制代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局区及静态存储区：存放全局变量、静态变量，生命周期在程序运行期间始终存在，程序结束时操作系统才会回收这部分空间。全局区分为已初始化全局区（data）和未初始化全局区（bss）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;堆区（heap）：由程序员负责分配和回收，如果程序员没有释放，程序结束时由操作系统回收。**堆从低地址向高地址增长。是不连续的内存区域。**大小可以灵活调整。堆大小受限于计算机系统中有效的虚拟内存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;栈区（stack）：由编译器自动分配与释放，存放为运行时函数分配的局部变量、函数参数、返回数据、返回地址等。&lt;strong&gt;栈从高地址向低地址增长，后进先出，是一块连续的空间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;栈空间默认是4M, 堆区一般是 1G - 4G&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;三种内存分配方式&#34;&gt;&lt;strong&gt;三种内存分配方式&lt;/strong&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;从静态存储区分配&lt;/p&gt;
&lt;p&gt;内存在程序编译的时候已经分配好，这块内存在程序的整个运行期间都存在。例如&lt;strong&gt;全局变量，static变量&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在栈上创建&lt;/p&gt;
&lt;p&gt;在执行函数时，函数内局部变量的存储单元可以在栈上创建，函数执行结束时，这些内存单元会自动被释放。
栈内存分配运算内置于处理器的指令集，效率高，但是分配的内存容量有限。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从堆上分配&lt;/p&gt;
&lt;p&gt;亦称为动态内存分配。
程序在运行的时候使用&lt;strong&gt;malloc或者new&lt;/strong&gt;申请任意多少的内存，程序员自己负责在何时用&lt;strong&gt;free或delete&lt;/strong&gt;释放内存。
动态内存的生命周期有程序员决定，使用非常灵活，但如果在堆上分配了空间，既有责任回收它，否则运行的程序会出现内存泄漏，频繁的分配和释放不同大小的堆空间将会产生内存碎片。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;堆栈的区别&#34;&gt;&lt;strong&gt;堆栈的区别&lt;/strong&gt;
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;栈空间用于存储&lt;strong&gt;函数参数和局部变量&lt;/strong&gt;，空间由&lt;strong&gt;系统&lt;/strong&gt;自动分配和回收。堆空间存储动态分配的内存，分配和释放空间由&lt;strong&gt;程序员&lt;/strong&gt;控制，有可能产生内存泄漏。&lt;/li&gt;
&lt;li&gt;栈空间是后进先出的数据结构，可用空间是一块连续的内存块。堆空间在不断的分配和释放过程中，可用空间链表频繁更新，造成可用空间逐渐碎片化。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;栈空间的默认大小只有几M&lt;/strong&gt;的空间，生长方式是向下的，向着内存地址减小的方向消耗空间。&lt;strong&gt;堆空间理论大小有几G的空间&lt;/strong&gt;，生长方式是向上的，向着内存地址增大的方向消耗空间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;栈效率较高&lt;/strong&gt;，有寄存器支持。&lt;strong&gt;堆空间&lt;/strong&gt;需要通过可用空间链表的扫描和调整以及相邻空间的合并等操作，&lt;strong&gt;效率相对较低&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;tips：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用递归解决问题要考虑到栈溢出的问题，如果确实有可能发生，可以考虑使用循环代替递归。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2内存泄漏&#34;&gt;2、内存泄漏
&lt;/h3&gt;&lt;p&gt;内存泄漏是指在程序执行过程中，由于&lt;strong&gt;未能正确释放不再使用的动态分配内存&lt;/strong&gt;，导致这些内存块变得不可访问，从而无法再被回收和重用的情况。内存泄漏可能导致程序在运行时占用越来越多的内存，最终耗尽可用内存资源，导致程序性能下降甚至崩溃。&lt;/p&gt;
&lt;p&gt;产生内存泄漏就是因为&lt;strong&gt;分配的内存没有及时回收&lt;/strong&gt;。由于栈内存由编译器负责分配和回收，因此不存在内存泄漏的原因。而堆内存有程序员负责分配和回收，这种人为的控制导致了内存泄漏的发生。&lt;/p&gt;
&lt;p&gt;具体来讲，内存泄漏是由于在程序中通过malloc或者new从堆中申请了一块空间，但是在使用后并没有调用free或者delete释放，导致这块空间既无法使用也无人回收，从而造成内存泄漏。&lt;/p&gt;
&lt;p&gt;内存泄漏的主要原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;未释放动态分配内存&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;丢失对分配内存的指针&lt;/strong&gt;：指向动态分配内存的指针赋给其他指针或者重新分配，而没有在合适的时候释放原始内存。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;循环引用&lt;/strong&gt;：如果对象之间存在循环引用，引用计数可能永远不会归零，从而导致对象不会被释放。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数调用中的内存泄漏&lt;/strong&gt;：在函数中分配了内存，但在函数返回前没有释放。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;如何防止内存泄露&#34;&gt;&lt;strong&gt;如何防止内存泄露?&lt;/strong&gt;
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;**使用智能指针。**它们可以自动管理内存的分配和释放。当不再需要某个对象时，智能指针会自动释放与之关联的内存，从而防止内存泄漏。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用 RAII（资源获取即初始化）&lt;/strong&gt;：在C++中，RAII 是一种常见的资源管理技术，通过对象的生命周期来管理资源的分配和释放。例如，可以&lt;strong&gt;使用对象的析构函数来释放资源&lt;/strong&gt;，确保资源在对象不再需要时被正确释放。&lt;/p&gt;
&lt;p&gt;将内存的分配封装在类中，构造函数分配内存，析构函数释放内存；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;在动态内存分配后及时释放&lt;/strong&gt;。使用 &lt;code&gt;new&lt;/code&gt; 或 &lt;code&gt;malloc&lt;/code&gt; 进行动态内存分配，确保在不再需要内存时调用 &lt;code&gt;delete&lt;/code&gt; 或 &lt;code&gt;free&lt;/code&gt; 来释放它。通常，使用局部变量和栈分配可以避免显式的内存管理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用内存分析工具&lt;/strong&gt;：工具如Valgrind。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一定要将基类的析构函数声明为&lt;strong&gt;虚函数&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象数组的释放一定要用&lt;strong&gt;delete []&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3mallocfree-和-newdelete&#34;&gt;3、malloc/free 和 new/delete
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;malloc/free是&lt;strong&gt;C语言库函数&lt;/strong&gt;，通过函数调用访问，需要传递参数并接收返回值。new/delete是&lt;strong&gt;C++运算符&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;malloc/free函数&lt;strong&gt;只能应用于基本类型&lt;/strong&gt;。new/delete&lt;strong&gt;可以用于自定义类型&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;malloc/free函数&lt;strong&gt;返回void类型指针&lt;/strong&gt;（必须进行类型转换），new和delete返回的是&lt;strong&gt;具体类型指针&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;malloc函数只负责申请空间，并返回首地址。new/delete还会&lt;strong&gt;调用对象的构造函数/析构函数。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;malloc&lt;strong&gt;需要计算需要的内存大小&lt;/strong&gt;，new&lt;strong&gt;自动计算&lt;/strong&gt;要分配的空间大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;new是类型安全的，malloc不是。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//编译错误
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;malloc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//编译无错误
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;new/delete可以被重载，而malloc/free并不允许重载。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;malloc的底层是如何实现的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）malloc函数的底层实现是操作系统有一个由可用内存块连接成的空闲链表。调用malloc时，它将遍历该链表寻找足够大的内存空间，将该块一分为二（一块与用户申请的大小相等，另一块为剩下来的碎片，会返回链表），调用free函数时，内存块重新连接回链表。&lt;/p&gt;
&lt;p&gt;（2）若内存块过于琐碎无法满足用户需求，则操作系统会合并相邻的内存块。&lt;/p&gt;
&lt;h3 id=&#34;4delete和delete&#34;&gt;4、delete和delete[]
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;new[]中的数组元素是基本类型时，通过delete和delete[]都可以释放数组空间。（待查证）&lt;/p&gt;
&lt;p&gt;new[]中的数组元素是自定义类型时，只能通过delete[]释放数组空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建议申请和释放空间&lt;strong&gt;采用完全配对的形式&lt;/strong&gt;：new和delete成对使用，new[]与delete[]成对使用，不管数组元素是基本数据类型还是自定义类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当数组元素是&lt;strong&gt;自定义类型时使用delete[]&lt;/strong&gt;，delete在释放空间时只会调用数组中首个元素的析构函数，而delete[]会调用所有元素的析构函数&lt;/p&gt;
&lt;p&gt;当数组元素是基本数据类型时，delete和delete[]释放数组空间是等价的。对于基本数据类型，系统可以根据数组长度和数据类型计算出数组所占的空间，然后一次性释放整个空间，因此不需要区分delete和delete[]。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;5内存越界&#34;&gt;5、内存越界
&lt;/h3&gt;&lt;p&gt;内存越界又称内存访问越界，是指访问了所申请空间之外的内存。&lt;/p&gt;
&lt;p&gt;tips：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;vector中包含三个迭代器：first迭代器指向第一个元素，finish迭代器指向最后一个有效元素的下一个位置，end_of_storage迭代器指向整个vector空间末尾的下一个位置。&lt;strong&gt;通过下标访问vector中的元素时不会做边界检查，如果想在访问vector中的元素时首先进行边界检查，可以使用vector中的at函数。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;6智能指针&#34;&gt;6、智能指针
&lt;/h3&gt;&lt;p&gt;C++中有三种常见的智能指针，它们用于管理动态分配的内存和自动释放资源，帮助减少内存泄漏和错误的机会。这些智能指针包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;std::shared_ptr&lt;/strong&gt;（共享指针）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::shared_ptr&lt;/code&gt; 是一种共享所有权的智能指针。多个 &lt;code&gt;std::shared_ptr&lt;/code&gt; 可以共享同一块内存，并且会在最后一个拥有者释放资源时自动释放内存。这种指针适用于多个拥有者的情况，例如，在容器中存储对象，或者多个对象需要共享某个资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;std::unique_ptr&lt;/strong&gt;（独占指针）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt; 是一种独占所有权的智能指针。每个 &lt;code&gt;std::unique_ptr&lt;/code&gt; 拥有其所指向的资源，并且在其生命周期结束时自动释放资源。这种指针适用于单一拥有者的情况，例如，防止多个指针同时管理同一资源，从而提高了程序的安全性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;std::weak_ptr&lt;/strong&gt;（弱引用指针）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::weak_ptr&lt;/code&gt; 也是一种共享指针，但它不增加资源的引用计数，因此不会影响资源的生命周期。&lt;code&gt;std::weak_ptr&lt;/code&gt; 主要用于&lt;strong&gt;避免循环引用问题&lt;/strong&gt;，其中多个对象相互引用，导致资源无法释放。通过将一个或多个 &lt;code&gt;std::weak_ptr&lt;/code&gt; 引用添加到已经由 &lt;code&gt;std::shared_ptr&lt;/code&gt; 管理的资源上，可以解决这个问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;防止内存泄漏：智能指针可以确保在不再需要资源时自动释放它们，从而防止了内存泄漏。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;简化内存管理：智能指针减轻了程序员手动跟踪和释放内存的负担，降低了出错的风险。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提高代码安全性：独占指针 &lt;code&gt;std::unique_ptr&lt;/code&gt; 防止了多个指针同时管理同一资源，增强了程序的安全性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决循环引用问题：弱引用指针 &lt;code&gt;std::weak_ptr&lt;/code&gt; 可以帮助解决多个对象相互引用导致资源无法释放的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四stl&#34;&gt;四、STL
&lt;/h2&gt;&lt;p&gt;STL（标准模板库）六⼤组件分别是:&lt;strong&gt;容器、算法、迭代器、仿函数、适配器、空间配置器&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;1容器有哪些&#34;&gt;1、容器有哪些
&lt;/h3&gt;&lt;p&gt;C++标准库提供了多种容器类型，用于存储和组织数据：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;序列容器（Sequence Containers）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;std::vector&lt;/strong&gt;：动态数组，支持快速随机访问，可动态增长。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;std::deque&lt;/strong&gt;：双端队列，支持快速随机访问，可在两端进行插入和删除操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;std::list&lt;/strong&gt;：双向链表，支持在任何位置进行插入和删除操作，但不支持随机访问。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;std::forward_list&lt;/strong&gt;：单向链表，支持在前方插入和删除操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关联容器（Associative Containers）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;std::set&lt;/strong&gt;：有序集合，不允许重复元素。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;std::multiset&lt;/strong&gt;：有序集合，允许重复元素。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;std::map&lt;/strong&gt;：有序映射（键-值对），不允许重复键。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;std::multimap&lt;/strong&gt;：有序映射，允许重复键。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无序容器（Unordered Containers）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;std::unordered_set&lt;/strong&gt;：无序集合，不允许重复元素，基于哈希表实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;std::unordered_multiset&lt;/strong&gt;：无序集合，允许重复元素，基于哈希表实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;std::unordered_map&lt;/strong&gt;：无序映射，不允许重复键，基于哈希表实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;std::unordered_multimap&lt;/strong&gt;：无序映射，允许重复键，基于哈希表实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容器适配器（Container Adapters）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;std::stack&lt;/strong&gt;：栈，基于其他序列容器实现，提供了后进先出（LIFO）的操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;std::queue&lt;/strong&gt;：队列，基于其他序列容器实现，提供了先进先出（FIFO）的操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;std::priority_queue&lt;/strong&gt;：优先队列，基于其他序列容器实现，元素按照优先级排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2stl的优点&#34;&gt;2、STL的优点
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可移植性&lt;/strong&gt;：STL是C++标准库的一部分，在不同的C++编译器和平台上都有一致的行为和接口。&lt;/p&gt;
&lt;p&gt;这意味着你可以编写可移植的代码，而不必担心不同编译器或操作系统的差异。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;高性能&lt;/strong&gt;：STL容器和算法经过精心设计和优化，通常具有高效的性能。&lt;/p&gt;
&lt;p&gt;例如，向量（&lt;code&gt;std::vector&lt;/code&gt;）提供了O(1)的随机访问时间，列表（&lt;code&gt;std::list&lt;/code&gt;）允许快速插入和删除操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可扩展性&lt;/strong&gt;：STL容器和算法是模板化的。&lt;/p&gt;
&lt;p&gt;意味着你可以轻松地创建自定义的容器和算法，以满足特定的需求。这种扩展性使得STL适用于各种不同的应用场景。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;安全性&lt;/strong&gt;：STL容器和算法经过严格的测试和验证，可以防止许多常见的错误。&lt;/p&gt;
&lt;p&gt;如缓冲区溢出、内存泄漏等。此外，STL的迭代器和智能指针提供了更安全的内存管理方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;丰富的算法库&lt;/strong&gt;：STL包含了丰富的算法库，包括查找、排序、转换、聚合等操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3vector容器实现与扩充&#34;&gt;3、vector容器实现与扩充
&lt;/h3&gt;&lt;h4 id=&#34;1-底层实现&#34;&gt;1. 底层实现
&lt;/h4&gt;&lt;p&gt;vector在堆中分配了⼀段连续的内存空间来存放元素。&lt;code&gt;vector&lt;/code&gt; 对象本身通常存储在栈上，但它的元素存储在堆上。&lt;/p&gt;
&lt;p&gt;1、三个迭代器
（1）first ： 指向的是vector中对象的起始字节位置
（2）last ： 指向当前最后⼀个元素的末尾字节
（3）end ： 指向整个vector容器所占用内存空间的末尾字节&lt;/p&gt;
&lt;h4 id=&#34;2-扩容&#34;&gt;2. 扩容
&lt;/h4&gt;&lt;p&gt;如果集合已满，在新增数据的时候，就要分配⼀块更⼤的内存，将原来的数据复制过来，释放之前的内存，在插⼊新增的元素&lt;/p&gt;
&lt;p&gt;所以对vector的任何操作，⼀旦引起空间重新配置，指向原vector的所有迭代器就都失效了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;size() 和 capacity()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）堆中分配内存，元素连续存放，内存空间只会增长不会减少&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;capacity()，在不分配新内存下最多可以保存的元素个数&lt;/p&gt;
&lt;p&gt;size()，返回当前已经存储数据的个数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（2）对于vector来说，capacity是永远⼤于等于size的&lt;/p&gt;
&lt;p&gt;capacity和size相等时，vector就会扩容，capacity变⼤（翻倍）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;vector扩容方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;扩容操作涉及到内存分配和元素复制。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为新容量分配一块更大的内存空间，通常是原容量的两倍或更多。&lt;/li&gt;
&lt;li&gt;将已有的元素从旧的内存位置复制到新的内存位置。&lt;/li&gt;
&lt;li&gt;释放旧的内存空间。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;resize()和reserve()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;resize()：改变当前容器内含有元素的数量(size())，而不是容器的容量&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当resize(len)中len&amp;gt;v.capacity()，则数组中的size和capacity均设置为len;&lt;/li&gt;
&lt;li&gt;当resize(len)中len&amp;lt;=v.capacity()，则数组中的size设置为len，而capacity不变;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;reserve()：改变当前容器的最⼤容量（capacity）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果reserve(len)的值 &amp;gt; 当前的capacity()，那么会重新分配⼀块能存len个对象的
空间，然后把之前的对象通过copy construtor复制过来，销毁之前的内存;&lt;/li&gt;
&lt;li&gt;当reserve(len)中len&amp;lt;=当前的capacity()，则数组中的capacity不变，size不变，即不对容器做任何改变。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4vector和list的区别&#34;&gt;4、vector和list的区别
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;vector底层实现是数组；list是双向链表&lt;/li&gt;
&lt;li&gt;vector是顺序内存,⽀持随机访问，list不行&lt;/li&gt;
&lt;li&gt;vector在中间节点进行插⼊删除会导致内存拷贝，list不会&lt;/li&gt;
&lt;li&gt;vector⼀次性分配好内存，不够时才进行翻倍扩容；list每次插⼊新节点都会进行
内存申请&lt;/li&gt;
&lt;li&gt;vector随机访问性能好，插⼊删除性能差；list随机访问性能差，插⼊删除性能好&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;deque（双端数组）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;⽀持快速随机访问，由于deque需要处理内部跳转，因此速度上没有vector快。&lt;/p&gt;
&lt;p&gt;1、deque概述：&lt;/p&gt;
&lt;p&gt;deque是⼀个双端开口的连续线性空间，其内部为分段连续的空间组成，随时可以增加⼀段新的空间并链接&lt;/p&gt;
&lt;p&gt;注意:&lt;/p&gt;
&lt;p&gt;由于deque的迭代器比vector要复杂，这影响了各个运算层⾯，所以除非必要尽量使用vector；为了提⾼效率，在对deque进行排序操作的时候，我们可以先把deque复制到vector中再进行排序最后在复制回deque&lt;/p&gt;
&lt;h2 id=&#34;五c11新特性&#34;&gt;五、C++11新特性
&lt;/h2&gt;&lt;h3 id=&#34;1类型推导&#34;&gt;1、类型推导
&lt;/h3&gt;&lt;p&gt;1、auto：  auto可以让编译器在编译期就推导出变量的类型&lt;/p&gt;
&lt;p&gt;2、 decltype： decltype则用于推导表达式类型，只用于编译器分析表达式的类型，表达式实际不会进行运算
decltype不会像auto⼀样忽略引用和cv属性，decltype会保留表达式的引用和cv属性&lt;/p&gt;
&lt;h3 id=&#34;2右值引用和移动语义&#34;&gt;2、右值引用和移动语义
&lt;/h3&gt;&lt;p&gt;左值右值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左值： 可以放在等号左边，可以取地址并有名字&lt;/li&gt;
&lt;li&gt;右值： 不可以放在等号左边，不能取地址，没有名字&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;字符串字⾯值&amp;quot;abcd&amp;quot;也是左值，不是右值&lt;/p&gt;
&lt;p&gt;++i、&amp;ndash;i是左值，i++、i&amp;ndash;是右值&lt;/p&gt;
&lt;h3 id=&#34;3nullptr&#34;&gt;3、nullptr
&lt;/h3&gt;&lt;p&gt;nullptr是用来代替NULL，用于表示空指针，取代了传统的 &lt;code&gt;NULL&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;C++11引⼊nullptr关键字来区分&lt;strong&gt;空指针和0&lt;/strong&gt;。nullptr 的类型为 nullptr_t，能够转换为任何指针或成员指针的类型，也可以进行相等或不等的比较。&lt;/p&gt;
&lt;h3 id=&#34;4列表初始化&#34;&gt;4、列表初始化
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// method1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// method2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// method3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// method4
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;采用花括号来进行初始化称为列表初始化，⽆论是初始化对象还是为对象赋新值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;智能指针&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;新的容器和算法：&lt;/strong&gt; 引入了新的容器类型（例如 &lt;code&gt;std::unordered_set&lt;/code&gt; 和 &lt;code&gt;std::unordered_map&lt;/code&gt;）和算法（例如 &lt;code&gt;std::move&lt;/code&gt; 和并行算法）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lambda 表达式：&lt;/strong&gt; Lambda 表达式允许你定义匿名函数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程支持和多线程库：&lt;/strong&gt; C++11引入了对多线程编程的支持，包括 &lt;code&gt;std::thread&lt;/code&gt; 类用于创建线程，原子操作、互斥量和条件变量等同步机制。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;六并发&#34;&gt;六、并发
&lt;/h2&gt;&lt;h3 id=&#34;1线程互斥&#34;&gt;1.线程互斥
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;thread&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;mutex&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 定义一个互斥锁
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;shared_resource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;thread_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;mtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 锁住互斥锁
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Thread &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;thread_id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34; is accessing the shared resource.&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 这里可以执行共享资源的操作
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;mtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 解锁互斥锁
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;kr&#34;&gt;thread&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shared_resource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;kr&#34;&gt;thread&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shared_resource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;t1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;join&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;t2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;join&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;2线程同步&#34;&gt;2.线程同步
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;thread&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;mutex&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;condition_variable&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;condition_variable&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;isAExecuted&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;printHelloA&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unique_lock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;hello a&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;isAExecuted&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;cv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;notify_one&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;printHelloB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unique_lock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;cv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;isAExecuted&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;hello b&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;kr&#34;&gt;thread&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;threadA&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;printHelloA&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;kr&#34;&gt;thread&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;threadB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;printHelloB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;threadA&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;join&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;threadB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;join&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;数据结构和算法&#34;&gt;数据结构和算法
&lt;/h1&gt;&lt;h3 id=&#34;数组和链表的关系&#34;&gt;数组和链表的关系
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;内存：数组在内存中是连续的一块区域，通过索引可以直接访问任何一个元素。而链表中的每个节点在内存中可以分布在任何位置，它们通过指针来互相连接。因此，相对于数组而言，链表需要额外的指针来维护节点之间的连接，因此需要更多的内存空间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;性能：数组的访问时间复杂度为O(1)，即无论要访问哪个元素，都可以通过索引直接访问到，因此访问速度非常快。而链表的访问时间复杂度为O(n)，因为需要从头节点开始遍历，直到找到目标节点。但是链表在插入和删除操作时比数组更快，因为只需要修改指针即可，不需要移动大量的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作复杂度：对于数组而言，插入和删除操作需要移动其他元素，因此操作复杂度为O(n)。而对于链表而言，插入和删除操作只需要修改指针，因此操作复杂度为O(1)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;map和unordered_map的区别&#34;&gt;map和unordered_map的区别
&lt;/h3&gt;&lt;p&gt;map和unordered_map都是C++ STL（标准模板库）中的关联容器，用于存储键值对。它们之间的主要区别在于实现方式和性能。&lt;/p&gt;
&lt;p&gt;map底层实现是红黑树（balanced binary search tree），它保证了元素按照键值的大小有序存储，并且支持快速查找、插入和删除操作。但是，由于红黑树是一种平衡二叉树，它的节点操作需要进行比较和旋转等复杂操作，所以性能相对较低，但仍然具有较好的稳定性和可预测性。&lt;/p&gt;
&lt;p&gt;unordered_map底层实现是哈希表（hash table），它通过哈希函数将键映射到桶（bucket）中，并且在桶内使用链表（linked list）或者平衡树（balanced binary search tree）存储值。哈希表的优势在于对于查找、插入和删除等操作，具有常数时间复杂度（O(1)），但是哈希表需要解决哈希冲突等问题，所以需要更多的空间来保证性能和负载因子的平衡，而且其元素顺序是不稳定的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;哈希表的实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于哈希表的实现，它通常使用了一个数组来存储桶，每个桶都是一个链表，用于存储具有相同哈希值的元素，从而实现O(1)的访问速度。当桶中的元素数量超过一个阈值时，哈希表就会进行扩容，并重新计算所有元素的哈希值。&lt;/p&gt;
&lt;p&gt;总体而言，如果需要对容器中的元素进行排序或者有序访问，那么使用map是更好的选择；如果需要高效的查找、插入和删除操作，那么unordered_map是更好的选择。&lt;/p&gt;
&lt;h3 id=&#34;程序&#34;&gt;程序
&lt;/h3&gt;&lt;h4 id=&#34;翻转字符串&#34;&gt;翻转字符串
&lt;/h4&gt;&lt;p&gt;可以使用双指针法来实现翻转字符串：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;reverseString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;temp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;temp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;hello world&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Original string: &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;reverseString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Reversed string: &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;用两个栈设计queue&#34;&gt;用两个栈，设计queue
&lt;/h4&gt;&lt;p&gt;使用两个栈实现队列可以参考以下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义两个 &lt;code&gt;stack&lt;/code&gt; 对象，命名为 &lt;code&gt;inStack&lt;/code&gt; 和 &lt;code&gt;outStack&lt;/code&gt;，用于存储队列元素。&lt;/li&gt;
&lt;li&gt;入队操作：将元素压入 &lt;code&gt;inStack&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;出队操作：从 &lt;code&gt;outStack&lt;/code&gt; 弹出元素，如果 &lt;code&gt;outStack&lt;/code&gt; 为空，则将 &lt;code&gt;inStack&lt;/code&gt; 中的所有元素出栈并压入 &lt;code&gt;outStack&lt;/code&gt;，再从 &lt;code&gt;outStack&lt;/code&gt; 弹出元素。&lt;/li&gt;
&lt;li&gt;获取队首元素：从 &lt;code&gt;outStack&lt;/code&gt; 弹出元素，如果 &lt;code&gt;outStack&lt;/code&gt; 为空，则将 &lt;code&gt;inStack&lt;/code&gt; 中的所有元素出栈并压入 &lt;code&gt;outStack&lt;/code&gt;，再从 &lt;code&gt;outStack&lt;/code&gt; 弹出元素，但不将其出队。&lt;/li&gt;
&lt;li&gt;判断队列是否为空：判断 &lt;code&gt;inStack&lt;/code&gt; 和 &lt;code&gt;outStack&lt;/code&gt; 是否都为空。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以下是代码示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stack&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;MyQueue&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;inStack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;pop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;outStack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inStack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;outStack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inStack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;top&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;inStack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;outStack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;front&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;outStack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inStack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;outStack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inStack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;top&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;inStack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;outStack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;top&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inStack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;outStack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stack&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inStack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stack&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;outStack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这个实现在入队操作时只需要将元素压入 &lt;code&gt;inStack&lt;/code&gt;，出队和获取队首元素时会先检查 &lt;code&gt;outStack&lt;/code&gt; 是否为空，如果为空则将 &lt;code&gt;inStack&lt;/code&gt; 中的所有元素转移到 &lt;code&gt;outStack&lt;/code&gt; 中，再弹出元素。这样能够确保出队和获取队首元素的时间复杂度为 $O(1)$，而空间复杂度则为 $O(n)$，其中 $n$ 为队列元素个数。&lt;/p&gt;
&lt;h4 id=&#34;字符串拼接&#34;&gt;字符串拼接
&lt;/h4&gt;&lt;p&gt;可以使用标准库提供的字符串类或者自己实现字符串拼接函数。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用标准库提供的字符串类&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用&lt;code&gt;std::string&lt;/code&gt;类可以很方便地实现字符串拼接，其&lt;code&gt;operator+&lt;/code&gt;和&lt;code&gt;operator+=&lt;/code&gt;操作符可以实现两个字符串的拼接或将一个字符串附加到另一个字符串的末尾。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;str1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;str2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;World&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;str1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;str2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 字符串拼接
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 在末尾附加空格
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;str2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 在末尾附加str2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;自己实现字符串拼接函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;自己实现字符串拼接函数可以通过动态分配内存来实现，可以使用&lt;code&gt;new&lt;/code&gt;和&lt;code&gt;delete&lt;/code&gt;操作符或者&lt;code&gt;std::allocator&lt;/code&gt;类来实现动态内存分配和释放。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// for strlen()
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;memory&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// for std::allocator
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 自定义字符串拼接函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;strconcat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;str1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;str2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;strlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;strlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 动态分配内存
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;allocator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;alloc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;alloc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;allocate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 拷贝字符串
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;copy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;str1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;copy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;str2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 添加结尾的空字符
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;str1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;str2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;World&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;strconcat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;str2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 释放动态分配的内存
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;allocator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;alloc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;alloc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;deallocate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;strlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;类的各种构造函数&#34;&gt;类的各种构造函数
&lt;/h4&gt;&lt;p&gt;在C++11中，类可以有以下几种构造函数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;默认构造函数：当没有为对象提供参数时，将调用默认构造函数。默认构造函数无需参数，可以通过编译器自动生成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;带参数的构造函数：为对象提供参数，初始化对象的数据成员。可以重载多个参数列表不同的构造函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拷贝构造函数：将一个已经存在的对象的数据成员拷贝到一个新的对象中。可以通过定义自己的拷贝构造函数来复制类的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移动构造函数：用来转移一个对象的资源所有权，而不是进行拷贝，从而提高程序性能。可以通过定义自己的移动构造函数来转移类的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚拟构造函数：用于解决动态多态性的问题，允许基类指针调用派生类的构造函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;显式构造函数：通过将构造函数声明为explicit，可以禁止隐式类型转换，只能使用显式类型转换来创建对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是一个示例代码，演示了这些构造函数的用法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Point&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;Point&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Default constructor called.&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;Point&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Constructor with parameters called.&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;Point&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Point&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Copy constructor called.&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;Point&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Point&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Move constructor called.&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;virtual&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;~&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Point&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Destructor called.&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;virtual&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Point (&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;, &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;)&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;explicit&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Point&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;xy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Explicit constructor called.&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;快排&#34;&gt;快排
&lt;/h4&gt;&lt;p&gt;它的基本思想是通过一组排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据小，然后再按此方法对这两部分数据进行快速排序，整个排序过程可以递归进行，以此使所有数据变成有序序列。&lt;/p&gt;
&lt;p&gt;假设当前的待排序的序列为 R[low,hight] ， 其中 low&amp;lt;=hight。同时选取首元素为基准元素。&lt;/p&gt;
&lt;p&gt;步骤一：选取首元素的第一个元素作为基准元素  pivot=R[low] ，i=low ，j=hight。&lt;/p&gt;
&lt;p&gt;步骤二：从右向左扫描，找到小于等于 pivot 的数，如果找到，R[i] 和 R[j] 交换 ，i++。&lt;/p&gt;
&lt;p&gt;步骤三：从左向右扫描，找到大于 pivot 的数，如果找到，R[i] 和 R[j] 交换，j&amp;ndash;。&lt;/p&gt;
&lt;p&gt;步骤四：重复 步骤二~步骤三，直到  j 与 i 的指针重合 返回位置 mid=i ，该位置的数正好是 pivot 元素。&lt;/p&gt;
&lt;p&gt;至此换成一趟排序，此时以 mid 为界线，将数据分割为两个子序列，左侧子序列都比 pivot 数小，右侧子序列都比 pivot 数大，然后再分别对这两个子序列进行快速排序。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;part&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;base&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;base&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;swap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;base&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;swap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;quickSort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;part&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;quickSort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;quickSort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push_back&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;sc&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;quickSort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;sc&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;交换两个数你有几种方法&#34;&gt;交换两个数？你有几种方法
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;err&#34;&gt;算术&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;err&#34;&gt;异或&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;^&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 只能对int,char..
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;^&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;^&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;^=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;^=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;操作系统&#34;&gt;操作系统
&lt;/h1&gt;&lt;p&gt;来源。小林coding&lt;/p&gt;
&lt;h2 id=&#34;一硬件结构&#34;&gt;一、硬件结构
&lt;/h2&gt;&lt;h4 id=&#34;11-冯诺依曼模型&#34;&gt;1.1 冯诺依曼模型
&lt;/h4&gt;&lt;p&gt;计算机基本结构：运算单元、控制单元、存储器、输入设备、输出设备。&lt;/p&gt;
&lt;p&gt;中央处理器与存储单元和输入输出设备通过总线连接：地址总线、控制总线、数据总线。&lt;/p&gt;
&lt;img src=&#34;imgs/embed_interview4.jpg&#34; alt=&#34;&#34; width=&#34;500&#34;&gt;
&lt;p&gt;&lt;strong&gt;内存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;程序和数据存储在内存，存储的区域是线性的。&lt;/p&gt;
&lt;p&gt;存储数据的基本单位是字节，每一个字节都对应一个内存地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中央处理器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;32 位和 64 位，称为 CPU 的位宽，代表 CPU 一次可以计算的数据量。&lt;/p&gt;
&lt;p&gt;CPU 位宽越大，可以计算的数值就越大。32 位 CPU 一次计算 4 个字节，64 位 CPU 一次可以计算 8 个字节。&lt;/p&gt;
&lt;p&gt;CPU 内部还有一些组件，常见的有&lt;strong&gt;控制单元、逻辑运算单元和寄存器&lt;/strong&gt;等。控制单元负责控制 CPU 工作，逻辑运算单元负责计算，寄存器（通用寄存器、程序计数器、指令寄存器）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总线&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用于 CPU 和内存或其他设备之间的通信&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;地址总线&lt;/em&gt;，将要操作的内存地址；CPU 操作4G的内存，就需要 32 条地址总线&lt;/li&gt;
&lt;li&gt;&lt;em&gt;数据总线&lt;/em&gt;，读写内存的数据；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;控制总线&lt;/em&gt;，用于发送和接收信号；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;12-程序执行的基本过程&#34;&gt;1.2 程序执行的基本过程
&lt;/h4&gt;&lt;p&gt;一个程序执行，CPU 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。&lt;/p&gt;
&lt;p&gt;CPU 从程序计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束，这个不断循环的过程被称为 &lt;strong&gt;CPU 的指令周期&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指令的执行速度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1GHz的CPU，指的是时钟频率是1G。时钟频率越高，时钟周期就越短，工作速度也就越快。&lt;/p&gt;
&lt;p&gt;程序的CPU执行时间= &lt;strong&gt;CPU 时钟周期数（CPU Cycles）和时钟周期时间（Clock Cycle Time）的乘积&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;CPU时钟周期数我们可以进一步拆解成：「&lt;strong&gt;指令数 x 每条指令的平均时钟周期数（Cycles Per Instruction，简称 &lt;code&gt;CPI&lt;/code&gt;）&lt;/strong&gt;」&lt;/p&gt;
&lt;h4 id=&#34;13-存储器的层次结构&#34;&gt;1.3 存储器的层次结构
&lt;/h4&gt;&lt;p&gt;存储器通常可以分为这么几个级别：&lt;/p&gt;
&lt;p&gt;寄存器、CPU Cache（L1/L2/L3）、内存、SSD/HDD 硬盘&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 寄存器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;寄存器的数量通常在几十到几百之间。寄存器的访问速度非常快，半个 CPU 时钟周期内完成读写。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. CPU Cache&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用的是 &lt;strong&gt;SRAM（Static Random-Access Memory，静态随机存储器）&lt;/strong&gt; 芯片。断电丢失。&lt;/p&gt;
&lt;p&gt;CPU 高速缓存通常分为 L1、L2、L3 这样的三层高速缓存，也称为一级缓存、二级缓存、三级缓存。&lt;/p&gt;
&lt;p&gt;**L1 高速缓存。**访问速度几乎和寄存器一样快，通常只需要 &lt;code&gt;2~4&lt;/code&gt; 个时钟周期。&lt;/p&gt;
&lt;p&gt;每个 CPU 核心都有一块属于自己的 L1 高速缓存，指令和数据在 L1 是分开存放的，所以 L1 高速缓存通常分成&lt;strong&gt;指令缓存&lt;/strong&gt;和&lt;strong&gt;数据缓存&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Linux 系统中查看L1 Cache容量大小&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 数据缓存容量大小&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ cat /sys/devices/system/cpu/cpu0/cache/index0/size
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;32K
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 指令缓存容量大小&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ cat /sys/devices/system/cpu/cpu0/cache/index1/size
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;32K
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;L2 高速缓存&lt;/strong&gt;位置比 L1 高速缓存距离 CPU 核心更远，大小比 L1 高速缓存更大，访问速度则更慢，速度在 &lt;code&gt;10~20&lt;/code&gt; 个时钟周期。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;L3 高速缓存&lt;/strong&gt;通常是多个 CPU 核心共用的，访问速度在 &lt;code&gt;20~60&lt;/code&gt;个时钟周期。&lt;/p&gt;
&lt;p&gt;L1 Cache 和 L2 Cache 都是每个 CPU 核心独有的，而 L3 Cache 是多个 CPU 核心共享的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 内存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;strong&gt;DRAM （Dynamic Random Access Memory，动态随机存取存储器）&lt;/strong&gt; 芯片。&lt;/p&gt;
&lt;p&gt;相比 SRAM，DRAM 的密度更高，功耗更低，有更大的容量，而且造价比 SRAM 芯片便宜很多。&lt;/p&gt;
&lt;p&gt;动态：只有不断刷新，数据才能被存储起来。&lt;/p&gt;
&lt;p&gt;DRAM 访问的速度会更慢，DRAM 的数据访问电路和刷新电路都比 SRAM 更复杂，所以访问的速度会更慢，内存速度大概在 &lt;code&gt;200~300&lt;/code&gt; 个 时钟周期之间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. SSD/HDD 硬盘&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;固体硬盘，断电后数据还存在。内存的读写速度比 SSD 大概快 &lt;code&gt;10~1000&lt;/code&gt; 倍。&lt;/p&gt;
&lt;p&gt;机械硬盘，通过物理读写的方式来访问数据的，访问速度是非常慢的，比内存慢 &lt;code&gt;10W&lt;/code&gt; 倍左右。&lt;/p&gt;
&lt;p&gt;当 CPU 需要访问内存中某个数据的时候，如果寄存器有这个数据，CPU 就直接从寄存器取数据即可，如果寄存器没有这个数据，CPU 就会查询 L1 高速缓存，如果 L1 没有，则查询 L2 高速缓存，L2 还是没有的话就查询 L3 高速缓存，L3 依然没有的话，才去内存中取数据。&lt;/p&gt;
&lt;h4 id=&#34;14--写出让-cpu-跑得更快的代码&#34;&gt;1.4  &lt;strong&gt;写出让 CPU 跑得更快的代码？&lt;/strong&gt;
&lt;/h4&gt;&lt;p&gt;CPU通过直接映射Cache访问内存数据&lt;/p&gt;
&lt;p&gt;一个内存的访问地址，包括&lt;strong&gt;组标记、CPU Cache Line 索引、偏移量&lt;/strong&gt;这三种信息，于是 CPU 就能通过这些信息，在 CPU Cache 中找到缓存的数据。而对于 CPU Cache 里的数据结构，则是由&lt;strong&gt;索引 + 有效位 + 组标记 + 数据块&lt;/strong&gt;组成。&lt;/p&gt;
&lt;img src=&#34;imgs/embed_interview5.jpg&#34; alt=&#34;&#34; width=&#34;500&#34; /&gt;
&lt;p&gt;如果内存中的数据已经在 CPU Cache 中了，那 CPU 访问一个内存地址的时候，会经历这 4 个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据内存地址中索引信息，计算在 CPU Cache 中的索引，也就是找出对应的 CPU Cache Line 的地址；&lt;/li&gt;
&lt;li&gt;找到对应 CPU Cache Line 后，判断 CPU Cache Line 中的有效位，确认 CPU Cache Line 中数据是否是有效的，如果是无效的，CPU 就会直接访问内存，并重新加载数据，如果数据有效，则往下执行；&lt;/li&gt;
&lt;li&gt;对比内存地址中组标记和 CPU Cache Line 中的组标记，确认 CPU Cache Line 中的数据是我们要访问的内存数据，如果不是的话，CPU 就会直接访问内存，并重新加载数据，如果是的话，则往下执行；&lt;/li&gt;
&lt;li&gt;根据内存地址中偏移量信息，从 CPU Cache Line 的数据块中，读取对应的字。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;访问的数据在 CPU Cache 中的话，意味着&lt;strong&gt;缓存命中&lt;/strong&gt;，缓存命中率越高的话，代码的性能就会越好，CPU 也就跑的越快。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;遍历数组的情况时，按照内存布局顺序访问，将可以有效的利用 CPU Cache 带来的好处，这样我们代码的性能就会得到很大的提升&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当有多个同时执行「计算密集型」的线程，为了防止因为切换到不同的核心，而导致缓存命中率下降的问题，我们可以把&lt;strong&gt;线程绑定在某一个 CPU 核心上&lt;/strong&gt;，这样性能可以得到非常可观的提升。&lt;/p&gt;
&lt;h4 id=&#34;15-缓存一致性问题&#34;&gt;1.5 缓存一致性问题
&lt;/h4&gt;&lt;p&gt;CPU Cache 是由很多个 Cache Line 组成的，CPU Line 是 CPU 从内存读取数据的基本单位，而 CPU Line 是由各种标志（Tag）+ 数据块（Data Block）组成，&lt;/p&gt;
&lt;p&gt;如果数据写入 Cache 之后，内存与 Cache 相对应的数据将会不同，这种情况下 Cache 和内存数据都不一致了，于是我们肯定是要把 Cache 中的数据同步到内存里的。&lt;/p&gt;
&lt;p&gt;两种针对写入数据的方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;保持内存与 Cache 一致性最简单的方式是，&lt;strong&gt;把数据同时写入内存和 Cache 中&lt;/strong&gt;，这种方法称为&lt;strong&gt;写直达（*Write Through*）&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;为了要减少数据写回内存的频率，就出现了&lt;strong&gt;写回（*Write Back*）的方法&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在写回机制中，&lt;strong&gt;当发生写操作时，新的数据仅仅被写入 Cache Block 里，只有当修改过的 Cache Block「被替换」时才需要写到内存中&lt;/strong&gt;，减少了数据写回内存的频率，这样便可以提高系统的性能。&lt;/p&gt;
&lt;p&gt;写回这个方法，在把数据写入到 Cache 的时候，只有在缓存不命中，同时数据对应的 Cache 中的 Cache Block 为脏标记的情况下，才会将数据写到内存中，而在缓存命中的情况下，则在写入后 Cache 后，只需把该数据对应的 Cache Block 标记为脏即可，而不用写到内存里。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓存一致性问题，A 号核心和 B 号核心的缓存，在这个时候是不一致，从而会导致执行结果的错误。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要解决这一问题，就需要一种机制，来同步两个不同核心里面的缓存数据。要实现的这个机制的话，要保证做到下面这 2 点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一点，某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为&lt;strong&gt;写传播（Write Propagation）&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;第二点，某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为&lt;strong&gt;事务的串行化（Transaction Serialization）&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;写传播很容易就理解，当某个核心在 Cache 更新了数据，就需要同步到其他核心的 Cache 里。&lt;/p&gt;
&lt;p&gt;要实现事务串行化，要做到 2 点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU 核心对于 Cache 中数据的操作，需要同步给其他 CPU 核心；&lt;/li&gt;
&lt;li&gt;要引入「锁」的概念，如果两个 CPU 核心里有相同数据的 Cache，那么对于这个 Cache 数据的更新，只有拿到了「锁」，才能进行对应的数据更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;16-中断&#34;&gt;1.6 中断
&lt;/h4&gt;&lt;p&gt;中断是系统用来响应硬件设备请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中断处理程序，要尽可能快的执行完，这样可以减少对正常进程运行调度地影响。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;中断请求的处理程序应该&lt;strong&gt;要短且快&lt;/strong&gt;，这样才能减少对正常进程运行调度地影响，而且&lt;strong&gt;中断处理程序可能会暂时关闭中断&lt;/strong&gt;，这时如果中断处理程序执行时间过长，可能在还未执行完中断处理程序前，&lt;strong&gt;会丢失当前其他设备的中断请求&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那 Linux 系统&lt;strong&gt;为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段，分别是「上半部和下半部分」&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;上半部用来快速处理中断&lt;/strong&gt;，一般会暂时关闭中断请求，主要负责处理跟硬件紧密相关或者时间敏感的事情。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;下半部用来延迟处理上半部未完成的工作&lt;/strong&gt;，一般以「内核线程」的方式运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中断处理程序的上部分和下半部可以理解为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;上半部直接处理硬件请求，也就是硬中断&lt;/strong&gt;，负责耗时短的工作，快速执行；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;下半部是由内核触发，也就说软中断&lt;/strong&gt;，负责上半部未完成的工作，通常都是耗时比较长的事情，延迟执行；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;硬中断（上半部）是会打断 CPU 正在执行的任务，然后立即执行中断处理程序，而软中断（下半部）是以内核线程的方式执行，并且每一个 CPU 都对应一个软中断内核线程，名字通常为「ksoftirqd/CPU 编号」&lt;/p&gt;
&lt;h4 id=&#34;17-操作系统内核&#34;&gt;1.7 操作系统内核
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;内核作为应用连接硬件设备的桥梁。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现代操作系统，内核一般会提供 4 个基本能力：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管理进程、线程，决定哪个进程、线程使用 CPU，也就是&lt;strong&gt;进程调度&lt;/strong&gt;的能力；&lt;/li&gt;
&lt;li&gt;管理内存，决定内存的分配和回收，也就是&lt;strong&gt;内存管理&lt;/strong&gt;的能力；&lt;/li&gt;
&lt;li&gt;管理硬件设备，为进程与硬件设备之间提供通信能力，也就是&lt;strong&gt;硬件通信&lt;/strong&gt;能力；&lt;/li&gt;
&lt;li&gt;提供系统调用，如果应用程序要运行更高权限运行的服务，那么就需要有&lt;strong&gt;系统调用&lt;/strong&gt;，它是&lt;strong&gt;用户程序与操作系统&lt;/strong&gt;之间的接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linux 内核设计的理念主要有这几个点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;MultiTask&lt;/em&gt;，多任务&lt;/li&gt;
&lt;li&gt;&lt;em&gt;SMP&lt;/em&gt;，对称多处理&lt;/li&gt;
&lt;li&gt;&lt;em&gt;ELF&lt;/em&gt;，可执行文件链接格式&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Monolithic Kernel&lt;/em&gt;，宏内核&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二内存管理&#34;&gt;二、内存管理
&lt;/h2&gt;&lt;h4 id=&#34;21-虚拟内存&#34;&gt;2.1 虚拟内存
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;将不同进程的虚拟地址和不同内存的物理地址映射起来。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;程序访问虚拟地址的时候，由操作系统转换成不同的物理地址，不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序所使用的内存地址叫做&lt;strong&gt;虚拟内存地址&lt;/strong&gt;（&lt;em&gt;Virtual Memory Address&lt;/em&gt;）&lt;/li&gt;
&lt;li&gt;实际存在硬件里面的空间地址叫&lt;strong&gt;物理内存地址&lt;/strong&gt;（&lt;em&gt;Physical Memory Address&lt;/em&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;操作系统是如何管理虚拟地址与物理地址之间的关系？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;主要有两种方式，分别是&lt;strong&gt;内存分段和内存分页&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内存分段&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;分段机制下，虚拟地址和物理地址是如何映射的？&lt;/p&gt;
&lt;p&gt;分段机制下的虚拟地址由两部分组成，&lt;strong&gt;段选择因子&lt;/strong&gt;和&lt;strong&gt;段内偏移量&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;段选择因子&lt;/strong&gt;里面最重要的是&lt;strong&gt;段号&lt;/strong&gt;，用作段表的索引。&lt;strong&gt;段表&lt;/strong&gt;保存这个&lt;strong&gt;段的基地址、段的界限和特权等级&lt;/strong&gt;等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;段内偏移量&lt;/strong&gt;应该位于 0 和段界限之间，物理内存地址=段基地址+段内偏移量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不足之处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个就是&lt;strong&gt;内存碎片&lt;/strong&gt;的问题。&lt;/li&gt;
&lt;li&gt;第二个就是&lt;strong&gt;内存交换的效率低&lt;/strong&gt;的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;内存分段会出现内存碎片吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;内存碎片分为，&lt;strong&gt;内部内存碎片&lt;/strong&gt;和&lt;strong&gt;外部内存碎片&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;内存分段管理可以做到段根据实际需求分配内存，有多少需求就分配多大的段，&lt;strong&gt;不会出现内部内存碎片&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;多个段未必能恰好使用所有的内存空间，会&lt;strong&gt;产生多个不连续的小物理内存&lt;/strong&gt;，导致新的程序无法被装载，所以&lt;strong&gt;会出现外部内存碎片&lt;/strong&gt;的问题。&lt;/p&gt;
&lt;p&gt;解决「外部内存碎片」的问题就是使用&lt;strong&gt;内存交换&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分段为什么会导致内存交换效率低的问题？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于多进程的系统来说，用分段的方式，外部内存碎片是很容易产生的，产生了外部内存碎片，那不得不重新 &lt;code&gt;Swap&lt;/code&gt; 内存区域，这个过程会产生性能瓶颈。&lt;/p&gt;
&lt;p&gt;因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;内存分页&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小&lt;/strong&gt;。这样一个连续并且尺寸固定的内存空间，我们叫&lt;strong&gt;页&lt;/strong&gt;。在 Linux 下，每一页的大小为 &lt;code&gt;4KB&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分页机制下，虚拟地址和物理地址是如何映射的？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在分页机制下，虚拟地址分为两部分，&lt;strong&gt;页号&lt;/strong&gt;和&lt;strong&gt;页内偏移&lt;/strong&gt;。页号作为页表的索引，&lt;strong&gt;页表&lt;/strong&gt;包含物理页每页所在&lt;strong&gt;物理内存的基地址&lt;/strong&gt;，物理内存地址=基地址+页内偏移。&lt;/p&gt;
&lt;p&gt;对于一个内存地址转换，其实就是这样三个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把虚拟内存地址，切分成页号和偏移量；&lt;/li&gt;
&lt;li&gt;根据页号，从页表里面，查询对应的物理页号；&lt;/li&gt;
&lt;li&gt;直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虚拟地址与物理地址之间通过&lt;strong&gt;页表&lt;/strong&gt;来映射，&lt;/p&gt;
&lt;p&gt;页表是存储在内存里的，&lt;strong&gt;内存管理单元&lt;/strong&gt; （&lt;em&gt;MMU&lt;/em&gt;）就做将虚拟内存地址转换成物理地址的工作。&lt;/p&gt;
&lt;p&gt;而当进程访问的虚拟地址在页表中查不到时，系统会产生一个&lt;strong&gt;缺页异常&lt;/strong&gt;，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;分页中，页与页之间是紧密排列的，所以不会有外部碎片。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是，内存分页机制分配内存的最小单位是一页，即使程序不足一页大小，我们最少只能分配一个页，所以页内会出现内存浪费，所以内存分页机制&lt;strong&gt;会有内部内存碎片&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为&lt;strong&gt;换出&lt;/strong&gt;。一旦需要的时候，再加载进来，称为&lt;strong&gt;换入&lt;/strong&gt;。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，&lt;strong&gt;内存交换的效率就相对比较高。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;加载程序的时候，不再需要一次性都把程序加载到物理内存中。&lt;strong&gt;只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;简单的分页有什么缺陷？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有空间上的缺陷。&lt;/p&gt;
&lt;p&gt;因为操作系统是可以同时运行非常多的进程的，这意味着页表会非常的庞大。&lt;/p&gt;
&lt;p&gt;在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 &lt;code&gt;4MB&lt;/code&gt; 的内存来存储页表。&lt;/p&gt;
&lt;p&gt;每个进程都是有自己的虚拟地址空间的，都有自己的页表。那么，&lt;code&gt;100&lt;/code&gt; 个进程的话，就需要 &lt;code&gt;400MB&lt;/code&gt; 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。&lt;/p&gt;
&lt;p&gt;要解决上面的问题，就需要采用一种叫作&lt;strong&gt;多级页表&lt;/strong&gt;的解决方案。&lt;/p&gt;
&lt;p&gt;把这个 100 多万个「页表项」的单级页表再分页，将一级页表分为 &lt;code&gt;1024&lt;/code&gt; 个二级页表，每个二级页表中包含 &lt;code&gt;1024&lt;/code&gt; 个「页表项」，形成&lt;strong&gt;二级分页&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由于局部性原理。如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;保存在内存中的页表承担的职责是将虚拟地址翻译成物理地址。假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了。所以&lt;strong&gt;页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于 64 位的系统，两级分页肯定不够了，就变成了四级目录。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;快表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;程序是有局部性的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。利用这一特性，把最常访问的几个页表项存储到访问速度更快的硬件，于是在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB（&lt;em&gt;Translation Lookaside Buffer&lt;/em&gt;） ，通常称为页表缓存、转址旁路缓存、快表等。&lt;/p&gt;
&lt;p&gt;在 CPU 芯片里面，封装了内存管理单元（&lt;em&gt;Memory Management Unit&lt;/em&gt;）芯片，它用来完成地址转换和 TLB 的访问与交互。&lt;/p&gt;
&lt;p&gt;有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。&lt;/p&gt;
&lt;p&gt;TLB 的命中率其实是很高的，因为程序最常访问的页就那么几个。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;段页式内存管理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为&lt;strong&gt;段页式内存管理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;段页式内存管理实现的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；&lt;/li&gt;
&lt;li&gt;接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样，地址结构就由&lt;strong&gt;段号、段内页号和页内位移&lt;/strong&gt;三部分组成。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Linux 的虚拟地址空间是如何分布的？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Linux 操作系统中，虚拟地址空间的内部又被分为&lt;strong&gt;内核空间和用户空间&lt;/strong&gt;两部分，最常见的 32 位和 64 位系统，如下所示：&lt;/p&gt;
&lt;img src=&#34;imgs/embed_interview6.jpg&#34; alt=&#34;&#34; width=&#34;500&#34; /&gt;
&lt;p&gt;可以看出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;32&lt;/code&gt; 位系统的内核空间占用 &lt;code&gt;1G&lt;/code&gt;，位于最高处，剩下的 &lt;code&gt;3G&lt;/code&gt; 是用户空间；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;64&lt;/code&gt; 位系统的内核空间和用户空间都是 &lt;code&gt;128T&lt;/code&gt;，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再来说说，内核空间与用户空间的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程在用户态时，只能访问用户空间内存；&lt;/li&gt;
&lt;li&gt;只有进入内核态后，才可以访问内核空间的内存；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然每个进程都各自有独立的虚拟内存，但是&lt;strong&gt;每个虚拟内存中的内核地址，其实关联的都是相同的物理内存&lt;/strong&gt;。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用户空间分布的情况，以 32 位系统为例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&#34;imgs/embed_interview7.jpg&#34; alt=&#34;&#34; width=&#34;500&#34; /&gt;
&lt;p&gt;用户空间内存，从&lt;strong&gt;低到高&lt;/strong&gt;分别是 6 种不同的内存段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码段，包括二进制可执行代码；&lt;/li&gt;
&lt;li&gt;数据段，包括已初始化的静态常量和全局变量；&lt;/li&gt;
&lt;li&gt;BSS 段，包括未初始化的静态变量和全局变量；&lt;/li&gt;
&lt;li&gt;堆段，包括动态分配的内存，从低地址开始向上增长；&lt;/li&gt;
&lt;li&gt;文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关）；&lt;/li&gt;
&lt;li&gt;栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 &lt;code&gt;8 MB&lt;/code&gt;。当然系统也提供了参数，以便我们自定义大小；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上图中的内存布局可以看到，代码段下面还有一段内存空间的（灰色部分），这一块区域是「保留区」，之所以要有保留区这是因为在大多数的系统里，我们认为比较小数值的地址不是一个合法地址，例如，我们通常在 C 的代码里会将无效的指针赋值为 NULL。因此，这里会出现一段不可访问的内存保留区，防止程序因为出现 bug，导致读或写了一些小内存地址的数据，而使得程序跑飞。&lt;/p&gt;
&lt;p&gt;在这 7 个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 &lt;code&gt;malloc()&lt;/code&gt; 或者 &lt;code&gt;mmap()&lt;/code&gt; ，就可以分别在堆和文件映射段动态分配内存。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 4GB 物理内存的机器上，申请 8G 内存会怎么样？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在32 位操作系统，进程最多只能申请 3 GB 大小的虚拟内存空间，所以进程申请 8GB 内存的话，在申请虚拟内存阶段就会失败。&lt;/p&gt;
&lt;p&gt;在 64 位操作系统，进程可以使用 128 TB 大小的虚拟内存空间，所以进程申请 8GB 内存是没问题的，因为进程申请内存是申请虚拟内存，只要不读写这个虚拟内存，操作系统就不会分配物理内存。&lt;/p&gt;
&lt;h4 id=&#34;22-malloc-是如何分配内存的&#34;&gt;2.2 malloc 是如何分配内存的
&lt;/h4&gt;&lt;p&gt;malloc申请内存的时候，会有两种方式向操作系统申请堆内存。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方式一：通过 brk() 系统调用从堆分配内存&lt;/li&gt;
&lt;li&gt;方式二：通过 mmap() 系统调用在文件映射区域分配内存；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用户分配的内存小于 128 KB，则通过 brk() 申请内存；大于 128 KB，则通过 mmap() 申请内存；&lt;/p&gt;
&lt;p&gt;malloc() 在分配内存的时候，并不是老老实实按用户预期申请的字节数来分配内存空间大小，而是&lt;strong&gt;会预分配更大的空间作为内存池&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;malloc 申请的内存，free 释放内存会归还给操作系统吗？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;malloc 通过 &lt;strong&gt;brk()&lt;/strong&gt; 方式申请的内存，free 释放内存的时候，&lt;strong&gt;并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;malloc 通过 &lt;strong&gt;mmap()&lt;/strong&gt; 方式申请的内存，free 释放内存的时候，&lt;strong&gt;会把内存归还给操作系统，内存得到真正的释放&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么不全部使用 mmap或全用brk？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;频繁通过 mmap 分配的内存的话，不仅每次都会发生运行态的切换，还会发生缺页中断（在第一次访问虚拟地址后），这样会导致 CPU 消耗较大&lt;/strong&gt;。 brk() 系统调用在堆空间申请内存的时候，由于堆空间是连续的，所以直接预分配更大的内存来作为内存池，当内存释放的时候，就缓存在内存池中。&lt;/p&gt;
&lt;p&gt;随着系统频繁地使用brk，尤其对于小块内存，堆内将产生越来越多不可用的碎片，导致“内存泄露”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;malloc 返回给用户态的内存起始地址比进程的堆空间起始地址多 16 字节&lt;/p&gt;
&lt;p&gt;执行 free() 函数时，free 会对传入进来的内存地址向左偏移 16 字节，多出来的 16 字节就是保存了该内存块的描述信息，比如有该内存块的大小。&lt;/p&gt;
&lt;h4 id=&#34;23-内存分配的过程&#34;&gt;2.3 内存分配的过程
&lt;/h4&gt;&lt;p&gt;应用程序通过 malloc 函数申请内存的时候，实际上申请的是虚拟内存，此时并不会分配物理内存。&lt;/p&gt;
&lt;p&gt;当应用程序读写了这块虚拟内存，CPU 就会去访问这个虚拟内存， 这时会发现这个虚拟内存没有映射到物理内存， CPU 就会产生&lt;strong&gt;缺页中断&lt;/strong&gt;，进程会从用户态切换到内核态，并将缺页中断交给内核的 Page Fault Handler （缺页中断函数）处理。&lt;/p&gt;
&lt;p&gt;缺页中断处理函数会看是否有空闲的物理内存，如果有，就直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系。&lt;/p&gt;
&lt;p&gt;如果没有空闲的物理内存，那么内核就会开始进行&lt;strong&gt;回收内存&lt;/strong&gt;的工作，回收的方式主要是两种：直接内存回收和后台内存回收。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;后台内存回收&lt;/strong&gt;（kswapd）：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程&lt;strong&gt;异步&lt;/strong&gt;的，不会阻塞进程的执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;直接内存回收&lt;/strong&gt;（direct reclaim）：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是&lt;strong&gt;同步&lt;/strong&gt;的，会阻塞进程的执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果直接内存回收后，空闲的物理内存仍然无法满足此次物理内存的申请，那么内核就会放最后的大招了 ——&lt;strong&gt;触发 OOM （Out of Memory）机制&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;OOM Killer 机制会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;哪些内存可以被回收？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;主要有两类内存可以被回收，而且它们的回收方式也不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;文件页&lt;/strong&gt;：内核缓存的磁盘数据和内核缓存的文件数据都叫作文件页。大部分文件页，都可以直接释放内存，以后有需要时，再从磁盘重新读取就可以了。而那些被应用程序修改过，并且暂时还没写入磁盘的数据（也就是脏页），就得先写入磁盘，然后才能进行内存释放。所以，&lt;strong&gt;回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;匿名页&lt;/strong&gt;：这部分内存没有实际载体，比如堆、栈数据等。这部分内存很可能还要再次被访问，所以不能直接释放内存，它们&lt;strong&gt;回收的方式是通过 Linux 的 Swap 机制&lt;/strong&gt;，Swap 会把不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文件页和匿名页的回收都是基于 LRU 算法，也就是优先回收不常访问的内存。LRU 回收算法，实际上维护着 active 和 inactive 两个双向链表，其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;active_list&lt;/strong&gt; 活跃内存页链表，这里存放的是最近被访问过（活跃）的内存页；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;inactive_list&lt;/strong&gt; 不活跃内存页链表，这里存放的是很少被访问（非活跃）的内存页；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;越接近链表尾部，就表示内存页越不常访问。这样，在回收内存时，系统就可以根据活跃程度，优先回收不活跃的内存。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NUMA 架构下的内存回收策略&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;SMP 指的是一种&lt;strong&gt;多个 CPU 处理器共享资源的电脑硬件架构&lt;/strong&gt;，也就是说每个 CPU 地位平等，它们共享相同的物理资源，包括总线、内存、IO、操作系统等。每个 CPU 访问内存所用时间都是相同的，因此，这种系统也被称为&lt;strong&gt;一致存储访问结构&lt;/strong&gt;（UMA）。&lt;/p&gt;
&lt;p&gt;随着 CPU 处理器核数的增多，多个 CPU 都通过一个总线访问内存，这样总线的带宽压力会越来越大，同时每个 CPU 可用带宽会减少，这也就是 SMP 架构的问题。&lt;/p&gt;
&lt;p&gt;非一致存储访问结构（NUMA）将每个 CPU 进行了分组，每一组 CPU 用 Node 来表示，一个 Node 可能包含多个 CPU 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每个 Node 有自己独立的资源，包括内存、IO 等&lt;/strong&gt;，每个 Node 之间可以通过互联模块总线（QPI）进行通信，所以，也就意味着每个 Node 上的 CPU 都可以访问到整个系统中的所有内存。但是，访问远端 Node 的内存比访问本地内存要耗时很多。&lt;/p&gt;
&lt;p&gt;在 NUMA 架构下，当某个 Node 内存不足时，系统可以从其他 Node 寻找空闲内存，也可以从本地内存中回收内存。&lt;/p&gt;
&lt;p&gt;在使用 NUMA 架构的服务器，如果系统出现还有一半内存的时候，却发现系统频繁触发「直接内存回收」，导致了影响了系统性能，那么大概率是因为当本地内存不足的时候，只选择回收本地内存的方式，而不去使用其他 Node 的空闲内存。&lt;/p&gt;
&lt;p&gt;虽然说访问远端 Node 的内存比访问本地内存要耗时很多，但是相比内存回收的危害而言，访问远端 Node 的内存带来的性能影响还是比较小的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如何保护一个进程不被 OOM 杀掉呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在系统空闲内存不足的情况，进程申请了一个很大的内存，如果直接内存回收都无法回收出足够大的空闲内存，那么就会触发 OOM 机制，内核就会根据算法选择一个进程杀掉。&lt;/p&gt;
&lt;p&gt;Linux会把系统中可以被杀掉的进程扫描一遍，并对每个进程打分，得分最高的进程就会被首先杀掉。&lt;/p&gt;
&lt;p&gt;进程得分的结果受下面这两个方面影响：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一，进程已经使用的物理内存页面数。&lt;/li&gt;
&lt;li&gt;第二，每个进程的 OOM 校准值 oom_score_adj。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个进程的 oom_score_adj 默认值都为 0，所以最终得分跟进程自身消耗的内存有关，消耗的内存越大越容易被杀掉。&lt;/p&gt;
&lt;p&gt;我们最好将一些很重要的系统服务的 oom_score_adj 配置为 -1000，比如 sshd，因为这些系统服务一旦被杀掉，我们就很难再登陆进系统了。&lt;/p&gt;
&lt;p&gt;但是，不建议将我们自己的业务程序的 oom_score_adj 设置为 -1000，因为业务程序一旦发生了内存泄漏，而它又不能被杀掉，这就会导致随着它的内存开销变大，OOM killer 不停地被唤醒，从而把其他进程一个个给杀掉。&lt;/p&gt;
&lt;h4 id=&#34;24-改进-lru-算法&#34;&gt;2.4 改进 LRU 算法
&lt;/h4&gt;&lt;p&gt;传统的 LRU 算法的实现思路是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当访问的页在内存里，就直接把该页对应的 LRU 链表节点移动到链表的头部。&lt;/li&gt;
&lt;li&gt;当访问的页不在内存里，除了要把该页放入到 LRU 链表的头部，还要淘汰 LRU 链表末尾的页。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;传统的 LRU 算法无法避免下面这两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;预读失效导致缓存命中率下降；&lt;/li&gt;
&lt;li&gt;缓存污染导致缓存命中率下降；&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;预读失效，怎么办？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;什么是预读机制？&lt;/p&gt;
&lt;p&gt;Linux 操作系统为基于 Page Cache 的读缓存机制提供&lt;strong&gt;预读机制&lt;/strong&gt;，一个例子是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用程序只想读取磁盘上文件 A 的 offset 为 0-3KB 范围内的数据，由于磁盘的基本读写单位为 block（4KB），于是操作系统至少会读 0-4KB 的内容，这恰好可以在一个 page 中装下。&lt;/li&gt;
&lt;li&gt;但是操作系统出于空间局部性原理（靠近当前被访问数据的数据，在未来很大概率会被访问到），会选择将磁盘块 offset [4KB,8KB)、[8KB,12KB) 以及 [12KB,16KB) 都加载到内存，于是额外在内存中申请了 3 个 page；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用程序利用 read 系统调动读取 4KB 数据，实际上内核使用预读机制（ReadaHead） 机制完成了 16KB 数据的读取，也就是通过一次磁盘顺序读将多个 Page 数据装入 Page Cache。&lt;/p&gt;
&lt;p&gt;这样下次读取 4KB 数据后面的数据的时候，就不用从磁盘读取了，直接在 Page Cache 即可命中数据。因此，预读机制带来的好处就是&lt;strong&gt;减少了 磁盘 I/O 次数，提高系统磁盘 I/O 吞吐量&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;预读失效会带来什么问题？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果&lt;strong&gt;这些被提前加载进来的页，并没有被访问&lt;/strong&gt;，相当于这个预读工作是白做了，这个就是&lt;strong&gt;预读失效&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果使用传统的 LRU 算法，就会把「预读页」放到 LRU 链表头部，而当内存空间不够的时候，还需要把末尾的页淘汰掉。&lt;/p&gt;
&lt;p&gt;如果这些「预读页」如果一直不会被访问到，就会出现一个很奇怪的问题，&lt;strong&gt;不会被访问的预读页却占用了 LRU 链表前排的位置，而末尾淘汰的页，可能是热点数据，这样就大大降低了缓存命中率&lt;/strong&gt; 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Linux 是如何避免预读失效带来的影响？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Linux 操作系统实现两个了 LRU 链表：&lt;strong&gt;活跃 LRU 链表（active_list）和非活跃 LRU 链表（inactive_list）&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;active list&lt;/strong&gt; 活跃内存页链表，这里存放的是最近被访问过（活跃）的内存页；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;inactive list&lt;/strong&gt; 不活跃内存页链表，这里存放的是很少被访问（非活跃）的内存页；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了这两个 LRU 链表后，&lt;strong&gt;预读页就只需要加入到 inactive list 区域的头部，当页被真正访问的时候，才将页插入 active list 的头部&lt;/strong&gt;。如果预读的页一直没有被访问，就会从 inactive list 移除，这样就不会影响 active list 中的热点数据。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;缓存污染会带来什么问题？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;缓存污染带来的影响就是很致命的，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 I/O，系统性能就会急剧下降。&lt;/p&gt;
&lt;p&gt;我以 MySQL 举例子，Linux 发生缓存污染的现象也是类似。&lt;/p&gt;
&lt;p&gt;当某一个 SQL 语句&lt;strong&gt;扫描了大量的数据&lt;/strong&gt;时，&lt;strong&gt;可能会导致大量热数据被淘汰了&lt;/strong&gt;，&lt;strong&gt;等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 I/O&lt;/strong&gt;，MySQL 性能就会急剧下降。&lt;/p&gt;
&lt;p&gt;注意， 缓存污染并不只是查询语句查询出了大量的数据才出现的问题，即使查询出来的结果集很小，也会造成缓存污染。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;怎么避免缓存污染造成的影响？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面的 LRU 算法只要数据被访问一次，就将数据加入活跃 LRU 链表（或者 young 区域），&lt;strong&gt;这种 LRU 算法进入活跃 LRU 链表的门槛太低了&lt;/strong&gt;！正式因为门槛太低，才导致在发生缓存污染的时候，很容就将原本在活跃 LRU 链表里的热点数据淘汰了。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;只要我们提高进入到活跃 LRU 链表的门槛，就能有效地保证活跃 LRU 链表里的热点数据不会被轻易替换掉&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Linux 操作系统&lt;/strong&gt;：在内存页被访问&lt;strong&gt;第二次&lt;/strong&gt;的时候，才将页从 inactive list 升级到 active list 里。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在批量读取数据时候，&lt;strong&gt;如果这些大量数据只会被访问一次，那么它们就不会进入到活跃 LRU 链表（或者 young 区域）&lt;/strong&gt;，也就不会把热点数据淘汰，只会待在非活跃 LRU 链表中，后续很快也会被淘汰。&lt;/p&gt;
&lt;h4 id=&#34;25-深入理解linux虚拟内存&#34;&gt;2.5 深入理解Linux虚拟内存
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;虚拟地址是什么&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;32 位虚拟地址的格式为：页目录项（10位）+ 页表项（10位） + 页内偏移（12位）。共 32 位组成的虚拟内存地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程虚拟内存空间中的每一个字节都有与其对应的虚拟内存地址，一个虚拟内存地址表示进程虚拟内存空间中的一个特定的字节。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么要使用虚拟地址访问内存&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在直接操作物理内存的情况下，我们需要知道每一个变量的位置都被安排在了哪里，而且还要注意和多个进程同时运行的时候，不能共用同一个地址，否则就会造成地址冲突。&lt;/p&gt;
&lt;p&gt;而当 CPU 访问进程的虚拟地址时，虚拟地址转换成不同的物理地址，这样不同的进程运行的时候，虽然操作的是同一虚拟地址，但其实背后写入的是不同的物理地址，这样就不会冲突了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序局部性原理表现为：时间局部性和空间局部性。时间局部性是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某块数据被访问，则不久之后该数据可能再次被访问。空间局部性是指一旦程序访问了某个存储单元，则不久之后，其附近的存储单元也将被访问。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此。无论一个进程实际可以占用的内存资源有多大，根据程序局部性原理，在某一段时间内，进程真正需要的物理内存其实是很少的一部分，只需要为每个进程分配很少的物理内存就可以保证进程的正常执行运转。&lt;/p&gt;
&lt;p&gt;虚拟内存引入之后，**每个进程都拥有自己独立的虚拟地址空间，进程与进程之间的虚拟内存地址空间是相互隔离，互不干扰的。**每个进程都认为自己独占所有内存空间。&lt;/p&gt;
&lt;p&gt;可以将多进程之间协同的相关复杂细节统统交给内核中的内存管理模块来处理。这一切都是因为虚拟内存能够提供内存地址空间的隔离，极大地扩展了可用空间。&lt;/p&gt;
&lt;p&gt;任何一个虚拟内存里所存储的数据，本质上还是保存在真实的物理内存里的。只不过内核帮我们做了虚拟内存到物理内存的这一层映射，将不同进程的虚拟地址和不同内存的物理地址映射起来。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;进程虚拟内存空间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&#34;imgs/embed_interview8.jpg&#34; alt=&#34;&#34; width=&#34;500&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;用于存放进程程序二进制文件中的机器指令的代码段&lt;/li&gt;
&lt;li&gt;用于存放程序二进制文件中定义的全局变量和静态变量的数据段和 BSS 段。&lt;/li&gt;
&lt;li&gt;用于在程序运行过程中动态申请内存的堆。&lt;/li&gt;
&lt;li&gt;用于存放动态链接库以及内存映射区域的文件映射与匿名映射区。&lt;/li&gt;
&lt;li&gt;用于存放函数调用过程中的局部变量和函数参数的栈。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;程序代码事先编写好，然后编译成二进制文件存放在磁盘中，CPU 会执行二进制文件中的机器码来驱动进程的运行。所以在进程运行之前，这些存放在二进制文件中的机器码需要被加载进内存中，而用于存放这些机器码的虚拟内存空间叫做&lt;strong&gt;代码段&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;全局变量在程序编译之后也会存储在二进制文件中，在程序运行之前，这些全局变量也需要被加载进内存中供程序访问。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;代码中被我们指定了初始值的全局变量和静态变量在虚拟内存空间中的存储区域我们叫做&lt;strong&gt;数据段&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有指定初始值的全局变量和静态变量在虚拟内存空间中的存储区域我们叫做 &lt;strong&gt;BSS 段&lt;/strong&gt;。这些未初始化的全局变量被加载进内存之后会被初始化为 0 值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BSS 段中的数据也存在于二进制文件中，因为内核知道这些数据是没有初值的，所以在二进制文件中只会记录 BSS 段的大小，在加载进内存时会生成一段 0 填充的内存空间。&lt;/p&gt;
&lt;p&gt;这些全局变量和静态变量都是在编译期间就确定的。&lt;/p&gt;
&lt;p&gt;但是我们程序在运行期间往往需要动态的申请内存，所以在虚拟内存空间中也需要一块区域来存放这些动态申请的内存，这块区域就叫做&lt;strong&gt;堆&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;程序在运行过程中还需要依赖动态链接库，这些动态链接库以 .so 文件的形式存放在磁盘中，这些动态链接库也有自己的对应的代码段，数据段，BSS 段，也需要一起被加载进内存中。&lt;/p&gt;
&lt;p&gt;还有用于内存文件映射的系统调用 mmap，会将文件与内存进行映射。&lt;/p&gt;
&lt;p&gt;这些动态链接库中的代码段，数据段，BSS 段，以及通过 mmap 系统调用映射的共享内存区，在虚拟内存空间的存储区域叫做&lt;strong&gt;文件映射与匿名映射区&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在文件映射与匿名映射区的地址增长方向是从高地址向低地址增长。&lt;/p&gt;
&lt;p&gt;程序运行调用各种函数过程中使用到的局部变量和函数参数也需要一块内存区域来保存。这一块区域在虚拟内存空间中叫做&lt;strong&gt;栈&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;32 位机器上进程虚拟内存空间分布&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 32 位机器上，指针的寻址范围为 2^32，所能表达的虚拟内存空间为 4 GB。所以在 32 位机器上进程的虚拟内存地址范围为：0x0000 0000 - 0xFFFF FFFF。&lt;/p&gt;
&lt;p&gt;其中用户态虚拟内存空间为 3 GB，虚拟内存地址范围为：0x0000 0000 - 0xC000 000 。&lt;/p&gt;
&lt;p&gt;内核态虚拟内存空间为 1 GB，虚拟内存地址范围为：0xC000 000 - 0xFFFF FFFF。&lt;/p&gt;
&lt;p&gt;代码段并不是从 0x0000 0000 地址开始的，而是从 0x0804 8000 地址开始。&lt;/p&gt;
&lt;p&gt;0x0000 0000 到 0x0804 8000 这段虚拟内存地址是一段&lt;strong&gt;不可访问的保留区&lt;/strong&gt;，因为在大多数操作系统中，&lt;strong&gt;数值比较小的地址通常被认为不是一个合法的地址，这块小地址是不允许访问的&lt;/strong&gt;。比如在 C 语言中我们通常会将一些无效的指针设置为 NULL，指向这块不允许访问的地址。&lt;/p&gt;
&lt;p&gt;64 位系统下只&lt;strong&gt;使用了 48 位&lt;/strong&gt;来描述虚拟内存空间，寻址范围为 2^48 ，所能表达的虚拟内存空间为 256TB。&lt;/p&gt;
&lt;p&gt;64 位系统中的虚拟内存布局和 32 位系统中的虚拟内存布局大体上是差不多的。主要不同的地方有三点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;就是前边提到的由高 16 位空闲地址造成的 canonical address 空洞。在这段范围内的虚拟内存地址是不合法的，因为它的高 16 位既不全为 0 也不全为 1，不是一个 canonical address，所以称之为 canonical address 空洞。&lt;/li&gt;
&lt;li&gt;在代码段跟数据段的中间还有一段不可以读写的保护段，它的作用是防止程序在读写数据段的时候越界访问到代码段，这个保护段可以让越界访问行为直接崩溃，防止它继续往下运行。&lt;/li&gt;
&lt;li&gt;用户态虚拟内存空间与内核态虚拟内存空间分别占用 128T，其中低128T 分配给用户态虚拟内存空间，&lt;em&gt;虚拟内存地址范围为：0x0000 0000 0000 0000 - 0x0000 7FFF FFFF F000&lt;/em&gt; 。高 128T 分配给内核态虚拟内存空间，&lt;em&gt;虚拟内存地址范围为：0xFFFF 8000 0000 0000 - 0xFFFF FFFF FFFF FFFF 。&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过 fork() 函数创建出的子进程，它的虚拟内存空间以及相关页表相当于父进程虚拟内存空间的一份拷贝，直接从父进程中拷贝到子进程中。&lt;/p&gt;
&lt;p&gt;通过 vfork 或者 clone 系统调用创建出的子进程，父进程和子进程的虚拟内存空间是共享的。也就是说父子进程之间使用的虚拟内存空间是一样的，并不是一份拷贝。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;内核虚拟内存空间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;内核态虚拟内存空间是所有进程共享的，不同进程进入内核态之后看到的虚拟内存空间是一样的。&lt;/p&gt;
&lt;p&gt;在总共大小 1G 的内核虚拟内存空间中，位于最前边有一块 896M 大小的区域，我们称之为&lt;strong&gt;直接映射区&lt;/strong&gt;或者线性映射区，地址范围为 3G &amp;ndash; 3G + 896m 。&lt;/p&gt;
&lt;p&gt;直接映射区虚拟内存地址会映射到 0 - 896M 这块连续的物理内存上。&lt;/p&gt;
&lt;p&gt;虽然这块区域中的虚拟地址是直接映射到物理地址上，但是内核在访问这段区域的时候还是走的虚拟内存地址，内核也会为这块空间建立映射页表。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 fork 系统调用创建进程的时候，内核会创建一系列进程相关的描述符，比如之前提到的进程的核心数据结构 task_struct，进程的内存空间描述符 mm_struct，以及虚拟内存区域描述符 vm_area_struct 等。进程相关的数据结构也会存放在物理内存前 896M 的这段区域中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当进程被创建完毕之后，在内核运行的过程中，会涉及内核栈的分配，内核会为每个进程分配一个固定大小的内核栈，每个进程的整个调用链必须放在自己的内核栈中，内核栈也是分配在直接映射区。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;直接映射区的前 16M 专门让内核用来为 DMA （直接内存存取）分配内存，这块 16M 大小的内存区域我们称之为 &lt;strong&gt;ZONE_DMA&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;直接映射区中剩下的部分也就是从 16M 到 896M（不包含 896M）这段区域，我们称之为 &lt;strong&gt;ZONE_NORMAL&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;物理内存 896M 以上的区域被内核划分为 ZONE_HIGHMEM 区域，我们称之为高端内存。&lt;/p&gt;
&lt;p&gt;物理内存假设为 4G，高端内存区域为 4G - 896M = 3200M。内核剩余可用的虚拟内存空间就变为了 1G - 896M = 128M。&lt;/p&gt;
&lt;p&gt;物理内存中的 ZONE_HIGHMEM 区域就只能采用动态映射的方式映射到 128M 大小的内核虚拟内存空间中，也就是说只能动态的一部分一部分的分批映射，先映射正在使用的这部分，使用完毕解除映射，接着映射其他部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;vmalloc 动态映射区&lt;/strong&gt;。采用动态映射的方式映射物理内存中的高端内存。&lt;/p&gt;
&lt;p&gt;和用户态进程使用 malloc 申请内存一样，在这块动态映射区内核是使用 vmalloc 进行内存分配。由于之前介绍的动态映射的原因，vmalloc 分配的内存在虚拟内存上是连续的，但是物理内存是不连续的。通过页表来建立物理内存与虚拟内存之间的映射关系，从而可以将不连续的物理内存映射到连续的虚拟内存上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;永久映射区&lt;/strong&gt;。在内核的这段虚拟地址空间中允许建立与物理高端内存的长期映射关系。&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;固定映射区&lt;/strong&gt;中的虚拟内存地址可以自由映射到物理内存的高端地址上，但是与动态映射区以及永久映射区不同的是，在固定映射区中虚拟地址是固定的，而被映射的物理地址是可以改变的。也就是说，有些虚拟地址在编译的时候就固定下来了，是在内核启动过程中被确定的，而这些虚拟地址对应的物理地址不是固定的。
在内核的启动过程中，有些模块需要使用虚拟内存并映射到指定的物理地址上，而且这些模块也没有办法等待完整的内存管理模块初始化之后再进行地址映射。因此，内核固定分配了一些虚拟地址，这些地址有固定的用途，使用该地址的模块在初始化的时候，将这些固定分配的虚拟地址映射到指定的物理地址上去&lt;/p&gt;
&lt;p&gt;在内核虚拟内存空间中的最后一块区域为&lt;strong&gt;临时映射区&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;32位体系结构下 Linux 虚拟内存空间整体布局
&lt;img src=&#34;https://cdn.xiaolincoding.com//mysql/other/68763fe509b7adf5987a3ce96c9d12ee.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是物理内存&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;内存也叫随机访问存储器（ random-access memory ）也叫 RAM 。而 RAM 分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一类是静态 RAM（ &lt;code&gt;SRAM&lt;/code&gt; ），这类 SRAM 用于 CPU 高速缓存，访问速度快，但是容量小，造价高。&lt;/li&gt;
&lt;li&gt;另一类则是动态 RAM ( &lt;code&gt;DRAM&lt;/code&gt; )，这类 DRAM 用于我们常说的主存上，其特点的是访问速度慢（相对高速缓存），但是容量大，造价便宜些（相对高速缓存）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多个存储器模块连接到存储控制器上，就聚合成了主存。DRAM 芯片就包装在存储器模块中，每个存储器模块中包含 8 个 DRAM 芯片。
&lt;img src=&#34;https://cdn.xiaolincoding.com//mysql/other/9651fbd7b5a3b397f7a81acfcd49723c.png&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com//mysql/other/a2112f84eed5dc53dd760cf6a5fdb538.png&#34; style=&#34;zoom: 33%;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;每一个 DRAM 芯片的存储结构是一个二维矩阵，二维矩阵中存储的元素我们称为超单元（supercell），每个 supercell 大小为一个字节（8 bit）。每个 supercell 都由一个坐标地址（i，j）。i 在计算机中行地址称为 RAS (row access strobe，行访问选通脉冲)。 j 在计算机中列地址称为 CAS (column access strobe,列访问选通脉冲)。
因为 DRAM 芯片的 IO 单位为一个字节（8 bit），所以需要 8 个 data 引脚从 DRAM 芯片传入传出数据。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DRAM 芯片的访问&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先存储控制器将行地址 RAS = 2 通过地址引脚发送给 DRAM 芯片。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DRAM 芯片根据 RAS = 2 将二维矩阵中的第二行的全部内容拷贝到内部行缓冲区中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接下来存储控制器会通过地址引脚发送 CAS = 2 到 DRAM 芯片中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DRAM芯片从内部行缓冲区中根据 CAS = 2 拷贝出第二列的 supercell 并通过数据引脚发送给存储控制器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;CPU 是如何访问内存的：
&lt;img src=&#34;https://cdn.xiaolincoding.com//mysql/other/efa862811f305ab0aa15c0422d8933e8.png&#34; style=&#34;zoom:50%;&#34; /&gt;
CPU 与内存之间的数据交互是通过总线完成的，而数据在总线上的传送是通过一系列的步骤完成的，这些步骤称为&lt;strong&gt;总线事务&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;其中数据从内存传送到 CPU 称之为&lt;strong&gt;读事务&lt;/strong&gt;（read transaction），数据从 CPU 传送到内存称之为&lt;strong&gt;写事务&lt;/strong&gt;（write transaction）。&lt;/p&gt;
&lt;p&gt;总线上传输的信号包括：地址信号，数据信号，控制信号。其中控制总线上传输的控制信号可以同步事务，并能够标识出当前正在被执行的事务信息：&lt;/p&gt;
&lt;p&gt;系统总线是连接 CPU 与 IO bridge 的，存储总线是来连接 IO bridge 和主存的。&lt;/p&gt;
&lt;p&gt;IO bridge 负责将系统总线上的电子信号转换成存储总线上的电子信号。IO bridge 也会将系统总线和存储总线连接到IO总线（磁盘等IO设备）上。这里我们看到 IO bridge 其实起的作用就是转换不同总线上的电子信号。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CPU 从内存读取数据过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先 CPU 芯片中的总线接口会在总线上发起读事务（read transaction）。 该读事务分为以下步骤进行：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CPU 将物理内存地址 A 放到系统总线上。随后 IO bridge 将信号传递到存储总线上。&lt;/li&gt;
&lt;li&gt;主存感受到存储总线上的地址信号并通过存储控制器将存储总线上的物理内存地址 A 读取出来。&lt;/li&gt;
&lt;li&gt;存储控制器通过物理内存地址 A 定位到具体的存储器模块，从 DRAM 芯片中取出物理内存地址 A 对应的数据 X。&lt;/li&gt;
&lt;li&gt;存储控制器将读取到的数据 X 放到存储总线上，随后 IO bridge 将存储总线上的数据信号转换为系统总线上的数据信号，然后继续沿着系统总线传递。&lt;/li&gt;
&lt;li&gt;CPU 芯片感受到系统总线上的数据信号，将数据从系统总线上读取出来并拷贝到寄存器中。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;如何根据物理内存地址从主存中读取数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;存储控制器会将&lt;strong&gt;物理内存地址&lt;/strong&gt;转换为 DRAM 芯片中 supercell 在二维矩阵中的坐标地址(RAS，CAS)。并将这个坐标地址发送给对应的存储器模块。随后存储器模块会将 RAS 和 CAS 广播到存储器模块中的所有 DRAM 芯片。依次通过 (RAS，CAS) 从 DRAM0 到 DRAM7 读取到相应的 supercell 。&lt;/p&gt;
&lt;p&gt;我们知道一个 supercell 存储了一个字节（ 8 bit ） 数据，这里我们从 DRAM0 到 DRAM7 依次读取到了 8 个 supercell 也就是 8 个字节，然后将这 8 个字节返回给存储控制器，由存储控制器将数据放到存储总线上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU 总是以 word size 为单位从内存中读取数据，在 64 位处理器中的 word size 为 8 个字节。64 位的内存每次只能吞吐 8 个字节。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CPU 每次会向内存读写一个 cache line 大小的数据（ 64 个字节），但是内存一次只能吞吐 8 个字节。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;内存读取数据只能是按照物理内存地址，8 个字节 8 个字节地顺序读取数据。所以说内存一次读取和写入的单位是 8 个字节。&lt;/p&gt;
&lt;p&gt;在程序员眼里连续的物理内存地址实际上在物理上是不连续的。因为这连续的 8 个字节其实是存储于不同的 DRAM 芯片上的。每个 DRAM 芯片存储一个字节（supercell）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CPU 向内存写入数据过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们现在假设 CPU 要将寄存器中的数据 X 写到物理内存地址 A 中。同样的道理，CPU 芯片中的总线接口会向总线发起写事务（write transaction）。写事务步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CPU 将要写入的物理内存地址 A 放入系统总线上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 IO bridge 的信号转换，将物理内存地址 A 传递到存储总线上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储控制器感受到存储总线上的地址信号，将物理内存地址 A 从存储总线上读取出来，并等待数据的到达。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU 将寄存器中的数据拷贝到系统总线上，通过 IO bridge 的信号转换，将数据传递到存储总线上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储控制器感受到存储总线上的数据信号，将数据从存储总线上读取出来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储控制器通过内存地址 A 定位到具体的存储器模块，最后将数据写入存储器模块中的 8 个 DRAM 芯片中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;26-深入理解-linux-物理内存管理&#34;&gt;2.6 深入理解 Linux 物理内存管理
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;从CPU 角度看物理内存模型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了快速索引到具体的物理内存页，内核为每个物理页 struct page 结构体定义了一个索引编号：PFN（Page Frame Number）。PFN 与 struct page 是一一对应的关系。&lt;/p&gt;
&lt;p&gt;内核提供了两个宏来完成 PFN 与 物理页结构体 struct page 之间的相互转换。它们分别是 page_to_pfn 与 pfn_to_page。&lt;/p&gt;
&lt;p&gt;内核中如何组织管理这些物理内存页 struct page 的方式我们称之为做物理内存模型，不同的物理内存模型，应对的场景以及 page_to_pfn 与 pfn_to_page 的计算逻辑都是不一样的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;FLATMEM 平坦内存模型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用一个数组来组织这些连续的物理内存页 struct page 结构，其在数组中对应的下标即为 PFN 。这种内存模型就叫做平坦内存模型 FLATMEM 。
&lt;img src=&#34;https://cdn.xiaolincoding.com//mysql/other/89fe28d0feb1cd31cbaad5352e1f43d9.png&#34; style=&#34;zoom:50%;&#34; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DISCONTIGMEM 非连续内存模型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;FLATMEM 平坦内存模型只适合管理一整块连续的物理内存，而对于多块非连续的物理内存来说使用 FLATMEM 平坦内存模型进行管理则会造成很大的内存空间浪费。&lt;/p&gt;
&lt;p&gt;因为 FLATMEM 平坦内存模型是利用 mem_map 这样一个全局数组来组织这些被划分出来的物理页 page 的，而对于物理内存存在大量不连续的内存地址区间这种情况时，这些不连续的内存地址区间就形成了内存空洞。&lt;/p&gt;
&lt;p&gt;由于用于组织物理页的底层数据结构是 mem_map 数组，数组的特性又要求这些物理页是连续的，所以只能为这些内存地址空洞也分配 struct page 结构用来填充数组使其连续。&lt;/p&gt;
&lt;p&gt;而每个 struct page 结构大部分情况下需要占用 40 字节（struct page 结构在不同场景下内存占用会有所不同，这一点我们后面再说），如果物理内存中存在的大块的地址空洞，那么为这些空洞而分配的 struct page 将会占用大量的内存空间，导致巨大的浪费。&lt;/p&gt;
&lt;p&gt;在 DISCONTIGMEM 非连续内存模型中，内核将物理内存从宏观上划分成了一个一个的节点 node （微观上还是一页一页的物理页），每个 node 节点管理一块连续的物理内存。这样一来这些连续的物理内存页均被划归到了对应的 node 节点中管理，就避免了内存空洞造成的空间浪费。&lt;/p&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com//mysql/other/ae106d5d780328aae34d40560dc0442f.png&#34; style=&#34;zoom:50%;&#34; /&gt;
 DISCONTIGMEM 非连续内存模型其实就是 FLATMEM 平坦内存模型的一种扩展，在面对大块不连续的物理内存管理时，通过将每段连续的物理内存区间划归到 node 节点中进行管理，避免了为内存地址空洞分配 struct page 结构，从而节省了内存资源的开销。
&lt;blockquote&gt;
&lt;p&gt;SPARSEMEM 稀疏内存模型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;随着内存技术的发展，内核可以支持物理内存的热插拔了（后面我会介绍），这样一来物理内存的不连续就变为常态了，在上小节介绍的 DISCONTIGMEM 内存模型中，其实每个 node 中的物理内存也不一定都是连续的。&lt;/p&gt;
&lt;p&gt;SPARSEMEM 稀疏内存模型的核心思想就是对粒度更小的连续内存块进行精细的管理，用于管理连续内存块的单元被称作 section 。物理页大小为 4k 的情况下， section 的大小为 128M ，物理页大小为 16k 的情况下， section 的大小为 512M。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com//mysql/other/e3956ea9e4dab708d57c7c183c6b91d6.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在 SPARSEMEM 稀疏内存模型下 page_to_pfn 与 pfn_to_page 的计算逻辑又发生了变化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 page_to_pfn 的转换中，首先需要通过 page_to_section 根据 struct page 结构定位到 mem_section 数组中具体的 section 结构。然后在通过 section_mem_map 定位到具体的 PFN。&lt;/li&gt;
&lt;li&gt;在 pfn_to_page 的转换中，首先需要通过 __pfn_to_section 根据 PFN 定位到 mem_section 数组中具体的 section 结构。然后在通过 PFN 在 section_mem_map 数组中定位到具体的物理页 Page 。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;物理内存热插拔&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;内核引入了 SPARSEMEM 稀疏内存模型以便应对这种情况，提供对更小粒度的连续物理内存的灵活管理能力。&lt;/p&gt;
&lt;p&gt;集群的规模一大，那么物理内存出故障的几率也会大大增加，物理内存的热插拔对提供集群高可用性也是至关重要的。&lt;/p&gt;
&lt;p&gt;从总体上来讲，内存的热插拔分为两个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;物理热插拔阶段：这个阶段主要是从物理上将内存硬件插入（hot-add），拔出（hot-remove）主板的过程，其中涉及到硬件和内核的支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逻辑热插拔阶段：这一阶段主要是由内核中的内存管理子系统来负责，涉及到的主要工作为：如何动态的上线启用（online）刚刚 hot-add 的内存，如何动态下线（offline）刚刚 hot-remove 的内存。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个 mem_section 都可以在系统运行时改变 offline ，online 状态，以便支持内存的热插拔功能。 当mem_section offline时, 内核会把这部分内存隔离开, 使得该部分内存不可再被使用, 然后再把mem_section中已经分配的内存页迁移到其他 mem_section 的内存上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;内存的热插拔对进程来说是透明的，迁移后的物理页映射的虚拟内存地址不能变化。&lt;/p&gt;
&lt;p&gt;进程在用户空间访问内存都是根据虚拟内存地址通过页表找到对应的物理内存地址，这些迁移之后的物理页，虽然物理内存地址发生变化，内核通过修改地址之间映射关系，可以保证虚拟内存地址不会改变。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在内核态的虚拟地址空间的直接映射区。直接映射区中的物理页的虚拟地址会随着物理内存地址变动而变动, 因此这部分物理页是无法轻易迁移的。&lt;/p&gt;
&lt;p&gt;内核是如何解决这个头疼的问题呢？&lt;/p&gt;
&lt;p&gt;将内存按照物理页是否可迁移，划分为不可迁移页，可回收页，可迁移页。在可能会被拔出的内存中只分配那些可迁移的内存页，这些信息会在内存初始化的时候被设置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;从 CPU 角度看物理内存架构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;NUMA 节点物理内存区域的划分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们都知道内核对物理内存的管理都是以页为最小单位来管理的，每页默认 4K 大小，理想状况下任何种类的数据都可以存放在任何页框中，没有什么限制。比如：存放内核数据，用户数据，磁盘缓冲数据等。&lt;/p&gt;
&lt;p&gt;但是实际的计算机体系结构受到硬件方面的制约，间接导致限制了页框的使用方式。&lt;/p&gt;
&lt;p&gt;比如在 X86 体系结构下，ISA 总线的 DMA （直接内存存取）控制器，只能对内存的前16M 进行寻址，这就导致了 ISA 设备不能在整个 32 位地址空间中执行 DMA，只能使用物理内存的前 16M 进行 DMA 操作。&lt;/p&gt;
&lt;p&gt;因此直接映射区的前 16M 专门让内核用来为 DMA 分配内存，这块 16M 大小的内存区域我们称之为 ZONE_DMA。&lt;/p&gt;
&lt;p&gt;而直接映射区中剩下的部分也就是从 16M 到 896M（不包含 896M）这段区域，我们称之为 ZONE_NORMAL。从字面意义上我们可以了解到，这块区域包含的就是正常的页框（没有任何使用限制）。&lt;/p&gt;
&lt;p&gt;ZONE_NORMAL 由于也是属于直接映射区的一部分，对应的物理内存 16M 到 896M 这段区域也是被直接映射至内核态虚拟内存空间中的 3G + 16M 到 3G + 896M 这段虚拟内存上。&lt;/p&gt;
&lt;p&gt;而物理内存 896M 以上的区域被内核划分为 ZONE_HIGHMEM 区域，我们称之为高端内存。&lt;/p&gt;
&lt;p&gt;由于内核虚拟内存空间中的前 896M 虚拟内存已经被直接映射区所占用，而在 32 体系结构下内核虚拟内存空间总共也就 1G 的大小，这样一来内核剩余可用的虚拟内存空间就变为了 1G - 896M = 128M。&lt;/p&gt;
&lt;p&gt;显然物理内存中剩下的这 3200M 大小的 ZONE_HIGHMEM 区域无法继续通过直接映射的方式映射到这 128M 大小的虚拟内存空间中。&lt;/p&gt;
&lt;p&gt;这样一来物理内存中的 ZONE_HIGHMEM 区域就只能采用动态映射的方式映射到 128M 大小的内核虚拟内存空间中，也就是说只能动态的一部分一部分的分批映射，先映射正在使用的这部分，使用完毕解除映射，接着映射其他部分。&lt;/p&gt;
&lt;p&gt;所以内核会根据各个物理内存区域的功能不同，将 NUMA 节点内的物理内存主要划分为以下四个物理内存区域：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;ZONE_DMA：用于那些无法对全部物理内存进行寻址的硬件设备，进行 DMA 时的内存分配。例如前边介绍的 ISA 设备只能对物理内存的前 16M 进行寻址。该区域的长度依赖于具体的处理器类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ZONE_DMA32：与 ZONE_DMA 区域类似，该区域内的物理页面可用于执行 DMA 操作，不同之处在于该区域是提供给 32 位设备（只能寻址 4G 物理内存）执行 DMA 操作时使用的。该区域只在 64 位系统中起作用，因为只有在 64 位系统中才会专门为 32 位设备提供专门的 DMA 区域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ZONE_NORMAL：这个区域的物理页都可以直接映射到内核中的虚拟内存，由于是线性映射，内核可以直接进行访问。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ZONE_HIGHMEM：这个区域包含的物理页就是我们说的高端内存，内核不能直接访问这些物理页，这些物理页需要动态映射进内核虚拟内存空间中（非线性映射）。该区域只在 32 位系统中才会存在，因为 64 位系统中的内核虚拟内存空间太大了（128T），都可以进行直接映射。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;内核中定义的 zone_type 除了上边为大家介绍的四个物理内存区域，又多出了两个区域：ZONE_MOVABLE 和 ZONE_DEVICE。&lt;/p&gt;
&lt;p&gt;ZONE_DEVICE 是为支持热插拔设备而分配的非易失性内存（ Non Volatile Memory ），也可用于内核崩溃时保存相关的调试信息。&lt;/p&gt;
&lt;p&gt;ZONE_MOVABLE 是内核定义的一个&lt;strong&gt;虚拟内存区域&lt;/strong&gt;，该区域中的物理页可以来自于上边介绍的几种真实的物理区域。该区域中的页全部都是可以迁移的，主要是为了防止内存碎片和支持内存的热插拔。
因为随着系统的运行会伴随着不同大小的物理内存页的分配和释放，这种内存不规则的分配释放随着系统的长时间运行就会导致内存碎片，内存碎片会使得系统在明明有足够内存的情况下，依然无法为进程分配合适的内存。
如果这些物理页处于 ZONE_MOVABLE 区域，它们就可以被迁移，内核可以通过迁移页面来避免内存碎片的问题。
内核通过迁移页面来规整内存，这样就可以避免内存碎片，从而得到一大片连续的物理内存，以满足内核对大块连续内存分配的请求。&lt;strong&gt;所以这就是内核需要根据物理页面是否能够迁移的特性，而划分出 ZONE_MOVABLE 区域的目的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;事实上只有第一个 NUMA 节点可以包含所有的物理内存区域，其它的节点并不能包含所有的区域类型，因为有些内存区域比如：ZONE_DMA，ZONE_DMA32 必须从物理内存的起点开始。这些在物理内存开始的区域可能已经被划分到第一个 NUMA 节点了，后面的物理内存才会被依次划分给接下来的 NUMA 节点。因此后面的 NUMA 节点并不会包含 ZONE_DMA，ZONE_DMA32 区域。
ZONE_NORMAL、ZONE_HIGHMEM 和 ZONE_MOVABLE 是可以出现在所有 NUMA 节点上的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;物理内存区域中的水位线&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;内存资源是系统中最宝贵的系统资源，是有限的。当内存资源紧张的时候，系统的应对方法无非就是三种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;产生 OOM，内核直接将系统中占用大量内存的进程，将 OOM 优先级最高的进程干掉，释放出这个进程占用的内存供其他更需要的进程分配使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存回收，将不经常使用到的内存回收，腾挪出来的内存供更需要的进程分配使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存规整，将可迁移的物理页面进行迁移规整，消除内存碎片。从而获得更大的一片连续物理内存空间供进程分配。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;内核会为每个 NUMA 节点中的每个物理内存区域定制三条用于指示内存容量的水位线，分别是：WMARK_MIN（页最小阈值）， WMARK_LOW （页低阈值），WMARK_HIGH（页高阈值）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当该物理内存区域的剩余内存容量高于 _watermark[WMARK_HIGH] 时，说明此时该物理内存区域中的内存容量非常充足，内存分配完全没有压力。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当剩余内存容量在 _watermark[WMARK_LOW] 与_watermark[WMARK_HIGH] 之间时，说明此时内存有一定的消耗但是还可以接受，能够继续满足进程的内存分配需求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当剩余内容容量在 _watermark[WMARK_MIN] 与 _watermark[WMARK_LOW] 之间时，说明此时内存容量已经有点危险了，内存分配面临一定的压力，但是还可以满足进程的内存分配要求，当给进程分配完内存之后，就会唤醒 kswapd 进程开始内存回收，直到剩余内存高于 _watermark[WMARK_HIGH] 为止。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在这种情况下，进程的内存分配会触发内存回收，但请求进程本身不会被阻塞，由内核的 kswapd 进程异步回收内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;当剩余内容容量低于 _watermark[WMARK_MIN] 时，说明此时的内容容量已经非常危险了，如果进程在这时请求内存分配，内核就会进行&lt;strong&gt;直接内存回收&lt;/strong&gt;，这时请求进程会同步阻塞等待，直到内存回收完毕。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;27-内核如何描述物理内存页&#34;&gt;2.7 内核如何描述物理内存页
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com//mysql/other/bba0c0b540cbfcbbb709077d2a22ee3d-20230309235827777.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;经过前边几个小节的介绍，我想大家现在应该对 Linux 内核整个内存管理框架有了一个总体上的认识。&lt;/p&gt;
&lt;p&gt;如上图所示，在 NUMA 架构下内存被划分成了一个一个的内存节点（NUMA Node），在每个 NUMA 节点中，内核又根据节点内物理内存的功能用途不同，将 NUMA 节点内的物理内存划分为四个物理内存区域分别是：ZONE_DMA，ZONE_DMA32，ZONE_NORMAL，ZONE_HIGHMEM。其中 ZONE_MOVABLE 区域是逻辑上的划分，主要是为了防止内存碎片和支持内存的热插拔。&lt;/p&gt;
&lt;p&gt;物理内存区域中管理的就是物理内存页（ Linux 内存管理的最小单位），前面我们介绍的内核对物理内存的换入，换出，回收，内存映射等操作的单位就是页。内核为每一个物理内存区域分配了一个伙伴系统，用于管理该物理内存区域下所有物理内存页面的分配和释放。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;匿名页的反向映射&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们通常所说的内存映射是正向映射，即从虚拟内存到物理内存的映射。而&lt;strong&gt;反向映射则是从物理内存到虚拟内存的映射&lt;/strong&gt;，用于当某个物理内存页需要进行回收或迁移时，此时需要去找到这个物理页被映射到了哪些进程的虚拟地址空间中，并断开它们之间的映射。&lt;/p&gt;
&lt;p&gt;在没有反向映射的机制前，需要去遍历所有进程的虚拟地址空间中的映射页表，这个效率显然是很低下的。&lt;strong&gt;有了反向映射机制之后内核就可以直接找到该物理内存页到所有进程映射的虚拟地址空间 VMA ，并从 VMA 使用的进程页表中取消映射&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当进程开始访问这段虚拟内存时，内核会产生缺页中断，在缺页中断处理函数中才会去真正的分配物理内存（这时才会为子进程创建自己的 anon_vma 和 anon_vma_chain），并建立虚拟内存与物理内存之间的映射关系（正向映射）。&lt;/p&gt;
&lt;p&gt;每个匿名页对应唯一的 anon_vma 结构，但是一个匿名物理页可以映射到不同进程的虚拟内存空间中，每个进程的虚拟内存空间都是独立的，也就是说不同的进程就会有不同的 VMA。&lt;/p&gt;
&lt;p&gt;不同的 VMA 意味着同一个匿名页 anon_vma 就会对应多个 anon_vma_chain。那么如何通过一个 anon_vma 找到和他关联的所有 anon_vma_chain 呢？找到了这些 anon_vma_chain 也就意味着 struct page 找到了与它关联的所有进程虚拟内存空间 VMA。
struct anon_vma 结构中管理了一颗红黑树，这颗红黑树上管理的全部都是与该 anon_vma 关联的 anon_vma_chain。我们可以通过 struct page 中的 mapping 指针找到 anon_vma，然后遍历 anon_vma 中的这颗红黑树 rb_root ，从而找到与其关联的所有 anon_vma_chain。&lt;/p&gt;
&lt;p&gt;vm_area_struct 表示的只是进程虚拟内存空间中的一段虚拟内存区域，这块虚拟内存区域中可能会包含多个匿名页，所以 VMA 与物理内存页 page 也是有一对多的映射关系存在。&lt;/p&gt;
&lt;h2 id=&#34;三进程管理&#34;&gt;三、进程管理
&lt;/h2&gt;&lt;h3 id=&#34;1-进程-线程&#34;&gt;1. 进程 线程
&lt;/h3&gt;&lt;p&gt;并发：**多个程序、交替执行。**单核的 CPU 在某一个瞬间，只能运行一个进程。但在 1 秒钟期间，运行多个进程。&lt;/p&gt;
&lt;h4 id=&#34;11-进程的状态&#34;&gt;1.1 进程的状态
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;在一个进程的活动期间至少具备三种基本状态，即运行状态、就绪状态、阻塞状态。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行状态（&lt;em&gt;Running&lt;/em&gt;）：该时刻进程占用 CPU；&lt;/li&gt;
&lt;li&gt;就绪状态（&lt;em&gt;Ready&lt;/em&gt;）：可运行，由于其他进程处于运行状态而暂时停止运行；&lt;/li&gt;
&lt;li&gt;阻塞状态（&lt;em&gt;Blocked&lt;/em&gt;）：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建状态（&lt;em&gt;new&lt;/em&gt;）：进程正在被创建时的状态；&lt;/li&gt;
&lt;li&gt;结束状态（&lt;em&gt;Exit&lt;/em&gt;）：进程正在从系统中消失时的状态；&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/8-%E8%BF%9B%E7%A8%8B%E4%BA%94%E4%B8%AA%E7%8A%B6%E6%80%81.jpg&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；&lt;/li&gt;
&lt;li&gt;就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行；&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/10-%E8%BF%9B%E7%A8%8B%E4%B8%83%E4%B8%AD%E7%8A%B6%E6%80%81.jpg&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h4 id=&#34;12-进程控制块&#34;&gt;1.2 进程控制块
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;PCB 是进程存在的唯一标识。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PCB 具体包含的信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;进程描述信息：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；&lt;/li&gt;
&lt;li&gt;用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进程控制和管理信息：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程当前状态，如 new、ready、running、waiting 或 blocked 等；&lt;/li&gt;
&lt;li&gt;进程优先级：进程抢占 CPU 时的优先级；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;资源分配清单：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;CPU 相关信息：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;PCB 是如何组织的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过&lt;strong&gt;链表&lt;/strong&gt;的方式进行组织，把具有&lt;strong&gt;相同状态的进程链在一起，组成各种队列&lt;/strong&gt;。比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将所有处于就绪状态的进程链在一起，称为&lt;strong&gt;就绪队列&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;把所有因等待某事件而处于等待状态的进程链在一起就组成各种&lt;strong&gt;阻塞队列&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;13-进程的上下文切换&#34;&gt;1.3 进程的上下文切换
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;一个进程切换到另一个进程运行，称为进程的上下文切换&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU 上下文&lt;/strong&gt;：CPU &lt;strong&gt;寄存器&lt;/strong&gt;和&lt;strong&gt;程序计数器&lt;/strong&gt;是 CPU 在运行任何任务前，所必须依赖的环境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU 上下文切换&lt;/strong&gt;：先把前一个任务的 CPU 上下文（CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。&lt;/p&gt;
&lt;p&gt;根据任务的不同，把 CPU 上下文切换分成：&lt;strong&gt;进程上下文切换、线程上下文切换和中断上下文切换&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;进程的上下文切换&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进程是由内核管理和调度的，进程的切换只能发生在内核态。&lt;/p&gt;
&lt;p&gt;**进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。**包括了所有与进程执行状态相关的信息&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;寄存器、程序计数器&lt;/li&gt;
&lt;li&gt;进程控制块、栈、内存页表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行&lt;/p&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/13-%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2.jpg&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;blockquote&gt;
&lt;p&gt;进程上下文切换有哪些场景？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的&lt;strong&gt;时间片耗尽&lt;/strong&gt;了，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行；&lt;/li&gt;
&lt;li&gt;进程在&lt;strong&gt;系统资源不足&lt;/strong&gt;（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行；&lt;/li&gt;
&lt;li&gt;当进程通过&lt;strong&gt;睡眠函数 sleep 这样的方法将自己主动挂起&lt;/strong&gt;时，自然也会重新调度；&lt;/li&gt;
&lt;li&gt;当有&lt;strong&gt;优先级更高的进程运行&lt;/strong&gt;时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行；&lt;/li&gt;
&lt;li&gt;发生&lt;strong&gt;硬件中断&lt;/strong&gt;时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;14-线程&#34;&gt;1.4 线程
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;线程是进程当中的一条执行流程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;线程的优缺点？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;线程的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个进程中可以同时存在多个线程；&lt;/li&gt;
&lt;li&gt;各个线程之间可以并发执行；&lt;/li&gt;
&lt;li&gt;各个线程之间可以共享地址空间和文件等资源；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线程的缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（针对 C/C++ 语言）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例子，对于游戏的用户设计，不应该使用多线程的方式，否则一个用户挂了，会影响其他同个进程的线程。&lt;/p&gt;
&lt;h4 id=&#34;15-线程与进程的区别&#34;&gt;1.5 线程与进程的区别
&lt;/h4&gt;&lt;p&gt;线程与进程的比较如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程是资源分配的单位，线程是 CPU 调度的单位；&lt;/li&gt;
&lt;li&gt;进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；&lt;/li&gt;
&lt;li&gt;线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；&lt;/li&gt;
&lt;li&gt;线程能减少并发执行的时间和空间开销；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于，线程相比进程能减少开销，体现在：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程的创建时间比进程快。线程共享资源管理信息；&lt;/li&gt;
&lt;li&gt;线程的终止时间比进程快。线程释放的资源相比进程少很多；&lt;/li&gt;
&lt;li&gt;同一个进程内的线程切换比进程切换快，同一个进程的线程都具有同一个页表，在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；&lt;/li&gt;
&lt;li&gt;由于同一进程的各线程间共享内存和文件资源，在线程之间数据传递不需要经过内核了，数据交互效率更高；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;16-线程的上下文切换&#34;&gt;1.6 线程的上下文切换
&lt;/h4&gt;&lt;p&gt;当进程拥有多个线程时，这些线程会&lt;strong&gt;共享相同的虚拟内存和全局变量&lt;/strong&gt;等资源，这些资源在上下文切换时是不需要修改的；&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;线程上下文切换的是什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这还得看线程是不是属于同一个进程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线程的上下文切换相比进程，开销要小很多。&lt;/p&gt;
&lt;h4 id=&#34;17-线程的实现&#34;&gt;1.7 线程的实现
&lt;/h4&gt;&lt;p&gt;三种线程的实现方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用户线程&lt;/strong&gt;：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内核线程&lt;/strong&gt;：在内核中实现的线程，是由内核管理的线程；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;轻量级进程&lt;/strong&gt;：在内核中来支持用户线程；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;用户线程和内核线程的对应关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多对一&lt;/strong&gt;。多个用户线程对应同一个内核线程：&lt;/p&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/17-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B-%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB.jpg&#34; style=&#34;zoom: 25%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;一对一&lt;/strong&gt;。一个用户线程对应一个内核线程：&lt;/p&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/18-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B-%E4%B8%80%E5%AF%B9%E4%B8%80%E5%85%B3%E7%B3%BB.jpg&#34; style=&#34;zoom:25%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;多对多&lt;/strong&gt;。多个用户线程对应到多个内核线程：&lt;/p&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/19-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB.jpg&#34; style=&#34;zoom:25%;&#34; /&gt;
&lt;blockquote&gt;
&lt;p&gt;用户线程如何理解？存在什么优势和缺陷？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用户线程是基于用户态的线程管理库来实现的，那么&lt;strong&gt;线程控制块（Thread Control Block, TCB）&lt;/strong&gt; 也是在库里面来实现的，对于操作系统而言是看不到这个 TCB 的，它只能看到整个进程的 PCB。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用户级线程的模型，类似前面提到的&lt;strong&gt;多对一&lt;/strong&gt;的关系，多个用户线程对应同一个内核线程.&lt;/p&gt;
&lt;p&gt;用户线程的&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个进程都需要有它私有的线程控制块（TCB）列表，用来跟踪记录它各个线程状态信息（PC、栈指针、寄存器），TCB 由用户级线程库函数来维护，可用于不支持线程技术的操作系统；&lt;/li&gt;
&lt;li&gt;用户线程的切换也是由线程库函数来完成的，无需用户态与内核态的切换，所以速度特别快；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用户线程的&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于操作系统不参与线程的调度，如果一个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行了。&lt;/li&gt;
&lt;li&gt;当一个线程开始运行后，除非它主动地交出 CPU 的使用权，否则它所在的进程当中的其他线程无法运行，因为用户态的线程没法打断当前运行中的线程，它没有这个特权，只有操作系统才有，但是用户线程不是由操作系统管理的。&lt;/li&gt;
&lt;li&gt;由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会比较慢；&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;内核线程如何理解？存在什么优势和缺陷？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;内核线程是由操作系统管理的，线程对应的 TCB 自然是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;内核线程的模型，一对一的关系，一个用户线程对应一个内核线程。&lt;/p&gt;
&lt;p&gt;内核线程的&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行；&lt;/li&gt;
&lt;li&gt;分配给线程，多线程的进程获得更多的 CPU 运行时间；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内核线程的&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息，如 PCB 和 TCB；&lt;/li&gt;
&lt;li&gt;线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大；&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;轻量级进程如何理解？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;轻量级进程（Light-weight process，LWP）是内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持，而且 LWP 是由内核管理并像普通进程一样被调度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在大多数系统中，&lt;strong&gt;LWP与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在 LWP 之上也是可以使用用户线程的，那么 LWP 与用户线程的对应关系就有三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 : 1&lt;/code&gt;，即一个 LWP 对应 一个用户线程；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N : 1&lt;/code&gt;，即一个 LWP 对应多个用户线程；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;M : N&lt;/code&gt;，即多个 LWP 对应多个用户线程；&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/22-LWP.jpg&#34; style=&#34;zoom:25%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;1 : 1 模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个线程对应到一个 LWP 再对应到一个内核线程，如上图的进程 4，属于此模型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：实现并行，当一个 LWP 阻塞，不会影响其他 LWP；&lt;/li&gt;
&lt;li&gt;缺点：每一个用户线程，就产生一个内核线程，创建线程的开销较大。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;N : 1 模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多个用户线程对应一个 LWP 再对应一个内核线程，如上图的进程 2，线程管理是在用户空间完成的，此模式中用户的线程对操作系统不可见。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：用户线程要开几个都没问题，且上下文切换发生用户空间，切换的效率较高；&lt;/li&gt;
&lt;li&gt;缺点：一个用户线程如果阻塞了，则整个进程都将会阻塞，另外在多核 CPU 中，是没办法充分利用 CPU 的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;M : N 模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据前面的两个模型混搭一起，就形成 &lt;code&gt;M:N&lt;/code&gt; 模型，该模型提供了两级控制，首先多个用户线程对应到多个 LWP，LWP 再一一对应到内核线程，如上图的进程 3。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：综合了前两种优点，大部分的线程上下文发生在用户空间，且多个线程又可以充分利用多核 CPU 的资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;18-进程调度&#34;&gt;1.8 进程调度
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;调度时机&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进程从一个运行状态到另外一状态变化时，会触发一次调度。&lt;/p&gt;
&lt;p&gt;比如，以下状态的变化都会触发操作系统的调度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;从就绪态 -&amp;gt; 运行态&lt;/em&gt;：当进程被创建时，会进入到就绪队列，操作系统会从就绪队列选择一个进程运行；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;从运行态 -&amp;gt; 阻塞态&lt;/em&gt;：当进程发生 I/O 事件而阻塞时，操作系统必须选择另外一个进程运行；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;从运行态 -&amp;gt; 结束态&lt;/em&gt;：当进程退出结束后，操作系统得从就绪队列选择另外一个进程运行；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为，这些状态变化的时候，操作系统需要考虑是否要让新的进程给 CPU 运行，或者是否让当前进程从 CPU 上退出来而换另一个进程运行。&lt;/p&gt;
&lt;p&gt;如果硬件时钟提供某个频率的周期性中断，那么可以根据如何处理时钟中断 ，把调度算法分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;非抢占式调度算法&lt;/strong&gt;挑选一个进程，然后让该进程运行直到被阻塞，或者&lt;strong&gt;直到该进程退出，才会调用另外一个进程&lt;/strong&gt;，也就是说不会理时钟中断这个事情。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;抢占式调度算法&lt;/strong&gt;挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生&lt;strong&gt;时钟中断&lt;/strong&gt;，以便把 CPU 控制返回给调度程序进行调度，也就是常说的&lt;strong&gt;时间片机制&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;调度原则&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CPU 利用率&lt;/strong&gt;：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统吞吐量&lt;/strong&gt;：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;周转时间&lt;/strong&gt;：周转时间是进程运行+阻塞时间+等待时间的总和，一个进程的周转时间越小越好；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;等待时间&lt;/strong&gt;：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;响应时间&lt;/strong&gt;：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;调度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;strong&gt;单核 CPU 系统&lt;/strong&gt;中常见的调度算法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;01 先来先服务调度算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;非抢占式的&lt;strong&gt;先来先服务（First Come First Serve, FCFS）算法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;先来后到，&lt;strong&gt;每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当一个长作业先运行了，后面的短作业等待的时间就会很长，不利于短作业。&lt;/p&gt;
&lt;p&gt;FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I/O 繁忙型作业的系统。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;02 最短作业优先调度算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;最短作业优先（Shortest Job First, SJF）调度算法&lt;/strong&gt;同样也是顾名思义，它会&lt;strong&gt;优先选择运行时间最短的进程来运行&lt;/strong&gt;，这有助于提高系统的吞吐量。&lt;/p&gt;
&lt;p&gt;对长作业不利，很容易造成一种极端现象。一个长作业在就绪队列等待运行，就绪队列有非常多的短作业，就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;03 高响应比优先调度算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;「先来先服务调度算法」和「最短作业优先调度算法」都没有很好的权衡短作业和长作业。&lt;/p&gt;
&lt;p&gt;那么，&lt;strong&gt;高响应比优先 （\Highest Response Ratio Next, HRRN）调度算法&lt;/strong&gt;主要是权衡了短作业和长作业。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行&lt;/strong&gt;，「响应比优先级」的计算公式：&lt;/p&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/26-%E5%93%8D%E5%BA%94%E6%AF%94%E5%85%AC%E5%BC%8F.jpg&#34; style=&#34;zoom: 50%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;如果两个进程的「等待时间」相同时，「要求的服务时间」越短，「响应比」就越高，这样短作业的进程容易被选中运行；&lt;/li&gt;
&lt;li&gt;如果两个进程「要求的服务时间」相同时，「等待时间」越长，「响应比」就越高，这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进程要求服务的时间是不可预知的。所以，高响应比优先调度算法是「理想型」的调度算法，现实中是实现不了的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;04 时间片轮转调度算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最古老、最简单、最公平且使用最广的算法就是&lt;strong&gt;时间片轮转（Round Robin, RR）调度算法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每个进程被分配一个时间段，称为时间片（Quantum），即允许该进程在该时间段中运行。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配给另外一个进程；&lt;/li&gt;
&lt;li&gt;如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，时间片的长度就是一个很关键的点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；&lt;/li&gt;
&lt;li&gt;如果设得太长又可能引起对短作业进程的响应时间变长。将&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般来说，时间片设为 &lt;code&gt;20ms~50ms&lt;/code&gt; 通常是一个比较合理的折中值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;05 最高优先级调度算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（Highest Priority First，HPF）调度算法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;进程的优先级可以分为，静态优先级和动态优先级：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；&lt;/li&gt;
&lt;li&gt;动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是&lt;strong&gt;随着时间的推移增加等待进程的优先级&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该算法也有两种处理优先级高的方法，非抢占式和抢占式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。&lt;/li&gt;
&lt;li&gt;抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点。可能会导致低优先级的进程永远不会运行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;06 多级反馈队列调度算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;多级反馈队列（Multilevel Feedback Queue）调度算法&lt;/strong&gt;是「时间片轮转算法」和「最高优先级算法」的综合和发展。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。&lt;/li&gt;
&lt;li&gt;「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/28-%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97.jpg&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;设置了多个队列，赋予每个队列不同的优先级，每个&lt;strong&gt;队列优先级从高到低&lt;/strong&gt;，同时&lt;strong&gt;优先级越高时间片越短&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；&lt;/li&gt;
&lt;li&gt;当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也变更长了，所以该算法很好的&lt;strong&gt;兼顾了长短作业，同时有较好的响应时间。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-进程间的通信方式&#34;&gt;2. 进程间的通信方式？
&lt;/h3&gt;&lt;p&gt;每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。&lt;/p&gt;
&lt;h4 id=&#34;21-管道&#34;&gt;2.1 管道
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;管道传输数据是单向的&lt;/strong&gt;，如果想相互通信，我们需要创建两个管道才行。
进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循&lt;strong&gt;先进先出&lt;/strong&gt;原则，不支持 lseek 之类的文件定位操作。
&lt;strong&gt;匿名管道，它的通信范围是存在父子关系的进程&lt;/strong&gt;。
&lt;strong&gt;命名管道，它可以在不相关的进程间也能相互通信&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;管道这种通信方式效率低，不适合进程间频繁地交换数据&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;22-消息队列&#34;&gt;2.2 消息队列
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;消息队列是保存在内核中的消息链表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消息队列生命周期随内核&lt;/strong&gt;，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在。&lt;/p&gt;
&lt;p&gt;不足的地方有两点，&lt;strong&gt;一是通信不及时，二是附件也有大小限制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消息队列不适合比较大数据的传输&lt;/strong&gt;，因为在内核中每个消息体都有一个最大长度的限制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销&lt;/strong&gt;，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。&lt;/p&gt;
&lt;h4 id=&#34;23-共享内存&#34;&gt;2.3 共享内存
&lt;/h4&gt;&lt;p&gt;消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那&lt;strong&gt;共享内存&lt;/strong&gt;的方式，就很好的解决了这一问题。
&lt;strong&gt;共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中&lt;/strong&gt;。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。
用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。&lt;strong&gt;需要互斥访问。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;24-信号量&#34;&gt;2.4 信号量
&lt;/h4&gt;&lt;p&gt;为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，&lt;strong&gt;信号量&lt;/strong&gt;就实现了这一保护机制。
&lt;strong&gt;信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据&lt;/strong&gt;。
信号量表示资源的数量，控制信号量的方式有两种原子操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个是 &lt;strong&gt;P 操作&lt;/strong&gt;，这个操作会把信号量减去 1，相减后如果信号量 &amp;lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &amp;gt;= 0，则表明还有资源可使用，进程可正常继续执行。&lt;/li&gt;
&lt;li&gt;另一个是 &lt;strong&gt;V 操作&lt;/strong&gt;，这个操作会把信号量加上 1，相加后如果信号量 &amp;lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &amp;gt; 0，则表明当前没有阻塞中的进程；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。&lt;/p&gt;
&lt;p&gt;信号初始化为 &lt;code&gt;1&lt;/code&gt;，就代表着是&lt;strong&gt;互斥信号量&lt;/strong&gt;，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。
信号初始化为 &lt;code&gt;0&lt;/code&gt;，就代表着是&lt;strong&gt;同步信号量&lt;/strong&gt;，它可以保证进程 A 应在进程 B 之前执行。&lt;/p&gt;
&lt;h4 id=&#34;25-信号&#34;&gt;2.5 信号
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。&lt;/p&gt;
&lt;p&gt;信号是进程间通信机制中&lt;strong&gt;唯一的异步通信机制&lt;/strong&gt;，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.执行默认操作&lt;/strong&gt;。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.捕捉信号&lt;/strong&gt;。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.忽略信号&lt;/strong&gt;。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 &lt;code&gt;SIGKILL&lt;/code&gt; 和 &lt;code&gt;SEGSTOP&lt;/code&gt;，它们用于在任何时候中断或结束某一进程。&lt;/p&gt;
&lt;h4 id=&#34;26-socket&#34;&gt;2.6 Socket
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。&lt;/p&gt;
&lt;p&gt;根据创建 socket 类型的不同，通信的方式也就不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现 TCP 字节流通信： socket 类型是 AF_INET 和 SOCK_STREAM；&lt;/li&gt;
&lt;li&gt;实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；&lt;/li&gt;
&lt;li&gt;实现本地进程间通信： 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;针对 TCP 协议通信的 socket 编程模型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/12-TCP%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务端和客户端初始化 &lt;code&gt;socket&lt;/code&gt;，得到文件描述符；&lt;/li&gt;
&lt;li&gt;服务端调用 &lt;code&gt;bind&lt;/code&gt;，将绑定在 IP 地址和端口;&lt;/li&gt;
&lt;li&gt;服务端调用 &lt;code&gt;listen&lt;/code&gt;，进行监听；&lt;/li&gt;
&lt;li&gt;服务端调用 &lt;code&gt;accept&lt;/code&gt;，等待客户端连接；&lt;/li&gt;
&lt;li&gt;客户端调用 &lt;code&gt;connect&lt;/code&gt;，向服务器端的地址和端口发起连接请求；&lt;/li&gt;
&lt;li&gt;服务端 &lt;code&gt;accept&lt;/code&gt; 返回用于传输的 &lt;code&gt;socket&lt;/code&gt; 的文件描述符；&lt;/li&gt;
&lt;li&gt;客户端调用 &lt;code&gt;write&lt;/code&gt; 写入数据；服务端调用 &lt;code&gt;read&lt;/code&gt;读取数据；&lt;/li&gt;
&lt;li&gt;客户端断开连接时，会调用 &lt;code&gt;close&lt;/code&gt;，那么服务端 &lt;code&gt;read&lt;/code&gt; 读取数据的时候，就会读取到了 &lt;code&gt;EOF&lt;/code&gt;，待处理完数据后，服务端调用 &lt;code&gt;close&lt;/code&gt;，表示连接关闭。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;服务端调用 &lt;code&gt;accept&lt;/code&gt; 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。&lt;/p&gt;
&lt;p&gt;监听的 socket 和真正用来传送数据的 socket，是「&lt;strong&gt;两个&lt;/strong&gt;」 socket，一个叫作&lt;strong&gt;监听 socket&lt;/strong&gt;，一个叫作&lt;strong&gt;已完成连接 socket&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;针对 UDP 协议通信的 socket 编程模型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/13-UDP%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。&lt;/p&gt;
&lt;p&gt;对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。&lt;/p&gt;
&lt;p&gt;另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;针对本地进程间通信的 socket 编程模型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本地 socket 被用于在&lt;strong&gt;同一台主机上进程间通信&lt;/strong&gt;的场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本地 socket 的编程接口和 IPv4 、IPv6 套接字编程接口是一致的，可以支持「字节流」和「数据报」两种协议；&lt;/li&gt;
&lt;li&gt;本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是&lt;strong&gt;绑定一个本地文件&lt;/strong&gt;，这也就是它们之间的最大区别。&lt;/p&gt;
&lt;h3 id=&#34;3-线程冲突&#34;&gt;3. 线程冲突
&lt;/h3&gt;&lt;p&gt;在单核 CPU 系统里，为了实现多个程序同时运行的假象，操作系统通常以时间片调度的方式，让每个进程执行每次执行一个时间片，时间片用完了，就切换下一个进程运行，由于这个时间片的时间很短，于是就造成了「并发」的现象。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;互斥&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;两个线程分别对i++，加10000次，但结果是15173。
&lt;strong&gt;上面的情况称为竞争条件（&lt;em&gt;race condition&lt;/em&gt;）&lt;/strong&gt;，当多线程相互竞争操作共享变量时，由于运气不好，即在执行过程中发生了上下文切换，我们得到了错误的结果，事实上，每次运行都可能得到不同的结果，因此输出的结果存在&lt;strong&gt;不确定性（&lt;em&gt;indeterminate&lt;/em&gt;）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;由于多线程执行操作共享变量的这段代码可能会导致竞争状态，因此我们将此段代码称为&lt;strong&gt;临界区（&lt;em&gt;critical section&lt;/em&gt;），它是访问共享资源的代码片段，一定不能给多线程同时执行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们希望这段代码是&lt;strong&gt;互斥的，也就说保证一个线程在临界区执行时，其他线程应该被阻止进入临界区&lt;/strong&gt;，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;同步&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;所谓同步，就是并发进程/线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程/线程同步&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;同步与互斥是两种不同的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步就好比：「操作 A 应在操作 B 之前执行」，「操作 C 必须在操作 A 和操作 B 都完成之后才能执行」等；&lt;/li&gt;
&lt;li&gt;互斥就好比：「操作 A 和操作 B 不能在同一时刻执行」；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;31-互斥与同步的实现和使用&#34;&gt;3.1 互斥与同步的实现和使用
&lt;/h4&gt;&lt;p&gt;为了实现进程/线程间正确的协作，操作系统必须提供实现进程协作的措施和方法，主要的方法有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;锁&lt;/em&gt;：加锁、解锁操作；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;信号量&lt;/em&gt;：P、V 操作；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个都可以方便地实现进程/线程互斥，而信号量比锁的功能更强一些，它还可以方便地实现进程/线程同步。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;锁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用加锁操作和解锁操作可以解决并发线程/进程的互斥问题。
任何想进入临界区的线程，必须先执行加锁操作。若加锁操作顺利通过，则线程可进入临界区；在完成对临界资源的访问后再执行解锁操作，以释放该临界资源。&lt;/p&gt;
&lt;p&gt;根据锁的实现不同，可以分为「忙等待锁」和「无忙等待锁」。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们先来看看「忙等待锁」的实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现代 CPU 体系结构提供的特殊&lt;strong&gt;原子操作指令 —— 测试和置位（&lt;em&gt;Test-and-Set&lt;/em&gt;）指令&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果用 C 代码表示 Test-and-Set 指令，形式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/13-TestAndSet.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;测试并设置指令做了下述事情:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把 &lt;code&gt;old_ptr&lt;/code&gt; 更新为 &lt;code&gt;new&lt;/code&gt; 的新值&lt;/li&gt;
&lt;li&gt;返回 &lt;code&gt;old_ptr&lt;/code&gt; 的旧值；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;关键是这些代码是原子执行&lt;/strong&gt;。因为既可以测试旧值，又可以设置新值，所以我们把这条指令叫作「测试并设置」。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原子操作就是要么全部执行，要么都不执行，不能出现执行到一半的中间状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以运用 Test-and-Set 指令来实现「忙等待锁」&lt;/p&gt;
&lt;p&gt;很明显，当获取不到锁时，线程就会一直 while 循环，不做任何事情，所以就被称为「忙等待锁」，也被称为&lt;strong&gt;自旋锁（&lt;em&gt;spin lock&lt;/em&gt;）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这是最简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。在单处理器上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;再来看看「无等待锁」的实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;无等待锁顾明思议就是获取不到锁的时候，不用自旋。&lt;/p&gt;
&lt;p&gt;既然不想自旋，那当没获取到锁的时候，就把当前线程放入到锁的等待队列，然后执行调度程序，把 CPU 让给其他线程执行。&lt;/p&gt;
&lt;h4 id=&#34;32-信号量&#34;&gt;3.2 信号量
&lt;/h4&gt;&lt;p&gt;信号量是操作系统提供的一种协调共享资源访问的方法。&lt;/p&gt;
&lt;p&gt;通常&lt;strong&gt;信号量表示资源的数量&lt;/strong&gt;，对应的变量是一个整型（&lt;code&gt;sem&lt;/code&gt;）变量。&lt;/p&gt;
&lt;p&gt;另外，还有&lt;strong&gt;两个原子操作的系统调用函数来控制信号量的&lt;/strong&gt;，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;P 操作&lt;/em&gt;：将 &lt;code&gt;sem&lt;/code&gt; 减 &lt;code&gt;1&lt;/code&gt;，相减后，如果 &lt;code&gt;sem &amp;lt; 0&lt;/code&gt;，则进程/线程进入阻塞等待，否则继续，表明 P 操作可能会阻塞；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;V 操作&lt;/em&gt;：将 &lt;code&gt;sem&lt;/code&gt; 加 &lt;code&gt;1&lt;/code&gt;，相加后，如果 &lt;code&gt;sem &amp;lt;= 0&lt;/code&gt;，唤醒一个等待中的进程/线程，表明 V 操作不会阻塞；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;信号量不仅可以实现临界区的&lt;strong&gt;互斥访问控制&lt;/strong&gt;，还可以线程间的事件&lt;strong&gt;同步&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;信号量实现临界区的互斥访问&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为每类共享资源设置一个信号量 &lt;code&gt;s&lt;/code&gt;，其初值为 &lt;code&gt;1&lt;/code&gt;，表示该临界资源未被占用。&lt;/p&gt;
&lt;p&gt;只要把进入临界区的操作置于 &lt;code&gt;P(s)&lt;/code&gt; 和 &lt;code&gt;V(s)&lt;/code&gt; 之间，即可实现进程/线程互斥：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;信号量实现事件同步&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;同步的方式是设置一个信号量，其初值为 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;33-生产者-消费者问题&#34;&gt;3.3 生产者-消费者问题
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f/%e4%ba%92%e6%96%a5%e4%b8%8e%e5%90%8c%e6%ad%a5/20-%e7%94%9f%e4%ba%a7%e8%80%85%e6%b6%88%e8%b4%b9%e8%80%85.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;生产者-消费者模型&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;生产者-消费者问题描述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;生产者&lt;/strong&gt;在生成数据后，放在一个缓冲区中；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消费者&lt;/strong&gt;从缓冲区取出数据处理；&lt;/li&gt;
&lt;li&gt;任何时刻，&lt;strong&gt;只能有一个&lt;/strong&gt;生产者或消费者可以访问缓冲区；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们对问题分析可以得出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任何时刻只能有一个线程操作缓冲区，说明操作缓冲区是临界代码，&lt;strong&gt;需要互斥&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;缓冲区空时，消费者必须等待生产者生成数据；缓冲区满时，生产者必须等待消费者取出数据。说明生产者和消费者&lt;strong&gt;需要同步&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要三个信号量，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥信号量 &lt;code&gt;mutex&lt;/code&gt;：用于互斥访问缓冲区，初始化值为 1；&lt;/li&gt;
&lt;li&gt;资源信号量 &lt;code&gt;fullBuffers&lt;/code&gt;：用于消费者询问缓冲区是否有数据，有数据则读取数据，初始化值为 0（表明缓冲区一开始为空）；&lt;/li&gt;
&lt;li&gt;资源信号量 &lt;code&gt;emptyBuffers&lt;/code&gt;：用于生产者询问缓冲区是否有空位，有空位则生成数据，初始化值为 n （缓冲区大小）；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/21-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;34经典同步问题&#34;&gt;3.4经典同步问题
&lt;/h4&gt;&lt;h5 id=&#34;1-哲学家就餐问题&#34;&gt;1. 哲学家就餐问题
&lt;/h5&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/23-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E6%A8%A1%E5%9E%8B.jpg&#34; style=&#34;zoom:33%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;哲学家要两支叉子才进餐&lt;/strong&gt;。&lt;strong&gt;吃完后，会把两支叉子放回原处，继续思考&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何保证哲学家们的动作有序进行，而不会出现有人永远拿不到叉子呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;方案三&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;让偶数编号的哲学家「先拿左边的叉子后拿右边的叉子」，奇数编号的哲学家「先拿右边的叉子后拿左边的叉子」。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f/%e4%ba%92%e6%96%a5%e4%b8%8e%e5%90%8c%e6%ad%a5/28-%e5%93%b2%e5%ad%a6%e5%ae%b6%e8%bf%9b%e9%a4%90-%e6%96%b9%e6%a1%88%e4%b8%89%e7%a4%ba%e4%be%8b.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;方案四&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外一种可行的解决方案，我们&lt;strong&gt;用一个数组 state 来记录每一位哲学家的三个状态，分别是在进餐状态、思考状态、饥饿状态（正在试图拿叉子）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么，&lt;strong&gt;一个哲学家只有在两个邻居都没有进餐时，才可以进入进餐状态。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第 &lt;code&gt;i&lt;/code&gt; 个哲学家的左邻右舍，则由宏 &lt;code&gt;LEFT&lt;/code&gt; 和 &lt;code&gt;RIGHT&lt;/code&gt; 定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;LEFT&lt;/em&gt; : ( i + 5 - 1 ) % 5&lt;/li&gt;
&lt;li&gt;&lt;em&gt;RIGHT&lt;/em&gt; : ( i + 1 ) % 5&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2-读者-写者问题&#34;&gt;2. 读者-写者问题
&lt;/h5&gt;&lt;p&gt;读者只会读取数据，不会修改数据，而写者即可以读也可以修改数据。&lt;/p&gt;
&lt;p&gt;读者-写者的问题描述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;「读-读」允许：同一时刻，允许多个读者同时读&lt;/li&gt;
&lt;li&gt;「读-写」互斥：没有写者时读者才能读，没有读者时写者才能写&lt;/li&gt;
&lt;li&gt;「写-写」互斥：没有其他写者时，写者才能写&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;方案一&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;读者优先&lt;/strong&gt;的策略，因为只要有读者正在读的状态，后来的读者都可以直接进入，如果读者持续不断进入，则写者会处于饥饿状态。&lt;/p&gt;
&lt;p&gt;使用信号量的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信号量 &lt;code&gt;wMutex&lt;/code&gt;：控制写操作的互斥信号量，初始值为 1 ；&lt;/li&gt;
&lt;li&gt;读者计数 &lt;code&gt;rCount&lt;/code&gt;：正在进行读操作的读者个数，初始化为 0；&lt;/li&gt;
&lt;li&gt;信号量 &lt;code&gt;rCountMutex&lt;/code&gt;：控制对 rCount 读者计数器的互斥修改，初始值为 1；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/32-%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85-%E6%96%B9%E6%A1%88%E4%B8%80%E7%A4%BA%E4%BE%8B.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;方案二&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;写者优先策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只要有写者准备要写入，写者应尽快执行写操作，后来的读者就必须阻塞；&lt;/li&gt;
&lt;li&gt;如果有写者持续不断写入，则读者就处于饥饿；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在方案一的基础上新增如下变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信号量 &lt;code&gt;rMutex&lt;/code&gt;：控制读者进入的互斥信号量，初始值为 1；&lt;/li&gt;
&lt;li&gt;信号量 &lt;code&gt;wDataMutex&lt;/code&gt;：控制写者写操作的互斥信号量，初始值为 1；&lt;/li&gt;
&lt;li&gt;写者计数 &lt;code&gt;wCount&lt;/code&gt;：记录写者数量，初始值为 0；&lt;/li&gt;
&lt;li&gt;信号量 &lt;code&gt;wCountMutex&lt;/code&gt;：控制 wCount 互斥修改，初始值为 1；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体实现如下代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/33-%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85-%E6%96%B9%E6%A1%88%E4%BA%8C%E7%A4%BA%E4%BE%8B.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;方案三&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;既然读者优先策略和写者优先策略都会造成饥饿的现象，那么我们就来实现一下公平策略。&lt;/p&gt;
&lt;p&gt;公平策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优先级相同；&lt;/li&gt;
&lt;li&gt;写者、读者互斥访问；&lt;/li&gt;
&lt;li&gt;只能一个写者访问临界区；&lt;/li&gt;
&lt;li&gt;可以有多个读者同时访问临界资源；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体代码实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/34-%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85-%E6%96%B9%E6%A1%88%E4%B8%89%E7%A4%BA%E4%BE%8B.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;开始来了一些读者读数据，它们全部进入读者队列，此时来了一个写者，执行 &lt;code&gt;P(falg)&lt;/code&gt; 操作，使得后续到来的读者都阻塞在 &lt;code&gt;flag&lt;/code&gt; 上，不能进入读者队列，这会使得读者队列逐渐为空，即 &lt;code&gt;rCount&lt;/code&gt; 减为 0。&lt;/p&gt;
&lt;p&gt;这个写者也不能立马开始写（因为此时读者队列不为空），会阻塞在信号量 &lt;code&gt;wDataMutex&lt;/code&gt; 上，读者队列中的读者全部读取结束后，最后一个读者进程执行 &lt;code&gt;V(wDataMutex)&lt;/code&gt;，唤醒刚才的写者，写者则继续开始进行写操作。&lt;/p&gt;
&lt;h3 id=&#34;4死锁&#34;&gt;4.死锁
&lt;/h3&gt;&lt;h4 id=&#34;1-死锁的产生&#34;&gt;1. 死锁的产生
&lt;/h4&gt;&lt;p&gt;当两个线程为了保护两个不同的共享资源而使用了两个互斥锁，那么这两个互斥锁应用不当的时候，可能会造成&lt;strong&gt;两个线程都在等待对方释放锁&lt;/strong&gt;，在没有外力的作用下，这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了&lt;strong&gt;死锁&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;死锁只有&lt;strong&gt;同时满足&lt;/strong&gt;以下四个条件才会发生：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥条件；&lt;/li&gt;
&lt;li&gt;持有并等待条件；&lt;/li&gt;
&lt;li&gt;不可剥夺条件；&lt;/li&gt;
&lt;li&gt;环路等待条件；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;互斥条件是指&lt;strong&gt;多个线程不能同时使用同一个资源&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;持有并等待条件是指&lt;strong&gt;线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不可剥夺条件是指，当线程已经持有了资源 ，&lt;strong&gt;在自己使用完之前不能被其他线程获取&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;环路等待条件指的是，在死锁发生的时候，&lt;strong&gt;两个线程获取资源的顺序构成了环形链&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;2-避免死锁&#34;&gt;2. 避免死锁
&lt;/h4&gt;&lt;p&gt;产生死锁的四个必要条件是：互斥条件、持有并等待条件、不可剥夺条件、环路等待条件。&lt;/p&gt;
&lt;p&gt;那么避免死锁问题就只需要破环其中一个条件就可以，最常见的并且可行的就是&lt;strong&gt;使用资源有序分配法，来破环环路等待条件&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;5-悲观锁乐观锁&#34;&gt;5. 悲观锁、乐观锁
&lt;/h3&gt;&lt;p&gt;「&lt;strong&gt;互斥锁、自旋锁、读写锁、乐观锁、悲观锁&lt;/strong&gt;」的选择和使用。&lt;/p&gt;
&lt;h4 id=&#34;1-互斥锁与自旋锁&#34;&gt;1. 互斥锁与自旋锁
&lt;/h4&gt;&lt;p&gt;当已经有一个线程加锁后，其他线程加锁则就会失败，互斥锁和自旋锁对于加锁失败后的处理方式是不一样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;互斥锁&lt;/strong&gt;加锁失败后，线程会&lt;strong&gt;释放 CPU&lt;/strong&gt; ，给其他线程；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;自旋锁&lt;/strong&gt;加锁失败后，线程会&lt;strong&gt;忙等待&lt;/strong&gt;，直到它拿到锁；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;互斥锁是「独占锁」，线程加锁就会失败，会释放CPU给其他线程，加锁的代码就被阻塞。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的&lt;/strong&gt;。加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本：&lt;/p&gt;
&lt;p&gt;会有&lt;strong&gt;两次线程上下文切换的成本&lt;/strong&gt;。线程的状态从「运行」状态设置为「睡眠」状态。「睡眠」状态的线程会变为「就绪」状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线程的上下文切换的是什么？当两个线程是属于同一个进程，&lt;strong&gt;因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自旋锁。当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 &lt;code&gt;while&lt;/code&gt; 循环等待实现，不过最好是使用 CPU 提供的 &lt;code&gt;PAUSE&lt;/code&gt; 指令来实现「忙等待」，因为可以减少循环等待时的耗电量。&lt;/p&gt;
&lt;p&gt;自旋锁是最比较简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。&lt;strong&gt;需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;自旋锁开销少，在多核系统下一般不会主动产生线程切换，&lt;strong&gt;如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源&lt;/strong&gt;，所以自旋的时间和被锁住的代码执行的时间是成「正比」的关系。&lt;/p&gt;
&lt;p&gt;自旋锁与互斥锁使用层面比较相似，但实现层面上完全不同：&lt;strong&gt;当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;2读写锁&#34;&gt;2.读写锁
&lt;/h4&gt;&lt;p&gt;由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。&lt;strong&gt;读写锁适用于能明确区分读操作和写操作的场景&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;读写锁的工作原理是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率。&lt;/li&gt;
&lt;li&gt;但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，写锁是独占锁，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而读锁是共享锁，因为读锁可以被多个线程同时持有。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读写锁在读多写少的场景，能发挥出优势&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;根据实现的不同，读写锁可以分为「读优先锁」和「写优先锁」。&lt;/p&gt;
&lt;p&gt;读优先锁。读锁能被更多的线程持有。写任务只有在读任务全部完成后才会执行。&lt;/p&gt;
&lt;p&gt;写优先锁。优先服务写线程。正在读的线程读取完，写线程才执行，后面的读线程在写进程完成后才执行。（写线程来了之后的读线程都被阻塞）&lt;/p&gt;
&lt;p&gt;不管优先读锁还是写锁，对方可能会出现饿死问题，那么我们就不偏袒任何一方，搞个「公平读写锁」。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公平读写锁比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;3-乐观锁与悲观锁&#34;&gt;3. 乐观锁与悲观锁
&lt;/h4&gt;&lt;p&gt;互斥锁、自旋锁、读写锁，都是属于悲观锁。&lt;/p&gt;
&lt;p&gt;悲观锁做事比较悲观，它认为&lt;strong&gt;多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：&lt;strong&gt;先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;乐观锁的心态是，不管三七二十一，先改了资源再说。另外，你会发现&lt;strong&gt;乐观锁全程并没有加锁，所以它也叫无锁编程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。&lt;/p&gt;
&lt;p&gt;乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以&lt;strong&gt;只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;总结&#34;&gt;总结
&lt;/h4&gt;&lt;p&gt;开发过程中，最常见的就是&lt;strong&gt;互斥锁&lt;/strong&gt;的了，互斥锁加锁失败时，会用「线程切换」来应对，当加锁失败的线程再次加锁成功后的这一过程，会有两次线程上下文切换的成本，性能损耗比较大。&lt;/p&gt;
&lt;p&gt;如果我们明确知道被锁住的代码的执行时间很短，那我们应该选择开销比较小的&lt;strong&gt;自旋锁&lt;/strong&gt;，因为自旋锁加锁失败时，并不会主动产生线程切换，而是一直忙等待，直到获取到锁，那么如果被锁住的代码执行时间很短，那这个忙等待的时间相对应也很短。&lt;/p&gt;
&lt;p&gt;如果能区分读操作和写操作的场景，那&lt;strong&gt;读写锁&lt;/strong&gt;就更合适了，它允许多个读线程可以同时持有读锁，提高了读的并发性。根据偏袒读方还是写方，可以分为读优先锁和写优先锁，读优先锁并发性很强，但是写线程会被饿死，而写优先锁会优先服务写线程，读线程也可能会被饿死，那为了避免饥饿的问题，于是就有了公平读写锁，它是用队列把请求锁的线程排队，并保证先入先出的原则来对线程加锁，这样便保证了某种线程不会被饿死，通用性也更好点。&lt;/p&gt;
&lt;p&gt;互斥锁、自旋锁、读写锁都属于&lt;strong&gt;悲观锁&lt;/strong&gt;，悲观锁认为并发访问共享资源时，冲突概率可能非常高，所以在访问共享资源前，都需要先加锁。&lt;/p&gt;
&lt;p&gt;相反的，如果并发访问共享资源时，冲突概率非常低的话，就可以使用&lt;strong&gt;乐观锁&lt;/strong&gt;，它的工作方式是，在访问共享资源时，不用先加锁，修改完共享资源后，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。&lt;/p&gt;
&lt;p&gt;一旦冲突概率上升，就不适合使用乐观锁，因为它解决冲突的重试成本非常高。&lt;/p&gt;
&lt;p&gt;不管使用的哪种锁，我们的加锁的代码范围应该尽可能的小，也就是加锁的粒度要小，这样执行速度会比较快。再来，使用上了合适的锁，就会快上加快了。&lt;/p&gt;
&lt;h3 id=&#34;6-一个进程最多可以创建多少个线程&#34;&gt;6. 一个进程最多可以创建多少个线程？
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;32 位系统，用户态的虚拟空间只有 3G，如果创建线程时分配的栈空间是 10M，那么一个进程最多只能创建 300 个左右的线程。&lt;/li&gt;
&lt;li&gt;64 位系统，用户态的虚拟空间大到有 128T，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;7-线程崩溃了进程也会崩溃吗&#34;&gt;7. 线程崩溃了，进程也会崩溃吗？
&lt;/h3&gt;&lt;p&gt;线程是因为非法访问内存引起的崩溃，那么进程肯定会崩溃。因为在进程中，&lt;strong&gt;各个线程的地址空间是共享的&lt;/strong&gt;，某个线程对地址的非法访问就会导致内存的不确定性，进而可能会影响到其他线程，这种操作是危险的，操作系统会认为这很可能导致一系列严重的后果，于是干脆让整个进程崩溃。&lt;/p&gt;
&lt;p&gt;线程共享代码段，数据段，地址空间，文件非法访问内存有以下几种情况，我们以 C 语言举例来看看。&lt;/p&gt;
&lt;p&gt;1、针对只读内存写入数据&lt;/p&gt;
&lt;p&gt;2、访问了进程没有权限访问的地址空间（比如内核空间）。&lt;/p&gt;
&lt;p&gt;3、访问了不存在的内存。&lt;/p&gt;
&lt;p&gt;以上错误都是访问内存时的错误，所以统一会报 Segment Fault 错误（即段错误），这些都会导致进程崩溃。&lt;/p&gt;
&lt;h2 id=&#34;四进程调度页面置换磁盘调度算法&#34;&gt;四、进程调度/页面置换/磁盘调度算法
&lt;/h2&gt;&lt;h3 id=&#34;41-进程调度算法&#34;&gt;4.1 进程调度算法
&lt;/h3&gt;&lt;p&gt;常见的调度算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先来先服务调度算法&lt;/li&gt;
&lt;li&gt;最短作业优先调度算法&lt;/li&gt;
&lt;li&gt;高响应比优先调度算法&lt;/li&gt;
&lt;li&gt;时间片轮转调度算法&lt;/li&gt;
&lt;li&gt;最高优先级调度算法&lt;/li&gt;
&lt;li&gt;多级反馈队列调度算法&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;42-内存页面置换算法&#34;&gt;4.2 内存页面置换算法
&lt;/h3&gt;&lt;p&gt;在了解内存页面置换算法前，我们得先谈一下&lt;strong&gt;缺页异常（缺页中断）&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;缺页异常（缺页中断）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当 CPU 访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。&lt;/p&gt;
&lt;p&gt;页面置换算法的功能是，&lt;strong&gt;当出现缺页异常，需调入新页面而内存已满时，选择被置换的物理页面&lt;/strong&gt;，也就是说选择一个物理页面换出到磁盘，然后把需要访问的页面换入到物理页。&lt;/p&gt;
&lt;p&gt;算法目标则是，尽可能减少页面的换入换出的次数，常见的页面置换算法有如下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最佳页面置换算法（&lt;em&gt;OPT&lt;/em&gt;）&lt;/li&gt;
&lt;li&gt;先进先出置换算法（&lt;em&gt;FIFO&lt;/em&gt;）&lt;/li&gt;
&lt;li&gt;最近最久未使用的置换算法（&lt;em&gt;LRU&lt;/em&gt;）&lt;/li&gt;
&lt;li&gt;时钟页面置换算法（&lt;em&gt;Lock&lt;/em&gt;）&lt;/li&gt;
&lt;li&gt;最不常用置换算法（&lt;em&gt;LFU&lt;/em&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;1-最佳页面置换算法&#34;&gt;1. 最佳页面置换算法
&lt;/h4&gt;&lt;p&gt;最佳页面置换算法基本思路是，&lt;strong&gt;置换在「未来」最长时间不访问的页面&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这很理想，实际系统中无法实现，因为程序访问页面时是动态的，我们是无法预知每个页面在「下一次」访问前的等待时间。&lt;/p&gt;
&lt;p&gt;所以，最佳页面置换算法作用是为了衡量你的算法的效率，你的算法效率越接近该算法的效率，那么说明你的算法是高效的。&lt;/p&gt;
&lt;h4 id=&#34;2-先进先出置换算法&#34;&gt;2. 先进先出置换算法
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;选择在内存驻留时间很长的页面进行中置换&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;3-最近最久未使用的置换算法&#34;&gt;3. 最近最久未使用的置换算法
&lt;/h4&gt;&lt;p&gt;最近最久未使用（&lt;em&gt;LRU&lt;/em&gt;）的置换算法的基本思路是，发生缺页时，&lt;strong&gt;选择最长时间没有被访问的页面进行置换&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;虽然 LRU 在理论上是可以实现的，但代价很高。为了完全实现 LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。&lt;/p&gt;
&lt;p&gt;困难的是，在每次访问内存时都必须要更新「整个链表」。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作。&lt;/p&gt;
&lt;p&gt;所以，LRU 虽然看上去不错，但是由于开销比较大，实际应用中比较少使用。&lt;/p&gt;
&lt;h4 id=&#34;4-时钟页面置换算法&#34;&gt;4. 时钟页面置换算法
&lt;/h4&gt;&lt;p&gt;该算法的思路是，把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。&lt;/p&gt;
&lt;p&gt;当发生缺页中断时，算法首先检查表针指向的页面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；&lt;/li&gt;
&lt;li&gt;如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;5最不常用算法&#34;&gt;5.最不常用算法
&lt;/h4&gt;&lt;p&gt;最不常用（&lt;em&gt;LFU&lt;/em&gt;）算法，这名字听起来很调皮，但是它的意思不是指这个算法不常用，而是&lt;strong&gt;当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;它的实现方式是，对每个页面设置一个「访问计数器」，每当一个页面被访问时，该页面的访问计数器就累加 1。在发生缺页中断时，淘汰计数器值最小的那个页面。&lt;/p&gt;
&lt;p&gt;要增加一个计数器来实现，这个硬件成本是比较高的，另外如果要对这个计数器查找哪个页面访问次数最小，查找链表本身，如果链表长度很大，是非常耗时的，效率不高。&lt;/p&gt;
&lt;p&gt;但还有个问题，LFU 算法只考虑了频率问题，没考虑时间的问题，比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。&lt;/p&gt;
&lt;p&gt;那这个问题的解决的办法还是有的，可以定期减少访问的次数，比如当发生时间中断时，把过去时间访问的页面的访问次数除以 2，也就说，随着时间的流失，以前的高访问次数的页面会慢慢减少，相当于加大了被置换的概率。&lt;/p&gt;
&lt;h3 id=&#34;43-磁盘调度算法&#34;&gt;4.3 磁盘调度算法
&lt;/h3&gt;&lt;p&gt;寻道的时间是磁盘访问最耗时的部分，如果请求顺序优化的得当，必然可以节省一些不必要的寻道时间，从而提高磁盘的访问性能。&lt;/p&gt;
&lt;p&gt;假设有下面一个请求序列，每个数字代表磁道的位置：&lt;/p&gt;
&lt;p&gt;98，183，37，122，14，124，65，67&lt;/p&gt;
&lt;p&gt;初始磁头当前的位置是在第 &lt;code&gt;53&lt;/code&gt; 磁道。&lt;/p&gt;
&lt;p&gt;接下来，分别对以上的序列，作为每个调度算法的例子，那常见的磁盘调度算法有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先来先服务算法&lt;/li&gt;
&lt;li&gt;最短寻道时间优先算法&lt;/li&gt;
&lt;li&gt;扫描算法&lt;/li&gt;
&lt;li&gt;循环扫描算法&lt;/li&gt;
&lt;li&gt;LOOK 与 C-LOOK 算法&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;1-先来先服务&#34;&gt;1. 先来先服务
&lt;/h4&gt;&lt;p&gt;先来先服务（&lt;em&gt;First-Come，First-Served，FCFS&lt;/em&gt;），顾名思义，&lt;strong&gt;先到来的请求，先被服务。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先来先服务算法总共移动了 &lt;code&gt;640&lt;/code&gt; 个磁道的距离，这么一看这种算法，比较简单粗暴，但是&lt;strong&gt;如果大量进程竞争使用磁盘，请求访问的磁道可能会很分散&lt;/strong&gt;，性能上就会显得很差，因为寻道时间过长。&lt;/p&gt;
&lt;h4 id=&#34;2-最短寻道时间优先&#34;&gt;2. 最短寻道时间优先
&lt;/h4&gt;&lt;p&gt;最短寻道时间优先（&lt;em&gt;Shortest Seek First，SSF&lt;/em&gt;）算法的工作方式是，优先选择从当前磁头位置所需寻道时间最短的请求&lt;/p&gt;
&lt;p&gt;磁头移动的总距离是 &lt;code&gt;236&lt;/code&gt; 磁道，相比先来先服务性能提高了不少。&lt;/p&gt;
&lt;p&gt;但这个算法可能存在某些请求的&lt;strong&gt;饥饿&lt;/strong&gt;，因为本次例子我们是静态的序列，看不出问题，假设是一个动态的请求，如果后续来的请求都是小于 183 磁道的，那么 183 磁道可能永远不会被响应，于是就产生了饥饿现象，这里&lt;strong&gt;产生饥饿的原因是磁头在一小块区域来回移动&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;3-扫描算法&#34;&gt;3. 扫描算法
&lt;/h4&gt;&lt;p&gt;最短寻道时间优先算法会产生饥饿的原因在于：磁头有可能再一个小区域内来回得移动。&lt;/p&gt;
&lt;p&gt;为了防止这个问题，可以规定：&lt;strong&gt;磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向，这就是扫描（*Scan*）算法&lt;/strong&gt;。也叫做电梯算法。&lt;/p&gt;
&lt;p&gt;扫描调度算法性能较好，&lt;strong&gt;不会产生饥饿现象&lt;/strong&gt;，但是存在这样的问题，中间部分的磁道会比较占便宜，&lt;strong&gt;中间部分相比其他部分响应的频率会比较多&lt;/strong&gt;，也就是说每个磁道的响应频率存在差异。&lt;/p&gt;
&lt;h4 id=&#34;4-循环扫描算法&#34;&gt;4. 循环扫描算法
&lt;/h4&gt;&lt;p&gt;扫描算法使得每个磁道响应的频率存在差异，那么要优化这个问题的话，可以总是按相同的方向进行扫描，使得每个磁道的响应频率基本一致。&lt;/p&gt;
&lt;p&gt;循环扫描（&lt;em&gt;Circular Scan, CSCAN&lt;/em&gt; ）规定：只有磁头朝某个特定方向移动时，才处理磁道访问请求，而返回时直接快速移动至最靠边缘的磁道，也就是复位磁头，这个过程是很快的，并且&lt;strong&gt;返回中途不处理任何请求&lt;/strong&gt;，该算法的特点，就是&lt;strong&gt;磁道只响应一个方向上的请求&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;磁头先响应了右边的请求，直到碰到了最右端的磁道 199，就立即回到磁盘的开始处（磁道 0），但这个返回的途中是不响应任何请求的，直到到达最开始的磁道后，才继续顺序响应右边的请求。&lt;/p&gt;
&lt;p&gt;循环扫描算法相比于扫描算法，对于各个位置磁道响应频率相对比较平均。&lt;/p&gt;
&lt;h4 id=&#34;5look-与-c-look算法&#34;&gt;5.LOOK 与 C-LOOK算法
&lt;/h4&gt;&lt;p&gt;我们前面说到的扫描算法和循环扫描算法，都是磁头移动到磁盘「最始端或最末端」才开始调换方向。&lt;/p&gt;
&lt;p&gt;那这其实是可以优化的，优化的思路就是&lt;strong&gt;磁头在移动到「最远的请求」位置，然后立即反向移动。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那针对 SCAN 算法的优化则叫 LOOK 算法，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，&lt;strong&gt;反向移动的途中会响应请求&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而针 C-SCAN 算法的优化则叫 C-LOOK，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，&lt;strong&gt;反向移动的途中不会响应请求&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;五文件系统&#34;&gt;五、文件系统
&lt;/h2&gt;&lt;h4 id=&#34;1-文件系统的基本组成&#34;&gt;1. 文件系统的基本组成
&lt;/h4&gt;&lt;p&gt;Linux 最经典的一句话是：「&lt;strong&gt;一切皆文件&lt;/strong&gt;」&lt;/p&gt;
&lt;p&gt;Linux 文件系统会为每个文件分配两个数据结构：&lt;strong&gt;索引节点（index node）和目录项（directory entry）&lt;/strong&gt;，它们主要用来记录文件的元信息和目录层次结构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;索引节点，也就是 &lt;em&gt;inode&lt;/em&gt;，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、&lt;strong&gt;数据在磁盘的位置&lt;/strong&gt;等等。索引节点是文件的&lt;strong&gt;唯一&lt;/strong&gt;标识，它们之间一一对应，也同样都会被存储在硬盘中，所以&lt;strong&gt;索引节点同样占用磁盘空间&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;目录项，也就是 &lt;em&gt;dentry&lt;/em&gt;，用来记录文件的名字、&lt;strong&gt;索引节点指针&lt;/strong&gt;以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，&lt;strong&gt;目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于索引节点唯一标识一个文件，而目录项记录着文件的名字，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别名。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。&lt;/p&gt;
&lt;p&gt;目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目录项和目录是一个东西吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。&lt;/p&gt;
&lt;p&gt;如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。&lt;/p&gt;
&lt;p&gt;注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;那文件数据是如何存储在磁盘的呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;磁盘读写的最小单位是&lt;strong&gt;扇区&lt;/strong&gt;，扇区的大小只有 &lt;code&gt;512B&lt;/code&gt; 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。&lt;/p&gt;
&lt;p&gt;所以，文件系统把多个扇区组成了一个&lt;strong&gt;逻辑块&lt;/strong&gt;，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 &lt;code&gt;4KB&lt;/code&gt;，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。&lt;/p&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E7%9B%AE%E5%BD%95%E9%A1%B9%E5%92%8C%E7%B4%A2%E5%BC%95%E5%85%B3%E7%B3%BB%E5%9B%BE.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;索引节点是存储在硬盘上的数据，那么为了加速文件的访问，通常会把索引节点加载到内存中。&lt;/p&gt;
&lt;p&gt;另外，磁盘进行格式化的时候，会被分成三个存储区域，分别是超级块、索引节点区和数据块区。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;超级块&lt;/em&gt;，用来存储文件系统的详细信息，比如块个数、块大小、空闲块等等。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;索引节点区&lt;/em&gt;，用来存储索引节点；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;数据块区&lt;/em&gt;，用来存储文件或目录数据；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们不可能把超级块和索引节点区全部加载到内存，这样内存肯定撑不住，所以只有当需要使用的时候，才将其加载进内存，它们加载进内存的时机是不同的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;超级块：当文件系统挂载时进入内存；&lt;/li&gt;
&lt;li&gt;索引节点区：当文件被访问时进入内存；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-虚拟文件系统&#34;&gt;2. 虚拟文件系统
&lt;/h4&gt;&lt;p&gt;文件系统的种类众多，而操作系统希望&lt;strong&gt;对用户提供一个统一的接口&lt;/strong&gt;，于是在用户层与文件系统层引入了中间层，这个中间层就称为&lt;strong&gt;虚拟文件系统（Virtual File System，VFS）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;VFS 定义了一组所有文件系统都支持的数据结构和标准接口，这样程序员不需要了解文件系统的工作原理，只需要了解 VFS 提供的统一接口即可。&lt;/p&gt;
&lt;p&gt;Linux 支持的文件系统也不少，根据存储位置的不同，可以把文件系统分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;磁盘的文件系统&lt;/strong&gt;，它是直接把数据存储在磁盘中，比如 Ext 2/3/4、XFS 等都是这类文件系统。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存的文件系统&lt;/strong&gt;，这类文件系统的数据不是存储在硬盘的，而是占用内存空间，我们经常用到的 &lt;code&gt;/proc&lt;/code&gt; 和 &lt;code&gt;/sys&lt;/code&gt; 文件系统都属于这一类，读写这类文件，实际上是读写内核中相关的数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络的文件系统&lt;/strong&gt;，用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文件系统首先要先挂载到某个目录才可以正常使用，比如 Linux 系统在启动时，会把文件系统挂载到根目录。&lt;/p&gt;
&lt;h4 id=&#34;3-文件的使用&#34;&gt;3. 文件的使用
&lt;/h4&gt;&lt;p&gt;首先，我们得通过系统调用来打开一个文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E5%86%99%E5%88%B0%E7%A3%81%E7%9B%98%E8%BF%87%E7%A8%8B.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;write 的过程&#34;
	
	
&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;打开文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,...);&lt;/span&gt;         &lt;span class=&#34;err&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;写数据&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;             &lt;span class=&#34;err&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;关闭文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;上面简单的代码是读取一个文件的过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先用 &lt;code&gt;open&lt;/code&gt; 系统调用打开文件，&lt;code&gt;open&lt;/code&gt; 的参数中包含文件的路径名和文件名。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;write&lt;/code&gt; 写数据，其中 &lt;code&gt;write&lt;/code&gt; 使用 &lt;code&gt;open&lt;/code&gt; 所返回的&lt;strong&gt;文件描述符&lt;/strong&gt;，并不使用文件名作为参数。&lt;/li&gt;
&lt;li&gt;使用完文件后，要用 &lt;code&gt;close&lt;/code&gt; 系统调用关闭文件，避免资源的泄露。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;打开了一个文件后，操作系统会跟踪进程打开的所有文件，所谓的跟踪呢，就是操作系统为每个进程维护一个打开文件表，文件表里的每一项代表「&lt;strong&gt;文件描述符&lt;/strong&gt;」，所以说文件描述符是打开文件的标识。&lt;/p&gt;
&lt;p&gt;操作系统在打开文件表中维护着打开文件的状态和信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的；&lt;/li&gt;
&lt;li&gt;文件打开计数器：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目；&lt;/li&gt;
&lt;li&gt;文件磁盘位置：绝大多数文件操作都要求系统修改文件数据，该信息保存在内存中，以免每个操作都从磁盘中读取；&lt;/li&gt;
&lt;li&gt;访问权限：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等），该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I/O 请求；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;文件系统的基本操作单位是数据块&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;4-文件的存储&#34;&gt;4. 文件的存储
&lt;/h4&gt;&lt;p&gt;文件的数据是要存储在硬盘上面的，数据在磁盘上的存放方式，就像程序在内存中存放的方式那样，有以下两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连续空间存放方式&lt;/li&gt;
&lt;li&gt;非连续空间存放方式：「链表方式」和「索引方式」。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;连续空间存放方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前提，必须先知道一个文件的大小。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;文件头里需要指定「起始块的位置」和「长度」&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：读写效率高，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：磁盘空间碎片、文件长度不易扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非连续空间存放方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分为「链表方式」和「索引方式」。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;链表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以&lt;strong&gt;消除磁盘碎片&lt;/strong&gt;，提高磁盘空间的利用率，同时&lt;strong&gt;文件的长度可以动态扩展&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;分为「&lt;strong&gt;隐式链表&lt;/strong&gt;」和「&lt;strong&gt;显式链接&lt;/strong&gt;」两种形式。&lt;/p&gt;
&lt;p&gt;「&lt;strong&gt;隐式链表&lt;/strong&gt;」。实现的方式是文件头要包含「第一块」和「最后一块」的位置，并且每个数据块里面留出一个指针空间，用来存放下一个数据块的位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：无法直接访问数据块，只能通过指针顺序访问文件。以及数据块指针消耗了一定的存储空间&lt;/strong&gt;。&lt;strong&gt;稳定性较差&lt;/strong&gt;，系统在运行过程中由于软件或者硬件错误&lt;strong&gt;导致链表中的指针丢失或损坏，会导致文件数据的丢失。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;「&lt;strong&gt;显式链接&lt;/strong&gt;」。把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中**，该表在整个磁盘仅设置一张，**每个表项中存放链接指针，指向下一个数据块号。&lt;/p&gt;
&lt;p&gt;由于查找记录的过程是在内存中进行的，&lt;strong&gt;提高了检索速度，而且减少了访问磁盘的次数&lt;/strong&gt;。&lt;strong&gt;缺点是&lt;/strong&gt;不适用于大磁盘。&lt;/p&gt;
&lt;p&gt;链表的方式解决了连续分配的磁盘碎片和文件动态扩展的问题，但是不能有效支持直接访问。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;索引&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;索引的实现是为每个文件创建一个「&lt;strong&gt;索引数据块&lt;/strong&gt;」，里面存放的是&lt;strong&gt;指向文件数据块的指针列表&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文件头需要包含指向「索引数据块」的指针&lt;/strong&gt;，这样就可以通过文件头知道索引数据块的位置，再通过索引数据块里的索引信息找到对应的数据块。&lt;/p&gt;
&lt;p&gt;索引的方式优点在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件的创建、增大、缩小很方便；&lt;/li&gt;
&lt;li&gt;不会有碎片的问题；&lt;/li&gt;
&lt;li&gt;支持顺序读写和随机读写；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺陷之一就是存储索引带来的开销。&lt;/p&gt;
&lt;p&gt;如果文件很大，大到一个索引数据块放不下索引信息，如何处理大文件的存放呢？可以通过组合的方式，来处理大文件的存储。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;\链表 + 索引的组合，这种组合称为「&lt;strong&gt;链式索引块&lt;/strong&gt;」，它的实现方式是&lt;strong&gt;在索引数据块留出一个存放下一个索引数据块的指针&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;、索引 + 索引的方式，这种组合称为「&lt;strong&gt;多级索引块&lt;/strong&gt;」，实现方式是&lt;strong&gt;通过一个索引块来存放多个索引数据块&lt;/strong&gt;，&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83.png&#34; alt=&#34;img&#34; style=&#34;zoom:67%;&#34; /&gt;
&lt;h4 id=&#34;5空闲空间管理&#34;&gt;5.空闲空间管理
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;空闲表法&lt;/li&gt;
&lt;li&gt;空闲链表法&lt;/li&gt;
&lt;li&gt;位图法&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;空闲表法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;空闲表法就是为所有空闲空间建立一张表，表内容包括空闲区的第一个块号和该空闲区的块个数，注意，这个方式是连续分配的。&lt;/p&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95.png&#34; alt=&#34;空闲表法&#34; style=&#34;zoom:67%;&#34; /&gt;
&lt;p&gt;当请求分配磁盘空间时，系统依次扫描空闲表里的内容，&lt;/p&gt;
&lt;p&gt;系统回收文件空间。也需顺序扫描空闲表，寻找一个空闲表条目并将释放空间的第一个物理块号及它占用的块数填到这个条目中。&lt;/p&gt;
&lt;p&gt;这种方法仅当有少量的空闲区时才有较好的效果。因为，如果存储空间中有着大量的小的空闲区，则空闲表变得很大，这样查询效率会很低。另外，这种分配技术适用于建立连续文件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;空闲链表法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用「链表」的方式来管理空闲空间，每一个空闲块里有一个指针指向下一个空闲块。&lt;/p&gt;
&lt;p&gt;当创建文件需要一块或几块时，就从链头上依次取下一块或几块。反之，当回收空间时，把这些空闲块依次接到链头上。&lt;/p&gt;
&lt;p&gt;这种技术只要在主存中保存一个指针，令它指向第一个空闲块。其特点是简单，但不能随机访问，工作效率低。&lt;/p&gt;
&lt;p&gt;空闲表法和空闲链表法都不适合用于大型文件系统，因为这会使空闲表或空闲链表太大。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;位图法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;位图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。&lt;/p&gt;
&lt;p&gt;当值为 0 时，表示对应的盘块空闲，值为 1 时，表示对应的盘块已分配。&lt;/p&gt;
&lt;p&gt;在 Linux 文件系统就采用了位图的方式来管理空闲空间，不仅用于数据空闲块的管理，还用于 inode 空闲块的管理，因为 inode 也是存储在磁盘的。Linux文件系统中位图由块组组成。&lt;/p&gt;
&lt;h4 id=&#34;6-目录的存储&#34;&gt;6. 目录的存储
&lt;/h4&gt;&lt;p&gt;和普通文件不同的是，&lt;strong&gt;普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在目录文件的块中，最简单的保存格式就是&lt;strong&gt;列表&lt;/strong&gt;，就是一项一项地将目录下的文件信息（如文件名、文件 inode、文件类型等）列在表里。&lt;/p&gt;
&lt;p&gt;列表中每一项就代表该目录下的文件的文件名和对应的 inode，通过这个 inode，就可以找到真正的文件。&lt;/p&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E7%9B%AE%E5%BD%95%E5%93%88%E5%B8%8C%E8%A1%A8.png&#34; alt=&#34;目录格式哈希表&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;如果一个目录有超级多的文件，我们要想在这个目录下找文件，按照列表一项一项的找，效率就不高了。&lt;/p&gt;
&lt;p&gt;于是，保存目录的格式改成&lt;strong&gt;哈希表&lt;/strong&gt;，对文件名进行哈希计算，把哈希值保存起来，如果我们要查找一个目录下面的文件名，可以通过名称取哈希。如果哈希能够匹配上，就说明这个文件的信息在相应的块里面。&lt;/p&gt;
&lt;p&gt;Linux 系统的 ext 文件系统就是采用了哈希表，来保存目录的内容，这种方法的优点是查找非常迅速，插入和删除也较简单，不过需要一些预备措施来避免哈希冲突。&lt;/p&gt;
&lt;h4 id=&#34;7软链接和硬链接&#34;&gt;7.软链接和硬链接
&lt;/h4&gt;&lt;p&gt;有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过&lt;strong&gt;硬链接（Hard Link）&lt;/strong&gt; 和&lt;strong&gt;软链接（Symbolic Link）&lt;/strong&gt; 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。&lt;/p&gt;
&lt;p&gt;硬链接是&lt;strong&gt;多个目录项中的「索引节点」指向一个文件&lt;/strong&gt;，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以&lt;strong&gt;硬链接是不可用于跨文件系统的&lt;/strong&gt;。由于多个目录项都是指向一个 inode，那么&lt;strong&gt;只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软链接相当于重新创建一个文件，这个文件有&lt;strong&gt;独立的 inode&lt;/strong&gt;，但是这个&lt;strong&gt;文件的内容是另外一个文件的路径&lt;/strong&gt;，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以&lt;strong&gt;软链接是可以跨文件系统的&lt;/strong&gt;，甚至&lt;strong&gt;目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;8-文件-io&#34;&gt;8. 文件 I/O
&lt;/h4&gt;&lt;p&gt;文件的读写方式各有千秋，对于文件的 I/O 分类也非常多，常见的有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓冲与非缓冲 I/O&lt;/li&gt;
&lt;li&gt;直接与非直接 I/O&lt;/li&gt;
&lt;li&gt;阻塞与非阻塞 I/O VS 同步与异步 I/O&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;缓冲与非缓冲 I/O&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文件操作的标准库是可以实现数据的缓存，那么&lt;strong&gt;根据「是否利用标准库缓冲」，可以把文件 I/O 分为缓冲 I/O 和非缓冲 I/O&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓冲 I/O，利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件。&lt;/li&gt;
&lt;li&gt;非缓冲 I/O，直接通过系统调用访问文件，不经过标准库缓存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;「缓冲」特指标准库内部实现的缓冲。&lt;/p&gt;
&lt;p&gt;比方说，很多程序遇到换行时才真正输出，而换行前的内容，其实就是被标准库暂时缓存了起来，这样做的目的是，减少系统调用的次数，毕竟系统调用是有 CPU 上下文切换的开销的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;直接与非直接 I/O&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;根据是「否利用操作系统的缓存」，可以把文件 I/O 分为直接 I/O 与非直接 I/O&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接 I/O，不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘。&lt;/li&gt;
&lt;li&gt;非直接 I/O，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;系统调用函数指定了 &lt;code&gt;O_DIRECT&lt;/code&gt; 标志，则表示使用直接 I/O。如果没有设置过，默认使用的是非直接 I/O。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果用了非直接 I/O 进行写数据操作，内核什么情况下才会把缓存数据写入到磁盘？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下几种场景会触发内核缓存的数据写入磁盘：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在调用 &lt;code&gt;write&lt;/code&gt; 的最后，当发现内核缓存的数据太多的时候，内核会把数据写到磁盘上；&lt;/li&gt;
&lt;li&gt;用户主动调用 &lt;code&gt;sync&lt;/code&gt;，内核缓存会刷到磁盘上；&lt;/li&gt;
&lt;li&gt;当内存十分紧张，无法再分配页面时，也会把内核缓存的数据刷到磁盘上；&lt;/li&gt;
&lt;li&gt;内核缓存的数据的缓存时间超过某个时间时，也会把数据刷到磁盘上；&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;阻塞与非阻塞 I/O VS 同步与异步 I/O&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;阻塞 I/O&lt;/strong&gt;，当用户程序执行 &lt;code&gt;read&lt;/code&gt; ，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，当拷贝过程完成，&lt;code&gt;read&lt;/code&gt; 才会返回。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非阻塞 I/O&lt;/strong&gt;，非阻塞的 read 请求在数据未准备好的情况下立即返回，可以继续往下执行，此时应用程序不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序缓冲区，&lt;code&gt;read&lt;/code&gt; 调用才可以获取到结果。&lt;/p&gt;
&lt;p&gt;访问管道或 socket 时，如果设置了 &lt;code&gt;O_NONBLOCK&lt;/code&gt; 标志，那么就表示使用的是非阻塞 I/O 的方式访问，而不做任何设置的话，默认是阻塞 I/O。&lt;/p&gt;
&lt;p&gt;应用程序每次轮询内核的 I/O 是否准备好，轮询的过程中，应用程序啥也做不了，只是在循环。为了解决这种傻乎乎轮询方式，于是 &lt;strong&gt;I/O 多路复用&lt;/strong&gt;技术就出来了，如 select、poll，它是通过 I/O 事件分发，当内核数据准备好时，再以事件通知应用程序进行操作。&lt;/p&gt;
&lt;p&gt;这个做法大大改善了 CPU 的利用率，因为当调用了 I/O 多路复用接口，如果没有事件发生，那么当前线程就会发生阻塞，这时 CPU 会切换其他线程执行任务，等内核发现有事件到来的时候，会唤醒阻塞在 I/O 多路复用接口的线程，然后用户可以进行后续的事件处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I/O 多路复用接口最大的优势在于，用户可以在一个线程内同时处理多个 socket 的 IO 请求&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;无论是阻塞 I/O、非阻塞 I/O，还是基于非阻塞 I/O 的多路复用&lt;strong&gt;都是同步调用。因为它们在 read 调用时，内核将数据从内核空间拷贝到应用程序空间，过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，read 调用就会在这个同步过程中等待比较长的时间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异步 I/O&lt;/strong&gt; 是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程都不用等待。&lt;/p&gt;
&lt;p&gt;当我们发起 &lt;code&gt;aio_read&lt;/code&gt; 之后，就立即返回，内核自动将数据从内核空间拷贝到应用程序空间，这个拷贝过程同样是异步的，内核自动完成的，和前面的同步操作不一样，应用程序并不需要主动发起拷贝动作。&lt;/p&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E5%90%8C%E6%AD%A5VS%E5%BC%82%E6%AD%A5IO.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;I/O 是分为两个过程的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据准备的过程&lt;/li&gt;
&lt;li&gt;数据从内核空间拷贝到用户进程缓冲区的过程&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;阻塞 I/O 会阻塞在「过程 1 」和「过程 2」，而非阻塞 I/O 和基于非阻塞 I/O 的多路复用只会阻塞在「过程 2」，所以这三个都可以认为是同步 I/O。&lt;/p&gt;
&lt;p&gt;异步 I/O 则不同，「过程 1 」和「过程 2 」都不会阻塞。&lt;/p&gt;
&lt;h4 id=&#34;9-写文件时进程发生了崩溃已写入的数据会丢失吗&#34;&gt;9. 写文件时，进程发生了崩溃，已写入的数据会丢失吗
&lt;/h4&gt;&lt;p&gt;进程写文件时（使用缓冲 IO），进程发生了崩溃，已写入的数据会丢失吗？&lt;/p&gt;
&lt;p&gt;不会的。&lt;/p&gt;
&lt;p&gt;进程在执行 write （使用缓冲 IO）系统调用的时候，实际上是将文件数据写到了内核的 page cache，它是文件系统中用于缓存文件数据的缓冲，所以即使进程崩溃了，文件数据还是保留在内核的 page cache，我们读数据的时候，也是从内核的 page cache 读取，因此还是依然读的进程崩溃前写入的数据。&lt;/p&gt;
&lt;p&gt;内核会找个合适的时机，将 page cache 中的数据持久化到磁盘。但是如果 page cache 里的文件数据，在持久化到磁盘之前，系统发生了崩溃，那这部分数据就会丢失了。&lt;/p&gt;
&lt;p&gt;我们也可以在程序里调用 fsync 函数，在写文文件的时候，立刻将文件数据持久化到磁盘，这样就可以解决系统崩溃导致的文件数据丢失的问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Swap 与缺页中断&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Swap 机制指的是当物理内存不够用，内存管理单元（Memory Mangament Unit，MMU）需要提供调度算法来回收相关内存空间，然后将清理出来的内存空间给当前内存申请方。&lt;/p&gt;
&lt;p&gt;Swap 机制存在的本质原因是 Linux 系统提供了虚拟内存管理机制，每一个进程认为其独占内存空间，因此所有进程的内存空间之和远远大于物理内存。所有进程的内存空间之和超过物理内存的部分就需要交换到磁盘上。&lt;/p&gt;
&lt;p&gt;操作系统以 page 为单位管理内存，当进程发现需要访问的数据不在内存时，操作系统可能会将数据以页的方式加载到内存中。上述过程被称为&lt;strong&gt;缺页中断&lt;/strong&gt;，当操作系统发生缺页中断时，就会通过系统调用将 page 再次读到内存中。&lt;/p&gt;
&lt;p&gt;但主内存的空间是有限的，当主内存中不包含可以使用的空间时，操作系统会从选择合适的物理内存页驱逐回磁盘，为新的内存页让出位置，&lt;strong&gt;选择待驱逐页的过程在操作系统中叫做页面替换（Page Replacement）&lt;/strong&gt;，替换操作又会触发 swap 机制。&lt;/p&gt;
&lt;p&gt;如果物理内存足够大，那么可能不需要 Swap 机制，但是 Swap 在这种情况下还是有一定优势：对于有发生内存泄漏几率的应用程序（进程），Swap 交换分区更是重要，这可以确保内存泄露不至于导致物理内存不够用，最终导致系统崩溃。但内存泄露会引起频繁的 swap，此时非常影响操作系统的性能。&lt;/p&gt;
&lt;p&gt;需要我们理解一下文件的数据。&lt;strong&gt;文件 = 数据 + 元数据&lt;/strong&gt;。元数据用来描述文件的各种属性，也必须存储在磁盘上。因此，我们说保证文件一致性其实包含了两个方面：数据一致+元数据一致。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;文件的元数据包括：文件大小、创建时间、访问时间、属主属组等信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们考虑如下一致性问题：如果发生写操作并且对应的数据在 Page Cache 中，那么写操作就会直接作用于 Page Cache 中，此时如果数据还没刷新到磁盘，那么内存中的数据就领先于磁盘，此时对应 page 就被称为 Dirty page。&lt;/p&gt;
&lt;p&gt;当前 Linux 下以两种方式实现文件一致性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Write Through（写穿）&lt;/strong&gt;：向用户层提供特定接口，应用程序可主动调用接口来保证文件一致性；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Write back（写回）&lt;/strong&gt;：系统中存在定期任务（表现形式为内核线程），周期性地同步文件系统中文件脏数据块，这是默认的 Linux 一致性方案；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Write Through 与 Write back 在持久化的可靠性上有所不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Write Through 以牺牲系统 I/O 吞吐量作为代价，向上层应用确保一旦写入，数据就已经落盘，不会丢失；&lt;/li&gt;
&lt;li&gt;Write back 在系统发生宕机的情况下无法确保数据已经落盘，因此存在数据丢失的问题。不过，在程序挂了，例如被 kill -9，Page Cache 中的数据操作系统还是会确保落盘；&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;page-cache-的优劣势&#34;&gt;Page Cache 的优劣势
&lt;/h2&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;优势&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1.加快数据访问&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据在内存中进行缓存，由于内存访问比磁盘访问快很多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.减少 I/O 次数，提高系统磁盘 I/O 吞吐量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Page Cache 的缓存以及预读能力，而程序又往往符合局部性原理，因此通过一次 I/O 将多个 page 装入 Page Cache 能够减少磁盘 I/O 次数， 进而提高系统磁盘 I/O 吞吐量。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;劣势&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最直接的缺点是&lt;strong&gt;需要占用额外物理内存空间&lt;/strong&gt;，物理内存在比较紧俏的时候可能会导致频繁的 swap 操作，最终导致系统的磁盘 I/O 负载的上升。&lt;/p&gt;
&lt;p&gt;另一个缺陷是对应用层并没有提供很好的管理 API，几乎是透明管理。应用层即使想优化 Page Cache 的使用策略也很难进行。&lt;/p&gt;
&lt;p&gt;Page Cache 最后一个缺陷是在某些应用场景下比 Direct I/O 多一次磁盘读 I/O 以及磁盘写 I/O。&lt;/p&gt;
&lt;p&gt;Direct I/O 即直接 I/O。其名字中的”直接”二字用于区分使用 page cache 机制的缓存 I/O。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存文件 I/O：用户空间要读写一个文件并&lt;strong&gt;不直接&lt;/strong&gt;与磁盘交互，而是中间夹了一层缓存，即 page cache；&lt;/li&gt;
&lt;li&gt;直接文件 I/O：用户空间读取的文件&lt;strong&gt;直接&lt;/strong&gt;与磁盘交互，没有中间 page cache 层；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;“直接”在这里还有另一层语义：其他所有技术中，数据至少需要在内核空间存储一份，但是在 Direct I/O 技术中，数据直接存储在用户空间中，绕过了内核。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Direct I/O 的读写非常有特点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Write 操作：由于其不使用 page cache，所以其进行写文件，如果返回成功，数据就真的落盘了（不考虑磁盘自带的缓存）；&lt;/li&gt;
&lt;li&gt;Read 操作：由于其不使用 page cache，每次读操作是真的从磁盘中读取，不会从文件系统的缓存中读取。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;六设备管理&#34;&gt;六、设备管理
&lt;/h2&gt;&lt;h3 id=&#34;81-键盘敲入-a-字母时操作系统期间发生了什么&#34;&gt;8.1 键盘敲入 A 字母时，操作系统期间发生了什么？
&lt;/h3&gt;&lt;h4 id=&#34;1设备控制器&#34;&gt;1.设备控制器
&lt;/h4&gt;&lt;p&gt;为了屏蔽设备之间的差异，每个设备都有一个叫&lt;strong&gt;设备控制器（Device Control）&lt;/strong&gt; 的组件，比如硬盘有硬盘控制器、显示器有视频控制器等。&lt;/p&gt;
&lt;p&gt;设备控制器里有芯片，它可执行自己的逻辑，也有自己的寄存器，用来与 CPU 进行通信，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过写入这些寄存器，操作系统可以命令设备发送数据、接收数据、开启或关闭，或者执行某些其他操作。&lt;/li&gt;
&lt;li&gt;通过读取这些寄存器，操作系统可以了解设备的状态，是否准备好接收一个新的命令等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际上，控制器是有三类寄存器，它们分别是&lt;strong&gt;状态寄存器（Status Register）&lt;/strong&gt;、 &lt;strong&gt;命令寄存器（Command Register）以及数据寄存器（Data Register）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;三个寄存器的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据寄存器，CPU 向 I/O 设备写入需要传输的数据，比如要打印的内容是「Hello」，CPU 就要先发送一个 H 字符给到对应的 I/O 设备。&lt;/li&gt;
&lt;li&gt;命令寄存器，CPU 发送一个命令，告诉 I/O 设备，要进行输入/输出操作，于是就会交给 I/O 设备去工作，任务完成后，会把状态寄存器里面的状态标记为完成。&lt;/li&gt;
&lt;li&gt;状态寄存器，目的是告诉 CPU ，现在已经在工作或工作已经完成，如果已经在工作状态，CPU 再发送数据或者命令过来，都是没有用的，直到前面的工作已经完成，状态寄存标记成已完成，CPU 才能发送下一个字符和命令。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CPU 通过读写设备控制器中的寄存器控制设备，这可比 CPU 直接控制输入输出设备，要方便和标准很多。&lt;/p&gt;
&lt;p&gt;输入输出设备可分为两大类 ：&lt;strong&gt;块设备（Block Device）和字符设备（Character Device）&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;块设备，把数据存储在固定大小的块中，每个块有自己的地址，硬盘、USB 是常见的块设备。&lt;/li&gt;
&lt;li&gt;字符设备，以字符为单位发送或接收一个字符流，字符设备是不可寻址的，也没有任何寻道操作，鼠标是常见的字符设备。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;块设备通常传输的数据量会非常大，于是控制器设立了一个可读写的&lt;strong&gt;数据缓冲区&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU 写入数据到控制器的缓冲区时，当缓冲区的数据囤够了一部分，才会发给设备。&lt;/li&gt;
&lt;li&gt;CPU 从控制器的缓冲区读取数据时，也需要缓冲区囤够了一部分，才拷贝到内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样做是为了，减少对设备的频繁操作。&lt;/p&gt;
&lt;p&gt;那 CPU 是如何与设备的控制寄存器和数据缓冲区进行通信的？存在两个方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;端口 I/O，每个控制寄存器被分配一个 I/O 端口，可以通过特殊的汇编指令操作这些寄存器，比如 &lt;code&gt;in/out&lt;/code&gt; 类似的指令。&lt;/li&gt;
&lt;li&gt;内存映射 I/O，将所有控制寄存器映射到内存空间中，这样就可以像读写内存一样读写数据缓冲区。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-io-控制方式&#34;&gt;2. I/O 控制方式
&lt;/h4&gt;&lt;p&gt;当 CPU 给设备发送了一个指令，让设备控制器去读设备的数据，它读完的时候，要怎么通知 CPU 呢？&lt;/p&gt;
&lt;p&gt;控制器的寄存器一般会有状态标记位，用来标识输入或输出操作是否完成。&lt;/p&gt;
&lt;p&gt;第一种&lt;strong&gt;轮询等待&lt;/strong&gt;的方法，让 CPU 一直查寄存器的状态，直到状态标记为完成，很明显，这种方式非常的傻瓜，它会占用 CPU 的全部时间。&lt;/p&gt;
&lt;p&gt;第二种方法 —— &lt;strong&gt;中断&lt;/strong&gt;，通知操作系统数据已经准备好了。我们一般会有一个硬件的&lt;strong&gt;中断控制器&lt;/strong&gt;，当设备完成任务后触发中断到中断控制器，中断控制器就通知 CPU，一个中断产生了，CPU 需要停下当前手里的事情来处理中断。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;另外，中断有两种，一种&lt;strong&gt;软中断&lt;/strong&gt;，例如代码调用 &lt;code&gt;INT&lt;/code&gt; 指令触发，一种是&lt;strong&gt;硬件中断&lt;/strong&gt;，就是硬件通过中断控制器触发的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中断的方式对于频繁读写数据的磁盘，并不友好，这样 CPU 容易经常被打断，会占用 CPU 大量的时间。对于这一类设备的问题的解决方法是使用 &lt;strong&gt;DMA（Direct Memory Access）&lt;/strong&gt; 功能，它可以使得设备在 CPU 不参与的情况下，能够自行完成把设备 I/O 数据放入到内存。&lt;/p&gt;
&lt;p&gt;DMA 的工作方式如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU 需对 DMA 控制器下发指令，告诉它想读取多少数据，读完的数据放在内存的某个地方就可以了；&lt;/li&gt;
&lt;li&gt;接下来，DMA 控制器会向磁盘控制器发出指令，通知它从磁盘读数据到其内部的缓冲区中，接着磁盘控制器将缓冲区的数据传输到内存；&lt;/li&gt;
&lt;li&gt;当磁盘控制器把数据传输到内存的操作完成后，磁盘控制器在总线上发出一个确认成功的信号到 DMA 控制器；&lt;/li&gt;
&lt;li&gt;DMA 控制器收到信号后，DMA 控制器发中断通知 CPU 指令完成，CPU 就可以直接用内存里面现成的数据了；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到， CPU 当要读取磁盘数据的时候，只需给 DMA 控制器发送指令，然后返回去做其他事情，当磁盘数据拷贝到内存后，DMA 控制机器通过中断的方式，告诉 CPU 数据已经准备好了，可以从内存读数据了。仅仅在传送开始和结束时需要 CPU 干预。&lt;/p&gt;
&lt;h4 id=&#34;3-设备驱动程序&#34;&gt;3. 设备驱动程序
&lt;/h4&gt;&lt;p&gt;虽然设备控制器屏蔽了设备的众多细节，但每种设备的控制器的寄存器、缓冲区等使用模式都是不同的，所以为了屏蔽「设备控制器」的差异，引入了&lt;strong&gt;设备驱动程序&lt;/strong&gt;。&lt;/p&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F.png&#34; alt=&#34;img&#34; style=&#34;zoom:33%;&#34; /&gt;
&lt;p&gt;设备控制器属于属于硬件，而设备驱动程序属于操作系统的一部分，操作系统的内核代码可以像本地调用代码一样使用设备驱动程序的接口，而设备驱动程序是面向设备控制器的代码，它发出操控设备控制器的指令后，才可以操作设备控制器。&lt;/p&gt;
&lt;p&gt;不同的设备控制器虽然功能不同，但是&lt;strong&gt;设备驱动程序会提供统一的接口给操作系统&lt;/strong&gt;，这样不同的设备驱动程序，就可以以相同的方式接入操作系统。&lt;/p&gt;
&lt;p&gt;设备完成了事情，则会发送中断来通知操作系统。那操作系统就需要有一个地方来处理这个中断，这个地方也就是在设备驱动程序里，它会及时响应控制器发来的中断请求，并根据这个中断的类型调用响应的&lt;strong&gt;中断处理程序&lt;/strong&gt;进行处理。&lt;/p&gt;
&lt;p&gt;通常，设备驱动程序初始化的时候，要先注册一个该设备的中断处理函数。&lt;/p&gt;
&lt;p&gt;中断处理程序的处理流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 I/O 时，设备控制器如果已经准备好数据，则会通过中断控制器向 CPU 发送中断请求；&lt;/li&gt;
&lt;li&gt;保护被中断进程的 CPU 上下文；&lt;/li&gt;
&lt;li&gt;转入相应的设备中断处理函数；&lt;/li&gt;
&lt;li&gt;进行中断处理；&lt;/li&gt;
&lt;li&gt;恢复被中断进程的上下文；&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;4-通用块层&#34;&gt;4. 通用块层
&lt;/h4&gt;&lt;p&gt;对于块设备，为了减少不同块设备的差异带来的影响，Linux 通过一个统一的&lt;strong&gt;通用块层&lt;/strong&gt;，来管理不同的块设备。&lt;/p&gt;
&lt;p&gt;通用块层是处于文件系统和磁盘驱动中间的一个块设备抽象层，它主要有两个功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个功能，向上为文件系统和应用程序，提供访问块设备的标准接口，向下把各种不同的磁盘设备抽象为统一的块设备，并在内核层面，提供一个框架来管理这些设备的驱动程序；&lt;/li&gt;
&lt;li&gt;第二功能，通用层还会给文件系统和应用程序发来的 I/O 请求排队，接着会对队列重新排序、请求合并等方式，也就是 I/O 调度，主要目的是为了提高磁盘读写的效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;5-存储系统-io-软件分层&#34;&gt;5. 存储系统 I/O 软件分层
&lt;/h4&gt;&lt;p&gt;前面说到了不少东西，设备、设备控制器、驱动程序、通用块层，现在再结合文件系统原理，我们来看看 Linux 存储系统的 I/O 软件分层。&lt;/p&gt;
&lt;p&gt;可以把 Linux 存储系统的 I/O 由上到下可以分为三个层次，分别是文件系统层、通用块层、设备层。他们整个的层次关系如下图：&lt;/p&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/I_O%E8%BD%AF%E4%BB%B6%E5%88%86%E5%B1%82.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;这三个层次的作用是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件系统层，包括虚拟文件系统和其他文件系统的具体实现，它向上为应用程序统一提供了标准的文件访问接口，向下会通过通用块层来存储和管理磁盘数据。&lt;/li&gt;
&lt;li&gt;通用块层，包括块设备的 I/O 队列和 I/O 调度器，它会对文件系统的 I/O 请求进行排队，再通过 I/O 调度器，选择一个 I/O 发给下一层的设备层。&lt;/li&gt;
&lt;li&gt;设备层，包括硬件设备、设备控制器和驱动程序，负责最终物理设备的 I/O 操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了文件系统接口之后，不但可以通过文件系统的命令行操作设备，也可以通过应用程序，调用 &lt;code&gt;read&lt;/code&gt;、&lt;code&gt;write&lt;/code&gt; 函数，就像读写文件一样操作设备，所以说设备在 Linux 下，也只是一个特殊的文件。&lt;/p&gt;
&lt;p&gt;但是，除了读写操作，还需要有检查特定于设备的功能和属性。于是，需要 &lt;code&gt;ioctl&lt;/code&gt; 接口，它表示输入输出控制接口，是用于配置和修改特定设备属性的通用接口。&lt;/p&gt;
&lt;p&gt;另外，存储系统的 I/O 是整个系统最慢的一个环节，所以 Linux 提供了不少缓存机制来提高 I/O 的效率。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了提高文件访问的效率，会使用&lt;strong&gt;页缓存、索引节点缓存、目录项缓存&lt;/strong&gt;等多种缓存机制，目的是为了减少对块设备的直接调用。&lt;/li&gt;
&lt;li&gt;为了提高块设备的访问效率， 会使用&lt;strong&gt;缓冲区&lt;/strong&gt;，来缓存块设备的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;6键盘敲入字母时期间发生了什么&#34;&gt;6.键盘敲入字母时，期间发生了什么？
&lt;/h4&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/CPU%20%E7%A1%AC%E4%BB%B6%E6%80%BB%E7%BA%BF%E5%9B%BE.png&#34; alt=&#34;CPU 的硬件架构图&#34; style=&#34;zoom:25%;&#34; /&gt;
&lt;p&gt;当用户输入了键盘字符，&lt;strong&gt;键盘控制器&lt;/strong&gt;就会产生扫描码数据，并将其缓冲在键盘控制器的寄存器中，紧接着键盘控制器通过总线给 CPU 发送&lt;strong&gt;中断请求&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;CPU 收到中断请求后，操作系统会&lt;strong&gt;保存被中断进程的 CPU 上下文&lt;/strong&gt;，然后调用键盘的&lt;strong&gt;中断处理程序&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;键盘的中断处理程序是在&lt;strong&gt;键盘驱动程序&lt;/strong&gt;初始化时注册的，那键盘&lt;strong&gt;中断处理函数&lt;/strong&gt;的功能就是从键盘控制器的寄存器的缓冲区读取扫描码，再根据扫描码找到用户在键盘输入的字符，如果输入的字符是显示字符，那就会把扫描码翻译成对应显示字符的 ASCII 码，&lt;/p&gt;
&lt;p&gt;得到了显示字符的 ASCII 码后，就会把 ASCII 码放到「读缓冲区队列」，接下来就是要把显示字符显示屏幕了，显示设备的驱动程序会定时从「读缓冲区队列」读取数据放到「写缓冲区队列」，最后把「写缓冲区队列」的数据一个一个写入到显示设备的控制器的寄存器中的数据缓冲区，最后将这些数据显示在屏幕里。&lt;/p&gt;
&lt;p&gt;显示出结果后，&lt;strong&gt;恢复被中断进程的上下文&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;七网络系统&#34;&gt;七、网络系统
&lt;/h2&gt;&lt;h3 id=&#34;71-什么是零拷贝&#34;&gt;7.1 什么是零拷贝？
&lt;/h3&gt;&lt;h4 id=&#34;1为什么要有-dma-技术&#34;&gt;1.为什么要有 DMA 技术?
&lt;/h4&gt;&lt;p&gt;在没有 DMA 技术前，I/O 的过程是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU 发出对应的指令给磁盘控制器，然后返回；&lt;/li&gt;
&lt;li&gt;磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个&lt;strong&gt;中断&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/I_O%20%E4%B8%AD%E6%96%AD.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程。&lt;/p&gt;
&lt;p&gt;简单的搬运几个字符数据那没问题，但是如果我们用千兆网卡或者硬盘传输大量数据的时候，都用 CPU 来搬运的话，肯定忙不过来。&lt;/p&gt;
&lt;p&gt;于是就发明了 DMA 技术，也就是&lt;strong&gt;直接内存访问（Direct Memory Access）&lt;/strong&gt; 技术。&lt;/p&gt;
&lt;p&gt;DMA 技术简单理解就是，&lt;strong&gt;在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;DMA 控制器进行数据传输的过程：&lt;/p&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/DRM%20I_O%20%E8%BF%87%E7%A8%8B.png&#34; alt=&#34;img&#34; style=&#34;zoom:67%;&#34; /&gt;
&lt;p&gt;具体过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；&lt;/li&gt;
&lt;li&gt;操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务；&lt;/li&gt;
&lt;li&gt;DMA 进一步将 I/O 请求发送给磁盘；&lt;/li&gt;
&lt;li&gt;磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；&lt;/li&gt;
&lt;li&gt;CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到， &lt;strong&gt;CPU 不再参与「将数据从磁盘控制器缓冲区搬运到内核空间」的工作，这部分工作全程由 DMA 完成&lt;/strong&gt;。但是 CPU 在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要 CPU 来告诉 DMA 控制器。&lt;/p&gt;
&lt;p&gt;早期 DMA 只存在在主板上，如今由于 I/O 设备越来越多，数据传输的需求也不尽相同，所以每个 I/O 设备里面都有自己的 DMA 控制器。&lt;/p&gt;
&lt;h4 id=&#34;2传统的文件传输有多糟糕&#34;&gt;2.传统的文件传输有多糟糕？
&lt;/h4&gt;&lt;p&gt;传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。&lt;/p&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;p&gt;期间共&lt;strong&gt;发生了 4 次用户态与内核态的上下文切换&lt;/strong&gt;，因为发生了两次系统调用，一次是 &lt;code&gt;read()&lt;/code&gt; ，一次是 &lt;code&gt;write()&lt;/code&gt;，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。&lt;/p&gt;
&lt;p&gt;上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。&lt;/p&gt;
&lt;p&gt;其次，还&lt;strong&gt;发生了 4 次数据拷贝&lt;/strong&gt;，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：&lt;/p&gt;
&lt;p&gt;只是搬运一份数据，结果却搬运了 4 次，过多的数据拷贝无疑会消耗 CPU 资源，大大降低了系统性能。&lt;/p&gt;
&lt;p&gt;这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;3如何优化文件传输的性能&#34;&gt;3.如何优化文件传输的性能？
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;减少「用户态与内核态的上下文切换」的次数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一次系统调用必然会发生 2 次上下文切换：首先从用户态切换到内核态，当内核执行完任务后，再切换回用户态交由进程代码执行。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;要想减少上下文切换到次数，就要减少系统调用的次数&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;减少「数据拷贝」的次数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为文件传输的应用场景中，在用户空间我们并不会对数据「再加工」，所以数据实际上可以不用搬运到用户空间，因此&lt;strong&gt;用户的缓冲区是没有必要存在的&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;mmap + write&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用 &lt;code&gt;mmap()&lt;/code&gt; 替换 &lt;code&gt;read()&lt;/code&gt; 系统调用。&lt;code&gt;mmap()&lt;/code&gt; 系统调用函数会直接把内核缓冲区里的数据「&lt;strong&gt;映射&lt;/strong&gt;」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。&lt;/p&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/mmap%20%2B%20write%20%E9%9B%B6%E6%8B%B7%E8%B4%9D.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;使用 &lt;code&gt;mmap()&lt;/code&gt; 来代替 &lt;code&gt;read()&lt;/code&gt;， 可以减少一次数据拷贝的过程。&lt;/p&gt;
&lt;p&gt;但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;sendfile&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 &lt;code&gt;sendfile()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以替代前面的 &lt;code&gt;read()&lt;/code&gt; 和 &lt;code&gt;write()&lt;/code&gt; 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。&lt;/p&gt;
&lt;p&gt;其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。&lt;/p&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/senfile-3%E6%AC%A1%E6%8B%B7%E8%B4%9D.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;SG-DMA&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果网卡支持 SG-DMA（&lt;em&gt;The Scatter-Gather Direct Memory Access&lt;/em&gt;）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。&lt;/p&gt;
&lt;p&gt;从 Linux 内核 &lt;code&gt;2.4&lt;/code&gt; 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， &lt;code&gt;sendfile()&lt;/code&gt; 系统调用的过程发生了点变化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；&lt;/li&gt;
&lt;li&gt;第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个过程之中，只进行了 2 次数据拷贝&lt;/p&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/senfile-%E9%9B%B6%E6%8B%B7%E8%B4%9D.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;这就是所谓的&lt;strong&gt;零拷贝（Zero-copy）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，&lt;strong&gt;只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，总体来看，&lt;strong&gt;零拷贝技术可以把文件传输的性能提高至少一倍以上&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;4pagecache-有什么作用&#34;&gt;4.PageCache 有什么作用？
&lt;/h4&gt;&lt;p&gt;文件传输过程，第一步都是先需要先把磁盘文件数据拷贝「内核缓冲区」里，这个「内核缓冲区」实际上是&lt;strong&gt;磁盘高速缓存（*PageCache*）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;由于零拷贝使用了 PageCache 技术，可以使得零拷贝进一步提升了性能。&lt;/p&gt;
&lt;p&gt;读写磁盘相比读写内存的速度慢太多了，所以我们应该想办法把「读写磁盘」替换成「读写内存」。内存空间远比磁盘要小，内存注定只能拷贝磁盘里的一小部分数据。&lt;/p&gt;
&lt;p&gt;程序运行的时候，具有「局部性」，所以通常，刚被访问的数据在短时间内再次被访问的概率很高，于是我们可以用 &lt;strong&gt;PageCache 来缓存最近被访问的数据&lt;/strong&gt;，当空间不足时淘汰最久未被访问的缓存。&lt;/p&gt;
&lt;p&gt;所以，读磁盘数据的时候，优先在 PageCache 找，如果数据存在则可以直接返回；如果没有，则从磁盘中读取，然后缓存 PageCache 中。&lt;/p&gt;
&lt;p&gt;还有一点，读取磁盘数据的时候，需要找到数据所在的位置，但是对于机械磁盘来说，就是通过磁头旋转到数据所在的扇区，再开始「顺序」读取数据，但是旋转磁头这个物理动作是非常耗时的，为了降低它的影响，&lt;strong&gt;PageCache 使用了「预读功能」&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;PageCache 的优点主要是两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存最近被访问的数据；&lt;/li&gt;
&lt;li&gt;预读功能；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个做法，将大大提高读写磁盘的性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是，在传输大文件（GB 级别的文件）的时候，PageCache 会不起作用，那就白白浪费 DMA 多做的一次数据拷贝，造成性能的降低，即使使用了 PageCache 的零拷贝也会损失性能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当用户访问这些大文件的时候，内核就会把它们载入 PageCache 中，于是 PageCache 空间很快被这些大文件占满。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于文件太大，可能某些部分的文件数据被再次访问的概率比较低，这样就会带来 2 个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PageCache 由于长时间被大文件占据，其他「热点」的小文件可能就无法充分使用到 PageCache，于是这样磁盘读写的性能就会下降了；&lt;/li&gt;
&lt;li&gt;PageCache 中的大文件数据，由于没有享受到缓存带来的好处，但却耗费 DMA 多拷贝到 PageCache 一次；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;5大文件传输用什么方式实现&#34;&gt;5.大文件传输用什么方式实现？
&lt;/h4&gt;&lt;p&gt;当调用 read 方法读取文件时，进程实际上会阻塞在 read 方法调用，因为要等待磁盘数据的返回，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E9%98%BB%E5%A1%9E%20IO%20%E7%9A%84%E8%BF%87%E7%A8%8B.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E5%BC%82%E6%AD%A5%20IO%20%E7%9A%84%E8%BF%87%E7%A8%8B.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;对于阻塞的问题，可以用异步 I/O 来解决，它工作方式如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E5%BC%82%E6%AD%A5%20IO%20%E7%9A%84%E8%BF%87%E7%A8%8B.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;异步 I/O 并没有涉及到 PageCache，所以使用异步 I/O 就意味着要绕开 PageCache。&lt;/p&gt;
&lt;p&gt;绕开 PageCache 的 I/O 叫直接 I/O，使用 PageCache 的 I/O 则叫缓存 I/O。通常，对于磁盘，异步 I/O 只支持直接 I/O。&lt;/p&gt;
&lt;p&gt;大文件的传输不应该使用 PageCache，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache。&lt;/p&gt;
&lt;p&gt;于是，&lt;strong&gt;在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I/O + 直接 I/O」来替代零拷贝技术&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;直接 I/O 应用场景常见的两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用程序已经实现了磁盘数据的缓存，那么可以不需要 PageCache 再次缓存，减少额外的性能损耗。在 MySQL 数据库中，可以通过参数设置开启直接 I/O，默认是不开启；&lt;/li&gt;
&lt;li&gt;传输大文件的时候，由于大文件难以命中 PageCache 缓存，而且会占满 PageCache 导致「热点」文件无法充分利用缓存，从而增大了性能开销，因此，这时应该使用直接 I/O。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，由于直接 I/O 绕过了 PageCache，就无法享受内核的这两点的优化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内核的 I/O 调度算法会缓存尽可能多的 I/O 请求在 PageCache 中，最后「&lt;strong&gt;合并&lt;/strong&gt;」成一个更大的 I/O 请求再发给磁盘，这样做是为了减少磁盘的寻址操作；&lt;/li&gt;
&lt;li&gt;内核也会「&lt;strong&gt;预读&lt;/strong&gt;」后续的 I/O 请求放在 PageCache 中，一样是为了减少对磁盘的操作；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是，传输大文件的时候，使用「异步 I/O + 直接 I/O」了，就可以无阻塞地读取文件了。&lt;/p&gt;
&lt;p&gt;所以，传输文件的时候，我们要根据文件的大小来使用不同的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传输大文件的时候，使用「异步 I/O + 直接 I/O」；&lt;/li&gt;
&lt;li&gt;传输小文件的时候，则使用「零拷贝技术」；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;72-io-多路复用selectpollepoll&#34;&gt;7.2 I/O 多路复用：select/poll/epoll
&lt;/h3&gt;&lt;h4 id=&#34;1基本的-socket-模型&#34;&gt;1.基本的 Socket 模型
&lt;/h4&gt;&lt;p&gt;创建 Socket 的时候，可以指定网络层使用的是 IPv4 还是 IPv6，传输层使用的是 TCP 还是 UDP。&lt;/p&gt;
&lt;p&gt;服务器的程序要先跑起来，然后等待客户端的连接和数据，我们先来看看服务端的 Socket 编程过程是怎样的。&lt;/p&gt;
&lt;p&gt;服务端首先调用 &lt;code&gt;socket()&lt;/code&gt; 函数，创建网络协议为 IPv4，以及传输协议为 TCP 的 Socket ，接着调用 &lt;code&gt;bind()&lt;/code&gt; 函数，给这个 Socket 绑定一个 &lt;strong&gt;IP 地址和端口&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;绑定端口的目的：当内核收到 TCP 报文，通过 TCP 头里面的端口号，来找到我们的应用程序，然后把数据传递给我们。&lt;/li&gt;
&lt;li&gt;绑定 IP 地址的目的：一台机器是可以有多个网卡的，每个网卡都有对应的 IP 地址，当绑定一个网卡时，内核在收到该网卡上的包，才会发给我们；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;绑定完 IP 地址和端口后，就可以调用 &lt;code&gt;listen()&lt;/code&gt; 函数进行监听，此时对应 TCP 状态图中的 &lt;code&gt;listen&lt;/code&gt;，如果我们要判定服务器中一个网络程序有没有启动，可以通过 &lt;code&gt;netstat&lt;/code&gt; 命令查看对应的端口号是否有被监听。&lt;/p&gt;
&lt;p&gt;服务端进入了监听状态后，通过调用 &lt;code&gt;accept()&lt;/code&gt; 函数，来从内核获取客户端的连接，如果没有客户端连接，则会阻塞等待客户端连接的到来。&lt;/p&gt;
&lt;p&gt;那客户端是怎么发起连接的呢？客户端在创建好 Socket 后，调用 &lt;code&gt;connect()&lt;/code&gt; 函数发起连接，该函数的参数要指明服务端的 IP 地址和端口号，然后万众期待的 TCP 三次握手就开始了。&lt;/p&gt;
&lt;p&gt;在 TCP 连接的过程中，服务器的内核实际上为每个 Socket 维护了两个队列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个是「还没完全建立」连接的队列，称为 &lt;strong&gt;TCP 半连接队列&lt;/strong&gt;，这个队列都是没有完成三次握手的连接，此时服务端处于 &lt;code&gt;syn_rcvd&lt;/code&gt; 的状态；&lt;/li&gt;
&lt;li&gt;一个是「已经建立」连接的队列，称为 &lt;strong&gt;TCP 全连接队列&lt;/strong&gt;，这个队列都是完成了三次握手的连接，此时服务端处于 &lt;code&gt;established&lt;/code&gt; 状态；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当 TCP 全连接队列不为空后，服务端的 &lt;code&gt;accept()&lt;/code&gt; 函数，就会从内核中的 TCP 全连接队列里拿出一个已经完成连接的 Socket 返回应用程序，后续数据传输都用这个 Socket。&lt;/p&gt;
&lt;p&gt;监听的 Socket 和真正用来传数据的 Socket 是两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个叫作&lt;strong&gt;监听 Socket&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;一个叫作&lt;strong&gt;已连接 Socket&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;连接建立后，客户端和服务端就开始相互传输数据了，双方都可以通过 &lt;code&gt;read()&lt;/code&gt; 和 &lt;code&gt;write()&lt;/code&gt; 函数来读写数据。&lt;/p&gt;
&lt;p&gt;整个过程如下图：&lt;/p&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/tcp_socket.png&#34; alt=&#34;img&#34; style=&#34;zoom:33%;&#34; /&gt;
&lt;h4 id=&#34;2如何服务更多的用户&#34;&gt;2.如何服务更多的用户？
&lt;/h4&gt;&lt;p&gt;前面提到的 TCP Socket 调用流程是最简单、最基本的，它基本只能一对一通信，因为使用的是同步阻塞的方式，当服务端在还没处理完一个客户端的网络 I/O 时，或者 读写操作发生阻塞时，其他客户端是无法与服务端连接的。&lt;/p&gt;
&lt;p&gt;可如果我们服务器只能服务一个客户，那这样就太浪费资源了，于是我们要改进这个网络 I/O 模型，以支持更多的客户端。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;服务器单机理论最大能连接多少个客户端？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相信你知道 TCP 连接是由四元组唯一确认的，这个四元组就是：&lt;strong&gt;本机IP, 本机端口, 对端IP, 对端端口&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;服务器作为服务方，通常会在本地固定监听一个端口，等待客户端的连接。因此服务器的本地 IP 和端口是固定的，于是对于服务端 TCP 连接的四元组只有对端 IP 和端口是会变化的，所以&lt;strong&gt;最大 TCP 连接数 = 客户端 IP 数×客户端端口数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是&lt;strong&gt;服务端单机最大 TCP 连接数约为 2 的 48 次方&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这个理论值相当“丰满”，但是服务器肯定承载不了那么大的连接数，主要会受两个方面的限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;文件描述符&lt;/strong&gt;，Socket 实际上是一个文件，也就会对应一个文件描述符。在 Linux 下，单个进程打开的文件描述符数是有限制的，没有经过修改的值一般都是 1024，不过我们可以通过 ulimit 增大文件描述符的数目；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统内存&lt;/strong&gt;，每个 TCP 连接在内核中都有对应的数据结构，意味着每个连接都是会占用一定内存的；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那如果服务器的内存只有 2 GB，网卡是千兆的，能支持并发 1 万请求吗？&lt;/p&gt;
&lt;p&gt;并发 1 万请求，也就是经典的 C10K 问题 ，C 是 Client 单词首字母缩写，C10K 就是单机同时处理 1 万个请求的问题。&lt;/p&gt;
&lt;p&gt;从硬件资源角度看，对于 2GB 内存千兆网卡的服务器，如果每个请求处理占用不到 200KB 的内存和 100Kbit 的网络带宽就可以满足并发 1 万个请求。&lt;/p&gt;
&lt;p&gt;不过，要想真正实现 C10K 的服务器，要考虑的地方在于服务器的网络 I/O 模型，效率低的模型，会加重系统开销，从而会离 C10K 的目标越来越远。&lt;/p&gt;
&lt;h4 id=&#34;3多进程模型&#34;&gt;3.多进程模型
&lt;/h4&gt;&lt;p&gt;基于最原始的阻塞网络 I/O， 如果服务器要支持多个客户端，其中比较传统的方式，就是使用&lt;strong&gt;多进程模型&lt;/strong&gt;，也就是为每个客户端分配一个进程来处理请求。&lt;/p&gt;
&lt;p&gt;服务器的主进程负责监听客户的连接，一旦与客户端连接完成，accept() 函数就会返回一个「已连接 Socket」，这时就通过 &lt;code&gt;fork()&lt;/code&gt; 函数创建一个子进程，实际上就把父进程所有相关的东西都&lt;strong&gt;复制&lt;/strong&gt;一份，包括文件描述符、内存地址空间、程序计数器、执行的代码等。&lt;/p&gt;
&lt;p&gt;这两个进程刚复制完的时候，几乎一模一样。不过，会根据&lt;strong&gt;返回值&lt;/strong&gt;来区分是父进程还是子进程，如果返回值是 0，则是子进程；如果返回值是其他的整数，就是父进程。&lt;/p&gt;
&lt;p&gt;正因为子进程会&lt;strong&gt;复制父进程的文件描述符&lt;/strong&gt;，于是就可以直接使用「已连接 Socket 」和客户端通信了，&lt;/p&gt;
&lt;p&gt;可以发现，子进程不需要关心「监听 Socket」，只需要关心「已连接 Socket」；父进程则相反，将客户服务交给子进程来处理，因此父进程不需要关心「已连接 Socket」，只需要关心「监听 Socket」。&lt;/p&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/%E5%A4%9A%E8%BF%9B%E7%A8%8B.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;另外，当「子进程」退出时，实际上内核里还会保留该进程的一些信息，也是会占用内存的，如果不做好“回收”工作，就会变成&lt;strong&gt;僵尸进程&lt;/strong&gt;，随着僵尸进程越多，会慢慢耗尽我们的系统资源。&lt;/p&gt;
&lt;p&gt;因此，父进程要“善后”好自己的孩子，怎么善后呢？那么有两种方式可以在子进程退出后回收资源，分别是调用 &lt;code&gt;wait()&lt;/code&gt; 和 &lt;code&gt;waitpid()&lt;/code&gt; 函数。&lt;/p&gt;
&lt;p&gt;这种用多个进程来应付多个客户端的方式，在应对 100 个客户端还是可行的，但是当客户端数量高达一万时，肯定扛不住的，因为每产生一个进程，必会占据一定的系统资源，而且进程间上下文切换的“包袱”是很重的，性能会大打折扣。&lt;/p&gt;
&lt;p&gt;进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。&lt;/p&gt;
&lt;h4 id=&#34;4多线程模型&#34;&gt;4.多线程模型
&lt;/h4&gt;&lt;p&gt;既然进程间上下文切换的“包袱”很重，那我们就搞个比较轻量级的模型来应对多用户的请求 —— &lt;strong&gt;多线程模型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;单进程中可以运行多个线程，同进程里的线程可以共享进程的部分资源，比如文件描述符列表、进程空间、代码、全局数据、堆、共享库等，这些共享些资源在上下文切换时不需要切换，而只需要切换线程的私有数据、寄存器等不共享的数据，因此同一个进程下的线程上下文切换的开销要比进程小得多。&lt;/p&gt;
&lt;p&gt;当服务器与客户端 TCP 完成连接后，通过 &lt;code&gt;pthread_create()&lt;/code&gt; 函数创建线程，然后将「已连接 Socket」的文件描述符传递给线程函数，接着在线程里和客户端进行通信，从而达到并发处理的目的。&lt;/p&gt;
&lt;p&gt;如果每来一个连接就创建一个线程，线程运行完后，还得操作系统还得销毁线程，虽说线程切换的上写文开销不大，但是如果频繁创建和销毁线程，系统开销也是不小的。&lt;/p&gt;
&lt;p&gt;那么，我们可以使用&lt;strong&gt;线程池&lt;/strong&gt;的方式来避免线程的频繁创建和销毁，所谓的线程池，就是提前创建若干个线程，这样当由新连接建立时，将这个已连接的 Socket 放入到一个队列里，然后线程池里的线程负责从队列中取出「已连接 Socket 」进行处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是，这个队列是全局的，每个线程都会操作，为了避免多线程竞争，线程在操作这个队列前要加锁。&lt;/p&gt;
&lt;p&gt;上面基于进程或者线程模型的，其实还是有问题的。新到来一个 TCP 连接，就需要分配一个进程或者线程，那么如果要达到 C10K，意味着要一台机器维护 1 万个连接，相当于要维护 1 万个进程/线程，操作系统就算死扛也是扛不住的。&lt;/p&gt;
&lt;h4 id=&#34;5io-多路复用&#34;&gt;5.I/O 多路复用
&lt;/h4&gt;&lt;p&gt;既然为每个请求分配一个进程/线程的方式不合适，那有没有可能只使用一个进程来维护多个 Socket 呢？答案是有的，那就是 &lt;strong&gt;I/O 多路复用&lt;/strong&gt;技术。&lt;/p&gt;
&lt;p&gt;一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用，这种思想很类似一个 CPU 并发多个进程，所以也叫做时分多路复用。&lt;/p&gt;
&lt;p&gt;我们熟悉的 select/poll/epoll 内核提供给用户态的多路复用系统调用，&lt;strong&gt;进程可以通过一个系统调用函数从内核中获取多个事件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;select/poll/epoll 是如何获取网络事件的呢？在获取事件时，先把所有连接（文件描述符）传给内核，再由内核返回产生了事件的连接，然后在用户态中再处理这些连接对应的请求即可。&lt;/p&gt;
&lt;h4 id=&#34;6selectpoll&#34;&gt;6.select/poll
&lt;/h4&gt;&lt;p&gt;select 实现多路复用的方式是，将已连接的 Socket 都放到一个&lt;strong&gt;文件描述符集合&lt;/strong&gt;，然后调用 select 函数将文件描述符集合&lt;strong&gt;拷贝&lt;/strong&gt;到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过&lt;strong&gt;遍历&lt;/strong&gt;文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合&lt;strong&gt;拷贝&lt;/strong&gt;回用户态里，然后用户态还需要再通过&lt;strong&gt;遍历&lt;/strong&gt;的方法找到可读或可写的 Socket，然后再对其处理。&lt;/p&gt;
&lt;p&gt;所以，对于 select 这种方式，需要进行 &lt;strong&gt;2 次「遍历」文件描述符集合&lt;/strong&gt;，一次是在内核态里，一个次是在用户态里 ，而且还会发生 &lt;strong&gt;2 次「拷贝」文件描述符集合&lt;/strong&gt;，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。&lt;/p&gt;
&lt;p&gt;select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 &lt;code&gt;1024&lt;/code&gt;，只能监听 0~1023 的文件描述符。&lt;/p&gt;
&lt;p&gt;poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。&lt;/p&gt;
&lt;p&gt;但是 poll 和 select 并没有太大的本质区别，&lt;strong&gt;都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合&lt;/strong&gt;，这种方式随着并发数上来，性能的损耗会呈指数级增长。&lt;/p&gt;
&lt;h4 id=&#34;epoll&#34;&gt;epoll
&lt;/h4&gt;&lt;p&gt;先复习下 epoll 的用法。如下的代码中，先用e poll_create 创建一个 epol l对象 epfd，再通过 epoll_ctl 将需要监视的 socket 添加到epfd中，最后调用 epoll_wait 等待数据。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;socket&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AF_INET&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SOCK_STREAM&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;listen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;epfd&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;epoll_create&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(...);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;epoll_ctl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;epfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//将所有需要监听的socket添加到epfd中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;epoll_wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(...);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;接收到数据的&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;socket&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;//处理
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;epoll 通过两个方面，很好解决了 select/poll 的问题。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;第一点&lt;/em&gt;，epoll 在内核里使用&lt;strong&gt;红黑树来跟踪进程所有待检测的文件描述字&lt;/strong&gt;，把需要监控的 socket 通过 &lt;code&gt;epoll_ctl()&lt;/code&gt; 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 &lt;code&gt;O(logn)&lt;/code&gt;。而 select/poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以 select/poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;第二点&lt;/em&gt;， epoll 使用&lt;strong&gt;事件驱动&lt;/strong&gt;的机制，内核里&lt;strong&gt;维护了一个链表来记录就绪事件&lt;/strong&gt;，当某个 socket 有事件发生时，通过&lt;strong&gt;回调函数&lt;/strong&gt;内核会将其加入到这个就绪事件列表中，当用户调用 &lt;code&gt;epoll_wait()&lt;/code&gt; 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。&lt;/p&gt;
&lt;p&gt;epoll 的方式即使监听的 Socket 数量越多的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常的多了，上限就为系统定义的进程打开的最大文件描述符个数。因而，&lt;strong&gt;epoll 被称为解决 C10K 问题的利器&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;边缘触发和水平触发&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;epoll 支持两种事件触发模式，分别是&lt;strong&gt;边缘触发（*edge-triggered，ET*）**和**水平触发（*level-triggered，LT*）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这两个术语还挺抽象的，其实它们的区别还是很好理解的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，&lt;strong&gt;服务器端只会从 epoll_wait 中苏醒一次&lt;/strong&gt;，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；&lt;/li&gt;
&lt;li&gt;使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，&lt;strong&gt;服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束&lt;/strong&gt;，目的是告诉我们有数据需要读取；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果使用边缘触发模式，I/O 事件发生时只会通知一次，而且我们不知道到底能读写多少数据，所以在收到通知后应尽可能地读写数据，以免错失读写的机会。因此，我们会&lt;strong&gt;循环&lt;/strong&gt;从文件描述符读写数据，那么如果文件描述符是阻塞的，没有数据可读写时，进程会阻塞在读写函数那里，程序就没办法继续往下执行。所以，&lt;strong&gt;边缘触发模式一般和非阻塞 I/O 搭配使用&lt;/strong&gt;，程序会一直执行 I/O 操作，直到系统调用（如 &lt;code&gt;read&lt;/code&gt; 和 &lt;code&gt;write&lt;/code&gt;）返回错误，错误类型为 &lt;code&gt;EAGAIN&lt;/code&gt; 或 &lt;code&gt;EWOULDBLOCK&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。&lt;/p&gt;
&lt;p&gt;select/poll 只有水平触发模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。&lt;/p&gt;
&lt;p&gt;另外，使用 I/O 多路复用时，最好搭配非阻塞 I/O 一起使用，&lt;strong&gt;多路复用 API 返回的事件并不一定可读写的&lt;/strong&gt;，如果使用阻塞 I/O， 那么在调用 read/write 时则会发生程序阻塞，因此最好搭配非阻塞 I/O，以便应对极少数的特殊情况。&lt;/p&gt;
&lt;h4 id=&#34;总结-1&#34;&gt;总结
&lt;/h4&gt;&lt;p&gt;最基础的 TCP 的 Socket 编程，它是阻塞 I/O 模型，基本上只能一对一通信，那为了服务更多的客户端，我们需要改进网络 I/O 模型。&lt;/p&gt;
&lt;p&gt;比较传统的方式是使用多进程/线程模型，每来一个客户端连接，就分配一个进程/线程，然后后续的读写都在对应的进程/线程，这种方式处理 100 个客户端没问题，但是当客户端增大到 10000 个时，10000 个进程/线程的调度、上下文切换以及它们占用的内存，都会成为瓶颈。&lt;/p&gt;
&lt;p&gt;为了解决上面这个问题，就出现了 I/O 的多路复用，可以只在一个进程里处理多个文件的 I/O，Linux 下有三种提供 I/O 多路复用的 API，分别是：select、poll、epoll。&lt;/p&gt;
&lt;p&gt;select 和 poll 并没有本质区别，它们内部都是使用「线性结构」来存储进程关注的 Socket 集合。&lt;/p&gt;
&lt;p&gt;在使用的时候，首先需要把关注的 Socket 集合通过 select/poll 系统调用从用户态拷贝到内核态，然后由内核检测事件，当有网络事件产生时，内核需要遍历进程关注 Socket 集合，找到对应的 Socket，并设置其状态为可读/可写，然后把整个 Socket 集合从内核态拷贝到用户态，用户态还要继续遍历整个 Socket 集合找到可读/可写的 Socket，然后对其处理。&lt;/p&gt;
&lt;p&gt;很明显发现，select 和 poll 的缺陷在于，当客户端越多，也就是 Socket 集合越大，Socket 集合的遍历和拷贝会带来很大的开销，因此也很难应对 C10K。&lt;/p&gt;
&lt;p&gt;epoll 是解决 C10K 问题的利器，通过两个方面解决了 select/poll 的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;epoll 在内核里使用「红黑树」来关注进程所有待检测的 Socket，红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)，通过对这棵黑红树的管理，不需要像 select/poll 在每次操作时都传入整个 Socket 集合，减少了内核和用户空间大量的数据拷贝和内存分配。&lt;/li&gt;
&lt;li&gt;epoll 使用事件驱动的机制，内核里维护了一个「链表」来记录就绪事件，只将有事件发生的 Socket 集合传递给应用程序，不需要像 select/poll 那样轮询扫描整个集合（包含有和无事件的 Socket ），大大提高了检测的效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而且，epoll 支持边缘触发和水平触发的方式，而 select/poll 只支持水平触发，一般而言，边缘触发的方式会比水平触发的效率高。&lt;/p&gt;
&lt;h3 id=&#34;73-高性能网络模式reactor-和-proactor&#34;&gt;7.3 高性能网络模式：Reactor 和 Proactor
&lt;/h3&gt;&lt;h3 id=&#34;74-什么是一致性哈希&#34;&gt;7.4 什么是一致性哈希？
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;一致性哈希是什么，使用场景，解决了什么问题？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大多数网站背后肯定不是只有一台服务器提供服务，因为单机的并发量和数据量都是有限的，所以都会用多台服务器构成集群来对外提供服务。&lt;/p&gt;
&lt;p&gt;但是问题来了，现在有那么多个节点（后面统称服务器为节点，因为少一个字），要如何分配客户端的请求呢？&lt;/p&gt;
&lt;p&gt;&amp;hellip;&lt;/p&gt;
&lt;h2 id=&#34;面经题&#34;&gt;面经题
&lt;/h2&gt;&lt;h3 id=&#34;信号量和互斥量&#34;&gt;信号量和互斥量
&lt;/h3&gt;&lt;p&gt;信号量和互斥量都是线程同步的工具，主要用于多个线程之间对共享资源的访问控制。它们的区别主要在于对共享资源的控制方式和应用场景的不同。&lt;/p&gt;
&lt;p&gt;互斥量是一种独占式的锁，即只有一个线程能够持有互斥量并访问共享资源，其他线程需要等待该线程释放锁之后才能访问。互斥量主要用于对临界区的保护，即对共享资源的访问需要互斥进行。&lt;/p&gt;
&lt;p&gt;信号量是一种计数器，主要用于控制对有限资源的访问。它可以对共享资源的访问进行控制，但并不是独占的，即多个线程可以同时持有信号量并访问共享资源。信号量的计数器可以增加或减少，当计数器为0时，等待该信号量的线程将被阻塞，直到计数器大于0为止。&lt;/p&gt;
&lt;p&gt;应用场景上，互斥量通常用于对共享资源的独占访问，例如文件访问、共享内存等；而信号量主要用于控制对有限资源的访问，例如进程数、线程数、信号量数量等。&lt;/p&gt;
&lt;h3 id=&#34;cpu的轮询和中断模式&#34;&gt;CPU的轮询和中断模式
&lt;/h3&gt;&lt;p&gt;CPU的轮询和中断模式是计算机硬件中两种基本的处理器工作方式。&lt;/p&gt;
&lt;p&gt;轮询模式是指CPU不断地查询外设的状态寄存器，以确定是否有新的数据需要处理。CPU会不断地循环查询，直到数据到达才能处理，这种方式通常会占用大量的CPU时间，且效率不高。&lt;/p&gt;
&lt;p&gt;中断模式是指CPU将控制权交给外设，等待外设向CPU发出中断信号，CPU收到中断信号后，立即停止当前任务，跳转到中断服务程序处理中断请求。中断模式通常比轮询模式效率更高，能够使CPU在等待外设数据的过程中，可以处理其他任务。&lt;/p&gt;
&lt;p&gt;在实际应用中，中断模式通常比轮询模式更为常用，因为它能够充分利用CPU的时间，提高系统的响应速度。但是中断模式需要进行上下文切换和中断处理，会增加CPU的负担，因此在一些对实时性要求极高的应用场合，还是会使用轮询模式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;浅拷贝和深拷贝是指在对象复制时，是否复制对象内部的数据。浅拷贝只复制对象的指针或引用，而不复制对象的数据；深拷贝则会复制对象的所有数据。多态是指同一种操作作用于不同的对象，可以有不同的实现方式。在C++中，多态可以通过虚函数和继承来实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;flash和内存的区别&#34;&gt;Flash和内存的区别
&lt;/h3&gt;&lt;p&gt;Flash和内存是两种不同的存储设备，它们之间的区别如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;存储介质不同：Flash是一种闪存储存介质，通常用于存储非易失性数据，例如程序代码、数据配置等。而内存是一种易失性存储介质，通常用于暂存数据和程序运行时所需要的临时数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读写方式不同：Flash存储的数据是按块（block）读写的，一般每个块的大小为数十KB到数百KB不等，而内存存储的数据是按字节（byte）读写的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;速度和容量不同：Flash的读写速度较慢，一般比内存慢几倍或更多，但Flash存储容量较大，可以存储数GB的数据。而内存读写速度较快，但存储容量较小，一般只有数MB或几十MB。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用场景不同：Flash适用于需要存储非易失性数据的场合，例如嵌入式设备的程序代码、配置数据等。而内存适用于需要快速读写临时数据的场合，例如计算机运行程序时的临时数据、缓存等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总的来说，Flash和内存都是计算机系统中重要的存储设备，各有自己的优势和不同的应用场景。&lt;/p&gt;
&lt;h3 id=&#34;多线程之间要传输大量的数据如何实现&#34;&gt;多线程之间要传输大量的数据，如何实现？
&lt;/h3&gt;&lt;p&gt;多线程之间要传输大量的数据，可以使用共享内存实现。共享内存是指多个进程可以访问同一块内存空间，其中一个进程将数据写入共享内存，其它进程则可以读取这些数据。&lt;/p&gt;
&lt;p&gt;在多线程中，使用共享内存需要注意线程同步和互斥。可以使用互斥锁和条件变量来确保共享内存的同步和互斥访问。同时，需要考虑内存分配和释放的问题，以避免出现内存泄漏和访问非法内存的问题。&lt;/p&gt;
&lt;h3 id=&#34;有名管道与匿名管道区别&#34;&gt;有名管道与匿名管道区别？
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;命名方式：有名管道通过在文件系统中创建一个特殊的文件来命名，可以用于任意进程之间的通信；而匿名管道没有文件名，只能用于有亲缘关系的进程之间的通信，如父进程与子进程之间的通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;持续性：有名管道是持久化的，直到显示删除文件为止；而匿名管道则是暂时存在的，只在创建的进程关闭后才会被自动删除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以用于通信的进程数量：有名管道可以用于多个进程之间的通信；而匿名管道只能用于两个进程之间的通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件描述符：有名管道和匿名管道都是文件描述符，可以像操作普通文件一样操作它们，如读写等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;线程进程间通信方式&#34;&gt;线程，进程间通信方式？
&lt;/h3&gt;&lt;p&gt;线程和进程之间可以通过多种方式进行通信，以下是一些常见的通信方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;共享内存：多个进程或线程可以访问同一个内存区域，从而实现数据共享。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;管道：一种半双工的通信方式，可以实现两个进程或线程之间的通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消息队列：可以实现多个进程或线程之间的异步通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号量：可以用来控制进程或线程的同步和互斥，也可以用来实现进程或线程间的通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号：进程可以向另一个进程或线程发送信号，通知其发生了某个事件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;套接字：可以实现不同机器之间的进程或线程通信，也可以实现同一机器上不同进程或线程之间的通信。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;现在多个线程怎么确定哪一个会先被执行&#34;&gt;现在多个线程，怎么确定哪一个会先被执行？
&lt;/h3&gt;&lt;p&gt;在多线程编程中，不能确保哪个线程会先执行，因为线程的执行顺序是不可预测的。线程的调度是由操作系统内核完成的，操作系统根据调度算法来决定下一个要执行的线程。因此，多个线程之间的执行顺序是不确定的，它取决于线程的优先级、时间片大小以及线程的阻塞和唤醒状态等因素。对于程序员来说，我们只能通过线程的同步和互斥机制来控制线程之间的执行顺序，以达到我们期望的结果。&lt;/p&gt;
&lt;h3 id=&#34;多个进程在获取不到锁的时候会进入什么状态&#34;&gt;多个进程在获取不到锁的时候会进入什么状态？
&lt;/h3&gt;&lt;p&gt;当多个进程在获取锁时，如果锁被占用，则进程会进入睡眠状态，等待锁的释放。在Linux中，进程等待锁的时候会进入阻塞状态，此时进程会被挂起，不再被调度器调度，直到锁被释放。进程被阻塞时，会从调度器的活动进程列表中移除，直到进程重新变成可运行状态时，才会再次被加入调度器的活动进程列表，等待被调度器调度。&lt;/p&gt;
&lt;h3 id=&#34;假设一个低优先的进程a获取先到锁高优先级的进程b获取不到锁那高优先级进程b的进行也会阻塞吗&#34;&gt;假设一个低优先的进程A获取先到锁，高优先级的进程B获取不到锁，那高优先级进程B的进行也会阻塞吗？
&lt;/h3&gt;&lt;p&gt;如果高优先级的进程B尝试获取的是阻塞锁（也称为互斥锁），那么B会阻塞直到获取到锁。如果高优先级的进程B尝试获取的是非阻塞锁（例如自旋锁），则B会在获取不到锁的情况下忙等待，而不会阻塞。无论是阻塞还是忙等待，高优先级进程的执行都会被阻塞，直到获取到锁为止。&lt;/p&gt;
&lt;h3 id=&#34;在用户态开发中程序跑飞出现段错误等情况用通过什么方式去定位&#34;&gt;在用户态开发中程序跑飞，出现段错误等情况，用通过什么方式去定位？
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用gdb调试工具：可以使用gdb设置断点，单步执行程序，查看内存、寄存器的值等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用valgrind工具：valgrind是一种内存调试和性能分析工具，可以检测内存泄漏、使用未初始化的内存、访问越界等问题。使用valgrind可以在程序运行时监视程序的行为，从而检测出一些常见的错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用coredump文件：当程序出现崩溃时，系统会生成一个coredump文件，其中包含了程序崩溃时的内存状态。可以使用gdb加载这个文件，进行调试。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用日志文件：程序可以在运行过程中输出日志信息，包括各种变量的值、函数的调用情况等等。可以根据这些信息定位问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;信号量机制怎么实现的该机制可以用于进程间通信吗&#34;&gt;信号量机制怎么实现的？该机制可以用于进程间通信吗？
&lt;/h3&gt;&lt;p&gt;信号量机制是一种用于多线程或多进程同步的机制，通常用于控制对共享资源的访问。在Linux中，信号量可以通过semaphore.h头文件中提供的函数来实现。&lt;/p&gt;
&lt;p&gt;具体实现中，使用一个计数器来跟踪共享资源的数量，当需要访问共享资源时，线程或进程会尝试获取一个信号量。如果信号量的计数器大于0，则表示可以访问共享资源，计数器会减1，线程或进程可以访问共享资源；如果计数器等于0，则表示共享资源已经被占用，线程或进程需要等待信号量释放后再尝试获取。&lt;/p&gt;
&lt;h3 id=&#34;线程一般是怎么调度的&#34;&gt;线程一般是怎么调度的？
&lt;/h3&gt;&lt;p&gt;Linux中的线程调度是通过调度器（scheduler）来完成的。调度器根据各个线程的优先级和调度策略，选择哪个线程应该在当前时刻运行。Linux中线程调度的主要策略是基于时间片的轮询调度（Round-Robin Scheduling），即每个线程分配一个时间片，当时间片用完后，调度器会将当前运行的线程挂起，然后选择一个新的线程运行。如果线程的时间片还没有用完，但是有更高优先级的线程需要运行，调度器会暂停当前线程，运行优先级更高的线程。这种调度方式可以保证每个线程在有限的时间内得到运行，避免某个线程一直占用CPU导致其他线程无法运行。&lt;/p&gt;
&lt;p&gt;除了时间片轮询调度外，Linux还提供了其他调度策略，如实时调度（Real-Time Scheduling）和优先级调度（Priority Scheduling），可以根据应用场景和需求进行选择。&lt;/p&gt;
&lt;h3 id=&#34;信号量互斥锁消息队列具体是怎么实现的&#34;&gt;信号量互斥锁消息队列具体是怎么实现的
&lt;/h3&gt;&lt;p&gt;信号量、互斥锁和消息队列都是常用的进程间通信机制，它们的具体实现方式如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;信号量（Semaphore）：信号量是一种用于多进程或者多线程编程中的同步原语，用于保护共享资源的访问。在Linux中，信号量可以使用信号量集（Semaphore Set）来实现。具体来说，每个信号量集由一个唯一的键值（Key）、一个信号量计数器以及一些信号量操作（P、V操作）组成。&lt;/li&gt;
&lt;li&gt;互斥锁（Mutex）：互斥锁也是用于保护共享资源的访问，但是只能被一个线程或进程持有，其他线程或进程要访问该资源时必须等待当前持有者释放锁。在Linux中，互斥锁可以使用pthread_mutex_t结构体和相关API来实现。&lt;/li&gt;
&lt;li&gt;消息队列（Message Queue）：消息队列是一种进程间通信机制，用于在不同进程之间传递数据。在Linux中，消息队列可以通过System V IPC或POSIX IPC API来实现。具体来说，消息队列是一个有名管道，每个消息都包含一个类型和一个数据块，进程可以通过指定类型来读取特定的消息。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;条件变量怎么实现&#34;&gt;条件变量怎么实现？
&lt;/h3&gt;&lt;p&gt;条件变量是多线程编程中一种同步机制，它允许线程在满足特定条件之前等待，当满足条件时，线程会被唤醒并执行相应操作。&lt;/p&gt;
&lt;p&gt;在Linux中，条件变量通常使用pthread_cond_t类型来表示，它可以与互斥量（pthread_mutex_t）结合使用。条件变量提供了三个主要的操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;pthread_cond_init()：初始化条件变量。&lt;/li&gt;
&lt;li&gt;pthread_cond_wait()：等待条件变量，如果条件不成立，则线程被阻塞，直到条件变量被唤醒。&lt;/li&gt;
&lt;li&gt;pthread_cond_signal()：唤醒等待条件变量的线程。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;程序包含两个线程：一个增加计数器的线程和一个等待计数器达到5的线程。增加计数器的线程在每次增加计数器后检查计数器是否等于5，如果是，则发送信号通知等待线程。等待线程在等待条件变量时被阻塞，直到计数器达到5，然后打印消息并退出。&lt;/p&gt;
&lt;p&gt;条件变量可以用于进程间通信，但只能用于在同一进程内创建的线程之间共享数据。如果要在不同进程之间共享数据，则需要使用其他机制，如共享内存或消息队列。&lt;/p&gt;
&lt;h3 id=&#34;可执行程序的后缀是什么它的内存开始地址是什么空间范围是多少&#34;&gt;可执行程序的后缀是什么？它的内存开始地址是什么？空间范围是多少？
&lt;/h3&gt;&lt;p&gt;可执行程序的后缀在不同的操作系统中可能会有所不同，比如在Windows中是“.exe”或“.dll”，在Linux中是没有后缀的可执行文件。&lt;/p&gt;
&lt;p&gt;可执行程序的内存开始地址和空间范围则取决于操作系统和程序的具体实现方式。在大多数操作系统中，可执行程序的内存空间是由操作系统分配的，一般从虚拟内存地址的低地址开始分配。对于32位操作系统，可执行程序的内存空间范围通常是从0x08048000到0xFFFFFFFF，而64位操作系统的可执行程序内存空间则更大。&lt;/p&gt;
&lt;h3 id=&#34;程序出现挂死的现象如何进行调试&#34;&gt;程序出现挂死的现象，如何进行调试？
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;打印日志：在程序中加入打印日志的语句，可以输出程序执行到的位置，以及一些变量的值，有助于定位问题。&lt;/li&gt;
&lt;li&gt;使用调试工具：比如GDB、LLDB等调试工具，可以对程序进行单步调试、查看变量的值等操作，可以帮助我们快速定位问题。&lt;/li&gt;
&lt;li&gt;模块化设计：程序模块化设计可以将程序拆分成若干个小模块，方便对问题进行定位和排查。&lt;/li&gt;
&lt;li&gt;代码静态分析：使用代码静态分析工具可以检测出代码中的潜在问题，比如内存泄漏、空指针等，有助于避免程序出现挂死等问题。&lt;/li&gt;
&lt;li&gt;硬件调试：如果程序挂死与硬件有关，可以使用硬件调试工具，比如逻辑分析仪、示波器等，来检测硬件是否正常工作。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;计算机网络&#34;&gt;计算机网络
&lt;/h1&gt;&lt;h2 id=&#34;一基础篇&#34;&gt;一、基础篇
&lt;/h2&gt;&lt;h3 id=&#34;21-tcpip-网络模型有哪几层&#34;&gt;2.1 TCP/IP 网络模型有哪几层？
&lt;/h3&gt;&lt;h4 id=&#34;应用层&#34;&gt;应用层
&lt;/h4&gt;&lt;p&gt;电脑或手机使用的应用软件都是在应用层实现。那么，当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用层专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。&lt;/li&gt;
&lt;li&gt;应用层是不用去关心数据是如何传输的。&lt;/li&gt;
&lt;li&gt;应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;传输层&#34;&gt;传输层
&lt;/h4&gt;&lt;p&gt;应用层的数据包会传给传输层，&lt;strong&gt;传输层&lt;/strong&gt;（&lt;em&gt;Transport Layer&lt;/em&gt;）是为应用层提供网络支持的。&lt;/p&gt;
&lt;p&gt;在传输层会有两个传输协议，分别是 TCP 和 UDP。&lt;/p&gt;
&lt;p&gt;TCP 的全称叫传输控制协议（&lt;em&gt;Transmission Control Protocol&lt;/em&gt;），大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如&lt;strong&gt;流量控制、超时重传、拥塞控制&lt;/strong&gt;等，这些都是为了保证数据包能可靠地传输给对方。&lt;/p&gt;
&lt;p&gt;UDP 相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。&lt;/p&gt;
&lt;p&gt;应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个 &lt;strong&gt;TCP 段&lt;/strong&gt;（&lt;em&gt;TCP Segment&lt;/em&gt;）。&lt;/p&gt;
&lt;p&gt;当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是&lt;strong&gt;端口&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;比如 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。&lt;/p&gt;
&lt;p&gt;由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。&lt;/p&gt;
&lt;h4 id=&#34;网络层&#34;&gt;网络层
&lt;/h4&gt;&lt;p&gt;不希望传输层协议处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是&lt;strong&gt;网络层&lt;/strong&gt;（&lt;em&gt;Internet Layer&lt;/em&gt;）。&lt;/p&gt;
&lt;p&gt;网络层最常使用的是 IP 协议（&lt;em&gt;Internet Protocol&lt;/em&gt;），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会&lt;strong&gt;再次进行分片&lt;/strong&gt;，得到一个即将发送到网络的 IP 报文。&lt;/p&gt;
&lt;p&gt;一般用 IP 地址给设备进行编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。只有一个单纯的 IP 地址虽然做到了区分设备，但是寻址起来就特别麻烦，全世界那么多台设备，难道一个一个去匹配？这显然不科学。&lt;/p&gt;
&lt;p&gt;因此，需要将 IP 地址分成两种意义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个是&lt;strong&gt;网络号&lt;/strong&gt;，负责标识该 IP 地址是属于哪个「子网」的；&lt;/li&gt;
&lt;li&gt;一个是&lt;strong&gt;主机号&lt;/strong&gt;，负责标识同一「子网」下的不同主机；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;怎么分的呢？这需要配合&lt;strong&gt;子网掩码&lt;/strong&gt;才能算出 IP 地址 的网络号和主机号。&lt;/p&gt;
&lt;p&gt;举个例子，比如 10.100.122.0/24，后面的&lt;code&gt;/24&lt;/code&gt;表示就是 &lt;code&gt;255.255.255.0&lt;/code&gt; 子网掩码，255.255.255.0 二进制是「11111111-11111111-11111111-00000000」，大家数数一共多少个1？不用数了，是 24 个1，为了简化子网掩码的表示，用/24代替255.255.255.0。&lt;/p&gt;
&lt;p&gt;知道了子网掩码，该怎么计算出网络地址和主机地址呢？&lt;/p&gt;
&lt;p&gt;将 10.100.122.2 和 255.255.255.0 进行&lt;strong&gt;按位与运算&lt;/strong&gt;，就可以得到网络号，&lt;/p&gt;
&lt;p&gt;将 255.255.255.0 取反后与IP地址进行进行&lt;strong&gt;按位与运算&lt;/strong&gt;，就可以得到主机号。&lt;/p&gt;
&lt;p&gt;IP 协议还有另一个重要的能力就是&lt;strong&gt;路由&lt;/strong&gt;。实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。&lt;/p&gt;
&lt;p&gt;路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;网络接口层&#34;&gt;网络接口层
&lt;/h4&gt;&lt;p&gt;生成了 IP 头部之后，接下来要交给&lt;strong&gt;网络接口层&lt;/strong&gt;（&lt;em&gt;Link Layer&lt;/em&gt;）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。&lt;/p&gt;
&lt;p&gt;IP 头部中的接收方 IP 地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，这个思路是行不通的。&lt;/p&gt;
&lt;p&gt;什么是以太网呢？电脑上的以太网接口，Wi-Fi接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。&lt;/p&gt;
&lt;p&gt;以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在以太网进行通讯要用到 MAC 地址。&lt;/p&gt;
&lt;p&gt;MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们&lt;strong&gt;可以通过 ARP 协议获取对方的 MAC 地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;总结-2&#34;&gt;总结
&lt;/h4&gt;&lt;p&gt;综上所述，TCP/IP 网络通常是由上到下分成 4 层，分别是&lt;strong&gt;应用层，传输层，网络层和网络接口层&lt;/strong&gt;。&lt;/p&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/tcpip%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.drawio.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;再给大家贴一下每一层的封装格式：&lt;/p&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。&lt;/p&gt;
&lt;h3 id=&#34;23-linux-系统是如何收发网络包的&#34;&gt;2.3 Linux 系统是如何收发网络包的？
&lt;/h3&gt;&lt;h4 id=&#34;1网络模型&#34;&gt;1.网络模型
&lt;/h4&gt;&lt;p&gt;为了使得多种设备能通过网络相互通信，和为了解决各种不同设备在网络互联中的兼容性问题，国际标准化组织制定了开放式系统互联通信参考模型（&lt;em&gt;Open System Interconnection Reference Model&lt;/em&gt;），也就是 OSI 网络模型。&lt;/p&gt;
&lt;p&gt;该模型主要有 7 层：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用层，负责给应用程序提供统一的接口；&lt;/li&gt;
&lt;li&gt;表示层，负责把数据转换成兼容另一个系统能识别的格式；&lt;/li&gt;
&lt;li&gt;会话层，负责建立、管理和终止表示层实体之间的通信会话；&lt;/li&gt;
&lt;li&gt;传输层，负责端到端的数据传输；&lt;/li&gt;
&lt;li&gt;网络层，负责数据的路由、转发、分片；&lt;/li&gt;
&lt;li&gt;数据链路层，负责数据的封帧和差错检测，以及 MAC 寻址；&lt;/li&gt;
&lt;li&gt;物理层，负责在物理网络中传输数据帧；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于 OSI 模型实在太复杂，提出的也只是概念理论上的分层，并没有提供具体的实现方案。&lt;/p&gt;
&lt;p&gt;事实上，我们比较常见，也比较实用的是四层模型，即 TCP/IP 网络模型，Linux 系统正是按照这套网络模型来实现网络协议栈的。&lt;/p&gt;
&lt;p&gt;TCP/IP 网络模型共有 4 层：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用层，负责向用户提供一组应用程序，比如 HTTP、DNS、FTP 等;&lt;/li&gt;
&lt;li&gt;传输层，负责端到端的通信，比如 TCP、UDP 等；&lt;/li&gt;
&lt;li&gt;网络层，负责网络包的封装、分片、路由、转发，比如 IP、ICMP 等；&lt;/li&gt;
&lt;li&gt;网络接口层，负责网络包在物理网络中的传输，比如网络包的封帧、 MAC 寻址、差错检测，以及通过网卡传输网络帧等；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TCP/IP 网络模型相比 OSI 网络模型简化了不少，也更加易记，它们之间的关系如下图：&lt;/p&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/OSI%E4%B8%8ETCP.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;不过，我们常说的七层和四层负载均衡，是用 OSI 网络模型来描述的，七层对应的是应用层，四层对应的是传输层。&lt;/p&gt;
&lt;h4 id=&#34;2linux-网络协议栈&#34;&gt;2.Linux 网络协议栈
&lt;/h4&gt;&lt;p&gt;应用层数据在每一层的封装格式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传输层，给应用数据前面增加了 TCP 头；&lt;/li&gt;
&lt;li&gt;网络层，给 TCP 数据包前面增加了 IP 头；&lt;/li&gt;
&lt;li&gt;网络接口层，给 IP 数据包前后分别增加了帧头和帧尾；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些新增的头部和尾部，都有各自的作用，也都是按照特定的协议格式填充，这每一层都增加了各自的协议头，那自然网络包的大小就增大了，但物理链路并不能传输任意大小的数据包，所以在以太网中，规定了最大传输单元（MTU）是 &lt;code&gt;1500&lt;/code&gt; 字节，也就是规定了单次传输的最大 IP 包大小。&lt;/p&gt;
&lt;p&gt;当网络包超过 MTU 的大小，就会在网络层分片，以确保分片后的 IP 包不会超过 MTU 大小，如果 MTU 越小，需要的分包就越多，那么网络吞吐能力就越差，相反的，如果 MTU 越大，需要的分包就越少，那么网络吞吐能力就越好。&lt;/p&gt;
&lt;p&gt;Linux 网络协议栈的样子，类似于 TCP/IP 的四层结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%8D%8F%E8%AE%AE%E6%A0%88.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;从上图的的网络协议栈，你可以看到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用程序需要通过系统调用，来跟 Socket 层进行数据交互；&lt;/li&gt;
&lt;li&gt;Socket 层的下面就是传输层、网络层和网络接口层；&lt;/li&gt;
&lt;li&gt;最下面的一层，则是网卡驱动程序和硬件网卡设备；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3linux-接收网络包的流程&#34;&gt;3.Linux 接收网络包的流程
&lt;/h4&gt;&lt;p&gt;网卡是计算机里的一个硬件，专门负责接收和发送网络包，当网卡接收到一个网络包后，会通过 DMA 技术，将网络包写入到指定的内存地址，也就是写入到 Ring Buffer ，这个是一个环形缓冲区，接着就会告诉操作系统这个网络包已经到达。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;那应该怎么告诉操作系统这个网络包已经到达了呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最简单的一种方式就是触发中断，也就是每当网卡收到一个网络包，就触发一个中断告诉操作系统。&lt;/p&gt;
&lt;p&gt;但是，这存在一个问题，在高性能网络场景下，网络包的数量会非常多，那么就会触发非常多的中断，要知道当 CPU 收到了中断，就会停下手里的事情，而去处理这些网络包，处理完毕后，才会回去继续其他事情，那么频繁地触发中断，则会导致 CPU 一直没完没了的处理中断，而导致其他任务可能无法继续前进，从而影响系统的整体效率。&lt;/p&gt;
&lt;p&gt;所以为了解决频繁中断带来的性能开销，Linux 内核在 2.6 版本中引入了 &lt;strong&gt;NAPI 机制&lt;/strong&gt;，它是混合「中断和轮询」的方式来接收网络包，它的核心概念就是&lt;strong&gt;不采用中断的方式读取数据&lt;/strong&gt;，而是首先采用中断唤醒数据接收的服务程序，然后 &lt;code&gt;poll&lt;/code&gt; 的方法来轮询数据。&lt;/p&gt;
&lt;p&gt;因此，当有网络包到达时，会通过 DMA 技术，将网络包写入到指定的内存地址，接着网卡向 CPU 发起硬件中断，当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数。&lt;/p&gt;
&lt;p&gt;硬件中断处理函数会做如下的事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要先「暂时屏蔽中断」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。&lt;/li&gt;
&lt;li&gt;接着，发起「软中断」，然后恢复刚才屏蔽的中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至此，硬件中断处理函数的工作就已经完成。&lt;/p&gt;
&lt;p&gt;硬件中断处理函数做的事情很少，主要耗时的工作都交给软中断处理函数了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;软中断的处理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;内核中的 ksoftirqd 线程专门负责软中断的处理，当 ksoftirqd 内核线程收到软中断后，就会来轮询处理数据。&lt;/p&gt;
&lt;p&gt;ksoftirqd 线程会从 Ring Buffer 中获取一个数据帧，用 sk_buff 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;网络协议栈&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，会先进入到网络接口层，在这一层会检查报文的合法性，如果不合法则丢弃，合法则会找出该网络包的上层协议的类型，比如是 IPv4，还是 IPv6，接着再去掉帧头和帧尾，然后交给网络层。&lt;/p&gt;
&lt;p&gt;到了网络层，则取出 IP 包，判断网络包下一步的走向，比如是交给上层处理还是转发出去。当确认这个网络包要发送给本机后，就会从 IP 头里看看上一层协议的类型是 TCP 还是 UDP，接着去掉 IP 头，然后交给传输层。&lt;/p&gt;
&lt;p&gt;传输层取出 TCP 头或 UDP 头，根据四元组「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的 Socket，并把数据放到 Socket 的接收缓冲区。&lt;/p&gt;
&lt;p&gt;最后，应用层程序调用 Socket 接口，将内核的 Socket 接收缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。&lt;/p&gt;
&lt;p&gt;至此，一个网络包的接收过程就已经结束了，你也可以从下图左边部分看到网络包接收的流程，右边部分刚好反过来，它是网络包发送的流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;二tcp篇&#34;&gt;二、TCP篇
&lt;/h2&gt;&lt;h3 id=&#34;21-tcp-三次握手与四次挥手&#34;&gt;2.1 TCP 三次握手与四次挥手
&lt;/h3&gt;&lt;h4 id=&#34;1tcp-头格式有哪些&#34;&gt;1.TCP 头格式有哪些？
&lt;/h4&gt;&lt;p&gt;TCP 头的格式&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230534096.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;TCP 头格式&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;序列号&lt;/strong&gt;：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。&lt;strong&gt;用来解决网络包乱序问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;确认应答号&lt;/strong&gt;：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。&lt;strong&gt;用来解决丢包的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;**控制位：**ACK、RST、SYN、FIN&lt;/p&gt;
&lt;h4 id=&#34;2为什么需要-tcp-协议-tcp-工作在哪一层&#34;&gt;2.为什么需要 TCP 协议？ TCP 工作在哪一层？
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;IP&lt;/code&gt; 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。&lt;/p&gt;
&lt;img src=&#34;https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230419839.png&#34; alt=&#34;OSI 参考模型与 TCP/IP 的关系&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 &lt;code&gt;TCP&lt;/code&gt; 协议来负责。&lt;/p&gt;
&lt;p&gt;因为 TCP 是一个工作在&lt;strong&gt;传输层&lt;/strong&gt;的&lt;strong&gt;可靠&lt;/strong&gt;数据传输的服务，它能确保接收端接收的网络包是&lt;strong&gt;无损坏、无间隔、非冗余和按序的。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;3什么是-tcp-&#34;&gt;3.什么是 TCP ？
&lt;/h4&gt;&lt;p&gt;TCP 是&lt;strong&gt;面向连接的、可靠的、基于字节流&lt;/strong&gt;的传输层通信协议。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230424714.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;面向连接&lt;/strong&gt;：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可靠的&lt;/strong&gt;：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字节流&lt;/strong&gt;：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;4tcp-连接&#34;&gt;4.TCP 连接？
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以我们可以知道，建立一个 TCP 连接是需要客户端与服务端达成上述三个信息的共识。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Socket&lt;/strong&gt;：由 IP 地址和端口号组成&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;序列号&lt;/strong&gt;：用来解决乱序问题等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;窗口大小&lt;/strong&gt;：用来做流量控制&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;5如何唯一确定一个-tcp-连接呢&#34;&gt;5.如何唯一确定一个 TCP 连接呢？
&lt;/h4&gt;&lt;p&gt;TCP 四元组可以唯一的确定一个连接，四元组包括如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源地址&lt;/li&gt;
&lt;li&gt;源端口&lt;/li&gt;
&lt;li&gt;目的地址&lt;/li&gt;
&lt;li&gt;目的端口&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;6udp-和-tcp-有什么区别呢分别的应用场景是&#34;&gt;6.UDP 和 TCP 有什么区别呢？分别的应用场景是？
&lt;/h4&gt;&lt;p&gt;UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。&lt;/p&gt;
&lt;p&gt;UDP 协议真的非常简，头部只有 &lt;code&gt;8&lt;/code&gt; 个字节（64 位），UDP 的头部格式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230439961.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;UDP 头部格式&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。&lt;/li&gt;
&lt;li&gt;包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。&lt;/li&gt;
&lt;li&gt;校验和：校验和是为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP 包。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;TCP 和 UDP 区别：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1. 连接&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP 是面向连接的传输层协议，传输数据前先要建立连接。&lt;/li&gt;
&lt;li&gt;UDP 是不需要连接，即刻传输数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;2. 服务对象&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP 是一对一的两点服务，即一条连接只有两个端点。&lt;/li&gt;
&lt;li&gt;UDP 支持一对一、一对多、多对多的交互通信&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;3. 可靠性&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。&lt;/li&gt;
&lt;li&gt;UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：&lt;a class=&#34;link&#34; href=&#34;https://xiaolincoding.com/network/3_tcp/quic.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;如何基于 UDP 协议实现可靠传输？(opens new window)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;4. 拥塞控制、流量控制&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。&lt;/li&gt;
&lt;li&gt;UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;5. 首部开销&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 &lt;code&gt;20&lt;/code&gt; 个字节，如果使用了「选项」字段则会变长的。&lt;/li&gt;
&lt;li&gt;UDP 首部只有 8 个字节，并且是固定不变的，开销较小。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;6. 传输方式&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP 是流式传输，没有边界，但保证顺序和可靠。&lt;/li&gt;
&lt;li&gt;UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;7. 分片不同&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。&lt;/li&gt;
&lt;li&gt;UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;TCP 和 UDP 应用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FTP&lt;/code&gt; 文件传输；&lt;/li&gt;
&lt;li&gt;HTTP / HTTPS；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包总量较少的通信，如 &lt;code&gt;DNS&lt;/code&gt; 、&lt;code&gt;SNMP&lt;/code&gt; 等；&lt;/li&gt;
&lt;li&gt;视频、音频等多媒体通信；&lt;/li&gt;
&lt;li&gt;广播通信；&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原因是 TCP 有&lt;strong&gt;可变长&lt;/strong&gt;的「选项」字段，而 UDP 头部长度则是&lt;strong&gt;不会变化&lt;/strong&gt;的，无需多一个字段去记录 UDP 的首部长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP 连接建立&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;7tcp-三次握手过程是怎样的&#34;&gt;7.TCP 三次握手过程是怎样的？
&lt;/h4&gt;&lt;p&gt;TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而&lt;strong&gt;建立连接是通过三次握手来进行的&lt;/strong&gt;。三次握手的过程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;TCP 三次握手&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一开始，客户端和服务端都处于 &lt;code&gt;CLOSE&lt;/code&gt; 状态。先是服务端主动监听某个端口，处于 &lt;code&gt;LISTEN&lt;/code&gt; 状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230500953.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;第一个报文 —— SYN 报文&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端会随机初始化序号（&lt;code&gt;client_isn&lt;/code&gt;），将此序号置于 TCP 首部的「序号」字段中，同时把 &lt;code&gt;SYN&lt;/code&gt; 标志位置为 &lt;code&gt;1&lt;/code&gt;，表示 &lt;code&gt;SYN&lt;/code&gt; 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 &lt;code&gt;SYN-SENT&lt;/code&gt; 状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230504118.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;第二个报文 —— SYN &amp;#43; ACK 报文&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务端收到客户端的 &lt;code&gt;SYN&lt;/code&gt; 报文后，首先服务端也随机初始化自己的序号（&lt;code&gt;server_isn&lt;/code&gt;），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 &lt;code&gt;client_isn + 1&lt;/code&gt;, 接着把 &lt;code&gt;SYN&lt;/code&gt; 和 &lt;code&gt;ACK&lt;/code&gt; 标志位置为 &lt;code&gt;1&lt;/code&gt;。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 &lt;code&gt;SYN-RCVD&lt;/code&gt; 状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230508297.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;第三个报文 —— ACK 报文&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 &lt;code&gt;ACK&lt;/code&gt; 标志位置为 &lt;code&gt;1&lt;/code&gt; ，其次「确认应答号」字段填入 &lt;code&gt;server_isn + 1&lt;/code&gt; ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 &lt;code&gt;ESTABLISHED&lt;/code&gt; 状态。&lt;/li&gt;
&lt;li&gt;服务端收到客户端的应答报文后，也进入 &lt;code&gt;ESTABLISHED&lt;/code&gt; 状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上面的过程可以发现&lt;strong&gt;第三次握手是可以携带数据的，前两次握手是不可以携带数据的&lt;/strong&gt;，这也是面试常问的题。&lt;/p&gt;
&lt;p&gt;一旦完成三次握手，双方都处于 &lt;code&gt;ESTABLISHED&lt;/code&gt; 状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么是三次握手？不是两次、四次？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;TCP 连接&lt;/strong&gt;：用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 &lt;strong&gt;Socket、序列号和窗口大小&lt;/strong&gt;称为连接。&lt;/p&gt;
&lt;p&gt;所以，重要的是&lt;strong&gt;为什么三次握手才可以初始化 Socket、序列号和窗口大小并建立 TCP 连接。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来，以三个方面分析三次握手的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三次握手才可以阻止重复历史连接的初始化（主要原因）&lt;/li&gt;
&lt;li&gt;三次握手才可以同步双方的初始序列号&lt;/li&gt;
&lt;li&gt;三次握手才可以避免资源浪费&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TCP 建立连接时，通过三次握手&lt;strong&gt;能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号&lt;/strong&gt;。序列号能够保证数据包不重复、不丢弃和按序传输。&lt;/p&gt;
&lt;p&gt;不使用「两次握手」和「四次握手」的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；&lt;/li&gt;
&lt;li&gt;「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;主要原因有两个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了防止历史报文被下一个相同四元组的连接接收（主要方面）；&lt;/li&gt;
&lt;li&gt;为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;TCP 连接断开&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;8tcp-四次挥手过程是怎样的&#34;&gt;8.TCP 四次挥手过程是怎样的？
&lt;/h4&gt;&lt;p&gt;天下没有不散的宴席，对于 TCP 连接也是这样， TCP 断开连接是通过&lt;strong&gt;四次挥手&lt;/strong&gt;方式。&lt;/p&gt;
&lt;p&gt;双方都可以主动断开连接，断开连接后主机中的「资源」将被释放，四次挥手的过程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;客户端主动关闭连接 —— TCP 四次挥手&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端打算关闭连接，此时会发送一个 TCP 首部 &lt;code&gt;FIN&lt;/code&gt; 标志位被置为 &lt;code&gt;1&lt;/code&gt; 的报文，也即 &lt;code&gt;FIN&lt;/code&gt; 报文，之后客户端进入 &lt;code&gt;FIN_WAIT_1&lt;/code&gt; 状态。&lt;/li&gt;
&lt;li&gt;服务端收到该报文后，就向客户端发送 &lt;code&gt;ACK&lt;/code&gt; 应答报文，接着服务端进入 &lt;code&gt;CLOSE_WAIT&lt;/code&gt; 状态。&lt;/li&gt;
&lt;li&gt;客户端收到服务端的 &lt;code&gt;ACK&lt;/code&gt; 应答报文后，之后进入 &lt;code&gt;FIN_WAIT_2&lt;/code&gt; 状态。&lt;/li&gt;
&lt;li&gt;等待服务端处理完数据后，也向客户端发送 &lt;code&gt;FIN&lt;/code&gt; 报文，之后服务端进入 &lt;code&gt;LAST_ACK&lt;/code&gt; 状态。&lt;/li&gt;
&lt;li&gt;客户端收到服务端的 &lt;code&gt;FIN&lt;/code&gt; 报文后，回一个 &lt;code&gt;ACK&lt;/code&gt; 应答报文，之后进入 &lt;code&gt;TIME_WAIT&lt;/code&gt; 状态&lt;/li&gt;
&lt;li&gt;服务端收到了 &lt;code&gt;ACK&lt;/code&gt; 应答报文后，就进入了 &lt;code&gt;CLOSE&lt;/code&gt; 状态，至此服务端已经完成连接的关闭。&lt;/li&gt;
&lt;li&gt;客户端在经过 &lt;code&gt;2MSL&lt;/code&gt; 一段时间后，自动进入 &lt;code&gt;CLOSE&lt;/code&gt; 状态，至此客户端也完成连接的关闭。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以看到，每个方向都需要&lt;strong&gt;一个 FIN 和一个 ACK&lt;/strong&gt;，因此通常被称为&lt;strong&gt;四次挥手&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这里一点需要注意是：&lt;strong&gt;主动关闭连接的，才有 TIME_WAIT 状态。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么挥手需要四次为什么挥手需要四次？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再来回顾下四次挥手双方发 &lt;code&gt;FIN&lt;/code&gt; 包的过程，就能理解为什么需要四次了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关闭连接时，客户端向服务端发送 &lt;code&gt;FIN&lt;/code&gt; 时，仅仅表示客户端不再发送数据了但是还能接收数据。&lt;/li&gt;
&lt;li&gt;服务端收到客户端的 &lt;code&gt;FIN&lt;/code&gt; 报文时，先回一个 &lt;code&gt;ACK&lt;/code&gt; 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 &lt;code&gt;FIN&lt;/code&gt; 报文给客户端来表示同意现在关闭连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 &lt;code&gt;ACK&lt;/code&gt; 和 &lt;code&gt;FIN&lt;/code&gt; 一般都会分开发送，因此是需要四次挥手。&lt;/p&gt;
&lt;h1 id=&#34;嵌入式单片机rtos&#34;&gt;嵌入式单片机/RTOS
&lt;/h1&gt;&lt;h3 id=&#34;stm32的哪些功能&#34;&gt;STM32的哪些功能
&lt;/h3&gt;&lt;p&gt;STM32是一款由意法半导体（STMicroelectronics）公司推出的32位微控制器，具有以下功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;内置ARM Cortex-M处理器核，提供高性能和低功耗。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集成了多个模块，例如模数转换器、通用定时器、串行通信接口、中断控制器等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持多种外设接口，例如USB、CAN、Ethernet、SDIO等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可编程性强，支持多种编程语言，例如C、C++、汇编语言等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供了多种包装形式和引脚数量，以适应不同的应用需求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供了丰富的开发工具和支持，例如开发板、编译器、调试器、软件库等，方便开发人员进行开发和调试。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总之，STM32是一款功能强大、灵活多样、易于开发和部署的微控制器。&lt;/p&gt;
&lt;h3 id=&#34;中断服务函数和普通函数的区别&#34;&gt;中断服务函数和普通函数的区别
&lt;/h3&gt;&lt;p&gt;中断服务函数和普通函数之间有很大的区别，主要体现在以下几个方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;触发条件不同：中断服务函数是由硬件中断触发执行的，而普通函数是由代码中的函数调用语句触发执行的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行环境不同：中断服务函数在中断发生时在中断上下文中执行，因此其执行环境与普通函数不同，需要遵循一定的编程规范。比如，中断服务函数不能访问用户空间的数据，不能进行堆栈分配等操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行时间限制：中断服务函数需要尽快完成处理，以便尽快返回中断处理，因为中断服务函数的执行会阻塞其他中断的处理。而普通函数没有时间限制，可以根据需要执行任意长的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数传递方式不同：中断服务函数的参数一般都是通过全局变量或者寄存器来传递的，而普通函数的参数是通过堆栈传递的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;数据如何在单片机上计算从哪里取出放到哪里&#34;&gt;数据如何在单片机上计算？从哪里取出，放到哪里？
&lt;/h3&gt;&lt;p&gt;从外部存储器中读取数据，并将计算结果存储到内部存储器或外部存储器中。具体的操作流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;数据读取：单片机中的数据通常来源于外部设备，例如传感器、存储卡等，或者是通过串口、网络等方式接收到的数据。通过单片机的外设模块，可以将这些数据读取到单片机内部的缓冲区中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据处理：读取到的数据需要进行处理，例如进行滤波、转换等操作。这些操作可以在单片机的中央处理器（CPU）中进行，或者通过专门的硬件模块实现，例如模数转换器（ADC）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据存储：处理完的数据可以存储到内部存储器（例如RAM）或者外部存储器（例如闪存、EEPROM）中。存储的方式可以是直接写入存储器地址，也可以使用文件系统等高级接口进行管理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;常用的位操作&#34;&gt;常用的位操作
&lt;/h3&gt;&lt;p&gt;按位与（&amp;amp;）、按位或（|）、按位异或（^）【相同为0，不同为1】、按位取反（~）、左移（&amp;laquo;）、右移（&amp;raquo;）&lt;/p&gt;
&lt;h3 id=&#34;uart&#34;&gt;UART
&lt;/h3&gt;&lt;p&gt;UART是一种串行通信协议，它使用两条线（TX和RX）进行全双工通信，其中TX是发送端线路，RX是接收端线路。&lt;/p&gt;
&lt;p&gt;UART的技术要点包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;波特率：UART通信的速率是由波特率决定的，波特率指的是每秒钟传输的位数。波特率越高，传输速率越快。在UART通信中，发送端和接收端必须设置相同的波特率才能正常通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据位数：UART通信中，数据位数指的是每个字符中包含的数据位数，通常为5、6、7或8位。不同的数据位数会影响通信的数据传输范围和精度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;停止位数：UART通信中，停止位数指的是每个字符传输结束后，发送端在TX线上保持的停止位数。通常为1或2个停止位，它们用于指示接收端此时可以进行下一次接收。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;校验位：UART通信中，校验位用于检测数据传输中的错误。常见的校验方式包括奇偶校验、偶偶校验、和校验等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据传输：UART通信中，每个字符由起始位、数据位、校验位和停止位组成，这些位的顺序和长度是固定的，发送端和接收端必须按照相同的顺序和长度传输数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中断处理：UART通信中，可以使用中断方式来处理数据的接收和发送，当数据接收或发送完成时，系统会产生一个中断信号，通知处理器进行相应的处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据流控制：UART通信中，为了避免数据的丢失或错误，可以使用数据流控制机制来控制数据的传输。常见的数据流控制方式包括硬件流控制和软件流控制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;数据格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;UART是一种通用异步收发传输技术，常用于串口通信。UART的数据格式包括数据位、停止位、奇偶校验位等，常用的数据格式有以下几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;8N1：8位数据位、无奇偶校验、1位停止位；&lt;/li&gt;
&lt;li&gt;7E1：7位数据位、偶校验、1位停止位；&lt;/li&gt;
&lt;li&gt;8O2：8位数据位、奇校验、2位停止位。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;如何保证在侦听UART时不会一直判断接收到0？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在侦听UART时，为了避免一直判断接收到0，可以使用一些技巧和策略来保证数据的正确接收。以下是一些常用的方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置接收超时：可以设置一个超时时间，在规定的时间内未接收到数据则认为接收完成，避免一直等待。例如，可以使用 select 或 poll 等系统调用来实现超时等待；&lt;/li&gt;
&lt;li&gt;定义特殊字符：可以定义一个特殊字符，例如 ETX（End of Text），表示数据传输结束。当接收到这个特殊字符时，即可认为数据接收完成；&lt;/li&gt;
&lt;li&gt;使用帧头和帧尾：可以在传输数据时添加帧头和帧尾，来标识数据的开始和结束。例如，可以使用 STX（Start of Text）作为帧头，ETX作为帧尾；&lt;/li&gt;
&lt;li&gt;定时接收：可以定时接收数据，在规定的时间内接收尽可能多的数据。例如，可以设置一个计数器，定时从接收缓冲区读取数据，直到计数器到达预设值。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;UART的奇偶校验&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;UART通信中的奇偶校验是一种检错方式，用于检查数据传输过程中是否出现了位错误。在UART中，发送端在传输每个数据字节时，都会附加一个奇偶校验位。奇偶校验位的值由该数据字节的二进制中1的个数决定，如果1的个数是偶数，则奇偶校验位为0，否则为1。接收端接收到数据后，会再次计算数据字节中1的个数，并与接收到的奇偶校验位进行比较，如果不一致，则说明传输过程中发生了位错误。&lt;/p&gt;
&lt;p&gt;UART通信中奇偶校验可以分为以下几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;奇校验（Odd Parity）：让数据中1的个数加上校验位等于奇数，校验位为1。&lt;/li&gt;
&lt;li&gt;偶校验（Even Parity）：让数据中1的个数加上校验位等于偶数，校验位为0。&lt;/li&gt;
&lt;li&gt;无校验（No Parity）：不对数据进行校验，不加校验位。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;奇偶校验可以提高数据传输的可靠性，但会占用一个数据位的空间，因此在数据量较大的情况下，可能会影响数据传输速率。&lt;/p&gt;
&lt;h3 id=&#34;arm和x86区别&#34;&gt;arm和x86区别
&lt;/h3&gt;&lt;p&gt;ARM和x86都是计算机处理器的架构，它们的设计思路和目标用户不同，因而具有一些不同的特点和优势。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;指令集：ARM架构采用的是精简指令集（RISC）的设计思路，指令集较为简单，指令长度一般为32位，指令的执行速度快，能够适应低功耗、低成本和高效率等应用场景；而x86架构采用的是复杂指令集（CISC）的设计思路，指令集较为复杂，指令长度一般为16位或32位，具有较强的兼容性和灵活性，但指令的执行速度相对较慢。&lt;/li&gt;
&lt;li&gt;处理器核心：ARM架构的处理器核心通常比x86的处理器核心更加简单，功耗更低。ARM处理器常常被应用于嵌入式系统和移动设备等对功耗和体积有较高要求的领域；而x86处理器的核心通常比较复杂，能够更好地处理大量的运算和数据传输，因此被广泛应用于个人电脑和服务器等领域。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;arm的多核某一核出现多载的现象如何处理&#34;&gt;ARM的多核某一核出现多载的现象，如何处理？
&lt;/h3&gt;&lt;p&gt;ARM的多核系统中，某一核出现多载的现象可能会导致系统性能下降，需要进行处理。以下是可能的处理方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;程序优化：如果出现多载现象是因为某个程序在该核上的运行负载过重导致的，可以对该程序进行优化，减少其运行负载。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程迁移：将某些运行负载较重的进程迁移到其他核上运行，可以减轻某一核的负载。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;功耗调节：如果出现多载现象是因为某一核功耗过高导致的，可以通过调节功耗来解决。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态频率调节：如果出现多载现象是因为某一核运行频率过低导致的，可以通过动态调节该核的运行频率来提高其性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多核同步：如果出现多载现象是因为多个核之间存在同步问题导致的，可以通过加入同步机制来解决。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;freertos操作系统的底层实现原理比如任务调度的底层实现&#34;&gt;FreeRTOS操作系统的底层实现原理，比如任务调度的底层实现
&lt;/h3&gt;&lt;p&gt;FreeRTOS 是一个基于实时操作系统内核的开源软件，可以用于嵌入式系统的开发，主要特点是小巧、高效、灵活和可移植。FreeRTOS 采用了时间片轮询调度算法，支持多任务调度、任务优先级、信号量、消息队列、互斥锁等特性。&lt;/p&gt;
&lt;p&gt;FreeRTOS 的任务调度采用了时间片轮询调度算法，它把时间片均分给各个任务，每个任务运行一个时间片后，就会被挂起，然后调度器再挑选一个优先级更高的任务继续运行。FreeRTOS 支持任务优先级，任务的优先级越高，它们获取 CPU 时间片的机会就越多。在多任务环境下，任务之间的切换是由调度器负责的，它会根据任务的优先级和时间片轮询算法来决定哪个任务先执行。&lt;/p&gt;
&lt;p&gt;FreeRTOS 还提供了多种同步和通信机制，包括信号量、消息队列、互斥锁等。它们可以用于实现线程间同步和通信，保证数据的正确性和一致性。FreeRTOS 还支持定时器、软件定时器等特性，可以用于实现定时任务和周期性任务。&lt;/p&gt;
&lt;p&gt;在底层实现方面，FreeRTOS 主要是通过中断实现任务调度和同步机制。FreeRTOS 会使用定时器中断来触发任务切换，使用信号量、消息队列等机制来实现线程间同步和通信。同时，FreeRTOS 还会使用互斥锁来保护共享资源，避免多任务环境下的竞态条件。&lt;/p&gt;
&lt;h3 id=&#34;iic&#34;&gt;IIC
&lt;/h3&gt;&lt;p&gt;IIC（Inter-Integrated Circuit）是一种由飞利浦公司开发的双线串行总线，可以连接多个设备，每个设备都有一个唯一的地址。以下是IIC相关技术要点的解释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据线和时钟线&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;IIC通信协议使用两根线：数据线（SDA）和时钟线（SCL）。数据线和时钟线都是双向的，都需要由主设备控制，数据传输是同步的，由主设备产生时钟信号。主设备通过时钟信号来同步数据的传输。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;IIC地址&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每个IIC设备都需要有一个唯一的地址，IIC设备可以是芯片、模块或其他外设。设备地址是7位或10位二进制数，其中前7位是设备地址，最高位指示读写操作，0表示写操作，1表示读操作。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;数据传输格式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;IIC通信协议中数据的传输是以字节为单位进行的，每个字节由8位二进制数组成，包括一个起始位（Start）、8位数据、一个确认位（Acknowledge）和一个停止位（Stop）。通信的过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主设备发送起始位（Start）信号&lt;/li&gt;
&lt;li&gt;主设备发送设备地址和读写标志&lt;/li&gt;
&lt;li&gt;从设备返回应答位（Acknowledge）信号&lt;/li&gt;
&lt;li&gt;主设备发送数据&lt;/li&gt;
&lt;li&gt;从设备返回应答位（Acknowledge）信号&lt;/li&gt;
&lt;li&gt;重复以上步骤，直到通信结束&lt;/li&gt;
&lt;li&gt;主设备发送停止位（Stop）信号&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;数据传输速度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;IIC通信协议的传输速度可以通过改变时钟信号的频率来调节，通常的IIC传输速率为100kbps、400kbps或1Mbps，根据实际需求选择合适的传输速率。&lt;/p&gt;
&lt;p&gt;总的来说，IIC通信协议使用简单，传输效率高，传输距离远，可靠性强，因此广泛应用于嵌入式系统中的外设连接和通信。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;IIC协议是一种串行通信协议，常用于连接芯片和外设，具有高速传输、多设备共享等特点。中断是一种硬件机制，可以在特定条件下打断CPU的正常执行流程，执行中断服务程序。中断可以用于处理外部事件，如定时器、IO口、串口等，提高系统的实时性和响应速度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;IIC协议最多能挂载的从设备个数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I2C（IIC）协议可以连接多个从设备，但具体能挂载的从设备个数取决于总线的负载容量和总线传输速率。每个从设备都会占用一定的总线带宽和电流负载，如果挂载过多的从设备可能会导致总线通信失败或数据传输出错。&lt;/p&gt;
&lt;p&gt;一般情况下，I2C总线上的从设备个数建议不要超过8个，这可以保证通信的稳定性和可靠性。如果需要连接更多的从设备，可以考虑使用I2C总线分支器（I2C multiplexer）或者I2C扩展芯片（I2C expander）等辅助器件来增加总线带宽和扩展设备数量。&lt;/p&gt;
&lt;h3 id=&#34;spi&#34;&gt;SPI
&lt;/h3&gt;&lt;p&gt;SPI（Serial Peripheral Interface）是一种同步串行通信协议，它用于在芯片之间传输数据。SPI通常在低速设备之间使用，例如传感器、LCD显示屏、ADC和DAC等设备。下面是SPI的一些技术要点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;通信方式：SPI是一种同步通信协议，通信双方通过共享时钟线（SCLK）来同步数据传输。一个设备发送数据到另一个设备，数据通过MOSI（Master Output Slave Input）线发送，而另一个设备通过MISO（Master Input Slave Output）线接收数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主从模式：SPI支持主从模式，主设备控制通信并发送时钟信号，从设备接受时钟信号和数据。主设备通过片选（CS）线选择从设备，每个从设备都有一个独特的片选线。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时序：SPI通信时序包括CPOL和CPHA两个参数，这两个参数控制时钟线的极性和相位。CPOL控制时钟线的空闲状态（高电平或低电平），而CPHA控制数据的采样时间。SPI支持四种时序模式，每种模式的CPOL和CPHA值不同，可以根据实际需求选择合适的模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传输速度：SPI通信速度取决于时钟频率和数据位数。通常情况下，SPI的时钟频率可以达到几十MHz，传输速度较快。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据传输：SPI通常使用全双工模式传输数据，数据可以在主设备和从设备之间双向传输。SPI可以传输不同大小的数据，从8位到16位或更高位。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;硬件要求：SPI需要四根线进行通信，包括时钟线（SCLK）、主设备输出从设备输入线（MOSI）、主设备输入从设备输出线（MISO）和片选线（CS）。SPI还需要一个外部时钟源，可以是晶振或其他时钟源。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总的来说，SPI是一种简单、高效的串行通信协议，具有快速传输速度和灵活的数据传输方式。它适用于短距离、高速数据传输，是许多微控制器和外设芯片之间常用的通信方式之一。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SPI有4种模式你知道是那4种模式吗？&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;iic和spi区别&#34;&gt;IIC和SPI区别
&lt;/h3&gt;&lt;p&gt;IIC和SPI都是常用的串行通信接口，但是它们有以下几个主要区别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通信方式：IIC是基于两根线（数据线和时钟线）进行通信的，而SPI是基于四根线（数据线、时钟线、片选线和从设备发出的数据有效标志线）进行通信的。&lt;/li&gt;
&lt;li&gt;设备数量：IIC可以连接多个从设备，而SPI连接多个从设备需要使用多路复用器或芯片选择器。&lt;/li&gt;
&lt;li&gt;传输速率：SPI通信速度比IIC快，因为SPI的时钟频率可以高达几十MHz，而IIC通常只能达到几百KHz。&lt;/li&gt;
&lt;li&gt;通信协议：IIC通常使用标准的I2C协议，而SPI通常没有标准协议，其通信协议可以根据具体的应用自定义。&lt;/li&gt;
&lt;li&gt;硬件复杂度：SPI通常需要更多的硬件支持，例如从设备芯片选择器等，而IIC只需要两根线就可以进行通信。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;比较一下串口iicspi通信的特点&#34;&gt;比较一下串口、IIC、SPI通信的特点
&lt;/h3&gt;&lt;p&gt;串口、IIC、SPI通信是常用的嵌入式通信协议，它们各有特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;串口通信：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;串口通信使用串行传输方式，只需要两根线即可实现通信。它的优点是可靠性高、使用成本低、传输距离远，可以实现双向通信。缺点是速度较慢，一般用于低速数据传输。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;IIC通信：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;IIC通信是一种基于双线串行总线的通信协议。它使用两条线（时钟线和数据线）来传输数据，可以实现多个设备共享同一条总线。IIC通信的优点是速度快，占用的IO口少，传输距离较短，可以实现双向通信。缺点是只能在短距离内传输数据。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;SPI通信：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;SPI通信是一种基于同步串行总线的通信协议。它使用四条线（时钟线、数据输入线、数据输出线、片选线）来传输数据，可以实现多个设备共享同一条总线。SPI通信的优点是速度快，传输距离较长，可以实现高速数据传输。缺点是占用的IO口多。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;stm32如何进入中断&#34;&gt;stm32如何进入中断？
&lt;/h3&gt;&lt;p&gt;STM32系列的微控制器使用ARM Cortex-M系列内核，其中包括Cortex-M0、Cortex-M3、Cortex-M4和Cortex-M7等不同的型号。这些内核都具有类似的中断控制器和中断服务机制，下面简要介绍STM32进入中断的流程。&lt;/p&gt;
&lt;p&gt;首先，在STM32中，需要使用NVIC寄存器配置和控制中断。在编写程序时，需要先使能中断控制器，即开启全局中断控制，使用如下代码可以实现：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;__enable_irq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//开启全局中断控制
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;接着，需要定义中断服务函数，即处理中断事件的函数。在STM32中，每个中断对应着一个中断服务函数，这个函数需要以&lt;code&gt;void function_name(void)&lt;/code&gt;的形式定义，其中&lt;code&gt;function_name&lt;/code&gt;是对应中断的名称。在函数内部，需要实现处理中断事件的代码。例如，下面是一个简单的定时器中断服务函数的示例代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;TIM2_IRQHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;TIM_GetITStatus&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TIM2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TIM_IT_Update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RESET&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;cm&#34;&gt;/* 处理中断事件 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;TIM_ClearITPendingBit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TIM2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TIM_IT_Update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//清除中断标志位
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在中断服务函数中，需要先检查中断标志位是否被触发，如果是则执行相应的代码。最后需要清除中断标志位，以使下一次中断能够被正确处理。&lt;/p&gt;
&lt;p&gt;最后，需要在主函数中配置中断向量表，即将中断向量表的地址设置为中断服务函数的地址。在STM32中，中断向量表是存储在内存的第一个地址处的一组函数指针，每个指针对应着一个中断服务函数。当发生中断时，中断向量表会自动跳转到对应中断服务函数的地址处执行相应的代码。在STM32中，可以使用如下代码配置中断向量表：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* 定义中断向量表 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g_pfnVectors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[])(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))((&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;g_pfnStack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;STACK_SIZE&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 其他中断服务函数的地址
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;TIM2_IRQHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// TIM2中断服务函数的地址
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* 将中断向量表地址设置为g_pfnVectors的地址 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;SCB&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;VTOR&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;g_pfnVectors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在上述代码中，&lt;code&gt;g_pfnVectors&lt;/code&gt;是一个函数指针数组，其中存储着中断服务函数的地址。&lt;code&gt;SCB-&amp;gt;VTOR&lt;/code&gt;是System Control Block（SCB）寄存器中的一个位域，用于指定中断向量表的地址。通过将&lt;code&gt;SCB-&amp;gt;VTOR&lt;/code&gt;设置为&lt;code&gt;g_pfnVectors&lt;/code&gt;的地址，即可将中断向量表设置为&lt;code&gt;g_pfnVectors&lt;/code&gt;所指向的地址。&lt;/p&gt;
&lt;h3 id=&#34;rs232和rs485的区别是什么&#34;&gt;RS232和RS485的区别是什么
&lt;/h3&gt;&lt;p&gt;RS232和RS485都是串口通信协议，但是有以下几个区别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;差分信号传输方式不同：RS232使用单向传输方式，即发送方和接收方之间只有一个信号线路，而RS485使用差分传输方式，即同时有一条正线和一条负线传输数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网络拓扑结构不同：RS232只能实现点对点通信，而RS485可以实现多点通信，支持半双工或全双工通信方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;电平信号电压和电流不同：RS232标准的电平信号电压范围为+/- 3V至+/- 15V，电流范围为+/- 3mA至+/- 30mA，而RS485标准的电平信号电压范围为+/- 1.5V至+/- 6V，电流范围为+/- 5mA。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据传输距离不同：RS232一般只能传输几米以内的距离，而RS485可以传输1000米以上的距离。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据传输速率不同：RS232的最高数据传输速率一般为115200bps，而RS485的最高数据传输速率一般为10Mbps。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RS485支持多主机通信，也就是多个主机可以同时访问同一个设备，而RS232只能支持一主一从的通信方式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总的来说，RS232适用于点对点通信，距离较近、速率较低的场景，而RS485适用于多点通信、距离较远、速率较高的场景。&lt;/p&gt;
&lt;h3 id=&#34;rs485如果是差分的方式那么是如何进行传输方向判定的&#34;&gt;RS485如果是差分的方式，那么是如何进行传输方向判定的？
&lt;/h3&gt;&lt;p&gt;RS485差分信号中，传输方向是通过控制芯片的RE（Receive Enable）和DE（Drive Enable）引脚来实现的。RE和DE引脚一般由控制芯片内部的逻辑控制电路控制，用于控制芯片的发送和接收状态。&lt;/p&gt;
&lt;p&gt;在发送数据时，RE和DE两个引脚被控制芯片同时拉高，表示芯片处于发送状态；在接收数据时，RE和DE两个引脚被控制芯片分别拉高和拉低，表示芯片处于接收状态。由此，接收端能够根据差分信号的电平变化来判断发送端的传输方向。当RE和DE引脚被控制芯片分别拉低和拉高时，表示芯片处于半双工模式，既可以发送数据也可以接收数据。&lt;/p&gt;
&lt;p&gt;TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是两种互联网传输协议。&lt;/p&gt;
&lt;p&gt;TCP是一种面向连接的、可靠的协议。它在传输数据之前要先建立连接，确保数据能够安全、可靠地传输。TCP协议提供了数据传输的可靠性，具有流量控制、拥塞控制、数据完整性校验等机制，能够保证数据的可靠性和完整性。但是，由于要建立连接，因此TCP协议的传输速度相对较慢，占用资源也较多。&lt;/p&gt;
&lt;p&gt;UDP是一种无连接的、不可靠的协议。它不需要事先建立连接，直接向目标主机发送数据报。UDP协议不提供数据传输的可靠性，也不具备流量控制、拥塞控制等机制，数据报可能会丢失或重复，但是它的传输速度较快，资源占用较少，适合于一些实时性要求较高、数据传输量较大的场合。&lt;/p&gt;
&lt;p&gt;总的来说，TCP适合于要求可靠性较高的数据传输场合，如文件传输、邮件传输、网页浏览等；而UDP适合于对实时性要求较高，但对数据传输的可靠性要求不高的场合，如视频直播、在线游戏等。&lt;/p&gt;
&lt;h3 id=&#34;中断是如何产生的具体的工作原理&#34;&gt;中断是如何产生的，具体的工作原理
&lt;/h3&gt;&lt;p&gt;中断是一种计算机处理器在执行程序时，接收到来自外部设备或其他软件的异步信号时，暂停正在执行的程序转而处理该信号的一种机制。&lt;/p&gt;
&lt;p&gt;当外设或其他软件需要向处理器发出中断请求时，会向处理器发送一个中断请求信号，处理器接收到信号后会停止正在执行的程序，并保存当前执行上下文（包括程序计数器、寄存器等状态）到栈中，接着跳转到中断处理程序的入口地址。中断处理程序执行完毕后，处理器再从栈中恢复上下文，继续执行被中断的程序。&lt;/p&gt;
&lt;p&gt;在计算机中，中断被实现为&lt;strong&gt;硬件中断&lt;/strong&gt;和&lt;strong&gt;软件中断&lt;/strong&gt;两种类型。硬件中断是由外部设备通过向处理器的中断控制器发送信号来触发的，而软件中断则是由程序在执行过程中通过系统调用等方式主动触发的。&lt;/p&gt;
&lt;h3 id=&#34;什么是dma&#34;&gt;什么是DMA？
&lt;/h3&gt;&lt;p&gt;DMA（Direct Memory Access，直接内存访问）是计算机系统中用于实现高速数据传输的一种技术。传统的数据传输需要由CPU通过读取外设的寄存器等方式来完成，这样CPU的时间和资源就会被浪费。而DMA技术则可以通过使用专门的DMA控制器，直接将数据从外设传输到内存，或者从内存传输到外设，从而减轻CPU的负担，提高数据传输的效率。&lt;/p&gt;
&lt;p&gt;DMA的实现方式大致可以分为以下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置DMA控制器：首先需要通过编程的方式设置DMA控制器的相关寄存器，如DMA控制器的工作模式、传输数据的源地址和目的地址、传输数据的长度等。&lt;/li&gt;
&lt;li&gt;请求DMA传输：外设需要向DMA控制器发送DMA请求信号，请求DMA传输。此时，DMA控制器会检查是否有优先级更高的DMA请求，如果有，则会暂停当前的DMA传输，优先执行更高优先级的DMA传输。&lt;/li&gt;
&lt;li&gt;执行DMA传输：DMA控制器在完成以上设置后，开始执行DMA传输操作。DMA传输过程中，DMA控制器负责管理数据的传输，并在传输结束后向外设发送传输完成的信号。&lt;/li&gt;
&lt;li&gt;DMA传输结束：当DMA传输结束后，DMA控制器会向CPU发送中断请求信号，通知CPU数据传输已经完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;uboot的启动流程&#34;&gt;uboot的启动流程
&lt;/h3&gt;&lt;h3 id=&#34;根文件系统的启动和挂载流程用的哪种文件系统&#34;&gt;根文件系统的启动和挂载流程，用的哪种文件系统
&lt;/h3&gt;&lt;h3 id=&#34;三个线程循环打印abc怎么同步&#34;&gt;三个线程循环打印abc怎么同步
&lt;/h3&gt;&lt;h3 id=&#34;rtos和linux的区别各自的优点&#34;&gt;rtos和linux的区别，各自的优点
&lt;/h3&gt;&lt;p&gt;单片机main函数执行前会执行什么&lt;/p&gt;
&lt;h1 id=&#34;linux&#34;&gt;LINUX
&lt;/h1&gt;&lt;h2 id=&#34;面经题-1&#34;&gt;面经题
&lt;/h2&gt;&lt;h3 id=&#34;常用linux指令&#34;&gt;常用linux指令
&lt;/h3&gt;&lt;p&gt;常用的 Linux 指令可以分为以下几类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文件操作类：包括 ls、cp、mv、rm、mkdir、rmdir、touch 等；&lt;/li&gt;
&lt;li&gt;文本编辑类：包括 vi、nano、emacs 等；&lt;/li&gt;
&lt;li&gt;系统信息类：包括 uname、hostname、top、free、df、du、ps 等；&lt;/li&gt;
&lt;li&gt;进程管理类：包括 ps、kill、pkill、pgrep、jobs、bg、fg 等；&lt;/li&gt;
&lt;li&gt;网络管理类：包括 ping、netstat、ifconfig、route 等；&lt;/li&gt;
&lt;li&gt;用户管理类：包括 useradd、userdel、passwd、groupadd、groupdel、chgrp、chown 等；&lt;/li&gt;
&lt;li&gt;权限管理类：包括 chmod、chown、chgrp 等；&lt;/li&gt;
&lt;li&gt;压缩解压类：包括 tar、gzip、gunzip、bzip2、bunzip2、zip、unzip 等；&lt;/li&gt;
&lt;li&gt;软件包管理类：包括 apt、yum、dpkg、rpm 等。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;除了以上常用指令外，Linux 还有很多其他实用的指令，如 sed、awk、find、grep、cut、sort、uniq、awk 等，可以根据需要进行使用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;man shutdown    &lt;span class=&#34;c1&#34;&gt;#命令说明&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;su				&lt;span class=&#34;c1&#34;&gt;#切换用户&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#目录&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; ls mkdir rm mv cp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;find /bin -name &lt;span class=&#34;s1&#34;&gt;&amp;#39;a*&amp;#39;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;#查找/bin目录下的所有以a开头的文件或者目录&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;pwd&lt;/span&gt;                         &lt;span class=&#34;c1&#34;&gt;#显示当前位置路径&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;touch rm vi/vim cat 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;more	&lt;span class=&#34;c1&#34;&gt;#可以逐页查看文件的内容，适用于查看大型日志文件，避免一次性加载整个文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;less 	&lt;span class=&#34;c1&#34;&gt;#比more加了几个功能&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tail -100 a.txt    &lt;span class=&#34;c1&#34;&gt;#查看文件的后100行&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;head
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#文件权限&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;chmod
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#压缩解压&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tar unzip
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;free		&lt;span class=&#34;c1&#34;&gt;#显示系统当前内存的使用情况&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;df -h  		&lt;span class=&#34;c1&#34;&gt;#显示文件系统的磁盘使用情况&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mount 		&lt;span class=&#34;c1&#34;&gt;#挂载&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;uname -a	&lt;span class=&#34;c1&#34;&gt;#显示一些重要的系统信息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;whoami		&lt;span class=&#34;c1&#34;&gt;#显示用户名&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#网络&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ifconfig	&lt;span class=&#34;c1&#34;&gt;#查看网络&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ping IP     &lt;span class=&#34;c1&#34;&gt;#查看与此IP地址的连接情况&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;netstat		&lt;span class=&#34;c1&#34;&gt;#查看网络连接、路由表、网络接口统计信息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#进程&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ps -ef      &lt;span class=&#34;c1&#34;&gt;#查看所有正在运行的进程&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;top    		&lt;span class=&#34;c1&#34;&gt;#显示当前系统中占用资源最多的一些进程&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;kill&lt;/span&gt; pid    &lt;span class=&#34;c1&#34;&gt;#杀死该pid的进程&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;git的base-rebase-merge的使用场景&#34;&gt;Git的base rebase merge的使用场景
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Git中的base、rebase和merge都是用于合并分支的命令，它们的使用场景和效果略有不同。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;merge&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;merge是将两个分支的修改合并到一起。&lt;/p&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将一个分支的修改合并到另一个分支；&lt;/li&gt;
&lt;li&gt;多个人同时开发同一分支，需要将多个分支的修改合并到一起。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;rebase&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;rebase是将一条分支的修改“移植”到另一条分支上，使得两条分支看起来像是连续的提交。在使用rebase命令时，Git会找到两条分支的共同祖先，然后将要移植的分支的修改按照提交顺序依次应用到目标分支上，并创建一个新的commit来保存这次移植的结果。rebase的优点是不会产生无用的合并提交，但是操作比较复杂，需要注意冲突的处理。&lt;/p&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将自己的修改“移植”到另一个分支上；&lt;/li&gt;
&lt;li&gt;保持自己的修改与主干分支同步。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;base&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;base是指两条分支的最近公共祖先。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总的来说，merge适用于一般的分支合并场景，rebase适用于将自己的修改与主干分支同步的场景，而base是用于理解分支关系的概念。具体使用哪种命令，需要根据具体情况进行判断。&lt;/p&gt;
&lt;h3 id=&#34;获取linux的根目录如何操作&#34;&gt;获取Linux的根目录如何操作？
&lt;/h3&gt;&lt;p&gt;在Linux中获取根目录可以使用以下两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用根目录的绝对路径&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根目录在Linux中的绝对路径为“/”，可以直接使用该路径来获取根目录，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;char* root_dir = &amp;#34;/&amp;#34;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;使用系统调用获取根目录&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以使用系统调用&lt;code&gt;getcwd()&lt;/code&gt;来获取当前工作目录的路径，然后在该路径上不断向上查找父目录，直到找到根目录为止。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;char root_dir[PATH_MAX];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;if (getcwd(root_dir, PATH_MAX) != NULL) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    while (strcmp(root_dir, &amp;#34;/&amp;#34;) != 0) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        chdir(&amp;#34;..&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        getcwd(root_dir, PATH_MAX);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;上述代码会在当前工作目录中不断向上查找，直到找到根目录为止，并将根目录路径保存在&lt;code&gt;root_dir&lt;/code&gt;中。注意，该方法需要依赖系统调用，且在权限限制较高的情况下可能无法执行。&lt;/p&gt;
&lt;h3 id=&#34;linux文件系统&#34;&gt;Linux文件系统
&lt;/h3&gt;&lt;p&gt;Linux文件系统是Linux操作系统中文件存储和管理的一种方式，它是操作系统内核中的一个子系统，主要用于管理计算机中的文件、目录、设备、链接等，以及提供对这些资源的访问和保护。Linux文件系统主要由以下几个部分组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;虚拟文件系统（Virtual File System，VFS）：它是Linux文件系统的核心组件，提供了统一的接口来访问不同类型的文件系统，如ext4、NTFS、FAT等。VFS将底层的文件系统抽象为一组通用操作，例如读、写、打开、关闭等，这些操作通过VFS接口来实现。&lt;/li&gt;
&lt;li&gt;硬盘分区：硬盘是Linux文件系统中最常用的存储介质之一，它通常会被分为多个分区，每个分区可以挂载到一个目录上。Linux支持多种分区格式，如MBR、GPT等。&lt;/li&gt;
&lt;li&gt;文件系统：文件系统是Linux文件系统的基本组成部分，它定义了文件和目录的存储方式、访问权限、索引方式等。Linux支持多种文件系统，如ext4、NTFS、FAT等。&lt;/li&gt;
&lt;li&gt;目录：目录是文件系统中的一种特殊文件，用于组织和管理其他文件和目录。Linux中的目录可以通过绝对路径或相对路径来访问。&lt;/li&gt;
&lt;li&gt;文件：文件是Linux文件系统中的基本单元，它可以包含文本、二进制数据、程序代码等。Linux中的文件可以分为普通文件、目录、设备文件、链接文件等多种类型。&lt;/li&gt;
&lt;li&gt;挂载：Linux中的挂载是将一个文件系统关联到一个目录上的过程，这样就可以通过该目录来访问该文件系统中的文件和目录。&lt;/li&gt;
&lt;li&gt;访问权限：Linux文件系统提供了丰富的访问权限控制机制，可以通过设置文件和目录的权限来控制用户对这些资源的访问和操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;shell怎么获得上一条命令执行结果&#34;&gt;shell怎么获得上一条命令执行结果
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;美元符号$加上括号&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;shell命令怎么在后台执行&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用&amp;amp;符号 使用nohup命令 使用ctrl+z和bg命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;linux下vss-rss-pss的区别&#34;&gt;linux下：VSS RSS PSS的区别
&lt;/h3&gt;&lt;p&gt;在 Linux 操作系统中，VSS（Virtual Set Size）、RSS（Resident Set Size）和 PSS（Proportional Set Size）都是用来表示进程占用内存的指标，它们之间的区别如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;VSS：进程的虚拟内存大小，包括代码、数据、共享库、栈和堆等等，它反映了进程最大的地址空间大小，但不代表进程实际使用的内存大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RSS：进程实际占用的物理内存大小，即进程的常驻集大小，包括进程使用的所有物理内存（包括共享库和代码段）以及匿名内存（进程栈和堆等）的大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PSS：根据进程占用的物理内存大小和进程所使用的共享内存大小来计算出来的一个指标，即“比例集大小”，它将共享内存按照使用比例分配到每个进程上，如果多个进程使用相同的共享内存，它们的 PSS 就会相等，相比 RSS 更加公平和精确。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要注意的是，RSS 包括共享内存的大小，而 PSS 则将共享内存按比例分配到每个进程上，因此 PSS 始终小于等于 RSS。另外，VSS 包含了所有映射到进程地址空间的虚拟地址，包括进程未使用的部分，因此 VSS 通常比 RSS 和 PSS 要大。&lt;/p&gt;
&lt;h1 id=&#34;linux驱动&#34;&gt;Linux驱动
&lt;/h1&gt;&lt;h2 id=&#34;面经题-2&#34;&gt;面经题
&lt;/h2&gt;&lt;h3 id=&#34;1linux驱动程序的功能是什么&#34;&gt;1、Linux驱动程序的功能是什么
&lt;/h3&gt;&lt;p&gt;Linux驱动程序是Linux内核中的一种特殊类型的程序，它的主要功能是&lt;strong&gt;将Linux内核与硬件设备之间进行交互，为用户空间的应用程序提供对硬件的访问和控制。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;硬件初始化&lt;/strong&gt;：Linux驱动程序需要完成硬件设备的初始化，包括设备的寄存器设置、内存映射、中断初始化等工作，以保证硬件设备能够正确地工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提供设备接口&lt;/strong&gt;：Linux驱动程序需要实现设备的接口，为用户空间的应用程序提供对硬件设备的访问和控制。例如，设备驱动程序可以提供设备文件接口，通过打开、读写、关闭等操作实现对硬件设备的访问。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理硬件中断&lt;/strong&gt;：许多硬件设备都支持中断机制，Linux驱动程序需要正确地处理硬件中断，例如响应硬件中断、处理中断请求、清除中断标志等工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;管理硬件资源&lt;/strong&gt;：许多硬件设备具有资源竞争的问题，例如同一时刻只能有一个进程使用设备。Linux驱动程序需要管理硬件资源，以保证多个进程之间能够正确地共享硬件资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;实现特定的功能&lt;/strong&gt;：一些设备驱动程序还需要实现特定的功能，例如网络驱动程序需要实现网络协议栈、文件系统驱动程序需要实现文件系统操作等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2内核程序中申请内存使用什么函数&#34;&gt;2、内核程序中申请内存使用什么函数
&lt;/h3&gt;&lt;p&gt;在Linux内核中，申请内存一般使用 kmalloc() 或者 kzalloc() 函数。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;kmalloc() 函数：kmalloc() 函数用于在内核中申请一块指定大小的内存空间，其函数原型为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;void *kmalloc(size_t size, gfp_t flags);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;size 参数表示需要申请的内存大小，flags 参数表示内存分配时的标志。该函数返回一个指向申请到的内存块的指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;kzalloc() 函数：kzalloc() 函数与 kmalloc() 函数相似，但会将申请到的内存空间清零，其函数原型为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;void *kzalloc(size_t size, gfp_t flags);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;size 和 flags 参数的含义与 kmalloc() 函数相同。该函数返回一个指向申请到的内存块的指针，同时该内存块的所有字节都被初始化为0。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两个函数都属于&lt;strong&gt;动态内存分配函数&lt;/strong&gt;，其申请的内存块是位于内核空间中的，因此不能直接被用户空间的应用程序访问。在使用完这些内存块后，应该使用 kfree() 函数将其释放，以避免内存泄漏。&lt;/p&gt;
&lt;h3 id=&#34;3内核程序中申请内存和应用程序时申请内存有什么区别&#34;&gt;3、内核程序中申请内存和应用程序时申请内存有什么区别？
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;内存的地址空间不同：应用程序中申请的内存位于用户空间，而内核程序中申请的内存位于内核空间。&lt;/li&gt;
&lt;li&gt;内存分配的方式不同：应用程序中通常使用 malloc()、calloc() 等函数动态地分配内存，而内核程序中通常使用 kmalloc()、kzalloc() 等函数动态地分配内存。&lt;/li&gt;
&lt;li&gt;内存管理的机制不同：在应用程序中，操作系统会使用虚拟内存管理机制对内存进行管理和保护，以保证不同进程之间不会相互干扰。而在内核程序中，操作系统直接管理物理内存，没有虚拟内存的保护机制，需要自己手动管理和保护内存，避免内存泄漏、内存溢出等问题。&lt;/li&gt;
&lt;li&gt;内存访问的权限不同：在应用程序中，一般只有用户空间的代码可以直接访问用户空间的内存，而内核程序可以直接访问内核空间的内存。另外，在内核空间中，还有访问硬件资源的权限，例如访问 I/O 端口、中断等。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4自旋锁和信号量在互斥使用时需要注意什么在中断服务程序里面的互斥是使用自旋锁还是信号量&#34;&gt;4、自旋锁和信号量在互斥使用时需要注意什么？在中断服务程序里面的互斥是使用自旋锁还是信号量？
&lt;/h3&gt;&lt;p&gt;自旋锁和信号量在互斥使用时需要注意以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;自旋锁是基于忙等待的锁机制，当资源被占用时，其他线程会一直循环等待直到获取到锁为止，这可能会导致死锁。因此，自旋锁的使用需要考虑锁的粒度和等待时间，避免死锁和长时间的忙等待。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号量是基于阻塞的锁机制，当资源被占用时，其他线程会被阻塞，等待锁释放后才能继续执行。因此，信号量的使用需要考虑锁的粒度和阻塞时间，避免死锁和长时间的阻塞。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在中断服务程序里面的互斥一般使用自旋锁，因为中断服务程序是在中断上下文中运行的，不能被阻塞，也不能访问用户空间的内存。自旋锁适用于短时间内等待锁的情况，因此在中断服务程序中使用自旋锁可以获得更好的性能。但需要注意，在中断服务程序中获取自旋锁时不能调用可能会引起阻塞的函数，否则会导致死锁或系统崩溃。&lt;/p&gt;
&lt;h3 id=&#34;5驱动卸载异常可能是由什么原因引起的&#34;&gt;5、驱动卸载异常可能是由什么原因引起的？
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;设备被卸载前未释放占用的资源：驱动程序在设备卸载前应该释放所有占用的资源，例如打开的文件描述符、内存、I/O 端口等。如果驱动程序未正确释放这些资源，可能会导致卸载异常。&lt;/li&gt;
&lt;li&gt;卸载操作被其他进程或模块阻塞：在进行驱动卸载操作时，如果其他进程或模块正在使用该驱动或设备，卸载操作可能会被阻塞，导致卸载异常。为了避免这种情况，驱动程序在卸载前应该先检查是否有其他进程或模块正在使用该设备，如果有，则应该等待其完成操作后再进行卸载。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;6-linux中引入模块机制有什么好处&#34;&gt;6 Linux中引入模块机制有什么好处？
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;灵活性：使用模块机制可以动态地向内核中添加或删除功能，而不需要重新编译整个内核。这使得内核的定制和升级变得更加灵活和方便。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;功能扩展：使用模块机制可以为内核添加新的功能或设备支持，例如网络驱动程序、文件系统、USB 设备等。这使得内核能够更好地适应各种硬件和应用场景。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;资源共享：模块机制可以允许多个模块共享内核资源，例如设备驱动程序可以通过模块机制实现共享同一设备的数据结构或函数接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;系统稳定性：模块机制可以使内核中的功能更加模块化，减少内核的复杂性，从而提高系统的稳定性和可靠性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调试和维护：使用模块机制可以方便地对内核模块进行调试和维护，例如可以通过调试工具动态地加载、卸载和调试内核模块，而不需要重启系统。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;熟悉MCU或者SOC常见驱动(CAN、以太网、存储驱动、USB、SPI、IIC、UART、DMA、中断等)&lt;/p&gt;
&lt;h3 id=&#34;如何将驱动部署到树莓派上&#34;&gt;如何将驱动部署到树莓派上
&lt;/h3&gt;&lt;p&gt;将驱动部署到树莓派上，大致的步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定需要部署的驱动和驱动源码，以及树莓派的操作系统版本和内核版本。&lt;/li&gt;
&lt;li&gt;在树莓派上安装编译工具链和内核头文件，这些工具和头文件可以通过apt-get命令安装。&lt;/li&gt;
&lt;li&gt;下载驱动源码，解压缩，进入源码目录，运行make命令编译驱动模块。编译生成的驱动模块文件通常位于源码目录下的“*.ko”文件中。&lt;/li&gt;
&lt;li&gt;加载驱动模块，可以通过insmod命令加载模块。如果需要在系统启动时自动加载模块，可以将模块名添加到/etc/modules文件中。&lt;/li&gt;
&lt;li&gt;卸载驱动模块，可以通过rmmod命令卸载模块。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;linux增加驱动的过程&#34;&gt;Linux增加驱动的过程
&lt;/h3&gt;&lt;p&gt;在Linux系统中增加一个驱动通常需要以下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;写驱动代码：驱动代码主要包括两部分，一是驱动程序，二是对应的设备节点。驱动程序是实现设备的读写和控制逻辑，设备节点则是用于用户空间和内核空间进行通信的接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译驱动代码：将驱动代码编译成内核模块（.ko文件），需要用到Linux内核源码中的Makefile文件和Kconfig文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加载驱动模块：使用insmod命令加载驱动模块，将模块插入内核并执行模块的初始化函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;卸载驱动模块：使用rmmod命令卸载驱动模块，将模块从内核中移除并执行模块的清理函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试驱动：使用测试程序或者应用程序通过设备节点进行读写或控制设备，测试驱动是否正常工作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在增加驱动的过程中需要注意以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;写驱动代码需要遵守Linux内核开发规范，包括驱动程序和设备节点的命名、内核数据结构的使用等方面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;驱动模块需要编译成内核模块，不能直接编译成可执行文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加载驱动模块需要具有root权限或者使用sudo命令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试驱动时需要注意数据的正确性和边界条件，防止出现内存泄漏、死锁等问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;驱动代码需要经过充分的测试和验证，确保其稳定性和可靠性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;嵌入式linux驱动是怎么写的&#34;&gt;嵌入式linux驱动是怎么写的？
&lt;/h3&gt;&lt;p&gt;嵌入式 Linux 驱动程序通常采用字符设备驱动、块设备驱动、网络设备驱动等类型，编写步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;确定驱动类型和设备名称：确定驱动类型，选择设备名称和驱动程序的主设备号，这是在驱动注册和设备文件节点创建时需要用到的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写设备文件操作函数：包括 open、release、read、write、ioctl 等函数，这些函数实现了对设备的控制和数据交互。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现驱动初始化和注销函数：init 和 exit 函数，init 函数初始化驱动，register_chrdev 和 cdev_add 函数完成驱动注册和设备节点创建，exit 函数注销驱动，释放驱动资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现中断处理函数：针对硬件中断，需要实现对应的中断处理函数，处理中断事件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写 Makefile 文件：编写 Makefile 文件，描述编译、链接、安装等过程，方便编译和部署。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译、链接、部署：使用交叉编译器编译、链接，将生成的驱动模块和相关文件部署到目标系统中，完成驱动程序的加载和运行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;说说linux多线程编程&#34;&gt;说说Linux多线程编程
&lt;/h3&gt;&lt;p&gt;Linux多线程编程指在Linux操作系统下使用多线程进行程序开发。Linux下的多线程编程主要是基于POSIX标准的pthread库来实现的。下面是Linux多线程编程的一些基本知识：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;线程创建：使用pthread_create()函数可以创建一个线程，该函数需要传入一个线程标识符、线程属性、线程函数和线程函数参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程同步：Linux下线程同步主要包括互斥锁、条件变量和信号量。互斥锁用于保护临界区，条件变量用于线程等待某些条件满足，信号量用于控制并发访问资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程退出：线程可以通过pthread_exit()函数来退出，也可以通过return语句退出。主线程可以通过pthread_join()函数等待其他线程退出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程取消：线程可以通过pthread_cancel()函数来取消，被取消的线程可以通过pthread_testcancel()函数来检测是否被取消。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程调度：Linux下的线程调度采用抢占式调度策略，优先级高的线程会抢占CPU资源，优先级低的线程会被挂起。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在进行Linux多线程编程时，需要注意以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;线程同步：多线程编程中需要考虑线程之间的同步问题，以避免数据竞争和死锁等问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存管理：多线程编程需要考虑内存的分配和释放，避免出现内存泄漏和野指针等问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程安全：多线程编程需要考虑线程安全问题，以避免出现数据竞争和线程不安全的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调试和排错：多线程编程中调试和排错比较困难，需要使用一些调试工具和技术，以便及时发现和解决问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;说说linux网络编程过程&#34;&gt;说说Linux网络编程过程
&lt;/h3&gt;&lt;p&gt;Linux网络编程主要涉及到以下过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建 socket
创建一个 socket 句柄用于后续操作。可以使用 socket 系统调用创建 socket 句柄，根据协议类型和传输方式，选择合适的参数来调用该系统调用。&lt;/li&gt;
&lt;li&gt;绑定 IP 地址和端口号
如果要接收来自网络的连接请求，需要使用 bind 系统调用将 socket 句柄与 IP 地址和端口号绑定。&lt;/li&gt;
&lt;li&gt;监听端口
使用 listen 系统调用让 socket 句柄进入监听状态，等待来自客户端的连接请求。&lt;/li&gt;
&lt;li&gt;接受连接请求
当有客户端连接请求到来时，使用 accept 系统调用接受连接请求并返回一个新的 socket 句柄，该句柄用于后续与客户端的通信。&lt;/li&gt;
&lt;li&gt;与客户端通信
使用 send 和 recv 等系统调用进行数据传输，其中 send 系统调用用于将数据发送到网络，recv 系统调用用于从网络中接收数据。&lt;/li&gt;
&lt;li&gt;断开连接
当通信结束后，使用 close 系统调用关闭与客户端的连接，释放相应的资源。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;gcc和armcc编译出来的程序有什么差异么&#34;&gt;gcc和armcc编译出来的程序有什么差异么？
&lt;/h3&gt;&lt;p&gt;GCC和ARMCC是两种不同的编译器，GCC是开源的C/C++编译器，而ARMCC是由ARM公司开发的商业编译器。它们在编译出来的程序上会有一些差异。&lt;/p&gt;
&lt;p&gt;一些差异点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译速度：ARMCC编译速度相对较快，GCC编译速度相对较慢。&lt;/li&gt;
&lt;li&gt;代码优化：ARMCC编译器在代码优化方面较强，能够生成更高效的代码，而GCC编译器在某些情况下可能会生成相对较差的代码。&lt;/li&gt;
&lt;li&gt;编译选项：ARMCC编译器提供了一些独特的编译选项，能够进行更为精细的控制，而GCC的编译选项相对简单。&lt;/li&gt;
&lt;li&gt;库的支持：GCC编译器可以使用开源的库，而ARMCC只能使用ARM提供的库。&lt;/li&gt;
&lt;li&gt;代码移植性：使用GCC编译的代码可以很方便地在不同的平台上移植，而使用ARMCC编译的代码则可能会存在一些平台兼容性问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ros操作系统是什么&#34;&gt;ROS操作系统是什么
&lt;/h3&gt;&lt;p&gt;ROS（Robot Operating System）是一个开源的机器人操作系统，旨在为机器人软件开发提供一种灵活、可重用的框架。从技术角度来说，ROS并不是一个完整的操作系统，而是一个构建在现有操作系统之上的中间件层，提供了一系列的工具、库和约定，使得机器人软件开发更加容易、快速和可靠。&lt;/p&gt;
&lt;p&gt;ROS的主要特点包括：&lt;/p&gt;
&lt;p&gt;1.分布式系统：ROS支持多台计算机上的节点通信，允许用户通过网络在不同的机器人上运行节点。&lt;/p&gt;
&lt;p&gt;2.模块化设计：ROS采用模块化设计，可以将不同的功能模块打包为独立的节点，方便用户自定义构建机器人应用程序。&lt;/p&gt;
&lt;p&gt;3.语言支持：ROS支持多种编程语言，包括C++、Python等，方便用户根据自己的需求选择不同的编程语言。&lt;/p&gt;
&lt;p&gt;4.强大的工具和库：ROS提供了丰富的工具和库，如可视化工具、运动规划库、机器人模拟器等，可以大大提高机器人软件开发的效率。&lt;/p&gt;
&lt;h3 id=&#34;ros操作系统和其它操作系统的区别&#34;&gt;ROS操作系统和其它操作系统的区别？
&lt;/h3&gt;&lt;p&gt;ROS（Robot Operating System）是一款机器人操作系统，而Linux是一款通用的计算机操作系统。虽然ROS是基于Linux开发的，但是它们之间有一些区别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;目标用户不同：Linux是通用的计算机操作系统，面向的用户是广泛的计算机用户，而ROS主要面向机器人应用领域的开发者和研究人员。&lt;/li&gt;
&lt;li&gt;应用场景不同：Linux可以应用于各种领域，包括服务器、桌面、移动设备等，而ROS主要用于机器人的控制、导航、感知等方面。&lt;/li&gt;
&lt;li&gt;软件架构不同：Linux的软件架构是通用的，而ROS则提供了一套专门为机器人开发的软件架构。ROS中的软件组件被称为“节点”（nodes），节点之间通过消息传递机制通信，方便实现分布式控制和处理。&lt;/li&gt;
&lt;li&gt;应用开发方式不同：Linux应用开发主要是面向进程和线程编程，而ROS应用开发则是基于节点的，需要使用ROS提供的工具和库函数进行开发。&lt;/li&gt;
&lt;li&gt;发布和共享代码的方式不同：Linux应用程序可以通过软件包管理工具进行发布和共享，而ROS应用程序则可以通过ROS软件包管理工具进行发布和共享。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;linux应用&#34;&gt;Linux应用
&lt;/h1&gt;&lt;h1 id=&#34;面经&#34;&gt;面经
&lt;/h1&gt;&lt;h4 id=&#34;项目有什么难点-怎么解决&#34;&gt;项目有什么难点 怎么解决
&lt;/h4&gt;&lt;h4 id=&#34;数组中选择第3大的数字&#34;&gt;数组中选择第3大的数字
&lt;/h4&gt;&lt;p&gt;小顶堆&lt;/p&gt;
&lt;p&gt;unordered_set&lt;/p&gt;
&lt;h4 id=&#34;tcpudp区别udp怎么变安全&#34;&gt;tcp、udp区别、udp怎么变安全
&lt;/h4&gt;&lt;p&gt;TCP：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向连接。在数据传输之前，必须建立一个连接。&lt;/li&gt;
&lt;li&gt;可靠的。使用序列号、确认和重传机制来确保数据的正确性和完整性。&lt;/li&gt;
&lt;li&gt;面向字节流。将数据分割成小块并以顺序发送，接收端重新组装这些块。&lt;/li&gt;
&lt;li&gt;适用于网页浏览、文件传输。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;UDP：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无连接。发送端直接将数据包发送到接收端，而不需要建立连接。&lt;/li&gt;
&lt;li&gt;不可靠。数据包可能会在传输过程中丢失或以不同的顺序到达。&lt;/li&gt;
&lt;li&gt;数据报协议。将数据分为离散的数据包，每个数据包都是一个独立的单元，没有顺序要求。&lt;/li&gt;
&lt;li&gt;适用于视频流、在线协议。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;UDP变安全&lt;/p&gt;
&lt;p&gt;加密数据，数据签名，消息认证码，访问控制&lt;/p&gt;
&lt;h4 id=&#34;访问wwwbaiducom用到了哪些协议&#34;&gt;访问www.baidu.com用到了哪些协议
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;HTTP/HTTPS（超文本传输协议）&lt;/li&gt;
&lt;li&gt;DNS（域名系统）&lt;/li&gt;
&lt;li&gt;TCP/IP（传输控制协议/互联网协议）&lt;/li&gt;
&lt;li&gt;TLS/SSL（传输层安全协议/安全套接字层协议）&lt;/li&gt;
&lt;li&gt;ICMP（Internet控制消息协议）：&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;io复用&#34;&gt;IO复用
&lt;/h4&gt;&lt;p&gt;用于在单个线程或进程中同时监视多个I/O操作，允许程序同时等待多个文件描述符（通常是套接字）上的I/O事件，通常与非阻塞I/O一起使用，以实现高效的异步I/O操作。&lt;/p&gt;
&lt;p&gt;一般步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建需要监视的套接字或文件描述符。&lt;/li&gt;
&lt;li&gt;使用I/O复用函数（如&lt;code&gt;select&lt;/code&gt;、&lt;code&gt;poll&lt;/code&gt;、&lt;code&gt;epoll&lt;/code&gt;等）来等待I/O事件。&lt;/li&gt;
&lt;li&gt;当有事件发生时，I/O复用函数将通知应用程序，应用程序可以执行相应的读取或写入操作。&lt;/li&gt;
&lt;li&gt;处理完事件后，应用程序继续等待下一个事件。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;异步io和非阻塞io&#34;&gt;异步IO和非阻塞IO
&lt;/h4&gt;&lt;p&gt;异步IO：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;发出I/O请求后不必等待操作完成。&lt;/p&gt;
&lt;p&gt;应用程序继续执行其他任务，而I/O操作完成后，操作系统会通知应用程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事件驱动&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;非阻塞IO：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;允许进程或线程在发出I/O请求后不必等待操作完成。&lt;/p&gt;
&lt;p&gt;非阻塞的I/O操作被调用时，它会立即返回。周期性地轮询或使用选择（select）函数来检查I/O操作是否已经完成。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;多线程和多进程优劣&#34;&gt;多线程和多进程优劣
&lt;/h4&gt;&lt;p&gt;多线程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多线程共享同一进程的内存空间，通信更高效&lt;/li&gt;
&lt;li&gt;创建销毁线程开销小，切换成本小&lt;/li&gt;
&lt;li&gt;适用于IO密集型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多进程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个进程有自己的独立空间，进程之间不会互相干扰&lt;/li&gt;
&lt;li&gt;适用于CPU密集型&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;内核线程和用户线程&#34;&gt;内核线程和用户线程
&lt;/h4&gt;&lt;p&gt;内核线程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内核直接管理和调度&lt;/li&gt;
&lt;li&gt;可以执行系统调用&lt;/li&gt;
&lt;li&gt;线程切换开销较高，它需要从用户模式切换到内核模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用户线程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户空间的应用程序库管理&lt;/li&gt;
&lt;li&gt;无法直接执行系统调用，必须将请求传递给相关的内核线程或进程。&lt;/li&gt;
&lt;li&gt;用户线程相对较轻量级且更灵活&lt;/li&gt;
&lt;li&gt;用户线程的线程切换开销较低，不涉及内核模式和用户模式之间的切换。线程切换是在用户空间完成的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;静态库是在编译的什么阶段产生的&#34;&gt;静态库是在编译的什么阶段产生的？
&lt;/h4&gt;&lt;p&gt;编译阶段&lt;/p&gt;
&lt;h4 id=&#34;虚函数存储在哪里&#34;&gt;虚函数存储在哪里？
&lt;/h4&gt;&lt;p&gt;虚函数表vtable在Linux/Unix中存放在可执行文件的只读数据段中(rodata)，微软的编译器将虚函数表存放在常量段。&lt;/p&gt;
&lt;h4 id=&#34;gdb常用命令&#34;&gt;gdb常用命令
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;启动和退出：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;gdb [可执行文件]&lt;/code&gt;：启动GDB并加载指定的可执行文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;quit&lt;/code&gt; 或 &lt;code&gt;q&lt;/code&gt;：退出GDB。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行程序&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;run&lt;/code&gt; 或 &lt;code&gt;r&lt;/code&gt;：运行被调试的程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;断点&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;break [文件名:行号]&lt;/code&gt;：在指定的源代码行上设置断点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;break [函数名]&lt;/code&gt;：在指定的函数入口处设置断点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;info breakpoints&lt;/code&gt;：列出所有断点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;delete [断点号]&lt;/code&gt;：删除指定的断点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;继续执行&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;continue&lt;/code&gt; 或 &lt;code&gt;c&lt;/code&gt;：继续执行程序，直到遇到下一个断点或程序结束。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;next&lt;/code&gt; 或 &lt;code&gt;n&lt;/code&gt;：执行下一行代码，不进入函数内部。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;step&lt;/code&gt; 或 &lt;code&gt;s&lt;/code&gt;：执行下一行代码，如果有函数调用，则进入函数内部。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;查看变量和内存&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;print [表达式]&lt;/code&gt; 或 &lt;code&gt;p [表达式]&lt;/code&gt;：打印表达式的值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;info locals&lt;/code&gt;：显示当前函数的局部变量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;info args&lt;/code&gt;：显示当前函数的参数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x/[格式] [地址]&lt;/code&gt;：以指定格式查看内存中的内容，例如 &lt;code&gt;x/4xw &amp;amp;variable&lt;/code&gt; 可以查看变量的四个字（word）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;回溯和堆栈&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;backtrace&lt;/code&gt; 或 &lt;code&gt;bt&lt;/code&gt;：显示函数调用堆栈。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;frame [帧号]&lt;/code&gt;：切换到指定堆栈帧。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;info frame&lt;/code&gt;：显示当前堆栈帧的信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设置断点条件&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;break [文件名:行号] if [条件]&lt;/code&gt;：在满足条件时触发断点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;监视点&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;watch [表达式]&lt;/code&gt;：设置监视点，当表达式的值发生变化时停止程序。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;info watchpoints&lt;/code&gt;：列出所有监视点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单步执行汇编指令&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;si&lt;/code&gt;：单步执行一条汇编指令。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ni&lt;/code&gt;：单步执行一条汇编指令，不进入函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;改变变量的值&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;set variable [变量名]=[新值]&lt;/code&gt;：修改变量的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加载共享库&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sharedlibrary&lt;/code&gt;：加载共享库以进行调试。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其他&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;list&lt;/code&gt; 或 &lt;code&gt;l&lt;/code&gt;：显示源代码。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;help&lt;/code&gt; 或 &lt;code&gt;h&lt;/code&gt;：获取GDB的帮助。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;info [选项]&lt;/code&gt;：显示有关程序、线程、源文件等的信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;memcpystrcpy区别&#34;&gt;memcpy、strcpy区别
&lt;/h4&gt;&lt;p&gt;memcpy：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从一个内存地址复制一定数量的字节到另一个内存地址。&lt;/li&gt;
&lt;li&gt;不需要包含终止符。但如果没有足够的目标内存空间，可能会导致缓冲区溢出。&lt;/li&gt;
&lt;li&gt;没有返回值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;strcpy:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;复制字符串直到遇到字符串终止符。&lt;/li&gt;
&lt;li&gt;需要确保源字符串以 null 结尾，否则可能导致未定义的行为。&lt;/li&gt;
&lt;li&gt;返回目标字符串的指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;讲一讲你了解的linux操作系统&#34;&gt;讲一讲你了解的linux操作系统
&lt;/h4&gt;&lt;p&gt;开源的、基于Unix的操作系统内核，它是一个典型的多用户、多任务操作系统。&lt;/p&gt;
&lt;p&gt;多样的发行版、命令行界面、开发者友好、网络和服务器、社区支持&lt;/p&gt;
&lt;h4 id=&#34;多线程开发需要注意些什么&#34;&gt;多线程开发需要注意些什么？
&lt;/h4&gt;&lt;p&gt;线程安全、死锁、资源管理、考虑性能、避免饥饿和优先级反转&lt;/p&gt;
&lt;h4 id=&#34;线程和进程的区别分别是怎么通信的&#34;&gt;线程和进程的区别，分别是怎么通信的
&lt;/h4&gt;&lt;p&gt;线程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU调度的单位&lt;/li&gt;
&lt;li&gt;共享相同的进程内存空间&lt;/li&gt;
&lt;li&gt;创建、销毁和切换开销小&lt;/li&gt;
&lt;li&gt;并发性较高，可以在同一进程内并发执行，共享数据和资源。&lt;/li&gt;
&lt;li&gt;通信：线程之间通信相对容易，因为它们共享相同的地址空间。线程之间通常使用共享内存、互斥锁、条件变量、信号量等同步机制来实现通信和资源共享。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;资源分配的单位&lt;/li&gt;
&lt;li&gt;每个进程都有自己的独立内存空间，通信和资源共享需要特殊的机制。&lt;/li&gt;
&lt;li&gt;通信：管道、消息队列、共享内存、套接字等。这些机制允许不同进程之间在不同的地址空间中进行数据传输和通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;用户空间和内核空间的访问方式&#34;&gt;用户空间和内核空间的访问方式
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过&lt;strong&gt;系统调用&lt;/strong&gt;请求内核执行特权操作。&lt;/p&gt;
&lt;p&gt;使用特殊的指令或软件中断（如x86架构上的&lt;code&gt;int 0x80&lt;/code&gt;或&lt;code&gt;syscall&lt;/code&gt;指令）来触发系统调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当发生&lt;strong&gt;中断&lt;/strong&gt;时，CPU会暂停正在执行的用户空间代码，并跳转到内核空间中断处理程序。&lt;/p&gt;
&lt;p&gt;中断处理程序负责处理中断，保存用户空间的状态、执行必要的操作，然后返回到用户空间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在用户空间，通常有一个&lt;strong&gt;系统调用库&lt;/strong&gt;（如glibc），它提供了与系统调用的高级接口，以便用户空间程序更容易地发起系统调用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对epoll的理解&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;允许程序同时监视多个文件描述符，以确定哪些文件描述符已准备好进行读取或写入，而无需阻塞地等待。提高了程序的并发性能。&lt;/li&gt;
&lt;li&gt;与传统的&lt;code&gt;select&lt;/code&gt;和&lt;code&gt;poll&lt;/code&gt;相比，&lt;code&gt;epoll&lt;/code&gt;在大规模并发的情况下表现更出色。它使用了内核事件通知机制，可以有效地管理大量的文件描述符，而不会引入线性扫描的性能问题。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;epoll&lt;/code&gt;通常与非阻塞I/O一起使用，以确保文件描述符的操作不会阻塞整个程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;如何避免死锁&#34;&gt;如何避免死锁
&lt;/h4&gt;&lt;p&gt;按顺序获取锁、使用超时机制、使用尝试锁、资源分级（获取较低级别的资源之后才能请求较高级别的资源）、定期检查死锁、使用自旋锁&lt;/p&gt;
&lt;h4 id=&#34;检测死锁&#34;&gt;检测死锁
&lt;/h4&gt;&lt;p&gt;资源申请机制、系统监视（多个进程都在等待某个资源，并且该资源的使用量已经达到或接近上限）、死锁检测算法（可以采用图论、图算法或其他数学方法）&lt;/p&gt;
&lt;h4 id=&#34;const和define区别&#34;&gt;const和define区别
&lt;/h4&gt;&lt;p&gt;const：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;具有作用域，只在定义它们的代码块或函数内可见。&lt;/li&gt;
&lt;li&gt;类型安全性，编译器会检查使用 &lt;code&gt;const&lt;/code&gt; 常量的地方是否与其类型兼容。&lt;/li&gt;
&lt;li&gt;在编译阶段处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;#define&lt;/code&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建的宏常量是全局的。&lt;/li&gt;
&lt;li&gt;没有类型信息，它们只是简单地进行文本替换。&lt;/li&gt;
&lt;li&gt;在预处理阶段处理的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;const变量可以用指针改变吗局部const和全局const都可以吗在mcu和linux上有什么区别&#34;&gt;const变量可以用指针改变吗，局部const和全局const都可以吗，在mcu和linux上有什么区别
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt; 变量是只读的，不能通过直接赋值或指针来修改其值。无论是局部的还是全局的 &lt;code&gt;const&lt;/code&gt; 变量都不行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;局部 &lt;code&gt;const&lt;/code&gt; 变量通常存储在栈上，全局范围内定义的 &lt;code&gt;const&lt;/code&gt; 变量存储在程序的数据段中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 MCU 上，内存资源通常有限，可能无法轻松支持数据段中的全局 &lt;code&gt;const&lt;/code&gt; 变量。不同的 MCU 使用不同的编译器和工具链，这些工具链可能对 &lt;code&gt;const&lt;/code&gt; 变量的处理方式有所不同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;什么时候要注意大小端&#34;&gt;什么时候要注意大小端
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;跨平台数据交换&lt;/strong&gt;：不同的计算机架构之间传递时，需要考虑大小端。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件格式&lt;/strong&gt;：如果您正在读取或写入二进制文件格式，文件中的数据的字节序可能与您的计算机字节序不同。在这种情况下，您需要进行字节序转换以正确处理文件中的数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络通信&lt;/strong&gt;：不同的计算机可能使用不同的字节序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;硬件寄存器&lt;/strong&gt;：某些硬件寄存器的访问可能受到大小端的影响。在与硬件通信时，需要了解硬件的字节序要求。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;互斥锁和自旋锁哪个不能递归访问&#34;&gt;互斥锁和自旋锁哪个不能递归访问
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;互斥锁是不支持递归访问的，这意味着同一线程在已经持有互斥锁的情况下再次尝试获取锁会导致死锁。要支持递归访问，需要使用递归互斥锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自旋锁通常支持递归访问，允许同一线程多次获取自旋锁，只要每次获取都有相应的释放操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;锁的选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果临界区的保护时间很短，且锁的竞争不激烈，自旋锁可能是一个更好的选择，因为它减少了线程切换的开销。&lt;/li&gt;
&lt;li&gt;如果临界区的保护时间较长，或者锁的竞争较激烈，互斥锁可能更适合，因为它可以有效地释放 CPU 资源并避免浪费。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;锁一定会调用系统调用吗&#34;&gt;锁一定会调用系统调用吗
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;用户态锁&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户态锁是在用户空间实现的，它们通常不涉及系统调用。用户态锁的操作是通过用户程序中的代码来完成的，而不需要进入内核态。&lt;/li&gt;
&lt;li&gt;例如，普通的互斥锁和自旋锁在低竞争情况下通常会采用忙等（自旋）方式，而不会触发系统调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;内核态锁&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内核态锁是在内核空间实现的，它们涉及系统调用。内核态锁的操作需要进入内核态，因为内核负责管理和维护锁的状态。&lt;/li&gt;
&lt;li&gt;例如，读写锁、条件变量等通常需要系统调用来进行锁的获取和释放。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;uart和spi如果需要两个芯片间双向通信用哪种协议&#34;&gt;uart和spi，如果需要两个芯片间双向通信用哪种协议
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;通信速度&lt;/strong&gt;：如果您需要高速通信，SPI 通常具有更高的速度潜力&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;硬件支持&lt;/strong&gt;：检查您的芯片和外围设备支持哪种通信协议。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通信距离&lt;/strong&gt;：SPI 通常用于短距离通信，而UART 可以用于较长的通信距离。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通信复杂性&lt;/strong&gt;：SPI 通常需要更多的线路和硬件资源。UART 通常较简单。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;自动化工具&#34;&gt;自动化工具
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Shell 脚本&lt;/li&gt;
&lt;li&gt;编程语言编写脚本和应用程序，用于自动化各种任务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容器编排工具&lt;/strong&gt;：容器编排工具如Docker Compose、Kubernetes&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;任务调度工具&lt;/strong&gt;：任务调度工具如Apache Airflow、Cron等用于定期执行任务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;监控和警报工具&lt;/strong&gt;：监控和警报工具如Prometheus、Nagios、Zabbix等&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;linux程序如果访问空指针会出现什么&#34;&gt;linux程序如果访问空指针会出现什么
&lt;/h4&gt;&lt;p&gt;段错误、未定义行为、程序崩溃或异常终止&lt;/p&gt;
&lt;h4 id=&#34;mmu是硬件还是软件&#34;&gt;mmu是硬件还是软件
&lt;/h4&gt;&lt;p&gt;MMU（内存管理单元）是硬件的一部分。实现在CPU中。MMU的主要任务是管理计算机内存的访问，包括&lt;strong&gt;虚拟内存到物理内存的映射&lt;/strong&gt;、&lt;strong&gt;内存保护&lt;/strong&gt;和&lt;strong&gt;访问权限&lt;/strong&gt;等。&lt;/p&gt;
&lt;p&gt;主要功能包括：&lt;/p&gt;
&lt;p&gt;​		地址映射、内存保护、页面交换、缓存管理&lt;/p&gt;
&lt;h4 id=&#34;三级页表是如何寻址的&#34;&gt;三级页表是如何寻址的
&lt;/h4&gt;&lt;p&gt;三级页表：顶级页表、中间页表和底层页表。&lt;/p&gt;
&lt;p&gt;如何寻址的一般过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟地址分解、顶级页表访问、中间页表访问、底层页表访问、偏移量计算、访问物理内存&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;什么情况下会自己写拷贝构造函数&#34;&gt;什么情况下会自己写拷贝构造函数
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;动态内存分配：&lt;/strong&gt; 默认的浅拷贝构造函数是浅拷贝。可能导致资源泄漏或悬挂指针。在这种情况下，需要编写自定义的拷贝构造函数来执行深拷贝，即复制指针指向的数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源管理：&lt;/strong&gt; 如果类负责管理其他资源，如文件句柄、网络连接等，可能需要自定义拷贝构造函数来确保在复制对象时适当地管理这些资源，以避免资源泄漏或重复释放资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特殊逻辑：&lt;/strong&gt; 希望在对象拷贝时执行特殊的逻辑操作，例如记录日志、更新计数器等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;禁止拷贝：&lt;/strong&gt; 在某些情况下，希望禁止类的对象被拷贝，以确保对象的唯一性。可以定义私有的拷贝构造函数并将其设置为删除，或者声明拷贝构造函数为私有，从而禁止对象的拷贝。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;stl库的内存配置&#34;&gt;STL库的内存配置
&lt;/h4&gt;&lt;p&gt;包括一级内存配置和二级内存配置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一级内存配置：&lt;/strong&gt; 一级内存配置使用C++标准库中的&lt;code&gt;new&lt;/code&gt;和&lt;code&gt;delete&lt;/code&gt;运算符来执行内存分配和释放操作。这些运算符是基本的内存配置工具，它们使用全局的内存池来进行分配和释放操作。一级内存配置相对简单，适用于大多数情况，但可能会受到内存碎片等问题的影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二级内存配置：&lt;/strong&gt; 二级内存配置是STL库中的高级内存配置机制，它是建立在一级内存配置之上的。STL的二级内存配置机制通过内存分配器（allocator）来实现，它可以更灵活地管理内存池，减少内存碎片和提高性能。二级内存配置的一个主要目标是提供更好的内存管理，以满足STL容器和算法的性能需求。&lt;/p&gt;
&lt;h4 id=&#34;线程安全是如何保证的除了锁还有&#34;&gt;线程安全是如何保证的？除了锁还有
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;互斥锁：&lt;/li&gt;
&lt;li&gt;读写锁：&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原子操作&lt;/strong&gt;：原子操作是不可分割的操作，它们可以确保在多线程环境中执行时不会中断。许多编程语言和库提供了原子操作，可以用来保护共享数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无锁数据结构&lt;/strong&gt;：无锁数据结构是一种设计，使用原子操作和非阻塞算法来实现线程安全。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;信号量和条件变量&lt;/strong&gt;：信号量和条件变量可以用来实现更复杂的同步机制。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程局部存储&lt;/strong&gt;：线程局部存储允许每个线程拥有自己独立的数据副本。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;我的面经&#34;&gt;我的面经
&lt;/h1&gt;&lt;p&gt;int a:1表示什么&lt;/p&gt;
&lt;p&gt;运行时bug怎么调试&lt;/p&gt;
&lt;h2 id=&#34;1-freertos-音乐播放器&#34;&gt;1. FreeRTOS 音乐播放器
&lt;/h2&gt;&lt;p&gt;歌曲名记录在listview控件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优先级&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;任务&lt;/th&gt;
          &lt;th&gt;优先级&lt;/th&gt;
          &lt;th&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;IDLE&lt;/td&gt;
          &lt;td&gt;0&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;GUI&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;UserIF&lt;/td&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;接口消息处理&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;LED&lt;/td&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Start&lt;/td&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;启动任务。最高优先级任务，这里实现按键扫描和触摸检测&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;MUSIC&lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;MP3软解任务&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;任务状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;阻塞  就绪 删除 挂起&lt;/p&gt;
&lt;p&gt;使用互斥信号量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;任务通信&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;10个存储指针变量的消息队列，同时分配SRAM作为动态内存&lt;/p&gt;
&lt;h2 id=&#34;2比特率和波特率&#34;&gt;2.比特率和波特率
&lt;/h2&gt;&lt;p&gt;比特率是每秒钟传送的比特数量。比特率基本单位为bit/s或bps，全称为bit per second&lt;/p&gt;
&lt;p&gt;波特：每秒钟传送的符号（码元）数量，又称为传码率，单位是波特（Baud、B，即symbol/s）。在通信系统中，携带数据信息的信号单元称为码元，也称为符号（symbol）。&lt;/p&gt;
&lt;p&gt;码元状态为N，此码元所需要的比特位数：$log_2N$&lt;/p&gt;
&lt;p&gt;比特率=波特率*$log_2N$&lt;/p&gt;
&lt;h2 id=&#34;3uart&#34;&gt;3.UART
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/150504364&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;参考&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通用异步收发器&lt;/strong&gt;（Universal Asynchronous Receiver/Transmitter,&lt;strong&gt;UART&lt;/strong&gt;)，&lt;strong&gt;是一种串行、异步、全双工的通信协议&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;传输速率：支持多种不同的波特率，最常见的包括9600、115200等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传输距离：用于短距离通信，典型的距离范围为几米到数十米。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;信号线上的状态为高电平时代表‘1’，信号线上的状态为低电平时代表‘0’。&lt;/p&gt;
&lt;img src=&#34;https://pic1.zhimg.com/80/v2-2ebc83957b33a1525468eed46d3139c8_720w.webp&#34; alt=&#34;img&#34; style=&#34;zoom:33%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;空闲位：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	当总线处于空闲状态时信号线的状态为‘1’即高电平，表示当前线路上没有数据传输。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;起始位：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　每开始一次通信时发送方先发出一个逻辑”0”的信号（低电平），表示传输字符的开始。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据位：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　起始位之后就是我们所要传输的数据，数据位可以是5、6、7、8，9位等，构成一个字符（一般都是8位）。先发送&lt;strong&gt;最低位&lt;/strong&gt;，最后发送&lt;strong&gt;最高位&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;奇偶校验位：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无校验（no parity）。&lt;/li&gt;
&lt;li&gt;奇校验（odd parity）：如果数据位中“1”的数目是偶数，则校验位为“1”，如果“1”的数目是奇数，校验位为“0”。&lt;/li&gt;
&lt;li&gt;偶校验（even parity）：如果数据为中“1”的数目是偶数，则校验位为“0”，如果为奇数，校验位为“1”。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;停止位：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　它是一个字符数据的结束标志。可以是1位、1.5位、2位的高电平。&lt;/p&gt;
&lt;h2 id=&#34;4spi&#34;&gt;4.SPI
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/as480133937/article/details/105764119&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/as480133937/article/details/105764119&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SPI(Serial Peripheral interface)，串行外围设备接口。高速的，全双工，同步的通信总线。摩托罗拉&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传输速率高，可以达到几十Mbps甚至更高。适用于相对短距离的通信&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SPI主从模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SPI分为主、从两种模式。一个主设备，一个或多个从设备。提供时钟的为主设备（Master），接收时钟的设备为从设备（Slave），SPI接口的读写操作，都是由主设备发起。当存在多个从设备时，通过各自的片选信号进行管理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SPI信号线&lt;/strong&gt;
SPI接口一般使用四条信号线通信：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MISO： 主设备输入/从设备输出引脚。该引脚在从模式下发送数据，在主模式下接收数据。&lt;/li&gt;
&lt;li&gt;MOSI： 主设备输出/从设备输入引脚。该引脚在主模式下发送数据，在从模式下接收数据。&lt;/li&gt;
&lt;li&gt;SCLK：串行时钟信号，由主设备产生。&lt;/li&gt;
&lt;li&gt;NSS：从设备片选信号，由主设备控制。低电平有效，多个从设备多个片选引脚。&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200429141530267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70&#34; style=&#34;zoom:33%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;设备选择&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当SPI主设备想读/写［从设备］时，它首先拉低［从设备］对应的SS线（SS是低电平有效）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SPI数据发送接收&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SPI主机和从机都有一个串行移位寄存器，主机通过向它的SPI串行寄存器写入一个字节来发起一次传输。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先拉低对应SS信号线，表示与该设备进行通信&lt;/li&gt;
&lt;li&gt;主机通过发送SCLK时钟信号，来告诉从机写数据或者读数据&lt;/li&gt;
&lt;li&gt;主机将要发送的数据写到发送数据缓存区(Menory)，缓存区经过移位寄存器(0~7)，串行移位寄存器通过MOSI信号线将字节一位一位的移出去传送给从机，同时MISO接口接收到的数据经过移位寄存器一位一位的移到接收缓存区。&lt;/li&gt;
&lt;li&gt;从机也将自己的串行移位寄存器(0~7)中的内容通过MISO信号线返回给主机。同时通过MOSI信号线接收主机发送的数据，这样，两个移位寄存器中的内容就被交换。&lt;/li&gt;
&lt;/ol&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200429143110758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70&#34; style=&#34;zoom:33%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;SPI时钟四种模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;时钟极性(CPOL)定义了时钟空闲状态电平：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPOL=0，表示当SCLK=0时处于空闲态，所以有效状态就是SCLK处于高电平时&lt;/li&gt;
&lt;li&gt;CPOL=1，表示当SCLK=1时处于空闲态，所以有效状态就是SCLK处于低电平时&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;时钟相位(CPHA)定义数据的采集时间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPHA=0，在时钟的第一个跳变沿（上升沿或下降沿）进行数据采样。在第2个边沿发送数据&lt;/li&gt;
&lt;li&gt;CPHA=1，在时钟的第二个跳变沿（上升沿或下降沿）进行数据采样。在第1个边沿发送数据&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200428214324195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70&#34; style=&#34;zoom:75%;&#34; /&gt;
&lt;h2 id=&#34;5iic&#34;&gt;5.IIC
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_38410730/article/details/80312357&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/qq_38410730/article/details/80312357&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/as480133937/article/details/105366932&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/as480133937/article/details/105366932&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;IIC（Inter－Integrated Circuit）总线。**半双工通信。**飞利浦公司。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标准模式的速率为100 kbps，快速模式为400 kbps。&lt;/li&gt;
&lt;li&gt;传输距离：I2C也适用于短距离通信，典型的距离范围为几米。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;支持多主控(multimastering)， 一个主控能够控制信号的传输和时钟频率。在任何时间点上只能有一个主控。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两根信号线：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SDA(Serial data)是数据线&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SCL(Serial clock line)是时钟线&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://img-blog.csdn.net/20180515110246982&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;传输数据的过程中一共有三种类型信号，分别为：&lt;strong&gt;开始信号、结束信号和应答信号。这些信号中，起始信号是必需的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;空闲状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SDA和SCL同时处于高电平时，规定为总线的空闲状态。由两条信号线各自的上拉电阻把电平拉高。 避免总线信号混乱，不会干扰其他设备。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I2C 总线在传送数据过程中共有三种类型信号， 它们分别是：开始信号、结束信号和应答信号。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;开始信号&lt;/strong&gt;：SCL 为高电平时，SDA 由高电平向低电平跳变，开始传送数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;结束信号&lt;/strong&gt;：SCL 为高电平时，SDA 由低电平向高电平跳变，结束传送数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应答信号&lt;/strong&gt;：发送器每发送一个字节（8个bit），就在时钟脉冲9期间释放数据线，由接收器反馈一个应答信号。
&lt;ul&gt;
&lt;li&gt;应答信号为低电平时，规定为有效应答位（ACK，简称应答位），表示接收器已经成功地接收了该字节；&lt;/li&gt;
&lt;li&gt;应答信号为高电平时，规定为非应答位（NACK），一般表示接收器接收该字节没有成功。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;起始信号是必需的，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据有效性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SDA线上的数据在SCL时钟“高”期间必须是稳定的，只有当SCL线上的时钟信号为低时，数据线上的“高”或“低”状态才可以改变。输出到SDA线上的每个字节必须是8位，数据传送时，先传送最高位（MSB），每一个被传送的字节后面都必须跟随一位应答位（即一帧共有9位）。&lt;/p&gt;
&lt;p&gt;当一个字节按数据位从高位到低位的顺序传输完后，紧接着从设备将拉低SDA线，回传给主设备一个应答位ACK， 此时才认为一个字节真正的被传输完成 ，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IIC总线的数据传送&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多数从设备的地址为7位或者10位，一般都用七位。&lt;strong&gt;八位设备地址=7位从机地址+读/写地址，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;再给地址添加一个方向位位用来表示接下来数据传输的方向，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;0表示主设备向从设备(write)写数据，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1表示主设备向从设备(read)读数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;主设备往从设备中写数据。数据传输格式如下：&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdn.net/20180515110715142&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主机首先产生START信号&lt;/li&gt;
&lt;li&gt;然后紧跟着发送一个从机地址，这个地址共有7位，紧接着的第8位是数据方 向位(R/W)，0表示主机发送数据(写)，1表示主机接收数据(读)&lt;/li&gt;
&lt;li&gt;主机发送地址时，总线上的每个从机都将这7位地址码与自己的地址进行比较，若相同，则认为自己正在被主机寻址，根据R/T位将自己确定为发送器和接收器&lt;/li&gt;
&lt;li&gt;这时候主机等待从机的应答信号(A)&lt;/li&gt;
&lt;li&gt;当主机收到应答信号时，发送要访问从机的那个地址， 继续等待从机的应答信号&lt;/li&gt;
&lt;li&gt;当主机收到应答信号时，发送N个字节的数据，继续等待从机的N次应答信号，&lt;/li&gt;
&lt;li&gt;主机产生停止信号，结束传送过程。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主设备从从设备中读数据。数据传输格式如下：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdn.net/20180515110852968&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主机首先产生START信号&lt;/li&gt;
&lt;li&gt;然后紧跟着发送一个从机地址，注意此时该地址的第8位为0，表明是向从机写命令，&lt;/li&gt;
&lt;li&gt;这时候主机等待从机的应答信号(ACK)&lt;/li&gt;
&lt;li&gt;当主机收到应答信号时，发送要访问的地址，继续等待从机的应答信号，&lt;/li&gt;
&lt;li&gt;当主机收到应答信号后，主机要改变通信模式(主机将由发送变为接收，从机将由接收变为发送)所以主机重新发送一个开始start信号，然后紧跟着发送一个从机地址，注意此时该地址的第8位为1，表明将主机设 置成接收模式开始读取数据，&lt;/li&gt;
&lt;li&gt;这时候主机等待从机的应答信号，当主机收到应答信号时，就可以接收1个字节的数据，当接收完成后，主机发送非应答信号，表示不在接收数据&lt;/li&gt;
&lt;li&gt;主机进而产生停止信号，结束传送过程。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;6can&#34;&gt;6.CAN
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/adazone/article/details/87921510?spm=1001.2101.3001.6661.1&amp;amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-87921510-blog-105372234.235%5Ev38%5Epc_relevant_anti_vip&amp;amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-87921510-blog-105372234.235%5Ev38%5Epc_relevant_anti_vip&amp;amp;utm_relevant_index=1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;参考&lt;/a&gt;,&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/32262127&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;参考2&lt;/a&gt;,&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/liuligui5200/article/details/79030676&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;参考3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CAN总线标准之规定了物理层和数据链路层。物理层和数据链路层：ISO11898；高速&lt;/p&gt;
&lt;p&gt;高速CAN总线。&lt;strong&gt;闭环 短距离&lt;/strong&gt;。最高速率为1Mbps，支持最长距离40m，总线两段安装&lt;strong&gt;端接电阻&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;低速CAN。&lt;strong&gt;开环 距离远&lt;/strong&gt;。最高速度125Kbps，最远距离1km。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;差分信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CAN_HIGH减去CAN_LOW的到的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;0V&amp;mdash;&amp;mdash;&amp;mdash;逻辑1&amp;mdash;&amp;mdash;隐形电平
2.0V&amp;mdash;&amp;mdash;-逻辑0&amp;mdash;&amp;ndash;显性电平&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多路载波侦听：网络上所有节点以多点接入的方式连接在同一根总线上，且发送数据是广播式的。网络上各个节点在发送数据前都要检测总线上是否有数据传输：若网络上有数据，暂时不发送数据，等待网络空闲时再发；若网络上无数据，立即发送已经准备好的数据。&lt;/li&gt;
&lt;li&gt;冲突检测：节点在发送数据时，要不停的检测发送的数据，确定是否与其他节点数据发送冲突，如果有冲突，则保证优先级高的报文先发送。&lt;/li&gt;
&lt;li&gt;非破坏性仲裁机制：通过ID仲裁，ID数值越小，报文优先级越高。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CAN一共规定了5中类型的帧&lt;/p&gt;
&lt;img src=&#34;https://pic1.zhimg.com/80/v2-8da13a1910fed8307df7b5d341e0d98c_720w.webp&#34; style=&#34;zoom: 80%;&#34; /&gt;
&lt;h2 id=&#34;面试问题&#34;&gt;面试问题
&lt;/h2&gt;&lt;h4 id=&#34;stm32参数-外设有哪些-输入输出类型&#34;&gt;STM32参数 外设有哪些 输入输出类型
&lt;/h4&gt;&lt;p&gt;外设：GPIO、UART、SPI、I2C、USB接口、定时器、ADC&lt;/p&gt;
&lt;p&gt;输入输出：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入模式&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;输入上拉模式&lt;/strong&gt;：引脚被配置为输入，但在未连接到外部信号时会被拉高。这有助于防止输入浮动，通常用于读取开关或按钮状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输入下拉模式&lt;/strong&gt;：引脚被配置为输入，但在未连接到外部信号时会被拉低。这也有助于防止输入浮动，通常用于读取开关或按钮状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输入浮空模式&lt;/strong&gt;：引脚被配置为输入，但不进行上拉或下拉。在这种模式下，引脚的电平状态由外部信号决定。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模拟输入模式&lt;/strong&gt;：引脚被配置为模拟输入，用于连接模拟传感器或读取模拟信号。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中断模式&lt;/strong&gt;：引脚被配置为中断输入，以便在引脚状态变化时触发中断处理程序。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;输出模式&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;推挽输出模式&lt;/strong&gt;：引脚被配置为输出，可以输出高电平或低电平。在推挽输出模式下，引脚可以提供较高的驱动电流。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开漏输出模式&lt;/strong&gt;：引脚被配置为开漏输出，可以输出低电平或者高阻态。通常与外部上拉电阻结合使用，用于连接多个设备共享同一信号线。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;复用功能模式&lt;/strong&gt;：引脚被配置为复用功能模式，用于连接到复用功能的外设，例如UART、SPI、I2C等通信接口，以及定时器、PWM等功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模拟输出模式&lt;/strong&gt;：引脚被配置为模拟输出，用于输出模拟信号&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;大华二面&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;野指针的产生场景&#34;&gt;野指针的产生场景
&lt;/h4&gt;&lt;p&gt;野指针是指 指向已经释放或者无效的内存地址的指针。&lt;/p&gt;
&lt;p&gt;产生场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存释放后未置空指针&lt;/li&gt;
&lt;li&gt;函数返回指针 指向函数内部的局部变量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最好方法是在释放内存后将指针置空，并且确保在超出指针的有效作用域之前不再使用它。&lt;/p&gt;
&lt;h4 id=&#34;线程ab交替输出12&#34;&gt;线程AB交替输出12
&lt;/h4&gt;&lt;p&gt;用父类A实例化一个对象会不会造成内存泄漏&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
