<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="并发与多线程 笔记参考: https://blog.csdn.net/qq_38231713/article/details/106091597\n代码参考: https://github.com/yunxijun/cpp11_multithread/blob/master/main.cpp\nB站https://www.bilibili.com/video/BV1Yb411L7ak?p=1&amp;vd_source=f8705e057957dafd33c98d31eb54e3cd\n第一节 并发基本概念及实现，进程、线程基本概念 （1）并发、进程、线程的基本概念和综述 并发，线程，进程要求必须掌握\n1.1 并发 两个或者更多的任务（独立的活动）同时发生（进行）：一个程序同时执行多个独立的任务；\n以往计算机，单核cpu（中央处理器）：某一个时刻只能执行一个任务，由操作系统调度，每秒钟进行多次所谓的“任务切换”。\n并发的假象（不是真正的并发），切换（上下文切换）时要保存变量的状态、执行进度等，切换回来时需要复原存在时间开销；\n随着硬件发展，出现了多处理器计算机：用于服务器和高性能计算领域。台式机：在一块芯片上有多核（一个CPU内有多个运算核心，对于操作系统来说，每个核心都是作为单独的CPU对待的）：双核，4核，8核，10核（自己的笔记本是4核8线程的）。能够实现真正的并行执行多个任务（硬件并发）\n使用并发的原因：可以同时干多个事，提高性能\n1.2 可执行程序 磁盘上的一个文件，windows下，扩展名为.exe；linux下，ls -la，rwx（可读可写可执行）\n1.3 进程 运行一个可执行程序，在windows下，可双击；在linux下，./文件名\n进程，一个可执行程序运行起来了，就叫创建了一个进程。进程就是运行起来的可执行程序。\n1.4 线程 a)每个进程（执行起来的可执行程序），都有唯一的一个主线程 b)当执行可执行程序时，产生一个进程后，这个主线程就随着这个进程默默启动起来了\nctrl+F5运行这个程序的时候，实际上是进程的主线程来执行（调用）这个main函数中的代码。主线程和进程同时存在\n线程：用来执行代码的。线程这个东西，可以理解为一条代码的执行通路\n除了主线程之外，可以通过写代码来创建其他线程，其他线程走的是别的道路，甚至去不同的地方\n每创建一个新线程，就可以在同一时刻，多干一个不同的事（多走一条不同的代码执行路径）\n多线程（并发） 线程并不是越多越好，每个线程，都需要一个独立的堆栈空间（大约1M），线程之间的切换要保存很多中间状态，切换也会耗费本该属于程序运行的时间 必须使用多线程的案例\n总结线程: a)线程是用来执行代码的;\nb)把线程这个东西理解成一条代码的执行通路 (道路)，一个新线程代表-条新的通路。\nc)一个进程自动包含一个主线程，主线程随着进程默默的启动并运行，我们可以通过编码来创建多个其他线程(非主线程)\n但是创建的数量最大都不建议超过200-300个， 至于到底多少个合适，大家在实际的项目中可以不断调整和优化，有的时候进程太多的时候效率反而会降低\nd)因为主线程是自动启动的，所以一个进程中最少也是有一个线程(主线程)。\ne)说白了:多线程程序可以同时干多个事，所以运行效率高。但是到底有多高，并不是一个很容易评估和量化的东西。\n1.5 学习心得 开发多线程程序：一个是实力的体现，一个是商用的必须需求 线程开发有一定难度 C++线程会设计很多新概念 网络方向：网络通讯、网络服务器，多线程是绝对绕不开的 （2）并发的实现方法 两个或者更多的任务（独立的活动）同时发生（进行）\n实现并发的手段：\na）通过多个进程实现并发\nb）在单独的进程中，写代码创建除了主线程之外的其他线程来实现并发\n2.1 多进程并发 比如账号服务器一个进程，游戏逻辑服务器一个进程。\n进程之间通信（同一个电脑上：管道，文件，消息队列，共享内存）；（不同电脑上：socket通信技术）\n2.2 多线程并发 线程：感觉像是轻量级的进程。每个进程有自己独立的运行路径，但一个进程中的所有线程共享地址空间（共享内存），全局变量、全局内存、全局指针、全局引用都可以在线程之间传递，所以多线程开销远远小于多进程\n共享内存带来新问题，数据一致性问题：线程A和线程B同时写会发生错误。\n多进程并发和多线程并发可以混合使用，但建议优先考虑多线程技术\n本课程中只讲多线程并发技术\n">
<title>并发与多线程 学习笔记</title>

<link rel='canonical' href='https://raff-zeng.github.io/post/reading-notes/notes-at-school/multithread/'>

<link rel="stylesheet" href="/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css"><meta property='og:title' content="并发与多线程 学习笔记">
<meta property='og:description' content="并发与多线程 笔记参考: https://blog.csdn.net/qq_38231713/article/details/106091597\n代码参考: https://github.com/yunxijun/cpp11_multithread/blob/master/main.cpp\nB站https://www.bilibili.com/video/BV1Yb411L7ak?p=1&amp;vd_source=f8705e057957dafd33c98d31eb54e3cd\n第一节 并发基本概念及实现，进程、线程基本概念 （1）并发、进程、线程的基本概念和综述 并发，线程，进程要求必须掌握\n1.1 并发 两个或者更多的任务（独立的活动）同时发生（进行）：一个程序同时执行多个独立的任务；\n以往计算机，单核cpu（中央处理器）：某一个时刻只能执行一个任务，由操作系统调度，每秒钟进行多次所谓的“任务切换”。\n并发的假象（不是真正的并发），切换（上下文切换）时要保存变量的状态、执行进度等，切换回来时需要复原存在时间开销；\n随着硬件发展，出现了多处理器计算机：用于服务器和高性能计算领域。台式机：在一块芯片上有多核（一个CPU内有多个运算核心，对于操作系统来说，每个核心都是作为单独的CPU对待的）：双核，4核，8核，10核（自己的笔记本是4核8线程的）。能够实现真正的并行执行多个任务（硬件并发）\n使用并发的原因：可以同时干多个事，提高性能\n1.2 可执行程序 磁盘上的一个文件，windows下，扩展名为.exe；linux下，ls -la，rwx（可读可写可执行）\n1.3 进程 运行一个可执行程序，在windows下，可双击；在linux下，./文件名\n进程，一个可执行程序运行起来了，就叫创建了一个进程。进程就是运行起来的可执行程序。\n1.4 线程 a)每个进程（执行起来的可执行程序），都有唯一的一个主线程 b)当执行可执行程序时，产生一个进程后，这个主线程就随着这个进程默默启动起来了\nctrl+F5运行这个程序的时候，实际上是进程的主线程来执行（调用）这个main函数中的代码。主线程和进程同时存在\n线程：用来执行代码的。线程这个东西，可以理解为一条代码的执行通路\n除了主线程之外，可以通过写代码来创建其他线程，其他线程走的是别的道路，甚至去不同的地方\n每创建一个新线程，就可以在同一时刻，多干一个不同的事（多走一条不同的代码执行路径）\n多线程（并发） 线程并不是越多越好，每个线程，都需要一个独立的堆栈空间（大约1M），线程之间的切换要保存很多中间状态，切换也会耗费本该属于程序运行的时间 必须使用多线程的案例\n总结线程: a)线程是用来执行代码的;\nb)把线程这个东西理解成一条代码的执行通路 (道路)，一个新线程代表-条新的通路。\nc)一个进程自动包含一个主线程，主线程随着进程默默的启动并运行，我们可以通过编码来创建多个其他线程(非主线程)\n但是创建的数量最大都不建议超过200-300个， 至于到底多少个合适，大家在实际的项目中可以不断调整和优化，有的时候进程太多的时候效率反而会降低\nd)因为主线程是自动启动的，所以一个进程中最少也是有一个线程(主线程)。\ne)说白了:多线程程序可以同时干多个事，所以运行效率高。但是到底有多高，并不是一个很容易评估和量化的东西。\n1.5 学习心得 开发多线程程序：一个是实力的体现，一个是商用的必须需求 线程开发有一定难度 C++线程会设计很多新概念 网络方向：网络通讯、网络服务器，多线程是绝对绕不开的 （2）并发的实现方法 两个或者更多的任务（独立的活动）同时发生（进行）\n实现并发的手段：\na）通过多个进程实现并发\nb）在单独的进程中，写代码创建除了主线程之外的其他线程来实现并发\n2.1 多进程并发 比如账号服务器一个进程，游戏逻辑服务器一个进程。\n进程之间通信（同一个电脑上：管道，文件，消息队列，共享内存）；（不同电脑上：socket通信技术）\n2.2 多线程并发 线程：感觉像是轻量级的进程。每个进程有自己独立的运行路径，但一个进程中的所有线程共享地址空间（共享内存），全局变量、全局内存、全局指针、全局引用都可以在线程之间传递，所以多线程开销远远小于多进程\n共享内存带来新问题，数据一致性问题：线程A和线程B同时写会发生错误。\n多进程并发和多线程并发可以混合使用，但建议优先考虑多线程技术\n本课程中只讲多线程并发技术\n">
<meta property='og:url' content='https://raff-zeng.github.io/post/reading-notes/notes-at-school/multithread/'>
<meta property='og:site_name' content=''>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='c&#43;&#43;' /><meta property='article:tag' content='multi-thread' /><meta property='article:published_time' content='2023-01-01T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2023-01-01T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="并发与多线程 学习笔记">
<meta name="twitter:description" content="并发与多线程 笔记参考: https://blog.csdn.net/qq_38231713/article/details/106091597\n代码参考: https://github.com/yunxijun/cpp11_multithread/blob/master/main.cpp\nB站https://www.bilibili.com/video/BV1Yb411L7ak?p=1&amp;vd_source=f8705e057957dafd33c98d31eb54e3cd\n第一节 并发基本概念及实现，进程、线程基本概念 （1）并发、进程、线程的基本概念和综述 并发，线程，进程要求必须掌握\n1.1 并发 两个或者更多的任务（独立的活动）同时发生（进行）：一个程序同时执行多个独立的任务；\n以往计算机，单核cpu（中央处理器）：某一个时刻只能执行一个任务，由操作系统调度，每秒钟进行多次所谓的“任务切换”。\n并发的假象（不是真正的并发），切换（上下文切换）时要保存变量的状态、执行进度等，切换回来时需要复原存在时间开销；\n随着硬件发展，出现了多处理器计算机：用于服务器和高性能计算领域。台式机：在一块芯片上有多核（一个CPU内有多个运算核心，对于操作系统来说，每个核心都是作为单独的CPU对待的）：双核，4核，8核，10核（自己的笔记本是4核8线程的）。能够实现真正的并行执行多个任务（硬件并发）\n使用并发的原因：可以同时干多个事，提高性能\n1.2 可执行程序 磁盘上的一个文件，windows下，扩展名为.exe；linux下，ls -la，rwx（可读可写可执行）\n1.3 进程 运行一个可执行程序，在windows下，可双击；在linux下，./文件名\n进程，一个可执行程序运行起来了，就叫创建了一个进程。进程就是运行起来的可执行程序。\n1.4 线程 a)每个进程（执行起来的可执行程序），都有唯一的一个主线程 b)当执行可执行程序时，产生一个进程后，这个主线程就随着这个进程默默启动起来了\nctrl+F5运行这个程序的时候，实际上是进程的主线程来执行（调用）这个main函数中的代码。主线程和进程同时存在\n线程：用来执行代码的。线程这个东西，可以理解为一条代码的执行通路\n除了主线程之外，可以通过写代码来创建其他线程，其他线程走的是别的道路，甚至去不同的地方\n每创建一个新线程，就可以在同一时刻，多干一个不同的事（多走一条不同的代码执行路径）\n多线程（并发） 线程并不是越多越好，每个线程，都需要一个独立的堆栈空间（大约1M），线程之间的切换要保存很多中间状态，切换也会耗费本该属于程序运行的时间 必须使用多线程的案例\n总结线程: a)线程是用来执行代码的;\nb)把线程这个东西理解成一条代码的执行通路 (道路)，一个新线程代表-条新的通路。\nc)一个进程自动包含一个主线程，主线程随着进程默默的启动并运行，我们可以通过编码来创建多个其他线程(非主线程)\n但是创建的数量最大都不建议超过200-300个， 至于到底多少个合适，大家在实际的项目中可以不断调整和优化，有的时候进程太多的时候效率反而会降低\nd)因为主线程是自动启动的，所以一个进程中最少也是有一个线程(主线程)。\ne)说白了:多线程程序可以同时干多个事，所以运行效率高。但是到底有多高，并不是一个很容易评估和量化的东西。\n1.5 学习心得 开发多线程程序：一个是实力的体现，一个是商用的必须需求 线程开发有一定难度 C++线程会设计很多新概念 网络方向：网络通讯、网络服务器，多线程是绝对绕不开的 （2）并发的实现方法 两个或者更多的任务（独立的活动）同时发生（进行）\n实现并发的手段：\na）通过多个进程实现并发\nb）在单独的进程中，写代码创建除了主线程之外的其他线程来实现并发\n2.1 多进程并发 比如账号服务器一个进程，游戏逻辑服务器一个进程。\n进程之间通信（同一个电脑上：管道，文件，消息队列，共享内存）；（不同电脑上：socket通信技术）\n2.2 多线程并发 线程：感觉像是轻量级的进程。每个进程有自己独立的运行路径，但一个进程中的所有线程共享地址空间（共享内存），全局变量、全局内存、全局指针、全局引用都可以在线程之间传递，所以多线程开销远远小于多进程\n共享内存带来新问题，数据一致性问题：线程A和线程B同时写会发生错误。\n多进程并发和多线程并发可以混合使用，但建议优先考虑多线程技术\n本课程中只讲多线程并发技术\n">
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu5202140483351697843.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/"></a></h1>
            <h2 class="site-description"></h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/raff-zeng'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/page/archives/' >
                
                
                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/post/tech-blogs/' >
                
                
                
                <span>技术博客</span>
            </a>
        </li>
        
        
        <li >
            <a href='/post/robot-notes/' >
                
                
                
                <span>机器人笔记</span>
            </a>
        </li>
        
        
        <li  class='current' >
            <a href='/post/reading-notes/' >
                
                
                
                <span>读书笔记</span>
            </a>
        </li>
        
        
        <li >
            <a href='/page/about/test-chinese/' >
                
                
                
                <span>关于我</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#第一节-并发基本概念及实现进程线程基本概念">第一节 并发基本概念及实现，进程、线程基本概念</a>
      <ol>
        <li><a href="#1并发进程线程的基本概念和综述">（1）并发、进程、线程的基本概念和综述</a>
          <ol>
            <li><a href="#11-并发">1.1 并发</a></li>
            <li><a href="#12-可执行程序">1.2 可执行程序</a></li>
            <li><a href="#13-进程">1.3 进程</a></li>
            <li><a href="#14-线程">1.4 线程</a></li>
            <li><a href="#总结线程">总结线程:</a></li>
            <li><a href="#15-学习心得">1.5 学习心得</a></li>
          </ol>
        </li>
        <li><a href="#2并发的实现方法">（2）并发的实现方法</a>
          <ol>
            <li><a href="#21-多进程并发">2.1 多进程并发</a></li>
            <li><a href="#22-多线程并发">2.2 多线程并发</a></li>
            <li><a href="#23-总结">2.3 总结</a></li>
          </ol>
        </li>
        <li><a href="#3c11新标准线程库">（3）C++11新标准线程库</a></li>
      </ol>
    </li>
    <li><a href="#第二节-线程启动结束创建线程多法joindetach">第二节 线程启动、结束，创建线程多法、join，detach</a>
      <ol>
        <li><a href="#1范例演示线程运行的开始">（1）范例演示线程运行的开始</a></li>
      </ol>
    </li>
    <li><a href="#第三节-线程传参详解detach大坑成员函数做线程函数">第三节 线程传参详解，detach()大坑，成员函数做线程函数</a>
      <ol>
        <li><a href="#一传递临时对象作为线程参数">一、传递临时对象作为线程参数</a>
          <ol>
            <li><a href="#11要避免的陷阱1">1.1要避免的陷阱1</a></li>
            <li><a href="#12要避免的陷阱2">1.2要避免的陷阱2：</a></li>
            <li><a href="#13总结">1.3总结</a></li>
          </ol>
        </li>
        <li><a href="#二临时对象作为线程参数继续讲">二、临时对象作为线程参数继续讲</a>
          <ol>
            <li><a href="#21线程id概念">2.1线程id概念</a></li>
          </ol>
        </li>
        <li><a href="#三传递类对象智能指针作为线程参数">三、传递类对象、智能指针作为线程参数</a>
          <ol>
            <li><a href="#31">3.1</a></li>
            <li><a href="#32"><em>3.2</em></a></li>
          </ol>
        </li>
        <li><a href="#四用成员函数指针做线程函数"><strong>四、用成员函数指针做线程函数</strong></a></li>
      </ol>
    </li>
    <li><a href="#第四节-创建多个线程数据共享问题分析案例代码">第四节 创建多个线程、数据共享问题分析、案例代码</a>
      <ol>
        <li><a href="#一创建和等待多个线程"><strong>一、创建和等待多个线程</strong></a></li>
        <li><a href="#二数据共享问题分析"><strong>二：数据共享问题分析</strong></a>
          <ol>
            <li><a href="#21-只读的数据">2.1 只读的数据</a></li>
            <li><a href="#22-有读有写">2.2 有读有写</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#第五节-互斥量概念用法死锁演示及解决详解">第五节 互斥量概念、用法、死锁演示及解决详解</a>
      <ol>
        <li><a href="#一互斥量mutex的基本概念">一、互斥量（mutex）的基本概念</a></li>
        <li><a href="#二互斥量的用法">二、互斥量的用法</a>
          <ol>
            <li><a href="#21-lockunlock">2.1 lock()，unlock()</a></li>
            <li><a href="#22-lock_guard模板">2.2 lock_guard模板</a></li>
          </ol>
        </li>
        <li><a href="#三死锁">三、死锁</a>
          <ol>
            <li><a href="#31-死锁演示">3.1 死锁演示</a></li>
            <li><a href="#32-死锁的一般解决方案">3.2 死锁的一般解决方案：</a></li>
            <li><a href="#33-stdlock函数模板">3.3 std::lock()函数模板</a></li>
            <li><a href="#34-stdlock_guard的stdadopt_lock参数">3.4 std::lock_guard的std::adopt_lock参数</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#第六节-unique_lock详解">第六节 unique_lock详解</a>
      <ol>
        <li><a href="#1unique_lock取代lock_guard">1.unique_lock取代lock_guard</a></li>
        <li><a href="#2unique_lock的第二个参数">2.unique_lock的第二个参数</a>
          <ol>
            <li><a href="#21-参数stdadopt_lock">2.1 参数std::adopt_lock：</a></li>
            <li><a href="#22-参数stdtry_to_lock">2.2 参数std::try_to_lock：</a></li>
            <li><a href="#23-参数stddefer_lock">2.3 参数std::defer_lock：</a></li>
          </ol>
        </li>
        <li><a href="#3unique_lock的成员函数前三个与stddefer_lock联合使用">3.unique_lock的成员函数（前三个与std::defer_lock联合使用）</a>
          <ol>
            <li><a href="#31-lock加锁">3.1 lock()：加锁。</a></li>
            <li><a href="#32-unlock解锁">3.2 unlock()：解锁。</a></li>
            <li><a href="#33-try_lock尝试给互斥量加锁">3.3 try_lock()：尝试给互斥量加锁</a></li>
            <li><a href="#34-release">3.4 release()：</a></li>
          </ol>
        </li>
        <li><a href="#4unique_lock所有权的传递">4.unique_lock所有权的传递</a>
          <ol>
            <li><a href="#1使用move转移">1.使用move转移</a></li>
            <li><a href="#2在函数中return一个临时变量即可以实现转移">2.在函数中return一个临时变量，即可以实现转移</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#第七节-单例设计模式共享数据分析解决call_once">第七节 单例设计模式共享数据分析、解决，call_once</a>
      <ol>
        <li><a href="#1设计模式">1.设计模式</a>
          <ol>
            <li><a href="#2单例设计模式">2.单例设计模式：</a></li>
            <li><a href="#3单例设计模式共享数据分析解决">3.单例设计模式共享数据分析、解决</a></li>
          </ol>
        </li>
        <li><a href="#4stdcall_once">4.std::call_once()：</a></li>
      </ol>
    </li>
    <li><a href="#第八节-condition_variablewaitnotify_onenotify_all">第八节 condition_variable、wait、notify_one、notify_all</a>
      <ol>
        <li><a href="#一条件变量condition_variablewaitnotify_onenotify_all">一、条件变量condition_variable、wait、notify_one、notify_all</a>
          <ol>
            <li><a href="#21如果wait有第二个参数就判断这个lambda表达式">2.1、如果wait有第二个参数就判断这个lambda表达式。</a></li>
            <li><a href="#22如果wait没有第二个参数则wait返回流程走下去">2.2、如果wait没有第二个参数，则wait返回，流程走下去。</a></li>
          </ol>
        </li>
        <li><a href="#二深入思考">二、深入思考</a></li>
        <li><a href="#三notify_all">三、notify_all()</a></li>
      </ol>
    </li>
    <li><a href="#第九节asyncfuturepackaged_taskpromise">第九节、async、future、packaged_task、promise</a>
      <ol>
        <li><a href="#一stdasyncstdfuture创建后台任务并返回值">一、std::async、std::future创建后台任务并返回值</a>
          <ol>
            <li><a href="#1stdlaunchdeferred">1、std::launch::deferred：</a></li>
            <li><a href="#2stdlaunchasync在调用async函数的时候就开始创建新线程">2、std::launch::async，在调用async函数的时候就开始创建新线程。</a></li>
          </ol>
        </li>
        <li><a href="#二stdpackaged_task打包任务把任务包装起来">二、std::packaged_task：打包任务，把任务包装起来。</a></li>
      </ol>
    </li>
    <li><a href="#第十节-future其他成员函数shared_futureatomic">第十节 future其他成员函数、shared_future、atomic</a>
      <ol>
        <li><a href="#一stdfuture-的成员函数">一、std::future 的成员函数</a></li>
        <li><a href="#二stdshared_future也是个类模板">二、std::shared_future：也是个类模板</a></li>
        <li><a href="#三stdatomic原子操作">三、std::atomic原子操作</a>
          <ol>
            <li><a href="#31-原子操作概念引出范例">3.1 原子操作概念引出范例：</a></li>
            <li><a href="#32-基本的stdatomic用法范例">3.2 基本的std::atomic用法范例</a></li>
          </ol>
        </li>
        <li><a href="#总结"><strong>总结：</strong></a></li>
      </ol>
    </li>
    <li><a href="#第十一节-stdatomic续谈stdasync深入谈">第十一节 std::atomic续谈、std::async深入谈</a>
      <ol>
        <li><a href="#一stdatomic续谈">一、std::atomic续谈</a></li>
        <li><a href="#二stdasync深入理解">二、std::async深入理解</a>
          <ol>
            <li><a href="#21-stdasync参数详述async-用来创建一个异步任务">2.1 std::async参数详述，async 用来创建一个异步任务</a></li>
            <li><a href="#22-stdasync和stdthread区别">2.2 std::async和std::thread()区别：</a></li>
            <li><a href="#23-async不确定性问题的解决">2.3 async不确定性问题的解决</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#第十二节-windows临界区其他各种mutex互斥量">第十二节 windows临界区、其他各种mutex互斥量</a>
      <ol>
        <li><a href="#一和二windows临界区">一和二、windows临界区</a></li>
        <li><a href="#三自动析构技术"><strong>三、自动析构技术</strong></a></li>
        <li><a href="#四递归独占互斥量-stdrecursive_mutex">四、递归独占互斥量 std::recursive_mutex</a></li>
        <li><a href="#五带超时的互斥量-stdtimed_mutex-和-stdrecursive_timed_mutex">五、带超时的互斥量 std::timed_mutex 和 std::recursive_timed_mutex</a>
          <ol>
            <li><a href="#51-stdtimed_mutex是待超时的独占互斥量">5.1 std::timed_mutex：是待超时的独占互斥量</a></li>
            <li><a href="#52-stdrecursive_timed_mutex是待超时的递归独占互斥量">5.2 std::recursive_timed_mutex：是待超时的递归独占互斥量</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#第十三章-补充知识线程池浅谈数量谈总结">第十三章 补充知识、线程池浅谈、数量谈、总结</a>
      <ol>
        <li><a href="#一补充一些知识点">一、补充一些知识点</a>
          <ol>
            <li><a href="#11-虚假唤醒">1.1 虚假唤醒：</a></li>
            <li><a href="#22-atomic">2.2 atomic：</a></li>
          </ol>
        </li>
        <li><a href="#二浅谈线程池">二、浅谈线程池：</a></li>
        <li><a href="#三线程创建数量谈">三、线程创建数量谈：</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/reading-notes/" >
                Reading-Notes
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/post/reading-notes/notes-at-school/multithread/">并发与多线程 学习笔记</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Jan 01, 2023</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 21 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="并发与多线程">并发与多线程
</h1><p>笔记参考: <a class="link" href="https://blog.csdn.net/qq_38231713/article/details/106091597"  target="_blank" rel="noopener"
    >https://blog.csdn.net/qq_38231713/article/details/106091597</a></p>
<p>代码参考: <a class="link" href="https://github.com/yunxijun/cpp11_multithread/blob/master/main.cpp"  target="_blank" rel="noopener"
    >https://github.com/yunxijun/cpp11_multithread/blob/master/main.cpp</a></p>
<img src="imgs/multi_thread1.jpg" alt="Image Description" width="500">
<p>B站https://www.bilibili.com/video/BV1Yb411L7ak?p=1&amp;vd_source=f8705e057957dafd33c98d31eb54e3cd</p>
<h2 id="第一节-并发基本概念及实现进程线程基本概念">第一节 并发基本概念及实现，进程、线程基本概念
</h2><h3 id="1并发进程线程的基本概念和综述">（1）并发、进程、线程的基本概念和综述
</h3><p>并发，线程，进程要求必须掌握</p>
<h4 id="11-并发">1.1 并发
</h4><ul>
<li>
<p>两个或者更多的任务（独立的活动）同时发生（进行）：一个程序同时执行多个独立的任务；</p>
</li>
<li>
<p>以往计算机，单核cpu（中央处理器）：某一个时刻只能执行一个任务，由操作系统调度，每秒钟进行多次所谓的“任务切换”。</p>
<p>并发的假象（不是真正的并发），切换（上下文切换）时要保存变量的状态、执行进度等，切换回来时需要复原存在时间开销；</p>
</li>
<li>
<p>随着硬件发展，出现了多处理器计算机：用于服务器和高性能计算领域。台式机：在一块芯片上有多核（一个CPU内有多个运算核心，对于操作系统来说，每个核心都是作为单独的CPU对待的）：双核，4核，8核，10核（自己的笔记本是4核8线程的）。能够实现真正的并行执行多个任务（硬件并发）</p>
</li>
<li>
<p>使用并发的原因：可以同时干多个事，提高性能</p>
</li>
</ul>
<h4 id="12-可执行程序">1.2 可执行程序
</h4><p>磁盘上的一个文件，windows下，扩展名为.exe；linux下，ls -la，rwx（可读可写可执行）</p>
<h4 id="13-进程">1.3 进程
</h4><p>运行一个可执行程序，在windows下，可双击；在linux下，./文件名</p>
<p>进程，一个可执行程序运行起来了，就叫创建了一个进程。进程就是运行起来的可执行程序。</p>
<h4 id="14-线程">1.4 线程
</h4><p>a)每个进程（执行起来的可执行程序），都有唯一的一个主线程
b)当执行可执行程序时，产生一个进程后，这个主线程就随着这个进程默默启动起来了</p>
<p>ctrl+F5运行这个程序的时候，实际上是进程的主线程来执行（调用）这个main函数中的代码。主线程和进程同时存在</p>
<p>线程：用来执行代码的。线程这个东西，可以理解为一条代码的执行通路</p>
<img src="imgs/multi_thread2.jpg" alt="" width="500">
<p>除了主线程之外，可以通过写代码来创建其他线程，其他线程走的是别的道路，甚至去不同的地方</p>
<p>每创建一个新线程，就可以在同一时刻，多干一个不同的事（多走一条不同的代码执行路径）</p>
<p>多线程（并发）
线程并不是越多越好，每个线程，都需要一个独立的堆栈空间（大约1M），线程之间的切换要保存很多中间状态，切换也会耗费本该属于程序运行的时间
必须使用多线程的案例</p>
<img src="imgs/multi_thread3.jpg" alt="" width="500">
<h4 id="总结线程">总结线程:
</h4><p>a)线程是用来执行代码的;</p>
<p>b)把线程这个东西理解成一条代码的执行通路 (道路)，一个新线程代表-条新的通路。</p>
<p>c)一个进程自动包含一个主线程，主线程随着进程默默的启动并运行，我们可以通过编码来创建多个其他线程(非主线程)</p>
<p>但是创建的数量最大都不建议超过200-300个， 至于到底多少个合适，大家在实际的项目中可以不断调整和优化，有的时候进程太多的时候效率反而会降低</p>
<p>d)因为主线程是自动启动的，所以一个进程中最少也是有一个线程(主线程)。</p>
<p>e)说白了:多线程程序可以同时干多个事，所以运行效率高。但是到底有多高，并不是一个很容易评估和量化的东西。</p>
<h4 id="15-学习心得">1.5 学习心得
</h4><ul>
<li>开发多线程程序：一个是实力的体现，一个是商用的必须需求</li>
<li>线程开发有一定难度</li>
<li>C++线程会设计很多新概念</li>
<li>网络方向：网络通讯、网络服务器，多线程是绝对绕不开的</li>
</ul>
<h3 id="2并发的实现方法">（2）并发的实现方法
</h3><p>两个或者更多的任务（独立的活动）同时发生（进行）</p>
<p>实现并发的手段：</p>
<p>a）通过多个进程实现并发</p>
<p>b）在单独的进程中，写代码创建除了主线程之外的其他线程来实现并发</p>
<h4 id="21-多进程并发">2.1 多进程并发
</h4><p>比如账号服务器一个进程，游戏逻辑服务器一个进程。</p>
<p>进程之间通信（同一个电脑上：管道，文件，消息队列，共享内存）；（不同电脑上：socket通信技术）</p>
<h4 id="22-多线程并发">2.2 多线程并发
</h4><ul>
<li>
<p>线程：感觉像是轻量级的进程。每个进程有自己独立的运行路径，但<strong>一个进程中的所有线程共享地址空间</strong>（共享内存），全局变量、全局内存、全局指针、全局引用都可以在线程之间传递，所以多线程开销远远小于多进程</p>
<p>共享内存带来新问题，数据一致性问题：线程A和线程B同时写会发生错误。</p>
</li>
<li>
<p>多进程并发和多线程并发可以混合使用，但建议优先考虑多线程技术</p>
</li>
<li>
<p>本课程中只讲多线程并发技术</p>
</li>
</ul>
<h4 id="23-总结">2.3 总结
</h4><p>和进程比，线程如下优点:</p>
<p>(1)线程启动速度更快，更轻量级;</p>
<p>(2)系统资源开销更少，执行速度更快，比如共享内存这种通信方式比任何其他的通信方式都快;</p>
<p>缺点:</p>
<p>(1)使用有-定难度，要小心处理数据的一致性问题;</p>
<h3 id="3c11新标准线程库">（3）C++11新标准线程库
</h3><p>以往</p>
<ul>
<li>
<p>windows：<code>CreateThread(), _beginthread(),_beginthreadexe()</code>创建线程；</p>
<p>linux：<code>pthread_create()</code>创建线程；</p>
<p>以往的多线程代码不能跨平台运行</p>
</li>
<li>
<p>临界区，互斥量</p>
</li>
<li>
<p>POSIX thread(pthread)库:跨平台，但要做一番配置，也不方便</p>
</li>
</ul>
<p>C++11</p>
<ul>
<li>从C++11新标准，C++语言本身增加对多线程的支持，意味着可移植性（跨平台），这大大减少开发人员的工作量</li>
</ul>
<h2 id="第二节-线程启动结束创建线程多法joindetach">第二节 线程启动、结束，创建线程多法、join，detach
</h2><h3 id="1范例演示线程运行的开始">（1）范例演示线程运行的开始
</h3><ul>
<li>程序运行起来，生成一个进程，该进程所属的主线程开始自动运行；当主线程从main（）函数返回，则整个进程执行完毕</li>
<li>主线程从main（）开始执行，那么我们自己创建的线程，也需要从一个函数开始运行（初始函数），一旦这个函数运行完毕，线程也结束运行</li>
<li>整个进程是否执行完毕的标志是：主线程是否执行完，如果主线程执行完毕了，就代表整个进程执行完毕了，此时如果其他子线程还没有执行完，也会被强行终止【此条有例外，以后会解释】</li>
</ul>
<p>创建一个线程：</p>
<ol>
<li>包含头文件thread</li>
<li>写初始函数</li>
<li>在main中创建thread</li>
</ol>
<p>必须要明白：有两个线程在跑，相当于整个程序中有两条线在同时走，即使一条被阻塞，另一条也能运行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">myPrint</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;我的线程开始运行&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//-------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//-------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;我的线程运行完毕&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//(1)创建了线程，线程执行起点（入口）是myPrint；(2)执行线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kr">thread</span> <span class="n">myThread</span><span class="p">(</span><span class="n">myPrint</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//(2)阻塞主线程并等待myPrint执行完，当myPrint执行完毕，join()就执行完毕，主线程继续往下执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//join意为汇合。阻塞主线程，让主线程等待子线程执行完毕，然后子线程和主线程汇合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">myThread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//如果主线程执行完毕了，但子线程没执行完毕，该程序不稳定。应该主线程等待子线程执行完毕后，自己才能最终退出。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">	<span class="c1">//设置断点可看到主线程等待子线程的过程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//F11逐语句，就是每z次执行一行语句，如果碰到函数调用，它就会进入到函数里面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//F10逐过程，碰到函数时，不进入函数，把函数调用当成一条语句执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">//(3)传统多线程程序中，主线程要等待子线程执行完毕，然后自己才能向下执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//detach:分离，主线程不再与子线程汇合，不再等待子线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//detach后，子线程和主线程失去关联，驻留在后台，由C++运行时库接管（守护线程）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//一旦用了detach(),就不能再用join()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//myThread.detach();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">//(4)joinable()判断是否可以成功使用join()或者detach()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//如果返回true，证明可以调用join()或者detach()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//如果返回false，证明调用过join()或者detach()，join()和detach()都不能再调用了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">myThread</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;可以调用可以调用join()或者detach()&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">else</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;不能调用可以调用join()或者detach()&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello World!&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>重要补充：</strong>
线程类参数是一个可调用对象。</p>
<p>一组可执行的语句称为可调用对象，c++中的可调用对象可以是<strong>函数、函数指针、lambda表达式、bind创建的对象或者重载了函数调用运算符的类对象</strong>。</p>
<p>用detach</p>
<p>​	不可以使用主线程中局部变量的引用</p>
<p>​	主线程的对象会被拷贝到子线程</p>
<p>二、其他创建线程的方法</p>
<p>①创建一个类，并编写圆括号重载函数，初始化一个该类的对象，把该对象作为线程入口地址</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Ta</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="k">operator</span><span class="p">()()</span> <span class="c1">//不能带参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;我的线程开始运行&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//-------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//-------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;我的线程运行完毕&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//main函数里的：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">Ta</span> <span class="n">ta</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kr">thread</span> <span class="nf">myThread</span><span class="p">(</span><span class="n">ta</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">myThread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>②lambda表达式创建线程</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//main函数中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">lambdaThread</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;我的线程开始执行了&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//-------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//-------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;我的线程开始执行了&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kr">thread</span> <span class="nf">myThread</span><span class="p">(</span><span class="n">lambdaThread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">myThread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>③把某个类中的某个函数作为线程的入口地址</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Data_</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">GetMsg</span><span class="p">(){}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">SaveMsh</span><span class="p">(){}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">//main函数里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Data_</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//第一个&amp;意思是取址，第二个&amp;意思是引用，相当于std::ref(s)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//thread oneobj(&amp;Data_::SaveMsh,s)传值也是可以的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//在其他的构造函数中&amp;obj是不会代表引用的，会被当成取地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//调用方式：对象成员函数地址，类实例，[成员函数参数]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//第二个参数可以传递对象s，也可以传递引用std::ref(s)或&amp;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//传递s，会调用拷贝构造函数在子线程中生成一个新的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//传递&amp;，子线程中还是用的原来的对象，所以就不能detach，因为主线程运行完毕会把该对象释放掉
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kr">thread</span> <span class="nf">oneobj</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Data_</span><span class="o">::</span><span class="n">SaveMsh</span><span class="p">,</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kr">thread</span> <span class="nf">twoobj</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Data_</span><span class="o">::</span><span class="n">GetMsg</span><span class="p">,</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">oneobj</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">twoobj</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="第三节-线程传参详解detach大坑成员函数做线程函数">第三节 线程传参详解，detach()大坑，成员函数做线程函数
</h2><blockquote>
<p>(1)传递临时对象作为线程参数</p>
<p>​	(1.1)要避免的陷阱(解释1)</p>
<p>​	(1.2)要避免的陷阱(解释2)</p>
<p>​	(1.3)总结</p>
<p>(2)临时对象作为线程参数继续讲</p>
<p>​	(2.1)线程id概念</p>
<p>​	(2.2)临时对象构造时机抓捕</p>
<p>(3)传递类对象、智能指针作为线程参数</p>
<p>(4)用成员函数指针做线程函数</p>
</blockquote>
<h3 id="一传递临时对象作为线程参数">一、传递临时对象作为线程参数
</h3><h4 id="11要避免的陷阱1">1.1要避免的陷阱1
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">myPrint</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pmybuf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//如果线程从主线程detach了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//i不是mvar真正的引用，实际上值传递，即使主线程中detach了子线程主线程结束了，子线程用i仍然是安全的，但仍不推荐传递引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//绝不推荐用指针，detach子线程时一定有问题
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//推荐改为const int i
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//pmybuf还是指向原来的字符串，所以这么写是不安全的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pmybuf</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">mvar</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span><span class="o">&amp;</span> <span class="n">mvary</span> <span class="o">=</span> <span class="n">mvar</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">char</span> <span class="n">mybuf</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;this is a test&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kr">thread</span> <span class="n">myThread</span><span class="p">(</span><span class="n">myPrint</span><span class="p">,</span> <span class="n">mvar</span><span class="p">,</span> <span class="n">mybuf</span><span class="p">);</span><span class="c1">//第一个参数是函数名，后两个参数是函数的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">myThread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//myThread.detach();	//子线程和主线程分别执行。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello World!&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="12要避免的陷阱2">1.2要避免的陷阱2：
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">myPrint</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">pmybuf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pmybuf</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">mvar</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span><span class="o">&amp;</span> <span class="n">mvary</span> <span class="o">=</span> <span class="n">mvar</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">char</span> <span class="n">mybuf</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;this is a test&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//如果detach了，这样仍然是不安全的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//因为存在主线程运行完了，mybuf被回收了，系统采用mybuf隐式类型转换成string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//推荐先创建一个临时对象thread myThread(myPrint, mvar, string(mybuf));就绝对安全了。。。。直接将mybuf转换成string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kr">thread</span> <span class="n">myThread</span><span class="p">(</span><span class="n">myPrint</span><span class="p">,</span> <span class="n">mvar</span><span class="p">,</span> <span class="n">mybuf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">myThread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//myThread.detach();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello World!&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>notes：</p>
<ul>
<li>main函数执行完之后才执行类的构造函数（20行）</li>
<li>若构造临时对象（19行），则在detach之前会执行构造函数和拷贝构造函数。</li>
</ul>
<p>只要用临时构造的对象作为参数传递给线程，就能够在主线程执行完毕前把线程函数的第二个参数构建出来，确保即便detach()子线程也安全运行</p>
<h4 id="13总结">1.3总结
</h4><ul>
<li>如果传递int这种简单类型，推荐使用<strong>值传递</strong>（<code>const int i</code>），不要用引用</li>
<li>如果传递类对象，避免使用隐式类型转换，全部都在<strong>创建线程这一行就创建出临时对象</strong>，然后在函数参数里，用引用来接，否则还会创建出一个对象</li>
<li>终极结论：建议不使用<code>detach()</code>，只使用<code>join()</code></li>
</ul>
<h3 id="二临时对象作为线程参数继续讲">二、临时对象作为线程参数继续讲
</h3><h4 id="21线程id概念">2.1线程id概念
</h4><ul>
<li>id是个数字，每个线程（不管是主线程还是子线程）实际上都对应着一个数字，而且每个线程对应的这个数字都不一样</li>
<li>线程id可以用C++标准库里的函数来<strong>获取</strong>。<code>std::this_thread::get_id()</code>来获取</li>
</ul>
<h3 id="三传递类对象智能指针作为线程参数">三、传递类对象、智能指针作为线程参数
</h3><h4 id="31">3.1
</h4><p>使用<code>std::ref</code>修改子线程中对象的值就会影响到主线程</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">mutable</span> <span class="kt">int</span> <span class="n">m_i</span><span class="p">;</span> <span class="c1">//m_i即使实在const中也可以被修改
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span><span class="n">m_i</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">myPrint</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">pmybuf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">pmybuf</span><span class="p">.</span><span class="n">m_i</span> <span class="o">=</span> <span class="mi">199</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;子线程myPrint的参数地址是&#34;</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">pmybuf</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;thread = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">A</span> <span class="n">myObj</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//myPrint(const A&amp; pmybuf)中引用不能去掉，如果去掉会多创建一个对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//const也不能去掉，去掉会出错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//即使是传递的const引用，但在子线程中还是会调用拷贝构造函数构造一个新的对象，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//所以在子线程中修改m_i的值不会影响到主线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//如果希望子线程中修改m_i的值影响到主线程，可以用thread myThread(myPrint, std::ref(myObj));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//这样const就是真的引用了，myPrint定义中的const就可以去掉了，类A定义中的mutable也可以去掉了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kr">thread</span> <span class="n">myThread</span><span class="p">(</span><span class="n">myPrint</span><span class="p">,</span> <span class="n">myObj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">myThread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//myThread.detach();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello World!&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="32"><em>3.2</em>
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">myPrint</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pzn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;thread = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myp</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//独占式指针只能通过std::move()才可以传递给另一个指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//传递后myp就指向空，新的pzn指向原来的内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//所以这时就不能用detach了，因为如果主线程先执行完，pzn指向的对象就被释放了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kr">thread</span> <span class="n">myThread</span><span class="p">(</span><span class="n">myPrint</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">up</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">	<span class="n">myThread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//myThread.detach();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="四用成员函数指针做线程函数"><strong>四、用成员函数指针做线程函数</strong>
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="n">thread_work</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;子线程thread_work执行&#34;</span> <span class="o">&lt;&lt;</span> <span class="k">this</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;thread = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span> <span class="n">myobj</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">mytobj</span><span class="p">(</span><span class="o">&amp;</span><span class="n">A</span><span class="o">::</span><span class="n">thread_work</span><span class="p">,</span><span class="o">&amp;</span><span class="n">myobj</span><span class="p">,</span><span class="mi">15</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">mytobj</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="第四节-创建多个线程数据共享问题分析案例代码">第四节 创建多个线程、数据共享问题分析、案例代码
</h2><img src="imgs/multi_thread4.jpg" alt="" width="500">
<h3 id="一创建和等待多个线程"><strong>一、创建和等待多个线程</strong>
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">myprint</span><span class="p">(</span><span class="kt">int</span> <span class="n">inum</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;myprint线程开始执行了，线程id= &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">inum</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;myprint线程结束执行了，线程id= &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">inum</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">mythreads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">mythreads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="kr">thread</span><span class="p">(</span><span class="n">myprint</span><span class="p">,</span><span class="n">i</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">mythreads</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">mythreads</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">;</span> <span class="n">iter</span><span class="o">++</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">iter</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;I love china&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>把thread对象放入到容器中管理，看起来像个thread对象数组，对一次创建大量的线程并对大量线程进行管理有好处</li>
<li>多个线程执行顺序是乱的，跟操作系统内部对线程的运行调度机制有关</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">TextThread</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;我是线程&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="cm">/*  …  */</span>
</span></span><span class="line"><span class="cl">     <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;线程&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;执行结束&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="c1">//main函数里     vector threadagg;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="n">threadagg</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="kr">thread</span><span class="p">(</span><span class="n">TextThread</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">     <span class="p">}</span>
</span></span><span class="line"><span class="cl">     <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="n">threadagg</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">     <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="二数据共享问题分析"><strong>二：数据共享问题分析</strong>
</h3><h4 id="21-只读的数据">2.1 只读的数据
</h4><ul>
<li>是安全稳定的，不需要特别处理，直接读就可以。</li>
</ul>
<h4 id="22-有读有写">2.2 有读有写
</h4><ul>
<li>
<p>若不加处理，就会出错</p>
</li>
<li>
<p>最简单的防止崩溃方法：<strong>读的时候不能写，写的时候不能读</strong>。</p>
<p>2个线程写，8个线程读时。2个线程不能同时写，8个线程不能同时读</p>
</li>
<li>
<p>写的动作分10小步，由于任务切换，导致各种诡异的事情发生（最可能的还是崩溃）</p>
</li>
<li>
<p><input checked="" disabled="" type="checkbox"> list：频繁的按顺序插入和删除数据时效率高。vector：随机的插入和删除数据效率高。</p>
</li>
</ul>
<h2 id="第五节-互斥量概念用法死锁演示及解决详解">第五节 互斥量概念、用法、死锁演示及解决详解
</h2><img src="imgs/multi_thread6.jpg" alt="" width="500">
<p>保护共享数据，操作时，某个线程用代码把共享数据锁住、操作数据、解锁，</p>
<p>​		其他想操作共享数据的线程必须等待解锁，锁定住，操作，解锁。</p>
<h3 id="一互斥量mutex的基本概念">一、互斥量（mutex）的基本概念
</h3><ul>
<li>互斥量就是个<strong>类对象</strong>，可以理解为一把锁，多个线程尝试用<code>lock()</code>成员函数来加锁，只有一个线程能锁定成功（成功的标志是<code>lock()</code>函数返回），如果没有锁成功，那么流程将卡在<code>lock()</code>这里不断尝试去锁定。</li>
<li>互斥量使用要小心，保护数据不多也不少，少了达不到效果，多了影响效率。</li>
</ul>
<h3 id="二互斥量的用法">二、互斥量的用法
</h3><p>包含<code>#include &lt;mutex&gt;</code>头文件</p>
<h4 id="21-lockunlock">2.1 lock()，unlock()
</h4><ul>
<li>步骤：1.<code>lock()</code>，2.操作共享数据，3.<code>unlock()</code>。</li>
<li><code>lock()</code>和<code>unlock()</code>要成对使用，代码的每一个分支都要有<code>unlock()</code></li>
<li>防止忘记<code>unlock()</code>，引入<code>lock_guard()</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="n">inMsgRecvQueue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;inMsgRecvQueue()执行，插入一个元素&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			
</span></span><span class="line"><span class="cl">			<span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">myguard</span><span class="p">(</span><span class="n">my_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">				<span class="c1">//my_mutex.lock();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="n">msgRecvQueue</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="c1">//my_mutex.unlock();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="nf">outMsgNULLProc</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">command</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">myguard</span><span class="p">(</span><span class="n">my_mutex</span><span class="p">);</span><span class="c1">//构造函数执行mutex::lock();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>								<span class="c1">//在作用域结束时，调用析构函数，执行mutex::unlock()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//my_mutex.lock();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msgRecvQueue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">//消息不为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">command</span> <span class="o">=</span> <span class="n">msgRecvQueue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">			<span class="n">msgRecvQueue</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">			<span class="c1">//my_mutex.unlock();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//my_mutex.unlock();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="nf">outMsgRecvQueue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">command</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="n">outMsgNULLProc</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;outMsgRecvQueue()执行，取出一个元素&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">command</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">				<span class="c1">//数据处理代码...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">else</span>
</span></span><span class="line"><span class="cl">			<span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;outMsgRecvQueue()执行，但目前消息队列中为空&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;end&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">msgRecvQueue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">my_mutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">A</span> <span class="n">myobja</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">myOutMsgObj</span><span class="p">(</span><span class="o">&amp;</span><span class="n">A</span><span class="o">::</span><span class="n">outMsgRecvQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">myobja</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">myInMsgObj</span><span class="p">(</span><span class="o">&amp;</span><span class="n">A</span><span class="o">::</span><span class="n">inMsgRecvQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">myobja</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">myOutMsgObj</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">myInMsgObj</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="22-lock_guard模板">2.2 lock_guard模板
</h4><ul>
<li><code>lock_guard&lt;mutex&gt; sbguard(myMutex);</code>取代<code>lock()</code>和<code>unlock()</code></li>
<li>lock_guard构造函数执行了<code>mutex::lock()</code>;在作用域结束时，调用析构函数，执行<code>mutex::unlock()</code></li>
</ul>
<h3 id="三死锁">三、死锁
</h3><p>死锁问题至少有两个互斥量才能产生。</p>
<h4 id="31-死锁演示">3.1 死锁演示
</h4><p>死锁至少有两个互斥量mutex1，mutex2。</p>
<ul>
<li>a.线程A执行时，这个线程先锁mutex1，并且锁成功了，然后去锁mutex2的时候，出现了上下文切换，mutex2没锁成功。</li>
<li>b.线程B执行，这个线程先锁mutex2，因为mutex2没有被锁，即mutex2可以被锁成功，然后线程B要去锁mutex1.</li>
<li>c.此时，死锁产生了，A锁着mutex1，需要锁mutex2，B锁着mutex2，需要锁mutex1，两个线程没办法继续运行下去。。。</li>
</ul>
<h4 id="32-死锁的一般解决方案">3.2 死锁的一般解决方案：
</h4><p>只要保证多个互斥量上锁的顺序一样就不会造成死锁。</p>
<h4 id="33-stdlock函数模板">3.3 std::lock()函数模板
</h4><ul>
<li><code>std::lock(mutex1,mutex2……);</code> 一次锁定多个互斥量（一般这种情况很少），用于处理多个互斥量。</li>
<li>如果互斥量中一个没锁住，它就等着，等所有互斥量都锁住，才能继续执行。如果有一个没锁住，就会把已经锁住的释放掉（要么互斥量都锁住，要么都没锁住，防止死锁）</li>
</ul>
<h4 id="34-stdlock_guard的stdadopt_lock参数">3.4 std::lock_guard的std::adopt_lock参数
</h4><ul>
<li>
<p><code>std::lock_guardstd::mutex my_guard(my_mutex,std::adopt_lock);</code></p>
<p>加入adopt_lock后，在调用lock_guard的构造函数时，不再进行lock();</p>
</li>
<li>
<p>adopt_guard为结构体对象，起一个标记作用，表示这个互斥量已经lock()，不需要在lock()。（必须把互斥量提前lock，否则会报异常。）</p>
</li>
<li>
<p>建议一个一个锁</p>
</li>
</ul>
<h2 id="第六节-unique_lock详解">第六节 unique_lock详解
</h2><img src="imgs/multi_thread7.jpg" alt="" width="500">
<h3 id="1unique_lock取代lock_guard">1.unique_lock取代lock_guard
</h3><p>unique_lock是个类模板，工作中一般使用lock_guard。</p>
<p>unique_lock比lock_guard灵活很多（多出来很多用法），效率差一点，内存占用多一点。</p>
<p><code>unique_lock&lt;std::mutex&gt; myUniLock(myMutex);</code></p>
<h3 id="2unique_lock的第二个参数">2.unique_lock的第二个参数
</h3><h4 id="21-参数stdadopt_lock">2.1 参数std::adopt_lock：
</h4><ul>
<li>表示<strong>这个互斥量已经被lock()，即不需要在构造函数中lock这个互斥量了</strong>。</li>
<li>前提：必须提前lock，否则会报异常。</li>
<li>unique_lock中也可以用这个参数</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">dura</span><span class="p">(</span><span class="mi">20000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">dura</span><span class="p">);</span> <span class="c1">//等待20秒
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="22-参数stdtry_to_lock">2.2 参数std::try_to_lock：
</h4><ul>
<li>尝试用mutex的lock()去锁定这个mutex，但如果没有锁定成功，会立即返回，不会阻塞在那里；</li>
<li>使用try_to_lock的原因是<strong>防止其他的线程锁定mutex太长时间，导致本线程一直阻塞在lock这个地方</strong></li>
<li>前提：不能提前<code>lock()</code>;</li>
<li><code>owns_lock()</code>方法判断是否拿到锁，如拿到返回true</li>
</ul>
<h4 id="23-参数stddefer_lock">2.3 参数std::defer_lock：
</h4><ul>
<li>如果没有第二个参数就对mutex进行加锁，加上defer_lock是初始化了一个没有加锁的mutex</li>
<li>不给它加锁的目的是以后可以调用unique_lock的一些方法</li>
<li>前提：不能提前lock</li>
</ul>
<h3 id="3unique_lock的成员函数前三个与stddefer_lock联合使用">3.unique_lock的成员函数（前三个与std::defer_lock联合使用）
</h3><h4 id="31-lock加锁">3.1 lock()：加锁。
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">myUniLock</span><span class="p">(</span><span class="n">myMutex</span><span class="err">，</span> <span class="n">defer_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">myUniLock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>不用自己unlock();</p>
<h4 id="32-unlock解锁">3.2 unlock()：解锁。
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">myUniLock</span><span class="p">(</span><span class="n">myMutex</span><span class="err">，</span> <span class="n">defer_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">myUniLock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">//处理一些共享代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">myUniLock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">//处理一些非共享代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">myUniLock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">//处理一些共享代码
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因为一些非共享代码要处理，可以暂时先unlock()，用其他线程把它们处理了，处理完后再lock()。</p>
<h4 id="33-try_lock尝试给互斥量加锁">3.3 try_lock()：尝试给互斥量加锁
</h4><p>如果拿不到锁，返回false，否则返回true。</p>
<h4 id="34-release">3.4 release()：
</h4><ul>
<li><code>unique_lock&lt;mutex&gt; myUniLock(myMutex);</code>相当于把myMutex和myUniLock绑定在了一起，release()就是解除绑定，返回它所管理的mutex对象的指针，并释放所有权</li>
<li><code>mutex* ptx = myUniLock.release();</code>所有权由ptx接管，如果原来mutex对象处理加锁状态，就需要ptx在以后进行解锁了(<code>ptx-&gt;unlock()</code>)。</li>
</ul>
<p>为什么需要unlock，因为lock的代码段越少，执行越快，整个程序的运行效率越高。</p>
<p>锁住的多少 称为代码的粗细。</p>
<p>​	a.锁住的代码少，叫做粒度细，执行效率高；
​	b.锁住的代码多，叫做粒度粗，执行效率低；</p>
<h3 id="4unique_lock所有权的传递">4.unique_lock所有权的传递
</h3><p><code>unique_lock&lt;mutex&gt; myUniLock(myMutex);</code>把myMutex和myUniLock绑定在了一起，也就是myUniLock拥有myMutex的所有权</p>
<h4 id="1使用move转移">1.使用move转移
</h4><ul>
<li>myUniLock拥有myMutex的所有权，myUniLock可以把自己对myMutex的所有权转移，但是不能复制。</li>
<li><code>unique_lock&lt;mutex&gt; myUniLock2(std::move(myUniLock));</code>
现在myUniLock2拥有myMutex的所有权。</li>
</ul>
<h4 id="2在函数中return一个临时变量即可以实现转移">2.在函数中return一个临时变量，即可以实现转移
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">rtn_unique_lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">tempUniLock</span><span class="p">(</span><span class="n">myMutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//移动构造函数那里讲从函数返回一个局部的unique_lock对象是可以的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//返回这种局部对象会导致系统生成临时的unique_lock对象，并调用unique_lock的移动构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">myUniLock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 然后就可以在外层调用，在sbguard具有对myMutex的所有权
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">sbguard</span> <span class="o">=</span> <span class="n">rtn_unique_lock</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="第七节-单例设计模式共享数据分析解决call_once">第七节 单例设计模式共享数据分析、解决，call_once
</h2><img src="imgs/multi_thread8.jpg" alt="" width="500">
<h3 id="1设计模式">1.设计模式
</h3><p>“设计模式”：代码的一些写法</p>
<ul>
<li>程序灵活，维护起来可能方便，用设计模式理念写出来的代码很晦涩，但是别人接管、阅读代码都会很痛苦</li>
<li>老外应付特别大的项目时，把项目的开发经验、模块划分经验，总结整理成设计模式（先有开发需求，后有理论总结和整理）</li>
<li>中国零几年设计模式刚开始火时，总喜欢拿一个设计模式往上套，导致一个小小的项目总要加几个设计模式，本末倒置</li>
<li>设计模式有其独特的优点，要活学活用，不要深陷其中，生搬硬套</li>
</ul>
<h4 id="2单例设计模式">2.单例设计模式：
</h4><p>单例设计模式使用频率比较高。</p>
<p>整个项目中，有某个或者某些特殊的类，只能创建一个属于该类的对象。</p>
<p>单例类：只能生成一个对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyCAS</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyCAS</span><span class="p">()</span> <span class="p">{}</span>	<span class="c1">//私有化构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">static</span> <span class="n">MyCAS</span> <span class="o">*</span><span class="n">m_instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">static</span> <span class="n">MyCAS</span> <span class="o">*</span><span class="n">GetInstance</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 这里多线程下不安全
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">m_instance</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 两个线程可能同时执行到这里，这样不好
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">m_instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyCAS</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 创建一个静态类对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">static</span> <span class="n">GarbageCollection</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">m_instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="nf">func</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;test&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 引入一个类，对new的对象进行回收
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">class</span> <span class="nc">GarbageCollection</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="o">~</span><span class="n">GarbageCollection</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">MyCAS</span><span class="o">::</span><span class="n">m_instance</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// 连个线程可能同时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">delete</span> <span class="n">MyCAS</span><span class="o">::</span><span class="n">m_instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">				<span class="n">MyCAS</span><span class="o">::</span><span class="n">m_instance</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//类静态变量初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">MyCAS</span> <span class="o">*</span><span class="n">MyCAS</span><span class="o">::</span><span class="n">m_instance</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyCAS</span> <span class="o">*</span><span class="n">p_a</span> <span class="o">=</span> <span class="n">MyCAS</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">p_a</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyCAS</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">system</span><span class="p">(</span><span class="s">&#34;pause&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="3单例设计模式共享数据分析解决">3.单例设计模式共享数据分析、解决
</h4><p>面临问题：需要在自己创建的线程中来创建单例类的对象，这种线程可能不止一个。我们可能面临GetInstance()这种成员函数需要互斥。</p>
<p>可以在加锁前判断m_instance是否为空，否则每次调用Singleton::getInstance()都要加锁，十分影响效率。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">resource_mutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyCAS</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyCAS</span><span class="p">()</span> <span class="p">{}</span>	<span class="c1">//私有化构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">static</span> <span class="n">MyCAS</span> <span class="o">*</span><span class="n">m_instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">static</span> <span class="n">MyCAS</span> <span class="o">*</span><span class="n">GetInstance</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//提高效率
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//如果if(m_instance != NULL)，条件成立，则肯定表示m_instance已经被new过
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//如果if(m_instance == NULL)，条件成立，不代表m_instance一定没被new过
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//双重锁定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">m_instance</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">mymutex</span><span class="p">(</span><span class="n">resource_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">m_instance</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// 两个线程可能同时执行到这里，这样不好
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="n">m_instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyCAS</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// 创建一个静态类对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">static</span> <span class="n">GarbageCollection</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">m_instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="nf">func</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;test&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 引入一个类，对new的对象进行回收
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">class</span> <span class="nc">GarbageCollection</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="o">~</span><span class="n">GarbageCollection</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">MyCAS</span><span class="o">::</span><span class="n">m_instance</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// 连个线程可能同时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">delete</span> <span class="n">MyCAS</span><span class="o">::</span><span class="n">m_instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">				<span class="n">MyCAS</span><span class="o">::</span><span class="n">m_instance</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//类静态变量初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">MyCAS</span> <span class="o">*</span><span class="n">MyCAS</span><span class="o">::</span><span class="n">m_instance</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyCAS</span> <span class="o">*</span><span class="n">p_a</span> <span class="o">=</span> <span class="n">MyCAS</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">p_a</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyCAS</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">system</span><span class="p">(</span><span class="s">&#34;pause&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果觉得在单例模式new了一个对象，而没有自己delete掉，这样不合理。可以增加一个类中类CGarhuishou，new一个单例类时创建一个静态的CGarhuishou对象，这样在程序结束时会调用CGarhuishou的析构函数，释放掉new出来的单例对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Singelton</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">static</span> <span class="n">Singleton</span> <span class="o">*</span> <span class="n">getInstance</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">instance</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		    <span class="k">static</span> <span class="n">CGarhuishou</span> <span class="n">huishou</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		    <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singelton</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">class</span> <span class="nc">CGarhuishou</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="o">~</span><span class="n">CGarhuishou</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">Singleton</span><span class="o">::</span><span class="n">instance</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">delete</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">				<span class="n">Singleton</span><span class="o">::</span><span class="n">instance</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">Singleton</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="k">static</span> <span class="n">Singleton</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Singleton</span> <span class="o">*</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">instance</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="4stdcall_once">4.std::call_once()：
</h3><p>函数模板，该函数的第一个参数为标记，第二个参数是一个函数名（如a()）。</p>
<ul>
<li>
<p>功能：能够保证函数a()只被调用一次。</p>
</li>
<li>
<p>具备互斥量的能力，而且比互斥量消耗的资源更少，更高效。</p>
</li>
<li>
<p>call_once()需要与一个标记结合使用，这个标记为<strong>std::once_flag</strong>；其实once_flag是一个结构;</p>
<p>call_once()就是通过标记来决定函数是否执行，调用成功后，就把标记设置为一种已调用状态。</p>
</li>
</ul>
<p>多个线程同时执行时，一个线程会等待另一个线程先执行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">once_flag</span> <span class="n">g_flag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Singleton</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">void</span> <span class="n">CreateInstance</span><span class="p">()</span><span class="c1">//call_once保证其只被调用一次
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//两个线程同时执行到这里，其中一个线程要等另外一个线程执行完毕
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">static</span> <span class="n">Singleton</span> <span class="o">*</span> <span class="nf">getInstance</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="n">call_once</span><span class="p">(</span><span class="n">g_flag</span><span class="p">,</span> <span class="n">CreateInstance</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">         <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">Singleton</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="k">static</span> <span class="n">Singleton</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Singleton</span> <span class="o">*</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">instance</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="第八节-condition_variablewaitnotify_onenotify_all">第八节 condition_variable、wait、notify_one、notify_all
</h2><img src="imgs/multi_thread9.jpg" alt="" width="500">
<h3 id="一条件变量condition_variablewaitnotify_onenotify_all">一、条件变量condition_variable、wait、notify_one、notify_all
</h3><p>std::condition_variable实际上是一个类，是一个和条件相关的类，说白了就是等待一个条件达成。
需要和互斥量来配合工作，用的时候需要生成这个类的对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="n">inMsgRecvQueue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;inMsgRecvQueue()执行，插入一个元素&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">myguard</span><span class="p">(</span><span class="n">my_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="n">msgRecvQueue</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="n">my_cond</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>	<span class="c1">//把wait()的线程唤醒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="nf">outMsgRecvQueue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">command</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">myguard1</span><span class="p">(</span><span class="n">my_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="c1">//wait()用来等一个东西
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">//如果第二个参数 lambda表达式返回值为true，那么wait()直接返回并继续执行。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">//如果第二个参数 lambda表达式返回值为false，那么wait()将解锁互斥量，并堵塞到本行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">//堵塞到其他某个线程调用notify_one()成员函数为止
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">//如果wait()没有第二个参数，my_cond.wait(myguard1);那么就跟第二个参数lambda表达式返回false效果一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">//wait()将解锁互斥量，并堵塞到本行，堵塞到其他某个线程调用notify_one()成员函数为止
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">my_cond</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">myguard1</span><span class="p">,</span> <span class="p">[</span><span class="k">this</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msgRecvQueue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">					<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">});</span>
</span></span><span class="line"><span class="cl">			<span class="n">command</span> <span class="o">=</span> <span class="n">msgRecvQueue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>	<span class="c1">//返回第一个元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">msgRecvQueue</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>	<span class="c1">//移除第一个元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">myguard1</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>	<span class="c1">//因为unique_lock的灵活性，所以我们可以随时解锁，以免锁住太长时间。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;outMsgRecvQueue()执行，取出一个元素&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">command</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">msgRecvQueue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">my_mutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">my_cond</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">A</span> <span class="n">myobja</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">myOutMsgObj</span><span class="p">(</span><span class="o">&amp;</span><span class="n">A</span><span class="o">::</span><span class="n">outMsgRecvQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">myobja</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">myInMsgObj</span><span class="p">(</span><span class="o">&amp;</span><span class="n">A</span><span class="o">::</span><span class="n">inMsgRecvQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">myobja</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">myOutMsgObj</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">myInMsgObj</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>wait()用来等一个东西</p>
</li>
<li>
<p>如果第二个参数的lambda表达式返回值是false，那么wait()将解锁互斥量，并阻塞到本行
如果第二个参数的lambda表达式返回值是true，那么wait()直接返回并继续执行。</p>
</li>
<li>
<p>阻塞到什么时候为止呢？阻塞到其他某个线程调用notify_one()成员函数为止；</p>
</li>
<li>
<p>如果没有第二个参数，那么效果跟第二个参数lambda表达式返回false效果一样</p>
<p>wait()将解锁互斥量，并阻塞到本行，阻塞到其他某个线程调用notify_one()成员函数为止。</p>
</li>
<li>
<p>当其他线程用notify_one()将本线程wait()唤醒后，这个wait恢复后。wait()不断尝试获取互斥量锁，如果获取不到那么流程就卡在wait()这里等待获取，如果获取到了，那么wait()就继续执行，获取到了锁</p>
</li>
</ul>
<p>wait被唤醒后，输入和输出队列都尝试获取锁，谁获得锁不确定。</p>
<p>若outMsgRecvQueue()正在处理一个事务，需要一段时间，而不是正卡在wait()等待被唤醒，那么此时这个notify_once无效。</p>
<h4 id="21如果wait有第二个参数就判断这个lambda表达式">2.1、如果wait有第二个参数就判断这个lambda表达式。
</h4><ul>
<li>a)如果表达式为false，那wait又对互斥量解锁，然后又休眠，等待再次被notify_one()唤醒</li>
<li>b)如果lambda表达式为true，则wait返回，流程可以继续执行（此时互斥量已被锁住）。</li>
</ul>
<h4 id="22如果wait没有第二个参数则wait返回流程走下去">2.2、如果wait没有第二个参数，则wait返回，流程走下去。
</h4><p>流程只要走到了wait()下面则互斥量一定被锁住了。</p>
<h3 id="二深入思考">二、深入思考
</h3><p>上面的代码可能导致出现一种情况：</p>
<p>因为outMsgRecvQueue()与inMsgRecvQueue()并不是一对一执行的，所以当程序循环执行很多次以后，可能在msgRecvQueue 中已经有了很多消息，但是，outMsgRecvQueue还是被唤醒一次只处理一条数据。这时可以考虑把outMsgRecvQueue多执行几次，或者对inMsgRecvQueue进行限流。</p>
<h3 id="三notify_all">三、notify_all()
</h3><p>notify_one()：通知一个线程的wait()</p>
<p>notify_all()：通知所有线程的wait()</p>
<h2 id="第九节asyncfuturepackaged_taskpromise">第九节、async、future、packaged_task、promise
</h2><img src="imgs/multi_thread10.jpg" alt="" width="500">
<p>本节内容需要包含头文件<code>#include &lt;future&gt;</code></p>
<h3 id="一stdasyncstdfuture创建后台任务并返回值">一、std::async、std::future创建后台任务并返回值
</h3><p>std::async是一个<strong>函数模板</strong>，用来启动一个异步任务，启动起来一个异步任务之后，它返回一个std::future对象，这个对象是个<strong>类模板</strong>。</p>
<p><strong>什么叫“启动一个异步任务”？</strong></p>
<p>​		就是自动创建一个线程，并开始 执行对应的线程入口函数，它返回一个std::future对象，这个std::future对象中就含有线程入口函数所返回的结果，我们可以通过调用future对象的成员函数get()来获取结果。</p>
<p>“future”将来的意思，也有人称呼std::future提供了一种访问异步操作结果的机制，就是说这个结果你可能没办法马上拿到，在这个线程执行完毕的时候，就能够拿到结果了，所以大家这么理解：future中保存着一个值，这个值是在将来的某个时刻能够拿到。</p>
<p>std::future对象的<strong>get()成员函数</strong>会等待线程执行结束并返回结果，拿不到结果它就会一直等待，感觉有点像join()。但是，它是可以获取结果的。</p>
<ul>
<li>get()只能调用一次，不能调用多次</li>
</ul>
<p>std::future对象的<strong>wait()成员函数</strong>，用于等待线程返回，本身并不返回结果，这个效果和 std::thread 的join()更像。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">mythread</span><span class="p">(</span><span class="kt">int</span> <span class="n">mypar</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mypar</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">mypar</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">mythread</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;mythread() start&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;threadid = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">dura</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">dura</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;mythread() end&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;threadid = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">A</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;main&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;threadid = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">mythread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;continue........&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result1</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//卡在这里等待mythread()执行完毕，拿到结果   等待拿到返回值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	
</span></span><span class="line"><span class="cl">	<span class="c1">//类成员函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="o">&amp;</span><span class="n">A</span><span class="o">::</span><span class="n">mythread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span> <span class="c1">//第二个参数是对象引用才能保证线程里执行的是同一个对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result2</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//或者result2.wait();  //等待线程返回，但不返回结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;good luck&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们通过向std::async()传递一个参数，该参数是std::launch类型（枚举类型），来达到一些特殊的目的：</p>
<h4 id="1stdlaunchdeferred">1、std::launch::deferred：
</h4><p>（defer推迟，延期）表示线程入口函数的调用会被延迟，一直到std::future的wait()或者get()函数被调用时（由主线程调用）才会执行；</p>
<p>如果wait()或者get()没有被调用，则不会执行。</p>
<p>实际上根本就没有创建新线程。std::launch::deferred意思时延迟调用，并没有创建新线程，是<strong>在主线程中调用的线程入口函数</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">mythread</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;mythread() start&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;threadid = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">dura</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">dura</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;mythread() end&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;threadid = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;main&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;threadid = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">deferred</span> <span class="p">,</span><span class="n">mythread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;continue........&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result1</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//卡在这里等待mythread()执行完毕，拿到结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;good luck&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><img src="imgs/multi_thread20.jpg" alt="" width="500">
<p>永远都会先打印出continue…，然后才会打印出mythread() start和mythread() end等信息。</p>
<h4 id="2stdlaunchasync在调用async函数的时候就开始创建新线程">2、std::launch::async，在调用async函数的时候就开始创建新线程。
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;main&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;threadid = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span> <span class="p">,</span><span class="n">mythread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;continue........&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result1</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;good luck&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="二stdpackaged_task打包任务把任务包装起来">二、std::packaged_task：打包任务，把任务包装起来。
</h3><p>类模板，它的模板参数是各种可调用对象，通过packaged_task把各种可调用对象包装起来，方便将来作为线程入口函数来调用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">mythread</span><span class="p">(</span><span class="kt">int</span> <span class="n">mypar</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mypar</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;mythread() start&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;threadid = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">dura</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">dura</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;mythread() end&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;threadid = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;main&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;threadid = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//我们把函数mythread通过packaged_task包装起来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//参数是一个int，返回值类型是int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">mypt</span><span class="p">(</span><span class="n">mythread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">mypt</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">mypt</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">	<span class="c1">//std::future对象里包含有线程入口函数的返回结果，这里result保存mythread返回的结果。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>可调用对象可由函数换成lambda表达式</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;main&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;threadid = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">mypt</span><span class="p">([](</span><span class="kt">int</span> <span class="n">mypar</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mypar</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;mythread() start&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;threadid = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">dura</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">dura</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;mythread() end&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;threadid = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">});</span> 
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">mypt</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">mypt</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">	<span class="c1">//std::future对象里包含有线程入口函数的返回结果，这里result保存mythread返回的结果。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;good luck&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>packaged_task包装起来的可调用对象还可以直接调用，从这个角度来讲，packaged_task对象也是一个可调用对象
<em>lambda的直接调用</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;main&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;threadid = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">mypt</span><span class="p">([](</span><span class="kt">int</span> <span class="n">mypar</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mypar</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;mythread() start&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;threadid = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">dura</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">dura</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;mythread() end&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;threadid = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">});</span> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">	<span class="n">mypt</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">mypt</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>std::promise，类模板</em>
我们能够在某个线程中给它赋值，然后我们可以在其他线程中，把这个值取出来</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">mythread</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">clac</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;mythread() start&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;threadid = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">dura</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">dura</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;mythread() end&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;threadid = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">clac</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">tmp</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">result</span><span class="p">);</span> <span class="c1">//结果保存到了tmp这个对象中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">task_vec</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myprom</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">mythread</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">myprom</span><span class="p">),</span> <span class="mi">180</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span> <span class="c1">//在这里线程已经执行完了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">fu1</span> <span class="o">=</span> <span class="n">myprom</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span> <span class="c1">//promise和future绑定，用于获取线程返回值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">fu1</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;result = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>**总结：**通过promise保存一个值，在将来某个时刻我们通过把一个future绑定到这个promise上，来得到绑定的值</p>
<p>注意：使用thread时，必须 join() 或者 detach() 否则程序会报异常</p>
<p><strong>小结：</strong></p>
<p>我们学习这些东西的目的并不是，要把他们都用到实际开发中。</p>
<p>相反，如果我们能够用最少的东西写出一个稳定的，高效的多线程程序，更值得赞赏。</p>
<p>我们为了成长必须阅读一些高手写的代码，从而实现自己代码的积累；</p>
<h2 id="第十节-future其他成员函数shared_futureatomic">第十节 future其他成员函数、shared_future、atomic
</h2><h3 id="一stdfuture-的成员函数">一、std::future 的成员函数
</h3><p>1、<code>std::future_status status = result.wait_for(std::chrono::seconds(2));</code>
卡住当前流程，等待std::async()的异步任务运行一段时间，然后返回其状态std::future_status。如果std::async()的参数是std::launch::deferred（延迟执行），则不会卡住主流程。
std::future_status是枚举类型，表示异步任务的执行状态。类型的取值有
std::future_status::timeout
std::future_status::ready
std::future_status::deferred</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">mythread</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;mythread() start&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;threadid = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">dura</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">dura</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;mythread() end&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;threadid = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;main&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;threadid = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">mythread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;continue........&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//cout &lt;&lt; result1.get() &lt;&lt; endl; //卡在这里等待mythread()执行完毕，拿到结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//等待1秒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">future_status</span> <span class="n">status</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">future_status</span><span class="o">::</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//超时：表示线程还没有执行完
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;超时了，线程还没有执行完&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//类成员函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><img src="imgs/multi_thread11.jpg" alt="" width="500">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">mythread</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;mythread() start&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;threadid = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//std::chrono::milliseconds dura(5000);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//std::this_thread::sleep_for(dura);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;mythread() end&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;threadid = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;main&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;threadid = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">deferred</span><span class="p">,</span> <span class="n">mythread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//std::future&lt;int&gt; result = std::async(mythread);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;continue........&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//cout &lt;&lt; result1.get() &lt;&lt; endl; //卡在这里等待mythread()执行完毕，拿到结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">std</span><span class="o">::</span><span class="n">future_status</span> <span class="n">status</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">future_status</span><span class="o">::</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//超时：表示线程还没有执行完
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;超时了，线程还没有执行完&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">future_status</span><span class="o">::</span><span class="n">ready</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//表示线程成功返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;线程执行成功，返回&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">future_status</span><span class="o">::</span><span class="n">deferred</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//如果设置 std::future&lt;int&gt; result = std::async(std::launch::deferred, mythread);，则本条件成立
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;线程延迟执行&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;good luck&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>get()只能使用一次，比如如果</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>就会报告异常
因为std::future中的get()函数的设计是一个<strong>移动语义</strong>，相当于将result中的值移动到了a中，再次get就报告了异常。</p>
<h3 id="二stdshared_future也是个类模板">二、std::shared_future：也是个类模板
</h3><p>std::future的 get() 成员函数是转移数据</p>
<p>std::shared_future 的 get()成员函数是复制数据</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">mythread</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;mythread() start&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;threadid = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">dura</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">dura</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;mythread() end&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;threadid = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;main&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;threadid = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">mypt</span><span class="p">(</span><span class="n">mythread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">mypt</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">mypt</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="n">ifcanget</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">valid</span><span class="p">();</span> <span class="c1">//判断future中的值是不是一个有效值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">std</span><span class="o">::</span><span class="n">shared_future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result_s</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">share</span><span class="p">());</span> <span class="c1">//执行完毕后result_s里有值，而result里空了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//std::shared_future&lt;int&gt; result_s(std::move(result));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//通过get_future返回值直接构造一个shared_future对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//std::shared_future&lt;int&gt; result_s(mypt.get_future());
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="k">auto</span> <span class="n">myresult1</span> <span class="o">=</span> <span class="n">result_s</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="k">auto</span> <span class="n">myresult2</span> <span class="o">=</span> <span class="n">result_s</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;good luck&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="三stdatomic原子操作">三、std::atomic原子操作
</h3><h4 id="31-原子操作概念引出范例">3.1 原子操作概念引出范例：
</h4><p>互斥量：多线程编程中 用于保护共享数据：先锁住， 操作共享数据， 解锁。</p>
<p>有两个线程，对一个变量进行操作，一个线程读这个变量的值，一个线程往这个变量中写值。</p>
<p>即使是一个简单变量的读取和写入操作，如果不加锁，也有可能会导致读写值混乱（一条C语句会被拆成3、4条汇编语句来执行，所以仍然有可能混乱）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">g_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">mythread1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">g_count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">mythread1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">mythread1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;正常情况下结果应该是200 0000次，实际是&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">g_count</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><img src="imgs/multi_thread12.jpg" alt="" width="500">
<p>使用mutex解决这个问题（但是速度变慢）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">g_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mymutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">mythread1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">u1</span><span class="p">(</span><span class="n">mymutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">g_count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">mythread1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">mythread1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;正常情况下结果应该是200 0000次，实际是&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">g_count</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><img src="imgs/multi_thread13.jpg" alt="" width="500">
<h4 id="32-基本的stdatomic用法范例">3.2 基本的std::atomic用法范例
</h4><p>可以把原子操作理解成一种：不需要用到互斥量加锁（无锁）技术的多线程并发编程方式。</p>
<p>原子操作：在多线程中不会被打断的程序执行片段。</p>
<p>从效率上来说，原子操作要比互斥量的方式效率要高。</p>
<p>互斥量的加锁一般是<strong>针对一个代码段</strong>，而原子操作<strong>针对</strong>的一般都是<strong>一个变量</strong>。</p>
<p>原子操作，一般都是指“不可分割的操作”；也就是说这种操作状态要么是完成的，要么是没完成的，不可能出现半完成状态。</p>
<p>std::atomic来代表原子操作，是个<strong>类模板</strong>。其实std::atomic是用来封装某个类型的值的</p>
<p>需要添加<code>#include &lt;atomic&gt;</code>头文件</p>
<p>范例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">g_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//封装了一个类型为int的 对象（值）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">mythread1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">g_count</span><span class="o">++</span><span class="p">;</span>	<span class="c1">//对应的操作是原子操作（不会被打断）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">mythread1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">mythread1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;正常情况下结果应该是200 0000次，实际是&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">g_count</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><img src="imgs/multi_thread14.jpg" alt="" width="500">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">g_ifEnd</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">//封装了一个类型为bool的 对象（值）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">mythread</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">dura</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span> <span class="p">(</span><span class="n">g_ifEnd</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;thread id = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;运行中&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">dura</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;thread id = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;运行结束&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">mythread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">mythread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">dura</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">dura</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">g_ifEnd</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;程序执行完毕&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><img src="imgs/multi_thread15.jpg" alt="" width="500">
<h3 id="总结"><strong>总结：</strong>
</h3><p>1、原子操作一般用于计数或者统计（如累计发送多少个数据包，累计接收到了多少个数据包），多个线程一起统计，这种情况如果不使用原子操作会导致统计发生混乱。</p>
<p>2、写商业代码时，如果不确定结果的影响，最好自己先写一小段代码调试。或者不要使用。</p>
<h2 id="第十一节-stdatomic续谈stdasync深入谈">第十一节 std::atomic续谈、std::async深入谈
</h2><img src="imgs/multi_thread16.jpg" alt="" width="500">
<h3 id="一stdatomic续谈">一、std::atomic续谈
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">g_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//封装了一个类型为int的 对象（值）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">mythread1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		 <span class="c1">//虽然g_count使用了原子操作模板，但是这种写法既读又写，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		 <span class="c1">//会导致计数错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="n">g_count</span> <span class="o">=</span> <span class="n">g_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">mythread1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">mythread1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;正常情况下结果应该是200 0000次，实际是&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">g_count</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><img src="imgs/multi_thread17.jpg" alt="" width="500">
<p>一般atomic原子操作，针对<code>++，--，+=，-=，&amp;=，|=，^=</code>是支持的，其他操作不一定支持。</p>
<h3 id="二stdasync深入理解">二、std::async深入理解
</h3><h4 id="21-stdasync参数详述async-用来创建一个异步任务">2.1 std::async参数详述，async 用来创建一个异步任务
</h4><ul>
<li>延迟调用参数 std::launch::deferred【延迟调用】，std::launch::async【强制创建一个线程】</li>
<li><code>std::thread()</code> 如果系统资源紧张，那么创建线程可能失败，那么执行<code>std::thread()</code>时整个程序可能崩溃。</li>
<li>std::async()我们一般不叫创建线程（他能够创建线程），一般叫它创建一个异步任务。</li>
<li>std::async和std::thread最明显的不同，就是 async 有时候并不创建新线程。</li>
</ul>
<p>①如果用std::launch::deferred 来调用async？</p>
<ul>
<li>延迟到调用 <code>get()</code> 或者 <code>wait()</code> 时执行，如果不调用就不会执行</li>
</ul>
<p>②如果用std::launch::async来调用async？</p>
<ul>
<li>强制这个异步任务在新线程上执行，这意味着，系统必须要创建出新线程来运行入口函数。</li>
</ul>
<p>③如果同时用 std::launch::async | std::launch::deferred</p>
<p>这里这个 | 意味着async的行为可能是 std::launch::async 创建新线程立即执行， 也可能是 std::launch::deferred 没有创建新线程并且延迟到调用get()执行，由<strong>系统根据实际情况来决定</strong>采取哪种方案</p>
<p>④不带额外参数 std::async(mythread)，只给async 一个入口函数名，此时的系统给的默认值是 std::launch::async | std::launch::deferred 和 ③ 一样，有系统自行决定异步还是同步运行。</p>
<h4 id="22-stdasync和stdthread区别">2.2 std::async和std::thread()区别：
</h4><p>std::thread()如果系统资源紧张可能出现创建线程失败的情况，如果创建线程失败那么程序就可能崩溃，而且不容易拿到函数返回值（不是拿不到）</p>
<p>std::async()创建异步任务。可能创建线程也可能不创建线程，并且容易拿到线程入口函数的返回值；</p>
<p>由于系统资源限制：
①如果用std::thread创建的线程太多，则可能创建失败，系统报告异常，崩溃。</p>
<p>②如果用std::async，一般就不会报异常，因为如果系统资源紧张，无法创建新线程的时候，async不加额外参数的调用方式就不会创建新线程。而是在后续调用get()请求结果时执行在这个调用get()的线程上。</p>
<p>如果你强制async一定要创建新线程就要使用 std::launch::async 标记。承受的代价是，系统资源紧张时可能崩溃。</p>
<p>③根据经验，一个程序中线程数量 不宜超过100~200 。</p>
<h4 id="23-async不确定性问题的解决">2.3 async不确定性问题的解决
</h4><p>不加额外参数的async调用时让系统自行决定，是否创建新线程。</p>
<p><code>std::future&lt;int&gt; result = std::async(mythread);</code>
问题焦点在于这个写法，任务到底有没有被推迟执行。</p>
<p>通过wait_for返回状态来判断：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">future_status</span> <span class="n">status</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">//std::future_status status = result.wait_for(6s);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">future_status</span><span class="o">::</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//超时：表示线程还没有执行完
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;超时了，线程还没有执行完&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">future_status</span><span class="o">::</span><span class="n">ready</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//表示线程成功放回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;线程执行成功，返回&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">future_status</span><span class="o">::</span><span class="n">deferred</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;线程延迟执行&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="第十二节-windows临界区其他各种mutex互斥量">第十二节 windows临界区、其他各种mutex互斥量
</h2><img src="imgs/multi_thread18.jpg" alt="" width="500">
<h3 id="一和二windows临界区">一和二、windows临界区
</h3><p>Windows临界区，同一个线程是可以重复进入的，但是进入的次数与离开的次数必须相等。
C++互斥量则不允许同一个线程重复加锁。</p>
<p>windows临界区是在windows编程中的内容，了解一下即可，效果几乎可以等同于c++11的mutex</p>
<p>包含<code>#include &lt;windows.h&gt;</code></p>
<p>windows中的临界区同mutex一样，可以保护一个代码段。但windows的临界区可以进入多次，离开多次，但是进入的次数与离开的次数必须相等，不会引起程序报异常出错。</p>
<p>而C++11中不允许一次性lock()两次，会报异常。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define __WINDOWSJQ_
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 把收到的消息传入队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">void</span> <span class="n">inMsgRecvQueue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;收到消息，并放入队列 &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef  __WINDOWSJQ_
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>			<span class="n">EnterCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_winsec</span><span class="p">);</span>	<span class="c1">//	进入临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">//EnterCriticalSection(&amp;my_winsec);	//	可以再次进入临界区,程序不会出错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">msgRecvQueue</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="n">LeaveCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_winsec</span><span class="p">);</span>	<span class="c1">//	离开临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">//LeaveCriticalSection(&amp;my_winsec);	//	如果进入两次，必须离开两次不会报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#elif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>			<span class="n">my_mutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">			<span class="n">msgRecvQueue</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="n">my_mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif </span><span class="c1">//  __WINDOWSJQ_
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;消息入队结束&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 从队列中取出消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">void</span> <span class="nf">outMsgRecvQueue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef  __WINDOWSJQ_
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>			<span class="n">EnterCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_winsec</span><span class="p">);</span>	<span class="c1">//	进入临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msgRecvQueue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">			<span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// 队列不为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">msgRecvQueue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">				<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;从消息队列中取出 &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">num</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">				<span class="n">msgRecvQueue</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">else</span>
</span></span><span class="line"><span class="cl">			<span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// 消息队列为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;消息队列为空 &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="n">LeaveCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_winsec</span><span class="p">);</span>	<span class="c1">//	离开临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#elif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>			<span class="n">my_mutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msgRecvQueue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">			<span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// 队列不为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">msgRecvQueue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">				<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;从消息队列中取出 &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">num</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">				<span class="n">msgRecvQueue</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">				<span class="n">my_mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">else</span>
</span></span><span class="line"><span class="cl">			<span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// 消息队列为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;消息队列为空 &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">				<span class="n">my_mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif </span><span class="c1">//  __WINDOWSJQ_
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;消息出队结束&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">A</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef __WINDOWSJQ_
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>		<span class="n">InitializeCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_winsec</span><span class="p">);</span>	<span class="c1">//	用临界区之前要初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#endif </span><span class="c1">// __WINDOWSJQ_
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">msgRecvQueue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">mutex</span> <span class="n">my_mutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef __WINDOWSJQ_
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>	<span class="n">CRITICAL_SECTION</span> <span class="n">my_winsec</span><span class="p">;</span>	<span class="c1">//	windows中的临界区，非常类似C++11中的mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#endif </span><span class="c1">// __WINDOWSJQ_
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">A</span> <span class="n">myobj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kr">thread</span>	<span class="n">myInMsgObj</span><span class="p">(</span><span class="o">&amp;</span><span class="n">A</span><span class="o">::</span><span class="n">inMsgRecvQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">myobj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="kr">thread</span>	<span class="n">myOutMsgObj</span><span class="p">(</span><span class="o">&amp;</span><span class="n">A</span><span class="o">::</span><span class="n">outMsgRecvQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">myobj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">myInMsgObj</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">myOutMsgObj</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">getchar</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="三自动析构技术"><strong>三、自动析构技术</strong>
</h3><p>C++：lock_guard防止忘了释放信号量，自动释放
windows：可以写个类自动释放临界区：</p>
<p>上述这种类<strong>RAII类</strong>（Resource Acquisition is initialization），即<strong>资源获取及初始化</strong>。容器，智能指针属于这种类。</p>
<h3 id="四递归独占互斥量-stdrecursive_mutex">四、递归独占互斥量 std::recursive_mutex
</h3><p>std::mutex 独占式互斥量</p>
<p>std::recursive_mutex：允许在同一个线程中同一个互斥量多次被 lock() ，（但是递归加锁的次数是有限制的，太多可能会报异常），效率要比mutex低。</p>
<p>如果你真的用了 recursive_mutex 要考虑代码是否有优化空间，如果能调用一次 lock()就不要调用多次。</p>
<h3 id="五带超时的互斥量-stdtimed_mutex-和-stdrecursive_timed_mutex">五、带超时的互斥量 std::timed_mutex 和 std::recursive_timed_mutex
</h3><h4 id="51-stdtimed_mutex是待超时的独占互斥量">5.1 std::timed_mutex：是待超时的独占互斥量
</h4><p>try_lock_for()：
等待一段时间，如果拿到了锁，或者超时了未拿到锁，就继续执行（有选择执行）如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">timeout</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">my_mymutex</span><span class="p">.</span><span class="n">try_lock_for</span><span class="p">(</span><span class="n">timeout</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//......拿到锁返回ture
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//做一些操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">my_mymutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span><span class="p">{</span>			<span class="c1">//拿不到锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">sleeptime</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">sleeptime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>try_lock_until()：</li>
</ul>
<p>参数是一个未来的时间点，在这个未来的时间没到的时间内，如果拿到了锁头，流程就走下来，如果时间到了没拿到锁，流程也可以走下来。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">timeout</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">my_mymutex</span><span class="p">.</span><span class="n">try_lock_until</span><span class="p">(</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">()</span> <span class="o">+</span> <span class="n">timeout</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//......拿到锁返回ture
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">sleeptime</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">sleeptime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>两者的区别就是一个参数是时间段，一个参数是时间点</p>
<h4 id="52-stdrecursive_timed_mutex是待超时的递归独占互斥量">5.2 std::recursive_timed_mutex：是待超时的递归独占互斥量
</h4><h2 id="第十三章-补充知识线程池浅谈数量谈总结">第十三章 补充知识、线程池浅谈、数量谈、总结
</h2><img src="imgs/multi_thread19.jpg" alt="" width="500">
<h3 id="一补充一些知识点">一、补充一些知识点
</h3><h4 id="11-虚假唤醒">1.1 虚假唤醒：
</h4><p>notify_one或者notify_all唤醒wait()后，实际有些线程可能不满足唤醒的条件，就会造成虚假唤醒，可以在wait中再次进行判断解决虚假唤醒。
解决：wait中要有第二个参数（lambda），并且这个lambda中要正确判断所处理的公共数据是否存在。</p>
<h4 id="22-atomic">2.2 atomic：
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">atm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">atm</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里只有读取atm是原子操作，但是整个这一行代码 cout &laquo; atm &laquo; endl; 并不是原子操作，导致最终显示在屏幕上的值是一个“曾经值”。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">atm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">atm2</span> <span class="o">=</span> <span class="n">atm</span><span class="p">;</span> <span class="c1">//原子量的赋值不允许
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这种拷贝初始化不可以，会报错。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">atm2</span><span class="p">(</span><span class="n">atm</span><span class="p">.</span><span class="n">load</span><span class="p">());</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>load()：以原子方式读atomic对象的值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">atm2</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>原子操作实质上是：不允许在进行原子对象操作时进行CPU的上下文切换。</p>
<h3 id="二浅谈线程池">二、浅谈线程池：
</h3><p>场景设想：服务器程序， 每来一个客户端，就创建一个新线程为这个客户提供服务。</p>
<p>问题：</p>
<p>1、2万个玩家，不可能给每个玩家创建一个新线程，此程序写法在这种场景下不通。</p>
<p>2、程序稳定性问题：编写代码中，“时不时地突然”创建一个线程，这种写法，一般情况下不会出错，但是不稳定的；</p>
<p>**线程池：**把一堆线程弄到一起，统一管理。这种统一管理调度，循环利用的方式，就叫做线程池。</p>
<p>**实现方式：**程序启动时，一次性创建好一定数量的线程。这种方式让人更放心，觉得程序代码更稳定。</p>
<h3 id="三线程创建数量谈">三、线程创建数量谈：
</h3><p>1、线程创建的数量极限的问题</p>
<p>一般来讲，2000个线程基本就是极限；再创建就会崩溃。</p>
<p>2、线程创建数量建议</p>
<p>a、采用某些计数开发程序提供的建议，遵照建议和指示来确保程序高效执行。</p>
<p>b、创建多线程完成业务；考虑可能被阻塞的线程数量，创建多余最大被阻塞线程数量的线程，如100个线程被阻塞再充值业务，开110个线程就是很合适的</p>
<p>c、线程创建数量尽量不要超过500个，尽量控制在200个之内；</p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/c&#43;&#43;/">C&#43;&#43;</a>
        
            <a href="/tags/multi-thread/">Multi-Thread</a>
        
    </section>


    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI&#43;WdtXRGWt2kTvGFasHpSy3SV"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.body, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="">
    <a href="/post/reading-notes/notes-at-school/cplusplus-basic/">
        
        

        <div class="article-details">
            <h2 class="article-title">c&#43;&#43;基础</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/post/reading-notes/notes-at-school/codealgorithm/">
        
        

        <div class="article-details">
            <h2 class="article-title">代码随想录 算法</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/post/reading-notes/notes-at-school/controlinterview/">
        
        

        <div class="article-details">
            <h2 class="article-title">控制算法面试</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/post/reading-notes/notes-at-school/ros-robotics-develop/">
        
        

        <div class="article-details">
            <h2 class="article-title">ROS机器人开发</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/post/reading-notes/notes-at-school/crazyswarmusage/">
        
        

        <div class="article-details">
            <h2 class="article-title">crazyswarm功能包使用</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    <script src="https://utteranc.es/client.js" 
        repo="raff-zeng/raff-zeng.github.io"
        issue-term="pathname"
        
        label="comment"
        
        crossorigin="anonymous"
        async
        >
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    let utterancesLoaded = false;

    function setUtterancesTheme(theme) {
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${theme}`
                },
                'https://utteranc.es'
            );
        }
    }

    addEventListener('message', event => {
        if (event.origin !== 'https://utteranc.es') return;

        
        utterancesLoaded = true;
        setUtterancesTheme(document.documentElement.dataset.scheme)
    });

    window.addEventListener('onColorSchemeChange', (e) => {
        if (!utterancesLoaded) return;
        setUtterancesTheme(e.detail)
    })
</script>


    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2024 raff
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.29.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
