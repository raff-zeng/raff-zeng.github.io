[{"content":"0 仿真仓库配置 地址：https://github.com/raff-zeng/MovingRobot_Sim\n1 2 3 4 5 6 7 8 9 # 安装docker(不确定直接运行是否正常，建议看内容，手动执行) docker/docker_install.sh # 拉osrf/ros:humble-desktop-full, 建立容器. (运行不成功则具体看脚本内容) cd ~/MovingRobot_Sim docker/docker_run.sh prepare # 编译 docker/docker_run.sh build 1 运行仿真 使用turtlebot4：http://www.turtlebot.net.cn/index.php?catid=72\nhttps://turtlebot.github.io/turtlebot4-user-manual/software/turtlebot4_simulator.html\n1 # 启动模型与环境 ","date":"2024-12-29T00:00:00Z","permalink":"https://raff-zeng.github.io/post/robot-notes/movingrobot_sim/","title":"MovingRobot_Sim"},{"content":"TODO 任务大方向 具体内容 slam cartographer nav2 Dijistra、A*、RRT、DWA、tinyMPC 多项式曲线、贝塞尔曲线、b样条曲线 control TinyMPC filter 卡尔曼滤波 openwrt 具体任务 开始时间 仿真仓库运行cartographer 2024-12-29 仿真仓库运行nav2 openwrt框架搭建 stm32源码编译烧录 ros源码编译烧录 ","date":"2024-12-29T00:00:00Z","permalink":"https://raff-zeng.github.io/post/private/todo/","title":"todo"},{"content":"机型参数 wheelTech R550.\nSTM32F407VET6+鲁班猫1S+深度相机+语音交互\n自重1.8kg. 负载3kg. 最大速度1.2m/s. 0.45m/s续航7h\n电机：MG513金属齿轮减速电机\n编码器：500线AB相高精度GMR(巨磁阻)编码器\n减速比1：30. 额定扭矩1kg.cm. 雷达：镭神N10P：6-12Hz. 25m. 5400Hz. 0.4°-0.8°. 60Klux\nASTRA系列RGBD深度相机：\n深度分辨率640×480 30fps 深度0.6m-4m. 视场角58.4°×45.5° RGB分辨率640×480 30fps 视场角63.1°×49.4° 鲁班猫1S(RK3566)：1TOPS\n电池：标称电压10.8V. 满电电压12.6V. 5100mah. 充电电流推荐2A. 充放电接口DC5.5-2.1母头\n科大讯飞六通道麦克风阵列语言模块\n野火鲁班猫在线资料文档 https://doc.embedfire.com/linux/rk356x/quick_start/zh/latest/README.html\nROS机器人与鲁班猫1S使用手册 http://lubancat.wheeltec.net/zh_CN/main/index.html?WHEELTEC\n野火鲁班猫openwrt[野火]OpenWrt用户手册—基于鲁班猫LubanCat — [野火]OpenWrt用户手册—基于LubanCat-RK系列板卡 文档\n","date":"2024-12-29T00:00:00Z","permalink":"https://raff-zeng.github.io/post/robot-notes/wheeltech-robot/","title":"轮趣R550-鲁班猫1S机器人"},{"content":"0 前言 环境：ubuntu22.04\nGitHub Pages 是一个静态站点托管服务，可以直接将页面托管于 GitHub 库或仓库 (repository) 中。\nHugo 是一个用 Go 语言编写的静态站点生成器，其优势为速度快。（还有hexo、jekyll）\n1 安装hugo 1 2 3 4 5 6 sudo apt-get install hugo # 或 sudo snap install hugo # 测试安装 hugo version 2 本地创建 1 2 3 4 5 6 7 8 # 创建 cd ~ hugo new site 【project-name】 cd ~/project-name # 安装主题. 可以在github搜索hugo theme. 找适合自己的, 这里选用Stack. cd ~/project-name/theme git submodule add https://github.com/CaiJimmy/hugo-theme-stack theme/Stack 修改配置文件hugo.toml\n1 2 3 4 baseURL = \u0026#39;https://【github用户名】.github.io/\u0026#39; languageCode = \u0026#39;zh-cn\u0026#39; title = \u0026#39;MY Site\u0026#39; theme = \u0026#39;Stack\u0026#39; 1 2 3 4 5 6 7 8 # 本地预览 hugo server # 网页输入 http://localhost:1313/ # 构建Hugo网站，将静态站点保存到public下 hugo 3 上传到github 这里选择使用两个仓库\n一个仓库储存整个代码, 设置为private. 并把/public文件夹添加到.gitignore\n第二个仓库储存public文件夹下的静态代码. 仓库名需要为 github用户名.github.io\n在自己的github下新建repo. 仓库名随意，应为【project-name】\n1 2 3 4 5 6 7 8 9 10 11 12 13 cd ~/project-name git init # 添加.gitignore cd ~/project-name touch .gitignore echo \u0026#34;/public\u0026#34; \u0026gt; .gitignore git add . git commit -m \u0026#34;repo init\u0026#34; git branch -M main git remote add origin git@github.com:【github用户名】/【仓库名】.git git push -u origin main 第二个仓库 1 2 3 4 5 6 7 cd ~/project-name/public/ git init git add . git commit -m \u0026#34;page first commit\u0026#34; git branch -M main git remote add origin git@github.com:【github用户名】/【github用户名.github.io】.git git push -u origin main 4 快捷方式 1 2 alias inblog=\u0026#39;cd ~/rfblogs_src/\u0026#39; alias blogpush=\u0026#39;inblog \u0026amp;\u0026amp; cd public \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m \u0026#34;update\u0026#34; \u0026amp;\u0026amp; git push \u0026amp;\u0026amp; cd ../\u0026#39; 5 使用Utterances配置评论 Utterances 是一个基于 GitHub Issues 的轻量级评论系统。它的主要优点是：\n无需额外账户，直接使用 GitHub。 评论存储在 GitHub Issues 中，不需要额外的服务器。 免费、开源，并且加载快速。 Utterances官网：https://utteranc.es/\n为项目博客安装Utterances： https://github.com/apps/utterances 设置配置 hugo.toml 中添加 1 2 3 4 5 6 7 8 9 10 11 [Params.Comments] enabled = true provider = \u0026#34;utterances\u0026#34; [Params.Comments.utterances] repo = \u0026#34;UserName/repo\u0026#34; issueTerm = \u0026#34;pathname\u0026#34; label = \u0026#34;comment\u0026#34; theme = \u0026#34;github-light\u0026#34; crossorigin = \u0026#34;anonymous\u0026#34; async = true 或使用config.yaml\n1 2 3 4 5 6 7 8 9 10 11 12 params: comments: enabled: true provider: utterances utterances: repo: raff-zeng/raff-zeng.github.io issueTerm: pathname label: comment theme: github-light crossorigin: anonymous async: true 6 配置头像 图像路径：\u0026lsquo;assets/img/avatar.png\u0026rsquo;\nhugo.toml :\n1 2 3 4 [avatar] enabled = true src = \u0026#34;img/avatar.png\u0026#34; local = true 或config.yaml\n1 2 3 4 avatar: enabled: true src: img/avatar.png\u0026#34; local: true 7 markdown文章 7.1 设置图片 解决HTML标签被忽略的警告 1 2 3 4 markup: goldmark: renderer: unsafe: true 文件树结构（这里把图片放在imgs文件夹下，方便管理） ├── post1 │ ├── imgs │ │ └── img.jpg │ └── index.md\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;!-- 方式1：使用HTML标签（推荐） --\u0026gt; \u0026lt;img src=\u0026#34;imgs/img.jpg\u0026#34; alt=\u0026#34;Image Description\u0026#34; width=\u0026#34;500\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;imgs/img.jpg\u0026#34; alt=\u0026#34;\u0026#34; style=\u0026#34;zoom:50%;\u0026#34; /\u0026gt; \u0026lt;!-- 居中 --\u0026gt; \u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;imgs/multi_thread1.jpg\u0026#34; alt=\u0026#34;Image Description\u0026#34; width=\u0026#34;500\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 方式2：使用Hugo短代码 --\u0026gt; \u0026lt;!-- 方式3：使用原生Markdown（不建议，因为width属性可能不被支持） 也可以用content下的相对路径 --\u0026gt; ![](imgs/multi_thread1.jpg) ![](reading-notes/notes-at-school/multithread/imgs/multi_thread1.jpg) 7.2 .md页面配置 \u0026mdash;: YAML 格式 +++: TOML 格式\n1 2 3 4 5 6 7 8 9 10 11 12 --- title: \u0026#39;Note\u0026#39; date: 2024-11-30 draft: false searchHidden: false # 允许被搜索 menu: main: name: Home weight: -100 params: icon: home --- 1 2 3 4 5 6 7 8 9 10 11 12 13 +++ title = \u0026#39;Note\u0026#39; date = \u0026#39;2024-11-20T22:00:02+08:00\u0026#39; draft = false searchHidden = false [menu.main] name = \u0026#34;Home\u0026#34; weight = -100 [menu.main.params] icon = \u0026#34;home\u0026#34; +++ 推荐使用YAML格式(\u0026mdash;)\n7.3 页面配置 配置上级页面，列举该文件夹下的页面:\n1 2 3 4 ── tech-blogs ├── hugo-start │ └── index.md └── _index.md _index.md：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 --- title: \u0026#39;技术博客\u0026#39; date: 2024-11-30 draft: false type: section layout: list # 使用列表布局 searchHidden: false # 允许被搜索 comments: false # 禁用评论 menu: main: name: 技术博客 weight: 1 params: # icon: home --- tech-blogs/hugo-star/index.md：\n1 2 3 4 5 6 7 8 9 10 11 12 13 --- title: \u0026#39;使用githubPage+hugo无成本建立博客\u0026#39; date: 2024-11-30 draft: false slug: test-chinese searchHidden: false # 允许被搜索 categories: - tech-blogs tags: - blog --- 正文 参考：\nhttps://zhuanlan.zhihu.com/p/57361697 https://mp.weixin.qq.com/s/Rm45Lh1yiP5Kr8Ve11ybpA hugo 中文网：https://hugo.opendocs.io/getting-started/ stack主题教程：https://stack.jimmycai.com/guide/getting-started ","date":"2024-11-30T00:00:00Z","permalink":"https://raff-zeng.github.io/post/tech-blogs/hugo-start/","title":"使用githubPage+hugo无成本建立博客"},{"content":"C++编程基础\n1.类和IO库 4.类和对象 4.1封装 属性和行为作为整体 from: 黑马程序员B站\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; const double PI = 3.14; class Circle { public: int m_r; double calculateZC() { return 2 * PI * m_r; } }; int main() { Circle cl; cl.m_r = 10; cout \u0026lt;\u0026lt; \u0026#34;圆的周长=\u0026#34; \u0026lt;\u0026lt; cl.calculateZC() \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 案例-设计学生类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class Student { public: //类中的属性和行为\t我们统一称为\t成员 //属性\t成员属性\t成员变量 //行为\t成员函数\t成员方法 //属性 string m_Name; int m_Id; //行为 //给姓名赋值 void setName(string name) { m_Name = name; } void showStudent() { cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; m_Name \u0026lt;\u0026lt; \u0026#34; 学号：\u0026#34; \u0026lt;\u0026lt; m_Id \u0026lt;\u0026lt; endl; } }; int main() { Student s1; Student s2; s1.m_Name = \u0026#34;张三\u0026#34;; s1.m_Id = 1; s1.showStudent(); s2.setName(\u0026#34;李四\u0026#34;); s2.m_Id = 2; s2.showStudent(); system(\u0026#34;pause\u0026#34;); return 0; } 访问权限 ​\t类在设计时,可以把属性和行为放在不同的权限下,加以控制\n访问权限有三种:\npublic\t公共权限\t类内可以访问\t类外可以访问 protected\t保护权限 类内可以访问 类外不可以访问 private\t私有权限 类内可以访问 类外不可以访问 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class Person { public: string m_name; protected: string m_car; private: int m_password; public: void func() { m_name = \u0026#34;张三\u0026#34;; m_car = \u0026#34;拖拉机\u0026#34;; m_password = 123456; } }; int main() { Person p1; p1.m_name = \u0026#34;李四\u0026#34;; //p1.m_car = \u0026#34;奔驰\u0026#34;;//保护权限内容，在类外访问不到 //p1.m_Password = 123;//私有权限内容，类外访问不到 system(\u0026#34;pause\u0026#34;); return 0; } struct和class区别 在C++中struct和class唯一的区别就在于默认的访问权限不同\n区别:\nstruct 默认权限为公共\nclass默认权限为私有\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class C1 { int m_A; //默认是私有权限 }; struct c2 { int m_A; //默认是公共权限 }; int main() { C1 c1; //c1.m_A = 10;//错误，访问权限是私有 c2 c2; c2.m_A = 10; // 正确，访问权限是公共 system(\u0026#34;pause\u0026#34;); return 0; } 成员属性设置为私有 优点1:将所有成员属性设置为私有，可以自己控制读写权限\n优点2:对于写权限，我们可以检测数据的有效性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class Person { public: //姓名设置可读可写 void setName(string name) { m_Name = name; } string getName() { return m_Name; } //获取年龄 int getAge() { return m_Age; } //设置年龄 void setAge(int age) { if (age \u0026lt; 0 || age \u0026gt; 150) { cout \u0026lt;\u0026lt; \u0026#34;你个老妖精!\u0026#34; \u0026lt;\u0026lt; endl; return; } m_Age = age; } //情人设置为只写 void setLover(string lover) { m_Lover = lover; } private: string m_Name; //可读可写姓名 int m_Age; // 只读年龄 string m_Lover;//只写情人 }; int main() { Person p;//姓名设置 p.setName(\u0026#34;张三\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;姓名:\u0026#34; \u0026lt;\u0026lt; p.getName() \u0026lt;\u0026lt; endl; //年龄设置 p.setAge(50), cout \u0026lt;\u0026lt; \u0026#34;年龄:\u0026#34; \u0026lt;\u0026lt; p.getAge() \u0026lt;\u0026lt; endl; //情人设置 p.setLover(\u0026#34;小王\u0026#34;); //cout\u0026lt;\u0026lt;\u0026#34;情人:\u0026#34; \u0026lt;\u0026lt; p.m_Lover \u0026lt;\u0026lt; endl; // 只写属性，不可以读取 system(\u0026#34;pause\u0026#34;); return 0; } 练习案例1:设计立方体类 设计立方体类(Cube)\n求出立方体的面积和体积\n分别用全局函数和成员函故判断两个立方体是否相等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; //立方体类设计 //1、创建立方体类 //2、设计属性 //3、设计行为获取立方体面积和体积 //4、分别利用全局函数和成员函数判断两个立方体是否相等 class Cube { public: //设置长 void setL(int l) { m_L = l; } //获取长 int getL() { return m_L; } void setW(int w) { m_W = w; } int getW() { return m_W; } void setH(int h) { m_H = h; } int getH() { return m_H; } int calculateS() { return 2 * m_L * m_W + 2 * m_W * m_H + 2 * m_L * m_H; } int calculateV() { return m_L * m_W * m_H; } private: int m_L; int m_W; int m_H; }; //利用全局函数判断两个立方体是否相等 bool isSame (Cube \u0026amp;c1 , Cube \u0026amp;c2){ if (c1.getL() == c2.getL() \u0026amp;\u0026amp; c1.getW() == c2.getW() \u0026amp;\u0026amp; c1.getH() == c2.getH()) { return true; } return false; } int main() { Cube c1; c1.setL(10); c1.setW(10); c1.setH(10); // 600 cout \u0026lt;\u0026lt; \u0026#34;c1的面积为:\u0026#34; \u0026lt;\u0026lt; c1.calculateS() \u0026lt;\u0026lt; endl; // 1000 cout \u0026lt;\u0026lt; \u0026#34;c1的体积为:\u0026#34; \u0026lt;\u0026lt; c1.calculateV() \u0026lt;\u0026lt; endl; Cube c2; c2.setL(10); c2.setW(10); c2.setH(10); bool ret = isSame(c1, c2); if (ret) { cout \u0026lt;\u0026lt; \u0026#34;c1和c2是相等的\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;c1和c2是不相等的\u0026#34; \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } 案例2:点和圆的关系 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; #include\u0026#34;point.h\u0026#34; #include\u0026#34;circle.h\u0026#34; //class Point { //public: //\tvoid setX(int x) { //\tm_X = x; //\t} //\tint getX() { //\treturn m_X; //\t} //\tvoid setY(int y) { //\tm_Y = y; //\t} //\tint getY() { //\treturn m_Y; //\t} //private: //\tint m_X; //\tint m_Y; //}; //class Circle{ //public: //\tvoid setR(int r) { //\tm_R = r; //\t} //\tint getR() { //\treturn m_R; //\t} //\tvoid setCenter(Point center) { //\tm_Center = center; //\t} //\tPoint getCenter() { //\treturn m_Center; //\t} //private: //\tint m_R; //\tPoint m_Center; //}; //判断点和圆关系 void isInCircle(Circle \u0026amp;c, Point \u0026amp;p) { //计算两点之间距离平方 int distance = (c.getCenter().getX() - p.getX()) * (c.getCenter().getX() - p.getX()) + (c.getCenter().getY() - p.getY()) * (c.getCenter().getY() - p.getY()); //计算半径的平方 int rDistance = c.getR()* c.getR(); //判断关系 if (distance == rDistance) { cout \u0026lt;\u0026lt; \u0026#34;点在圆上\u0026#34; \u0026lt;\u0026lt; endl; } else if (distance \u0026gt; rDistance) { cout \u0026lt;\u0026lt; \u0026#34;点在圆外\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;点在圆内\u0026#34; \u0026lt;\u0026lt; endl; } } int main() { Circle c; c.setR(10); Point center; center.setX(10); center.setY(0); c.setCenter(center); //创建点 Point p; p.setX(10); p.setY(9); isInCircle(c,p); system(\u0026#34;pause\u0026#34;); return 0; } point.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 #pragma once #include\u0026lt;iostream\u0026gt; using namespace std; class Point { public: void setX(int x); int getX(); void setY(int y); int getY() ; private: int m_X; int m_Y; }; circle.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #pragma once #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026#34;point.h\u0026#34; class Circle { public: void setR(int r); int getR(); void setCenter(Point center); Point getCenter(); private: int m_R; Point m_Center; }; point.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include\u0026#34;point.h\u0026#34; void Point::setX(int x) { m_X = x; } int Point::getX() { return m_X; } void Point::setY(int y) { m_Y = y; } int Point::getY() { return m_Y; } circle.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include\u0026#34;circle.h\u0026#34; void Circle::setR(int r) { m_R = r; } int Circle::getR() { return m_R; } void Circle::setCenter(Point center) { m_Center = center; } Point Circle::getCenter() { return m_Center; } main.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; #include\u0026#34;point.h\u0026#34; #include\u0026#34;circle.h\u0026#34; //判断点和圆关系 void isInCircle(Circle \u0026amp;c, Point \u0026amp;p) { //计算两点之间距离平方 int distance = (c.getCenter().getX() - p.getX()) * (c.getCenter().getX() - p.getX()) + (c.getCenter().getY() - p.getY()) * (c.getCenter().getY() - p.getY()); //计算半径的平方 int rDistance = c.getR()* c.getR(); //判断关系 if (distance == rDistance) { cout \u0026lt;\u0026lt; \u0026#34;点在圆上\u0026#34; \u0026lt;\u0026lt; endl; } else if (distance \u0026gt; rDistance) { cout \u0026lt;\u0026lt; \u0026#34;点在圆外\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;点在圆内\u0026#34; \u0026lt;\u0026lt; endl; } } int main() { Circle c; c.setR(10); Point center; center.setX(10); center.setY(0); c.setCenter(center); //创建点 Point p; p.setX(10); p.setY(9); isInCircle(c,p); system(\u0026#34;pause\u0026#34;); return 0; } 4.2对象的初始化和清理 C++中的面向对象来源于生活，每个对象也都会有初始设置以及对象销毁前的清理数据的设置。\n4.2.1构造函数和析构函数 对象的初始化和清理也是两个非常重要的安全问题\n​\t一个对象或者变量没有初始状态,对其使用后果是未知\n​\t同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题\nC++利用了构造函数和析构函数解决上述问题，这两个函教将会被编译器自动调用，完成对象初始化和清理工作。对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供 编译器提供的构造函数和析构函数是空实现.\n构造函数:主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。\n析构函数:主要作用在于对象销毁前系统自动调用，执行一些清理工作。\n构造函数语法:\t类名(){} 1.构造函数，没有返回值也不写void\n2.函数名称与类名相同\n3.构造函数可以有参数，因此可以发生重载\n4.程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次\n析构函数语法:\t~类名(){} 1.析构函数，没有返回值也不写void\n2.函数名称与类名相同,在名称前加上符号~\n3.析构函数不可以有参数，因此不可以发生重载Ⅰ\n4.程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class Person { public: //构造函数 Person() { cout \u0026lt;\u0026lt; \u0026#34;Person 构造函数的调用\u0026#34; \u0026lt;\u0026lt; endl; } //析构函数 ~Person() { cout \u0026lt;\u0026lt; \u0026#34;Person 析构函数的调用\u0026#34; \u0026lt;\u0026lt; endl; } }; void test01() { Person p; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.2.2构造函数的分类及调用 两种分类方式:\n按参数分为:有参构造和无参构造\n按类型分为:普通构造和拷贝构造\n三种调用方式:\n括号法 显示法 隐式转换法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class Person { public: //构造函数 Person() { cout \u0026lt;\u0026lt; \u0026#34;Person 无参构造函数的调用\u0026#34; \u0026lt;\u0026lt; endl; } Person(int a) { age = a; cout \u0026lt;\u0026lt; \u0026#34;Person 有参构造函数的调用\u0026#34; \u0026lt;\u0026lt; endl; } //拷贝构造函数 Person(const Person \u0026amp;p) { age = p.age; cout \u0026lt;\u0026lt; \u0026#34;Person 拷贝构造函数的调用\u0026#34; \u0026lt;\u0026lt; endl; } //析构函数 ~Person() { cout \u0026lt;\u0026lt; \u0026#34;Person 析构函数的调用\u0026#34; \u0026lt;\u0026lt; endl; } int age; }; //调用 void test01() { //1、括号法 Person p1;//默认构造函数调用 Person p2(10);//有参构造函数 Person p3(p2); //注意事项 //调用默认构造函数时候,不要加() //因为下面这行代码，编译器会认为是一个函数的声明 Person p1(); //2/显示法 Person p1; Person p2 = Person(10); Person p3 = Person(p2); Person(10);//匿名对象，特点:当前行执行结束后，系统会立即回收掉匿名对象 //注意事项2 //不要利用拷贝构造函数初始化匿名对象 Person(p3) == = Person p3;对象声明 //Person(p3); //3、隐式转换法 Person p4 = 10;//相当于Person p4 = Person(10); Person p5 = p4; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.2.3拷贝构造函数调用时机 C++中拷贝构造函数调用时机通常有三种情况\n使用一个已经创建完毕的对象来初始化一个新对象\n值传递的方式给函数参数传值\n以值方式返回局部对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include\u0026lt;iostream\u0026gt; using namespace std; class Person { public: //构造函数 Person() { cout \u0026lt;\u0026lt; \u0026#34;Person 默认构造函数的调用\u0026#34; \u0026lt;\u0026lt; endl; } Person(int a) { m_age = a; cout \u0026lt;\u0026lt; \u0026#34;Person 有参构造函数的调用\u0026#34; \u0026lt;\u0026lt; endl; } //拷贝构造函数 Person(const Person \u0026amp;p) { m_age = p.m_age; cout \u0026lt;\u0026lt; \u0026#34;Person 拷贝构造函数的调用\u0026#34; \u0026lt;\u0026lt; endl; } ~Person() { cout \u0026lt;\u0026lt; \u0026#34;Person 析构函数的调用\u0026#34; \u0026lt;\u0026lt; endl; } int m_age; }; //调用 void test01() { Person p1(20); Person p2(p1); } void doWork2(Person p) { } void test02() { Person p3; doWork2(p3); } Person doWork3() { Person p1; cout \u0026lt;\u0026lt; (int*)\u0026amp;p1 \u0026lt;\u0026lt; endl; return p1; } void test03() { Person p = doWork3(); cout \u0026lt;\u0026lt; (int*)\u0026amp;p \u0026lt;\u0026lt; endl; } int main() { //test01(); test03(); system(\u0026#34;pause\u0026#34;); return 0; } 4.2.4构造函数调用规则 默认情况下，C++编译器至少给一个类添加3个函数\n默认构造函教(无参，函数体为空) 默认析构函数(无参，函数体为空) 默认拷贝构造函数，对属性进行值拷贝 构造函数调用规则如下:\n如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造\n如果用户定义拷贝构造函数，c++不会再提供其他构造函数\n4.2.5深拷贝与浅拷贝 深浅拷贝是面试经典问题,也是常见的一个坑\n浅拷贝:简单的赋值拷贝操作\n深拷贝:在堆区重新申请空间,进行拷贝操作\nPerson p2（p1）如果利用编译器提供的拷贝构造函数,会做浅拷贝操作\n浅拷贝带来的问题就是堆区的内存重复释放 要利用深拷贝进行解决\n总结:如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include\u0026lt;iostream\u0026gt; using namespace std; class Person { public: //构造函数 Person() { cout \u0026lt;\u0026lt; \u0026#34;Person 默认构造函数的调用\u0026#34; \u0026lt;\u0026lt; endl; } Person(int age,int height) { m_age = age; m_height = new int(height); cout \u0026lt;\u0026lt; \u0026#34;Person 有参构造函数的调用\u0026#34; \u0026lt;\u0026lt; endl; } //拷贝构造函数 Person(const Person \u0026amp;p) { cout \u0026lt;\u0026lt; \u0026#34;Person 拷贝构造函数的调用\u0026#34; \u0026lt;\u0026lt; endl; m_age = p.m_age; //m_height = p.m_height; 编译器默认实现的 //深拷贝操作 m_height=new int(*p.m_height); } ~Person() { if (m_height != NULL) { delete m_height; } cout \u0026lt;\u0026lt; \u0026#34;Person 析构函数的调用\u0026#34; \u0026lt;\u0026lt; endl; } int m_age; int *m_height; }; //调用 void test01() { Person p1(18,160); cout \u0026lt;\u0026lt; \u0026#34;p1的年龄为\u0026#34; \u0026lt;\u0026lt; p1.m_age \u0026lt;\u0026lt; \u0026#34; p1的身高为\u0026#34; \u0026lt;\u0026lt; *p1.m_height \u0026lt;\u0026lt; endl; Person p2(p1); cout \u0026lt;\u0026lt; \u0026#34;p2的年龄为\u0026#34; \u0026lt;\u0026lt; p2.m_age \u0026lt;\u0026lt; \u0026#34; p2的身高为\u0026#34; \u0026lt;\u0026lt; *p2.m_height \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.2.6初始化列表 作用:C++提供了初始化列表语法,用来初始化属性\n语法:构造函数():属性1(值1),展性2(值2)\u0026hellip;（）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include\u0026lt;iostream\u0026gt; using namespace std; class Person { public: //构造函数 /*Person() { cout \u0026lt;\u0026lt; \u0026#34;Person 默认构造函数的调用\u0026#34; \u0026lt;\u0026lt; endl; }*/ // 传统初始化操作 /*Person(int a,int b,int c) { m_a = a; m_b = b; m_c = c; cout \u0026lt;\u0026lt; \u0026#34;Person 有参构造函数的调用\u0026#34; \u0026lt;\u0026lt; endl; }*/ //初始化列表初始化属性 Person():m_a(10), m_b(20), m_c(30) { } Person(int a,int b,int c):m_a(a), m_b(b), m_c(c) { } ~Person() { cout \u0026lt;\u0026lt; \u0026#34;Person 析构函数的调用\u0026#34; \u0026lt;\u0026lt; endl; } int m_a; int m_b; int m_c; }; //调用 void test01() { //Person p(10,20,30); Person p; cout \u0026lt;\u0026lt; \u0026#34;m_a=\u0026#34; \u0026lt;\u0026lt; p.m_a \u0026lt;\u0026lt; \u0026#34; m_b=\u0026#34; \u0026lt;\u0026lt; p.m_b \u0026lt;\u0026lt; \u0026#34; m_c=\u0026#34; \u0026lt;\u0026lt; p.m_c \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.2.7类对象作为类成员 C++类中的成员可以是另一个类的对象，我们称该成员为对象成员\n1 2 3 4 5 class A{} class B { A a; } B类中有对象A作为成员，A为对象成员\n那么当创建B对象时,A与B的构造和析构的顺序是谁先谁后?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class Phone { public: Phone(string pname) { m_pname = pname; cout \u0026lt;\u0026lt; \u0026#34;Phone的构造函数调用\u0026#34; \u0026lt;\u0026lt; endl; } ~Phone() { cout \u0026lt;\u0026lt; \u0026#34;Phone的析构函数调用\u0026#34; \u0026lt;\u0026lt; endl; } //手机品牌名 string m_pname; }; class Person { public: Person(string name, string pname) :m_name(name), m_phone(pname) { cout \u0026lt;\u0026lt; \u0026#34;Person的构造函数调用\u0026#34; \u0026lt;\u0026lt; endl; } ~Person() { cout \u0026lt;\u0026lt; \u0026#34;Person的析构函数调用\u0026#34; \u0026lt;\u0026lt; endl; } //姓名 string m_name; //手机 Phone m_phone; }; //调用 void test01() { Person p(\u0026#34;张三\u0026#34;, \u0026#34;华为\u0026#34;); cout \u0026lt;\u0026lt; p.m_name \u0026lt;\u0026lt; \u0026#34;拿着\u0026#34; \u0026lt;\u0026lt; p.m_phone.m_pname \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; }#include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class Phone { public: Phone(string pname) { m_pname = pname; cout \u0026lt;\u0026lt; \u0026#34;Phone的构造函数调用\u0026#34; \u0026lt;\u0026lt; endl; } ~Phone() { cout \u0026lt;\u0026lt; \u0026#34;Phone的析构函数调用\u0026#34; \u0026lt;\u0026lt; endl; } //手机品牌名 string m_pname; }; class Person { public: Person(string name, string pname) :m_name(name), m_phone(pname) { cout \u0026lt;\u0026lt; \u0026#34;Person的构造函数调用\u0026#34; \u0026lt;\u0026lt; endl; } ~Person() { cout \u0026lt;\u0026lt; \u0026#34;Person的析构函数调用\u0026#34; \u0026lt;\u0026lt; endl; } //姓名 string m_name; //手机 Phone m_phone; }; //调用 void test01() { Person p(\u0026#34;张三\u0026#34;, \u0026#34;华为\u0026#34;); cout \u0026lt;\u0026lt; p.m_name \u0026lt;\u0026lt; \u0026#34;拿着\u0026#34; \u0026lt;\u0026lt; p.m_phone.m_pname \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.2.8静态成员 静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员\n静态成员分为:\n静态成员变量 所有对象共享同一份数据。 在编译阶段分配内存 内声明，类外初始化 静态成员函数 所有对象共享同一个函数 静态成员函数只能访问静态成员变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class Person { public: //静态成员函数 static void func() { m_a = 100;//静态成员函数可以访问静态成员变量 //m_b = 200;// 静态成员函数不可以访问非静态成员变量，无法区分是哪个对象的m_b属性 cout \u0026lt;\u0026lt; \u0026#34;static void func 的调用\u0026#34; \u0026lt;\u0026lt; endl; } static int m_a;//静态成员变量 int m_b;//非静态成员变量 //静态成员函数也是有访问权限的 private: static void func2() { cout \u0026lt;\u0026lt; \u0026#34;static void func2 的调用\u0026#34; \u0026lt;\u0026lt; endl; } }; int Person::m_a = 0; //两种访问方式 void test01() { //1.通过对象访问 Person p; p.func(); //2.通过类名访问 Person::func(); //共享同一个 //Person::func2();//类外访问不到私有静态成员函数 } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.3 C++对象模型和this指针 4.3.1成员变量和成员函数分开存储 在C++中，类内的成员变呈和成员函数分开存储\n只有非静态成员变量才属于类的对象上\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class Person { int m_a;//非静态成员变量 属于类的对象上 static int m_b;//静态成员 不属于类对象上 void func() {}//非静态成员函数 不属于类对象上 static void func2() {};//静态成员函数 不属于类对象上 }; void test01() { Person p; //空对象占用内存空间为：1 //C++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置 // 每个空对象也应该有一个独一无二的内存地址 cout \u0026lt;\u0026lt; \u0026#34;size of p = \u0026#34; \u0026lt;\u0026lt; sizeof(p) \u0026lt;\u0026lt; endl; } void test02() { Person p; cout \u0026lt;\u0026lt; \u0026#34;size of p = \u0026#34; \u0026lt;\u0026lt; sizeof(p) \u0026lt;\u0026lt; endl; } int main() { test02(); system(\u0026#34;pause\u0026#34;); return 0; } 4.3.2 this指针概念 通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的\n每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码\n那么问题是:这一块代码是如何区分那个对象调用自己的呢?\nC++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象\nthis指针是隐含每一个非静态成员函数内的一种指针\nthis指针不需要定义，直接使用即可\nthis指针的用途:\n当形参和成员变量同名时，可用this指针来区分 在类的非静态成员函数中返回对象本身，可使用return *this 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include\u0026lt;iostream\u0026gt; using namespace std; class Person { public: Person(int age) { //this指针指向被调用的成员函数所属的对象 this-\u0026gt;age = age; } Person\u0026amp; PersonADDage(Person \u0026amp;p) { this-\u0026gt;age += p.age; //this指向p2的指针，而*this指向的就是p2这个对象本体 return *this; } int age; }; //1.解决名称冲突 void test01() { Person p1(18); cout \u0026lt;\u0026lt; \u0026#34;p1的年龄为： \u0026#34; \u0026lt;\u0026lt; p1.age \u0026lt;\u0026lt; endl; } //2.返回对象本身用*this void test02() { Person p1(10); Person p2(10); p2.PersonADDage(p1).PersonADDage(p1); cout \u0026lt;\u0026lt; \u0026#34;p2的年龄为： \u0026#34; \u0026lt;\u0026lt; p2.age \u0026lt;\u0026lt; endl; } int main() { test02(); system(\u0026#34;pause\u0026#34;); return 0; } 4.3.3空指针访问成员函数 C++中空指针也是可以调用成员函数的,但是也要注意有没有用到this指针\n如果用到this指针,需要加以判断保证代码的健壮性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include\u0026lt;iostream\u0026gt; using namespace std; class Person { public: void showClassName() { cout \u0026lt;\u0026lt; \u0026#34;this is Person class\u0026#34; \u0026lt;\u0026lt; endl; } void showClassAge() { //报错原因是因为传入的指针是为NULL if (this == NULL) { return; } cout \u0026lt;\u0026lt; \u0026#34;age= \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_age \u0026lt;\u0026lt; endl; } int m_age; }; //1.解决名称冲突 void test01() { Person *p = NULL; p-\u0026gt;showClassName(); p-\u0026gt;showClassAge(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.3.4 const修饰成员函数 常函数:\n成员函数后加const后我们称为这个函数为常函数 常函教内不可以修改成员属性 成员属性声明时加关键字mutable后，在常函数中依然可以修改 常对象:\n声明对象前加const称该对象为常对象 常对象只能调用常函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include\u0026lt;iostream\u0026gt; using namespace std; //常函数 class Person { public: //this指针的本质是指针常量 指针的指向是不可以修改的 //const Person * const this; //在成员函数后面加const，修饰的是this指向，让指针指向的值也不可以修改 void showPerson() const //相当于上一行 { this-\u0026gt;m_b = 100; //this-\u0026gt;m_a = 100; // this = NULL; //this指针不可以修改指针的指向的 } void func(){} int m_a; mutable int m_b;//特殊变量，即使在常函数中，也可以修改这个值,加关键字mutable }; //1.解决名称冲突 void test01() { Person p; p.showPerson(); } //常对象 void test02() { const Person p;//在对象前加const，变为常对象 //p.m_a = 100; p.m_b = 100;//m_B是特殊值，在常对象下也可以修改 //常对象只能调用常函数 p. showPerson() ; //p.func();//常对象不可以调用普通成员函数，因为普通成员函数可以修改属性 } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.4友元 生活中你的家有客厅(Public)，有你的卧室(Private)\n客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去\n但是呢，你也可以允许你的好闺蜜好基友进去。\n在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术\n友元的目的就是让一个函教或者类访问另一个类中私有成员\n友元的关键字为friend\n友元的三种实现\n全局函教做友元 类做友元 成员函数做友元 1.全局函教做友元 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class Building { // goodGay全局函数是 Building好朋友，可以访问Building中私有成员 friend void goodGay(Building *building); public: Building() { m_SittingRoom = \u0026#34;客厅\u0026#34;; m_BedRoom = \u0026#34;卧室\u0026#34;; } public: string m_SittingRoom;//客厅 private: string m_BedRoom;//卧室 }; //全局函数 void goodGay(Building *building) { cout \u0026lt;\u0026lt; \u0026#34;好基友的全局函数 正在访问：\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_SittingRoom \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;好基友的全局函数 正在访问：\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_BedRoom \u0026lt;\u0026lt; endl; } void test01() { Building building; goodGay(\u0026amp;building); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 2.类做友元 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class Building; class GoodGay { public: void visit();//参观函数访问Building中的属性 Building * building; GoodGay(); private: Building *building; }; class Building { friend class GoodGay; public: Building(); public: string m_SittingRoom;//客厅 private: string m_BedRoom;//卧室 }; Building::Building() { m_SittingRoom = \u0026#34;客厅\u0026#34;; m_BedRoom = \u0026#34;卧室\u0026#34;; } GoodGay::GoodGay() { //创建建筑物对象 building = new Building; } void GoodGay::visit() { cout \u0026lt;\u0026lt; \u0026#34;好基友的全局函数 正在访问：\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_SittingRoom \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;好基友的全局函数 正在访问：\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_BedRoom \u0026lt;\u0026lt; endl; } void test01() { GoodGay gg; gg.visit(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 3.成员函数做友元 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class Building; class GoodGay { public: GoodGay(); void visit();//让visit函数可以访问Building中私有成员 void visit2();//让visit函数不可以访问Building中私有成员 private: Building *building; }; class Building { friend void GoodGay::visit(); public: Building(); public: string m_SittingRoom;//客厅 private: string m_BedRoom;//卧室 }; Building::Building() { m_SittingRoom = \u0026#34;客厅\u0026#34;; m_BedRoom = \u0026#34;卧室\u0026#34;; } GoodGay::GoodGay() { //创建建筑物对象 building = new Building; } void GoodGay::visit() { cout \u0026lt;\u0026lt; \u0026#34;好基友的全局函数 正在访问：\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_SittingRoom \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;好基友的全局函数 正在访问：\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_BedRoom \u0026lt;\u0026lt; endl; } void GoodGay::visit2() { cout \u0026lt;\u0026lt; \u0026#34;好基友的全局函数 正在访问：\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_SittingRoom \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; \u0026#34;好基友的全局函数 正在访问：\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_BedRoom \u0026lt;\u0026lt; endl; } void test01() { GoodGay gg; gg.visit(); gg.visit2(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.5运算符重载 运算符重载概念:对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型\n4.5.1加号运算符重载 作用:实现两个自定义数据类型相加的运算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class Person { public: //1.成员函数重载+号 //Person operator+(Person \u0026amp;p) //{ //\tPerson temp; //\ttemp.m_a = this-\u0026gt;m_a + p.m_a; //\ttemp.m_b = this-\u0026gt;m_b + p.m_b; //\treturn temp; //} int m_a; int m_b; }; //2.全局函数重载+号 Person operator+(Person \u0026amp;p1, Person \u0026amp;p2) { Person temp; temp.m_a = p1.m_a + p2.m_a; temp.m_b = p1.m_b + p2.m_b; return temp; } //函数重载版本 Person operator+(Person \u0026amp;p1, int num) { Person temp; temp.m_a = p1.m_a + num; temp.m_b = p1.m_b + num; return temp; } void test01() { Person p1; p1.m_a = 10; p1.m_b = 10; Person p2; p2.m_a = 10; p2.m_b = 10; //成员函数重载本质调用 //Person p3 = p1.operator+(p2); //全局函数重载本质调用 //Person p3 = operator+(p1,p2); Person p3 = p1 + p2; //函数重载 Person p4 = p1 + 100; cout \u0026lt;\u0026lt; \u0026#34;p3.m_a = \u0026#34; \u0026lt;\u0026lt; p3.m_a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;p3.m_b = \u0026#34; \u0026lt;\u0026lt; p3.m_b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;p4.m_a = \u0026#34; \u0026lt;\u0026lt; p4.m_a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;p4.m_b = \u0026#34; \u0026lt;\u0026lt; p4.m_b \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结1:对于内置的数据类型的表达式的的运算符是个可能改变的\n总结2:不要溢用运算符重载\n4.5.2左移运算符重载 作用:可以输出自定义教据类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class Person { //利用成员函数重载左移运算符p.operator\u0026lt;\u0026lt;(cout)简化版本p \u0026lt;\u0026lt; cout //不会利用成员函数重载\u0026lt;\u0026lt;运算符，因为无法实现cout在左侧 //void operator\u0026lt;\u0026lt;( cout ) //{ //} friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;cout, Person \u0026amp;p); public: Person(int a,int b) { m_a = a; m_b = b; } private: int m_a; int m_b; }; //2.只能利用全局函数重载左移运算符 ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;cout, Person \u0026amp;p)//本质 operator\u0026lt;\u0026lt;(cout,p) 简化cout\u0026lt;\u0026lt;p { cout \u0026lt;\u0026lt; \u0026#34;m_a = \u0026#34; \u0026lt;\u0026lt; p.m_a \u0026lt;\u0026lt; \u0026#34; p.m_b = \u0026#34; \u0026lt;\u0026lt; p.m_b; return cout; } void test01() { Person p(10,10); cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt;\u0026#34; hello world!\u0026#34;\u0026lt;\u0026lt;endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.5.3递增运算符重载 作用:通过重载递增运算符,实现自己的整型教据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class MyInteger { friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;cout, MyInteger \u0026amp;myint); public: MyInteger() { m_num = 0; } //重载前置++运算符 返回引用为了一直对一个数据进行递增操作 MyInteger\u0026amp; operator++() { m_num++; return *this; } //重载后置++运算符 //void operator++(int) int代表占位参数，可以用于区分前置和后置递增 //temp是局部对象 返回值，不返回引用 MyInteger operator++(int) { //先记录当时结果 MyInteger temp = *this; //后递增 m_num++; // 最后将记录结果做返回 return temp; } private: int m_num; }; //重载左移运算符 ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;cout, MyInteger \u0026amp;myint) { cout \u0026lt;\u0026lt; myint.m_num; return cout; } void test01() { MyInteger myint; cout \u0026lt;\u0026lt; ++myint \u0026lt;\u0026lt; endl; } void test02() { MyInteger myint; cout \u0026lt;\u0026lt; myint++ \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; myint \u0026lt;\u0026lt; endl; } int main() { test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:前置递增返回引用,后置递增返回值\n4.5.4赋值运算符重载 C++编译器至少给一个类添加4个函数\n默认构造函数(无参，函教体为空) 默认析构函数(无参，函数体为空) 默认拷贝构造函数，对属性进行值拷贝 赋值运算符operator=,对属性进行值拷贝 如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class Person { public: Person(int age) { m_age =\tnew int(age); } ~Person() { if (m_age != NULL) { delete m_age; m_age = NULL; } } //重载 赋值运算符 Person\u0026amp; operator=(Person \u0026amp;p) { //编译器提供的是浅拷贝 //m_age=p.m_age; //应该先判断是否有属性在堆区，如果有先释放干净，然后再深拷贝 if (m_age != NULL) { delete m_age; m_age = NULL; } //深拷贝 m_age = new int(*p.m_age); return *this; } int *m_age; private: }; void test01() { Person p1(18); Person p2(20); Person p3(30); p3 = p2 = p1;//赋值操作 cout \u0026lt;\u0026lt; \u0026#34;p1的年龄为： \u0026#34; \u0026lt;\u0026lt; *p1.m_age \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;p2的年龄为： \u0026#34; \u0026lt;\u0026lt; *p2.m_age \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;p3的年龄为： \u0026#34; \u0026lt;\u0026lt; *p3.m_age \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.5.5关系运算符重载 作用:重载关系运算符，可以让两个自定义类型对象进行对比操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class Person { public: Person(string name,int age) { m_name = name; m_age =\tage; } //重载 ==号 bool operator==(Person \u0026amp;p) { if (this-\u0026gt;m_age == p.m_age \u0026amp;\u0026amp; this-\u0026gt;m_name == p.m_name) { return 1; } return 0; } //重载 !=号 bool operator!=(Person \u0026amp;p) { if (this-\u0026gt;m_age == p.m_age \u0026amp;\u0026amp; this-\u0026gt;m_name == p.m_name) { return 0; } return 1; } string m_name; int m_age; private: }; void test01() { Person p1(\u0026#34;Tom\u0026#34;,18); Person p2(\u0026#34;jerry\u0026#34;, 18); if (p1 == p2) { cout \u0026lt;\u0026lt; \u0026#34;p1和p2是相等的\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;p1和p2是不相等的\u0026#34; \u0026lt;\u0026lt; endl; } if (p1 != p2) { cout \u0026lt;\u0026lt; \u0026#34;p1和p2是不相等的\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;p1和p2相等的\u0026#34; \u0026lt;\u0026lt; endl; } } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.5.6函数调用运算符重载 函数调用运算符()也可以重载 由于重载后使用的方式非常像函数的调用，因此称为仿函数 仿函数没有固定写法。非常灵活 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class MyPrint { public: //重载函数调用运算符 void operator()(string test) { cout \u0026lt;\u0026lt; test \u0026lt;\u0026lt; endl; } private: }; void Myprint02(string test) { cout \u0026lt;\u0026lt; test \u0026lt;\u0026lt; endl; } void test01() { MyPrint myprint; myprint(\u0026#34;hello world\u0026#34;);//由于使用起来非常类似于函数调用，因此称为仿函数 Myprint02(\u0026#34;hello world\u0026#34;); } //仿函数非常灵活，没有固定的写法 //加法类 class MyAdd { public: int operator()(int num1,int num2) { return num1 + num2; } }; void test02() { MyAdd myadd; int ret = myadd(100, 100); cout \u0026lt;\u0026lt; ret \u0026lt;\u0026lt; endl; //匿名函数对象 cout \u0026lt;\u0026lt; MyAdd()(100, 100) \u0026lt;\u0026lt; endl; } int main() { test02(); system(\u0026#34;pause\u0026#34;); return 0; } 4.6继承 继承是面向对象三大特性之一 有些类与类之间存在特殊的关系，例如下图中:\n我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。\n这个时候我们就可以考虑利用继承的技术，减少重复代码\n例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同\n接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; //普通实现页面 //Java页面 //class Java //{ //public: //\tvoid header() //\t{ //\tcout \u0026lt;\u0026lt; \u0026#34;首页、公开课、登录、注册...(公共头部)\u0026#34; \u0026lt;\u0026lt; endl; //\t} //\tvoid footer() //\t{ //\tcout \u0026lt;\u0026lt; \u0026#34;帮助中心、交流合作、站内地图...(公共底部)\u0026#34; \u0026lt;\u0026lt; endl; //\t} //\tvoid left() //\t{ //\tcout \u0026lt;\u0026lt; \u0026#34;Java、python、C++、...(公共分类列表)\u0026#34; \u0026lt;\u0026lt; endl; //\t} //\tvoid content() //\t{ //\tcout \u0026lt;\u0026lt; \u0026#34;Java学科视频\u0026#34; \u0026lt;\u0026lt; endl; //\t} //private: //}; //class Python //{ //public: //\tvoid header() //\t{ //\tcout \u0026lt;\u0026lt; \u0026#34;首页、公开课、登录、注册...(公共头部)\u0026#34; \u0026lt;\u0026lt; endl; //\t} //\tvoid footer() //\t{ //\tcout \u0026lt;\u0026lt; \u0026#34;帮助中心、交流合作、站内地图...(公共底部)\u0026#34; \u0026lt;\u0026lt; endl; //\t} //\tvoid left() //\t{ //\tcout \u0026lt;\u0026lt; \u0026#34;Java、python、C++、...(公共分类列表)\u0026#34; \u0026lt;\u0026lt; endl; //\t} //\tvoid content() //\t{ //\tcout \u0026lt;\u0026lt; \u0026#34;Python学科视频\u0026#34; \u0026lt;\u0026lt; endl; //\t} //private: //}; //class CPP //{ //public: //\tvoid header() //\t{ //\tcout \u0026lt;\u0026lt; \u0026#34;首页、公开课、登录、注册...(公共头部)\u0026#34; \u0026lt;\u0026lt; endl; //\t} //\tvoid footer() //\t{ //\tcout \u0026lt;\u0026lt; \u0026#34;帮助中心、交流合作、站内地图...(公共底部)\u0026#34; \u0026lt;\u0026lt; endl; //\t} //\tvoid left() //\t{ //\tcout \u0026lt;\u0026lt; \u0026#34;Java、python、C++、...(公共分类列表)\u0026#34; \u0026lt;\u0026lt; endl; //\t} //\tvoid content() //\t{ //\tcout \u0026lt;\u0026lt; \u0026#34;C++学科视频\u0026#34; \u0026lt;\u0026lt; endl; //\t} //private: //}; class BasePage { public: void header() { cout \u0026lt;\u0026lt; \u0026#34;首页、公开课、登录、注册...(公共头部)\u0026#34; \u0026lt;\u0026lt; endl; } void footer() { cout \u0026lt;\u0026lt; \u0026#34;帮助中心、交流合作、站内地图...(公共底部)\u0026#34; \u0026lt;\u0026lt; endl; } void left() { cout \u0026lt;\u0026lt; \u0026#34;Java、python、C++、...(公共分类列表)\u0026#34; \u0026lt;\u0026lt; endl; } private: }; class Java :public BasePage { public: void content() { cout \u0026lt;\u0026lt; \u0026#34;Java学科视频\u0026#34; \u0026lt;\u0026lt; endl; } }; class Python :public BasePage { public: void content() { cout \u0026lt;\u0026lt; \u0026#34;Python学科视频\u0026#34; \u0026lt;\u0026lt; endl; } }; class CPP :public BasePage { public: void content() { cout \u0026lt;\u0026lt; \u0026#34;C++学科视频\u0026#34; \u0026lt;\u0026lt; endl; } }; void test01() { cout \u0026lt;\u0026lt; \u0026#34;Java的下载视频如下：\u0026#34; \u0026lt;\u0026lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout \u0026lt;\u0026lt; \u0026#34;--------------------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Python的下载视频如下：\u0026#34; \u0026lt;\u0026lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout \u0026lt;\u0026lt; \u0026#34;--------------------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;C++的下载视频如下：\u0026#34; \u0026lt;\u0026lt; endl; CPP cpp; cpp.header(); cpp.footer(); cpp.left(); cpp.content(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 继承的好处:减少重复代码\n语法: class 子类 : 继承方式 父类\n子类 也称为 派生类\n父类 也称为 基类\n派生类中的成员，包含两大部分:\n一类是从基类继承过来的，一类是自己增加的成员。\n从基类继承过过来的表现其共性,而新增的成员体现了其个性\n4.6.2继承方式 继承的语法:class 子类 : 继承方式 父类\n继承方式一共有三种:\n公共继承 保护继承 私有继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class Base1 { public: int m_a; protected: int m_b; private: int m_c; }; class Son1 :public Base1 { public: void func() { m_a = 10;//父类中的公共权限成员到子类中依然是公共权限 m_b = 10;//父类中的保护权限成员到子类中依然是保护权限 //m_c = 10;//父类中的私有权限成员子类访问不到 } }; void test01() { Son1 s1; s1.m_a = 100; //s1.m_b = 100;//到Son1中 m_b是保护权限类外访问不到 } class Son2 :protected Base1 { public: void func() { m_a = 10;//父类中的公共权限成员到子类中变为保护权限 m_b = 10;//父类中的保护权限成员到子类中依然是保护权限 //m_c = 10;//父类中的私有权限成员子类访问不到 } }; void test02() { Son2 s2; //s2.m_a = 100; //在Son2中 m_a变为保护权限，因此类外访问不到 //s2.m_b = 100;//到Son2中 m_b是保护权限类外访问不到 } class Son3 :private Base1 { public: void func() { m_a = 10;//父类中的公共权限成员到子类中变为私有权限 m_b = 10;//父类中的保护权限成员到子类中变为私有权限 //m_c = 10;//父类中的私有权限成员子类访问不到 } }; void test03() { Son3 s3; //s3.m_a = 100; //在Son2中 m_a变为私有权限，因此类外访问不到 //s3.m_b = 100;//到Son2中 m_b是私有权限类外访问不到 } class Grandson3 : public Son3 { public: void func() { //m_a = 1000;//到了Son3中 m_A变为私有，及时是儿子，也是访问不到 //m_B = 1000;//到了Son3中 m_B变为私有，及时是儿子，也是访问不到 } }; int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.6.3继承中的对象模型 问题:从父类继承过来的成员，哪些属于子类对象中?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; //利用开发人员命令提示工具查看对象模型 //跳转盘符F: //跳转文件路径cd具体路径下 //查看命名 //cl /d1 reportSingleClassLayoutSon \u0026#34;01 C++.cpp\u0026#34; class Base { public: int m_A; protected: int m_B; private: int m_C;//私有成员只是被隐藏了,但是还是会继承下去\t}; // 公共继承 class Son :public Base { public: int m_D; }; void test01() { //16 // 父类中所有非静态成员属性都会被子类继承下去 //父类中私有成员属性是被编译器给隐藏了，因此是访问不到，但是确实被继承下去了 cout \u0026lt;\u0026lt; \u0026#34;sizeof Son=\u0026#34; \u0026lt;\u0026lt; sizeof(Son) \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.6.4继承中构造和析构顺序 子类继承父类后，当创建子类对象，也会调用父类的构造函数\n问题:父类和子类的构造和析构阃序是谁先谁后?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class Base { public: Base() { cout \u0026lt;\u0026lt; \u0026#34;Base的构造函数\u0026#34; \u0026lt;\u0026lt; endl; } ~Base() { cout \u0026lt;\u0026lt; \u0026#34;Base的析构函数\u0026#34; \u0026lt;\u0026lt; endl; } }; // 公共继承 class Son :public Base { public: Son() { cout \u0026lt;\u0026lt; \u0026#34;Son的构造函数\u0026#34; \u0026lt;\u0026lt; endl; } ~Son() { cout \u0026lt;\u0026lt; \u0026#34;Son的析构函数\u0026#34; \u0026lt;\u0026lt; endl; } }; void test01() { //Base b; Son a; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 继承中的构造和析构顺序如下:\n先构造父类，再构造子类，析构的顺序与构造的顺序相反\n4.6.5继承同名成员处理方式 问题:当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢?\n访问子类同名成员直接访问即可 访问父类同名成员需要加作用域 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class Base { public: Base() { m_a = 100; } void func() { cout \u0026lt;\u0026lt; \u0026#34;Base - func()调用\u0026#34; \u0026lt;\u0026lt; endl; } void func(int a) { cout \u0026lt;\u0026lt; \u0026#34;Base - func()调用\u0026#34; \u0026lt;\u0026lt; endl; } int m_a; }; // 公共继承 class Son :public Base { public: Son() { m_a = 200; } void func() { cout \u0026lt;\u0026lt; \u0026#34;Son - func()调用\u0026#34; \u0026lt;\u0026lt; endl; } int m_a; }; //同名成员属性处理 void test01() { //Base b; Son a; cout \u0026lt;\u0026lt; \u0026#34;Son 下 m_a = \u0026#34; \u0026lt;\u0026lt; a.m_a \u0026lt;\u0026lt; endl; //如果通过子类对象访问到父类中同名成员，需要加作用域 cout \u0026lt;\u0026lt; \u0026#34;Base 下 m_a = \u0026#34; \u0026lt;\u0026lt; a.Base::m_a \u0026lt;\u0026lt; endl; } void test02() { Son s; //s.func(); //直接调用调用是子类中的同名成员 //如何调用到父类中同名成员函数?Ⅰ s.Base::func(); //如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏掉父类中所有同名成员函数 //如果想访问到父类中被隐藏的同名成员函数，需要加作用域 s.Base::func(100); } int main() { test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结: 1.子类对象可以直接访问到子类中同名成员\n2.子类对象加作用域可以访问到父类同名成员\n3.当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数\n4.6.6继承同名静态成员处理方式 问题:继承中同名的静态成员在子类对象上如何进行访问?\n静态成员和非静态成员出现同名,处理方式一致\n访问子类同名成员直接访问即可\n访问父类同名成员需要加作用域\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class Base { public: static int m_a; static void func() { cout \u0026lt;\u0026lt; \u0026#34;Base - static void func()\u0026#34; \u0026lt;\u0026lt; endl; } }; int Base::m_a = 100; class Son :public Base { public: static int m_a; static void func() { cout \u0026lt;\u0026lt; \u0026#34;Son - static void func()\u0026#34; \u0026lt;\u0026lt; endl; } }; int Son::m_a = 200; //同名静态成员属性 void test01() { Son s; //1.通过对象访问 cout \u0026lt;\u0026lt; \u0026#34;Son 下的m_a = \u0026#34; \u0026lt;\u0026lt; s.m_a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Base 下的m_a = \u0026#34; \u0026lt;\u0026lt; s.Base::m_a \u0026lt;\u0026lt; endl; //2.通过类名访问 cout \u0026lt;\u0026lt; \u0026#34;通过类名访问:\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Son下 m_a = \u0026#34; \u0026lt;\u0026lt; Son::m_a \u0026lt;\u0026lt; endl ; //第一个::代表通过类名方式访问第二个::代表访问父类作用域下 cout \u0026lt;\u0026lt; \u0026#34;Base下 m_a = \u0026#34; \u0026lt;\u0026lt;Son::Base::m_a\u0026lt;\u0026lt; endl ; } void test02() { Son s; //1.通过对象访问 s.func(); s.Base::func(); //2.通过类名访问 Son::func(); Son::Base::func(); // 子类出现和父类同名静态成员函数，也会隐藏父类中所有同名成员函数 / 如果想访问父类中被隐藏同名成员，需要加作用域 //Son::Base::func(100); } int main() { test02(); system(\u0026#34;pause\u0026#34;); return 0; } 4.6.7多继承语法 C++允许一个类继承多个类\n语法: class子类∶继承方式 父类1,继承方式 父类2\u0026hellip;\n多继承可能会引发父类中有同名成员出现,需要加作用域区分\nC++实际开发中不建议用多继承\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class Base1 { public: Base1() { m_a = 100; } int m_a; }; class Base2 { public: Base2() { m_a = 200; } int m_a; }; // //子类需要继承Base1和Base2 class Son :public Base1, public Base2 { public: Son() { m_c = 300; m_d = 400; } int m_c; int m_d; }; void test01() { Son s; cout \u0026lt;\u0026lt; \u0026#34;sizeof Son = \u0026#34; \u0026lt;\u0026lt; sizeof(s) \u0026lt;\u0026lt; endl; //当父类中出现同名成员，需要加作用域区分 cout \u0026lt;\u0026lt; \u0026#34;Basel::m_A = \u0026#34; \u0026lt;\u0026lt; s.Base1::m_a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Base2::m_A = \u0026#34; \u0026lt;\u0026lt; s.Base2::m_a \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.6.8菱形继承 菱形继承概念:\n​\t两个派生类继承同一个基类\n​\t又有某个类同时继承者两个派生类\n​\t这种继承被称为菱形继承,或者钻石继承\n典型的菱形继承案例：\n菱形继承问题:\n羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。 草泥马继承自动物的数据继承了两份，其实我们应该清楚。这份数据我们只需要一份就可以。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class Animal { public: int m_age; }; //利用虚继承解决菱形继承的问题 //继承之前加上关键字virtual变为虚继承 // Animal类称为虚基类 //羊类 class Sheep :virtual public Animal {}; //驼类 class Tuo :virtual public Animal {}; //羊驼类 class SheepTuo : public Sheep,public Tuo {}; void test01() { SheepTuo st; st.Sheep::m_age = 18; st.Tuo::m_age = 28; // 当菱形继承，两个父类拥有相同数据，需要加以作用域区分 cout \u0026lt;\u0026lt; \u0026#34;st.Sheep::m_age = \u0026#34; \u0026lt;\u0026lt; st.Sheep::m_age \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;st.Tuo::m_age = \u0026#34; \u0026lt;\u0026lt; st.Tuo::m_age \u0026lt;\u0026lt; endl; //这份数据我们知道只有有一份就可以，菱形继承导致数据有两份，资源浪费 cout \u0026lt;\u0026lt; \u0026#34;st.m_age = \u0026#34; \u0026lt;\u0026lt; st.m_age \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.7多态 4.7.1多态的基本概念 多态是C++面向对象三大特性之一\n多态分为两类\n静态多态:函数重载和运算符重载属于静态多态，复用函敌名 动态多态:派生类和虚函教实现运行时多态 静态多态和动态多态区别:\n静态多态的函数地址早绑定- 编译阶段确定函数地址 动态多态的函教地址晚绑定- 运行阶段确定函数地址 下面通过案例进行讲解多态\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; //多态 //动物类 class Animal { public: //虚函数 virtual void speak() { cout \u0026lt;\u0026lt; \u0026#34;动物在说话\u0026#34; \u0026lt;\u0026lt; endl; } }; class Cat :public Animal { public: //重写函数返回值类型函数名参数列表完全相同 //子类virtual关键字可写可不行，父类必须写 void speak() { cout \u0026lt;\u0026lt; \u0026#34;小猫在说话\u0026#34; \u0026lt;\u0026lt; endl; } }; class Dog :public Animal { public: void speak() { cout \u0026lt;\u0026lt; \u0026#34;小狗在说话\u0026#34; \u0026lt;\u0026lt; endl; } }; //执行说话的函数 //地址早绑定在编译阶段确定函数地址 //如果想执行让猫说话，那么这个函数地址就不能提前绑定，需要在运行阶段进行绑定，地址晚绑定 //动态多态满足条件 // 1、有继承关系 // 2、子类 \u0026#39;重写\u0026#39; 父类的虚函数 //动态多态使用 //父类的指针或者引用 指向子类对象 void doSpeak(Animal \u0026amp;animal) //Animal \u0026amp;animal=cat; { animal.speak(); } void test01() { Cat cat; doSpeak(cat); Dog dog; dog.speak(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结: 多态满足条件\n有继承关系 子类重写父类中的虚函数 多态使用条件\n父类指针或引用指向子类对象 重写:函数返回值类型函数名参数列表完全一致称为重写\n4.7.2多态案例- -计算器类 案例描述:\n分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类\n多态的优点:\n代码组织结构清晰 可读性强 利于前期和后期的扩展以及维护 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class Calculate { public: int getResult(string oper) { if (oper == \u0026#34;+\u0026#34;) { return m_num1 + m_num2; } else if (oper == \u0026#34;-\u0026#34;) { return m_num1 - m_num2; } else if (oper == \u0026#34;*\u0026#34;) { return m_num1 * m_num2; } } //如果想扩展新的功能，需求修改源码 //在真是开发中提倡开闭原则 //开闭原则:对扩展进行开放，对修改进行关闭 int m_num1; int m_num2; }; //利用多态实现计算器 //多态好处: //1. 组织结构清晰 //2、 可读性强 //3、 对于前期和后期扩展以及维护性高 //实现计算器抽象类 class AbstractCalculator { public: virtual int getResult() { return 0; } int m_num1; int m_num2; }; //加法计算器类 class AddCalculator :public AbstractCalculator { public: int getResult() { return m_num1 + m_num2; } }; //减法计算器类 class SubCalculator :public AbstractCalculator { public: int getResult() { return m_num1 - m_num2; } }; //乘法计算器类 class MulCalculator :public AbstractCalculator { public: int getResult() { return m_num1 * m_num2; } }; void test01() { Calculate c; c.m_num1 = 10; c.m_num2 = 10; cout \u0026lt;\u0026lt; c.m_num1 \u0026lt;\u0026lt; \u0026#34;+\u0026#34; \u0026lt;\u0026lt; c.m_num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; c.getResult(\u0026#34;+\u0026#34;) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; c.m_num1 \u0026lt;\u0026lt; \u0026#34;-\u0026#34; \u0026lt;\u0026lt; c.m_num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; c.getResult(\u0026#34;-\u0026#34;) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; c.m_num1 \u0026lt;\u0026lt; \u0026#34;*\u0026#34; \u0026lt;\u0026lt; c.m_num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; c.getResult(\u0026#34;*\u0026#34;) \u0026lt;\u0026lt; endl; } void test02() { AbstractCalculator *abc = new AddCalculator; abc-\u0026gt;m_num1 = 100; abc-\u0026gt;m_num2 = 100; cout \u0026lt;\u0026lt; abc-\u0026gt;m_num1 \u0026lt;\u0026lt; \u0026#34; + \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;m_num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;getResult() \u0026lt;\u0026lt; endl; //用完记得销毁 delete abc; abc = new SubCalculator; abc-\u0026gt;m_num1 = 100; abc-\u0026gt;m_num2 = 100; cout \u0026lt;\u0026lt; abc-\u0026gt;m_num1 \u0026lt;\u0026lt; \u0026#34; + \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;m_num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;getResult() \u0026lt;\u0026lt; endl; //用完记得销毁 delete abc; abc = new MulCalculator; abc-\u0026gt;m_num1 = 100; abc-\u0026gt;m_num2 = 100; cout \u0026lt;\u0026lt; abc-\u0026gt;m_num1 \u0026lt;\u0026lt; \u0026#34; + \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;m_num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;getResult() \u0026lt;\u0026lt; endl; //用完记得销毁 delete abc; } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 4.7.3纯虚函数和抽象类 在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容\n因此可以将虚函数改为纯虚函数\n纯虚函数语法: virtual 返回值类型 函数名(参数列表)=0\n当类中有了纯虚函数，这个类也称为抽象类\n抽象类特点:\n无法实例化对象 子类必须重写抽象类中的纯虚函数，否则也属于抽象类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class Base { public: //纯虚函数 //只要有一个纯虚函数，这个类称为抽象类 //抽象类特点： //1.无法实例化对象 //2.抽象类的子类必须重写抽象类中的纯虚函数，否则也属于抽象类 virtual void func() = 0; }; class Son :public Base { virtual void func() { cout \u0026lt;\u0026lt; \u0026#34;func函数调用\u0026#34; \u0026lt;\u0026lt; endl; } }; void test01() { //Base b;\t//抽象类无法实例化对象 //new Base;\t//抽象类无法实例化对象 Base *base = new Son; base-\u0026gt;func(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.7.4多态案例二-制作饮品 案例描述:\n制作饮品的大致流程为:煮水-冲泡-倒入杯中-加入辅料\n利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class AbstractDrinking { public: //煮水 virtual void Boil() = 0; //冲泡 virtual void Brew() = 0; //倒入杯中 virtual void PourInCup() = 0; //加入辅料 virtual void PutSomething() = 0; //制作饮品 void makeDrink() { Boil(); Brew(); PourInCup(); PutSomething(); } }; class Coffee :public AbstractDrinking { public: //煮水 virtual void Boil() { cout \u0026lt;\u0026lt; \u0026#34;煮农夫山泉\u0026#34; \u0026lt;\u0026lt; endl; } //冲泡 virtual void Brew() { cout \u0026lt;\u0026lt; \u0026#34;冲泡咖啡\u0026#34; \u0026lt;\u0026lt; endl; } //倒入杯中 virtual void PourInCup() { cout \u0026lt;\u0026lt; \u0026#34;倒入杯中\u0026#34; \u0026lt;\u0026lt; endl; } //加入辅料 virtual void PutSomething() { cout \u0026lt;\u0026lt; \u0026#34;加入糖和牛奶\u0026#34; \u0026lt;\u0026lt; endl; } }; class Tea :public AbstractDrinking { public: //煮水 virtual void Boil() { cout \u0026lt;\u0026lt; \u0026#34;煮矿泉水\u0026#34; \u0026lt;\u0026lt; endl; } //冲泡 virtual void Brew() { cout \u0026lt;\u0026lt; \u0026#34;冲泡茶叶\u0026#34; \u0026lt;\u0026lt; endl; } //倒入杯中 virtual void PourInCup() { cout \u0026lt;\u0026lt; \u0026#34;倒入杯中\u0026#34; \u0026lt;\u0026lt; endl; } //加入辅料 virtual void PutSomething() { cout \u0026lt;\u0026lt; \u0026#34;加入枸杞\u0026#34; \u0026lt;\u0026lt; endl; } }; //制作 void doWork(AbstractDrinking *abs) { abs-\u0026gt;makeDrink(); delete abs; } void test01() { doWork(new Coffee); cout \u0026lt;\u0026lt; \u0026#34;-----------------\u0026#34; \u0026lt;\u0026lt; endl; doWork(new Tea); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.7.5虚析构和纯虚析构 多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码\n解决方式:将父类中的析构函数改为虚析构或者纯虚析构\n虚析构和纯虚析构共性:\n可以解决父类指针释放子类对象 都需要有具体的函教实现 虚析构和纯虚析构区别:\n如果是纯虚析构,该类属于抽象类,无法实例化对象 虚析构语法:\nvirtual ~类名(){}\n纯虚析构语法:\nvirtual ~类名()=0;\n类名::~类名(){}\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class Animal { public: Animal() { cout \u0026lt;\u0026lt; \u0026#34;Animal构造函数调用\u0026#34; \u0026lt;\u0026lt; endl; } //利用虚析构可以解决 父类指针释放子类对象时不干净的问题 //virtual ~Animal() //{ //\tcout \u0026lt;\u0026lt; \u0026#34;Animal析构函数调用\u0026#34; \u0026lt;\u0026lt; endl; //} //纯虚析构 需要声明也需要实现 //有了纯虚析构之后，这个类也属于抽象类，无法实例化对象 virtual ~Animal() = 0; //纯虚函数 virtual void speak() = 0; }; Animal::~Animal() { cout \u0026lt;\u0026lt; \u0026#34;Animal纯析构函数调用\u0026#34; \u0026lt;\u0026lt; endl; } class Cat :public Animal { public: Cat(string name) { cout \u0026lt;\u0026lt; \u0026#34;Cat构造函数调用\u0026#34; \u0026lt;\u0026lt; endl; m_name = new string(name); } ~Cat() { if (m_name != NULL) { cout \u0026lt;\u0026lt; \u0026#34;Cat析构函数调用\u0026#34; \u0026lt;\u0026lt; endl; delete m_name; m_name = NULL; } } virtual void speak() { cout \u0026lt;\u0026lt; *m_name \u0026lt;\u0026lt; \u0026#34;小猫在说话\u0026#34; \u0026lt;\u0026lt; endl; } string *m_name; }; void test01() { Animal *animal = new Cat(\u0026#34;Tom\u0026#34;); animal-\u0026gt;speak(); //父类指针在析构时候不会调用子类中析构函数，导致子类如果有堆区属性，出现内存泄漏 delete animal; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:\n虚析构或纯虚析构就是用来解决通过父类指针释放子类对象 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构 拥有纯虚析构函数的类也属于抽象类 4.7.6多态案例三-电脑组装 案例描述:\n电简主要组成部件为CPU(用于计算)，显卡(用于显示)，内存条（用于存储)\n将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商\n创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口\n测试时组装三台不同的电脑进行工作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class CPU { public: virtual void calculate() = 0; }; class VideoCard { public: virtual void display() = 0; }; class Memory { public: virtual void storage() = 0; }; //电脑 class Computer { public: Computer(CPU *cpu, VideoCard *vc, Memory * mem) { m_cpu = cpu; m_vc = vc; m_mem = mem; } ~Computer() { if (m_cpu != NULL) { delete m_cpu; m_cpu = NULL; } if (m_vc != NULL) { delete m_vc; m_vc = NULL; } if (m_mem != NULL) { delete m_mem; m_mem = NULL; } } void work() { m_cpu-\u0026gt;calculate(); m_vc-\u0026gt;display(); m_mem-\u0026gt;storage(); } private: CPU * m_cpu; VideoCard * m_vc; Memory * m_mem; }; class IntelCPU :public CPU { virtual void calculate() { cout \u0026lt;\u0026lt; \u0026#34;intel的CPU开始工作了\u0026#34; \u0026lt;\u0026lt; endl; } }; class IntelVideoCard :public VideoCard { virtual void display() { cout \u0026lt;\u0026lt; \u0026#34;intel的显卡开始工作了\u0026#34; \u0026lt;\u0026lt; endl; } }; class IntelMemory :public Memory { virtual void storage() { cout \u0026lt;\u0026lt; \u0026#34;intel的内存条开始工作了\u0026#34; \u0026lt;\u0026lt; endl; } }; class LenovoCPU :public CPU { virtual void calculate() { cout \u0026lt;\u0026lt; \u0026#34;Lenovo的CPU开始工作了\u0026#34; \u0026lt;\u0026lt; endl; } }; class LenovoVideoCard :public VideoCard { virtual void display() { cout \u0026lt;\u0026lt; \u0026#34;Lenovo的显卡开始工作了\u0026#34; \u0026lt;\u0026lt; endl; } }; class LenovoMemory :public Memory { virtual void storage() { cout \u0026lt;\u0026lt; \u0026#34;Lenovo的内存条开始工作了\u0026#34; \u0026lt;\u0026lt; endl; } }; void test01() { //第一台电脑零件 CPU *intelCpu = new IntelCPU; VideoCard * intelCard = new IntelVideoCard; Memory *intelMem = new IntelMemory; //创建第一台电脑 Computer * computer1 = new Computer(intelCpu, intelCard, intelMem); computer1-\u0026gt;work(); delete computer1; cout \u0026lt;\u0026lt; \u0026#34;--------------------\u0026#34; \u0026lt;\u0026lt; endl; Computer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory); computer2-\u0026gt;work(); delete computer2; cout \u0026lt;\u0026lt; \u0026#34;--------------------\u0026#34; \u0026lt;\u0026lt; endl; Computer * computer3 = new Computer(new IntelCPU, new LenovoVideoCard, new LenovoMemory); computer3-\u0026gt;work(); delete computer3; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 5文件操作 程序运行时产生的数据都属于临时数据,程序—旦运行结束都会被释放\n通过文件可以将数据持久化\nC++中对文件操作需要包含头文件\u0026lt; fstream \u0026gt;\n文件类型分为两种:\n文本文件:文件以文本的AScII码形式存储在计算机中 二进制文件:文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们 操作文件的三大类:\nofstream:写操作 ifstream:读操作 fstream:读写操作 5.1 文本文件 5.1.1写文件 写文件步骤如下:\n包含头文件\t#include 创建流对象 ofstream ofs; 打开文件 ofs.open(文件路径\u0026quot;.打开方式); 写数据 ofs \u0026laquo;\u0026ldquo;写入的数据\u0026rdquo;; 关闭文件 ofs.close(); 文件打开方式：\n注意:文件打开方式可以配合使用，利用|操作符\n例如:用二进制方式写文件ios::binary | ios::out\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; #include\u0026lt;fstream\u0026gt; void test01() { ofstream ofs; ofs.open(\u0026#34;text.txt\u0026#34;, ios::out); ofs \u0026lt;\u0026lt; \u0026#34;张三\u0026#34; \u0026lt;\u0026lt; endl; ofs \u0026lt;\u0026lt; \u0026#34;18岁\u0026#34; \u0026lt;\u0026lt; endl; ofs.close(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:\n文件操作必须包含头文件fstream 读文件可以利用ofstream ,或者fstream类 打开文件时候需要指定操作文件的路径，以及打开方式 利用\u0026laquo;可以向文件中写数据 操作完毕,要关闭文件 5.1.2读文件 读文件与写文件步骤相似，但是读取方式相对于比较多\n读文件步骤如下:\n包含头文件 #include 创建流对象 ifstream ifs;\n打开文件并判断文件是否打开成功\nifs.open(\u0026ldquo;文件路径\u0026rdquo;.打开方式);\n读数据 四种方式读取\n关闭文件 ifs.close();\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; #include\u0026lt;fstream\u0026gt; void test01() { ifstream ifs; ifs.open(\u0026#34;text.txt\u0026#34;, ios::in); if (!ifs.is_open()) { cout \u0026lt;\u0026lt; \u0026#34;文件打开失败\u0026#34; \u0026lt;\u0026lt; endl; return; } //1.第一种 //char buf[1024] = { 0 }; //while (ifs \u0026gt;\u0026gt; buf) //{ //\tcout \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; //} //第二种 //char buf[1024] = { 0 }; //while (ifs.getline(buf,sizeof(buf))) //{ //\tcout \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; //} //第三种 //string buf; //while (getline(ifs,buf)) //{ //\tcout \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; //} //第四种 char c; while ((c = ifs.get()) != EOF) { cout \u0026lt;\u0026lt; c; } ifs.close(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:\n读文件可以利用 ifstream ,或者fstream类\n利用is_open函数可以判断文件是否打开成功\nclose关闭文件\n用第三种\n1 2 3 4 5 string buf; while (getline(ifs,buf)) { cout \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; } 5.2二进制文件 以二进制的方式对文件进行凌写操怍打开方式要指定为ios::binary\n5.2.1写文件 二进制方式写文件主要利用流对象调用成员函数write\n函数原型:ostrean\u0026amp; write(const char * buffer ,int len）;\n参数解释:字符指针buffer指向内存中一段存储空间。len是读写的字节数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; #include\u0026lt;fstream\u0026gt; class Person { public: char m_name[64]; int m_age; }; void test01() { ofstream ofs(\u0026#34;person.txt\u0026#34;, ios::binary | ios::out); //ofs.open(\u0026#34;person.tet\u0026#34;, ios::binary | ios::out); Person p = { \u0026#34;张三\u0026#34;,18 }; ofs.write((const char *)\u0026amp;p, sizeof(Person)); ofs.close(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:\n文件输出流对象可以通过write函数，以二进制方式写数据 5.2.2读文件 二进制方式读文件主要利用流对象调用成员函数read函数\n原型: istream\u0026amp; read(char *buffer,int len);\n参数解释:字宁符指针buffer指向内存中—段存储空间。len是读写的字节数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; #include\u0026lt;fstream\u0026gt; class Person { public: char m_name[64]; int m_age; }; void test01() { ifstream ifs(\u0026#34;person.txt\u0026#34;, ios::binary | ios::in); if (!ifs.is_open()) { cout \u0026lt;\u0026lt; \u0026#34;打开失败\u0026#34; \u0026lt;\u0026lt; endl; } Person p; ifs.read((char*)\u0026amp;p, sizeof(Person)); cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; p.m_name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; p.m_age \u0026lt;\u0026lt; endl; ifs.close(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 6.模板 6.2函数模板 C++另一种编程思想称为泛型编程，主要利用的技术就是模板 C++提供两种模板机制:函数模板和类模板 6.2.1函数模板语法 函数模板作用:\n建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。\n语法:\n1 2 template\u0026lt;typename T\u0026gt; 函数声明或定义 解释: template \u0026mdash;声明创建模板\ntypename \u0026mdash;表面其后面的符号是一种数据类型，可以用class代替\nT \u0026mdash;通用的数据类型，名称可以替换，通常为大写字母\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include\u0026lt;iostream\u0026gt; using namespace std; //函数模板 //交换两个整型函数 void swapInt(int \u0026amp;a, int \u0026amp;b) { int temp = a; a = b; b = temp; } //交换两个浮点型函数 void swapDouble(double \u0026amp;a,double \u0026amp;b) { double temp = a; a = b; b = temp; } //函数模板 template\u0026lt;typename T\u0026gt;//声明一个模板，告诉编译器后面代码中紧跟着的T不要报错，T是一个通用数据类型 void mySwap(T \u0026amp;a,T \u0026amp;b) { T temp = a; a = b; b = temp; } void test01() { int a = 10; int b = 20; //swapInt(a, b); //利用函数模板交换 //两种方式使用函数模板 //1、自动类型推导 //mySwap(a,b); // 2、显示指定类型 mySwap\u0026lt;int\u0026gt;(a,b); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:\n函数模板利用关键字template 使用函数模板有两种方式:自动类型推导、显示指定类型 模板的目的是为了提高复用性，将类型参数化 6.2.2函数模板注意事项 注意事项:\n自动类型推导，必须推导出一致的数据类型T,才可以使用 模板必须要确定出T的数据类型，才可以使用T 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include\u0026lt;iostream\u0026gt; using namespace std; //函数模板 template\u0026lt;class T\u0026gt;//Typename可以替换成class void mySwap(T \u0026amp;a,T \u0026amp;b) { T temp = a; a = b; b = temp; } void test01() { int a = 10; int b = 20; char c = \u0026#39;c\u0026#39;; // mySwap(a,b);//正确! // mySwap(a，c);//错误!推导不出一致的T类型 cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;b =\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } //2、模板必须要确定出T的数据类型，才可以使用 template\u0026lt;class T\u0026gt; void func() { cout \u0026lt;\u0026lt; \u0026#34;func调用\u0026#34; \u0026lt;\u0026lt; endl; } void test02() { func\u0026lt;int\u0026gt;(); } int main() { test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 6.2.3函数模板案例 案例描述:\n利用函数模板封装一个排序的函数，可以对不同数据类型数组进行排序。 排序规则从大到小，排序算法为选择排序 分别利用char数组和int数组进行测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include\u0026lt;iostream\u0026gt; using namespace std; //实现通用对数组进行排序的函数/规则从大到小 //算法选择 //测试char数组、int数组 //排序算法 template\u0026lt;class T\u0026gt; void mySort(T arr[], int len) { for (int i = 0; i \u0026lt; len; i++) { int max = i;// 认定最大值的下标 for (int j = i + 1; j \u0026lt; len; j++) { //认定的最大值比遍历出的数值要小，说明j下标的元素才是真正的最大值 if (arr[max] \u0026lt; arr[j]) { max = j;//更新最大值下标 }\t} if (max != i) { mySwap(arr[max], arr[i]); } } } template\u0026lt;class T\u0026gt; void mySwap(T \u0026amp;a, T \u0026amp;b) { T temp = a; a = b; b = temp; } //提供打印数组模板 template\u0026lt;class T\u0026gt; void printArray(T arr[], int len) { for (int i = 0; i \u0026lt; len; i++) { cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } void test01() { // 测试char数组 char charArr[] = \u0026#34;badcfe\u0026#34;; int num = sizeof(charArr) / sizeof(char); mySort(charArr,num); printArray(charArr,num); } void test02() { //测试int数组 int intArr[] = { 7, 5, 1, 3, 9, 2, 4, 6 , 8}; int num = sizeof(intArr) / sizeof(int); mySort(intArr,num); printArray(intArr,num); } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 6.2.4普通函数与函数模板的区别 普通函数与函数模板区别：\n普通函数调用时可以发生自动类型转换（隐式类型转换) 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换 如果利用显示指定类型的方式，可以发生隐式类型转换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include\u0026lt;iostream\u0026gt; using namespace std; //普通函数与函数模板区别 //1、普通函数调用可以发生隐式类型转换 //2、函数模板用自动类型推导，不可以发生隐式类型转换 //3、函数模板用显示指定类型，可以发生隐式类型转换 //普通函数 int myAdd01(int a, int b) { return a + b; } template\u0026lt;class T\u0026gt; T myAdd02(T a, T b) { return a + b; } void test01() { int a = 10; int b = 20; char c = \u0026#39;c\u0026#39;; cout \u0026lt;\u0026lt; myAdd01(a, b) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; myAdd01(a, c) \u0026lt;\u0026lt; endl;//c-\u0026gt;97 //自动类似推导\t不会发生隐式类型转换 //cout \u0026lt;\u0026lt; myAdd02(a,c) \u0026lt;\u0026lt; endl; //显示指定类型\t会发生隐式类型转换 cout \u0026lt;\u0026lt; myAdd02\u0026lt;int\u0026gt;(a, c) \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 6.2.5普通函数与函数模板的调用规则 调用规则如下:\n如果函数模板和普通函数都可以实现。优先调用普通函数 可以通过空模板参数列表来强制调用函数模板 函数模板也可以发生重载 如果函数模板可以产生更好的匹配,优先调用函数模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include\u0026lt;iostream\u0026gt; using namespace std; //普通函数 void myPrint(int a, int b) { cout \u0026lt;\u0026lt; \u0026#34;调用的普通函数\u0026#34; \u0026lt;\u0026lt; endl; } template\u0026lt;class T\u0026gt; void myPrint(T a, T b) { cout \u0026lt;\u0026lt; \u0026#34;调用的模板\u0026#34; \u0026lt;\u0026lt; endl; } template\u0026lt;class T\u0026gt; void myPrint(T a, T b,T c) { cout \u0026lt;\u0026lt; \u0026#34;调用的函数模板\u0026#34; \u0026lt;\u0026lt; endl; } void test01() { int a = 10; int b = 20; char c = \u0026#39;c\u0026#39;; //myPrint(a, b); //优先调用普通函数，若普通函数没有函数实现则编译器报错 //通过空模板参数列表，强制调用函数模板 //myPrint\u0026lt;\u0026gt;(a, b); //myPrint(a, b, 100); //如果函数模板产生更好的匹配,优先调用函数模板 char c1 = \u0026#39;c\u0026#39;; char c2 = \u0026#39;c\u0026#39;; myPrint(c1, c2); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 6.2.6模板的局限性 局限性:\n模板的通用性并不是万能的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; //模板局限性 //模板并不是万能的，有些特定数据类型，需要用具体化方式做特殊实现 class Person { public: Person(string name, int age) { this-\u0026gt;m_name = name; this-\u0026gt;m_age = age; } string m_name; int m_age; }; //对比两个数据是否相等函数 template\u0026lt;class T\u0026gt; bool myCompare(T \u0026amp;a, T \u0026amp;b) { if (a == b) { return true; } else { return false; } } //利用具体化Person的版本实现代码，具体化优先调用 template\u0026lt;\u0026gt; bool myCompare(Person \u0026amp;p1, Person \u0026amp;p2) { if (p1.m_name == p2.m_name \u0026amp;\u0026amp; p1.m_age == p2.m_age) { return true; } else { return false; } } void test01() { int a = 10; int b = 20; bool ret = myCompare(a, b); if (ret) { cout \u0026lt;\u0026lt; \u0026#34;a == b\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;a != b\u0026#34; \u0026lt;\u0026lt; endl; } }void test02() { Person p1(\u0026#34;Tom\u0026#34;, 10); Person p2(\u0026#34;Tom\u0026#34;, 10); bool ret = myCompare(p1, p2); if (ret) { cout \u0026lt;\u0026lt; \u0026#34;p1 == p2\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;p1 != p2\u0026#34; \u0026lt;\u0026lt; endl; } } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:\n利用具体化的模板，可以解决自定义类型的通用化I 学习模板并不是为了写模板，而是在STL能够运用系统提供的模板 6.3类模板 6.3.1类模板语法类模板 作用:\n建立一个通用类，类中的成员数据类型可以不员体制定，用一个虚拟的类型来代表。 1 2 template\u0026lt;typename T\u0026gt; 类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; template\u0026lt;class NameType,class AgeType\u0026gt; class Person { public: Person(NameType name, AgeType age) { this-\u0026gt;m_name = name; this-\u0026gt;m_age = age; } void showPerson() { cout \u0026lt;\u0026lt;\u0026#34;name = \u0026#34;\u0026lt;\u0026lt; m_name \u0026lt;\u0026lt;\u0026#34; age = \u0026#34;\u0026lt;\u0026lt; m_age \u0026lt;\u0026lt; endl; } NameType m_name; AgeType m_age; }; void test01() { Person\u0026lt;string, int\u0026gt;p1(\u0026#34;孙悟空\u0026#34;, 999); p1.showPerson(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板\n6.3.2类模板与函数模板区别 类模板与函数楼板区别主要有两点:\n类模板没有自动类型推导的使用方式 类模板在模板参数列表中可以有默认参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; template\u0026lt;class NameType=string,class AgeType=int\u0026gt; class Person { public: Person(NameType name, AgeType age) { this-\u0026gt;m_name = name; this-\u0026gt;m_age = age; } void showPerson() { cout \u0026lt;\u0026lt;\u0026#34;name = \u0026#34;\u0026lt;\u0026lt; m_name \u0026lt;\u0026lt;\u0026#34; age = \u0026#34;\u0026lt;\u0026lt; m_age \u0026lt;\u0026lt; endl; } NameType m_name; AgeType m_age; }; //1. 类模板没有自动类型推导的使用方式 void test01() { //Person p(\u0026#34;孙悟空\u0026#34;, 1000); 无法用自动类型推导 Person\u0026lt;string, int\u0026gt;p1(\u0026#34;孙悟空\u0026#34;, 1000);//只能用显示指定类型 p1.showPerson(); } //2. 类模板在模板参数列表中可以有默认参数 void test02() { Person\u0026lt;\u0026gt; p(\u0026#34;猪八戒\u0026#34;, 999); p.showPerson(); } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 6.3.3类模板中成员函数创建时机 类模板中成员函数和普通类中成员函数创建时机是有区别的:\n普通类中的成员函数一开始就可以创建 类模板中的成员函数在调用时才创建 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class Person1 { public: void showPerson1() { cout \u0026lt;\u0026lt;\u0026#34;Person1 show \u0026#34;\u0026lt;\u0026lt; endl; } }; class Person2 { public: void showPerson1() { cout \u0026lt;\u0026lt; \u0026#34;Person2 show \u0026#34; \u0026lt;\u0026lt; endl; } }; template\u0026lt;class T\u0026gt; class Myclass { public: T obj; //类模板中的成员函数 void func1() { obj.showPerson1(); } void func2() { obj.showPerson2(); } }; void test01() { Myclass\u0026lt;Person1\u0026gt;m; m.func1(); //m.func2(); } int main() { test01(); //test02(); system(\u0026#34;pause\u0026#34;); return 0; } 6.3.4类模板对象做函数参数 学习目标:\n类模板实例化出的对象，向函数传参的方式 —共有三种传入方式:\n指定传入的类型 \u0026mdash;直接显示对象的数据类型 参数模板化 \u0026mdash;将对象中的参数变为模板进行传递 整个类模板化 \u0026mdash;将这个对象类型模板化进行传递 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; // 类模板对象做函数参数 template\u0026lt;class T1,class T2\u0026gt; class Person { public: Person(T1 name, T2 age) { this-\u0026gt;m_name = name; this-\u0026gt;m_age = age; } void showPerson() { cout \u0026lt;\u0026lt; \u0026#34;name = \u0026#34; \u0026lt;\u0026lt;this-\u0026gt; m_name \u0026lt;\u0026lt; \u0026#34; age = \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_age \u0026lt;\u0026lt; endl; } T1 m_name; T2 m_age; }; //1、指定传入类型 void printPerson1(Person\u0026lt;string, int\u0026gt;\u0026amp;p) { p.showPerson(); } void test01() { Person\u0026lt;string, int\u0026gt;p(\u0026#34;孙悟空\u0026#34;, 100); printPerson1(p); } //2、参数模板化 template\u0026lt;class T1,class T2\u0026gt; void printPerson2(Person\u0026lt;T1,T2\u0026gt;\u0026amp;p) { p.showPerson(); cout \u0026lt;\u0026lt; \u0026#34;T1的类型为：\u0026#34; \u0026lt;\u0026lt; typeid(T1).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;T2的类型为：\u0026#34; \u0026lt;\u0026lt; typeid(T2).name() \u0026lt;\u0026lt; endl; } void test02() { Person\u0026lt;string, int\u0026gt;p(\u0026#34;猪八戒\u0026#34;, 90); printPerson2(p); } //3、整个类模板化 template\u0026lt;class T\u0026gt; void printPerson3(T \u0026amp;p) { p.showPerson(); cout \u0026lt;\u0026lt; \u0026#34;T1的类型为：\u0026#34; \u0026lt;\u0026lt; typeid(T).name() \u0026lt;\u0026lt; endl; } void test03() { Person\u0026lt;string, int\u0026gt;p(\u0026#34;唐僧\u0026#34;, 30); printPerson3(p); } int main() { //test01(); //test02(); test03(); system(\u0026#34;pause\u0026#34;); return 0; } 6.3.5类模板与继承 当类模板碰到继承时，需要注意一下几点:\n当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型 如果不指定，编译器无法给子类分配内存 如果想灵活指定出父类中T的类型，子类也需变为类模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; template\u0026lt;class T\u0026gt; class Base { public: T m; }; //class Son :public Base//错误，必须知道父类中的T类型，才能继承给子类 class Son :public Base\u0026lt;int\u0026gt; { }; void test01() { Son s1; } //如果想灵活指定父类中T类型，子类也需要变类模板 template\u0026lt;class T1,class T2\u0026gt; class Son2 :public Base\u0026lt;T2\u0026gt; { public: Son2() { cout \u0026lt;\u0026lt; \u0026#34;T1的类型为：\u0026#34; \u0026lt;\u0026lt; typeid(T1).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;T2的类型为：\u0026#34; \u0026lt;\u0026lt; typeid(T2).name()\u0026lt;\u0026lt; endl; } T1 obj; }; void test02() { Son2\u0026lt;int, char\u0026gt;S2; } int main() { test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 6.3.6类模板成员函数类外实现 学习目标:能够掌握类模板中的成员函数类外实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; template\u0026lt;class T1,class T2\u0026gt; class Person { public: Person(T1 name, T2 age); void showPerson(); T1 m_name; T2 m_age; }; //构造函数类外实现 template\u0026lt;class T1,class T2\u0026gt; Person\u0026lt;T1, T2\u0026gt;::Person(T1 name, T2 age) { this-\u0026gt;m_name = name; this-\u0026gt;m_age = age; } template\u0026lt;class T1, class T2\u0026gt; void Person\u0026lt;T1,T2\u0026gt;::showPerson() { cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_age \u0026lt;\u0026lt; endl; } void test01() { Person\u0026lt;string, int\u0026gt;p(\u0026#34;tom\u0026#34;, 20); p.showPerson(); } int main() { test01(); //test02(); system(\u0026#34;pause\u0026#34;); return 0; } 6.3.7类模板分文件编写 学习目标:\n掌握类模板成员函数分文件编写产生的问题以及解决方式 问题:\n类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到 解决:\n解决方式1∶直接包含.cpp源文件 解决方式2∶将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制 main.cpp:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; //第一种解决方式，直接包含 源文件 //#include\u0026#34;person.cpp\u0026#34; //第二种解决方法，将.h和.cpp中的内容写到一起，将后缀名改为.hpp文件 #include\u0026#34;person.hpp\u0026#34; void test01() { Person\u0026lt;string, int\u0026gt;p(\u0026#34;tom\u0026#34;, 20); p.showPerson(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } person.hpp:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #pragma once #include\u0026lt;iostream\u0026gt; using namespace std; template\u0026lt;class T1, class T2\u0026gt; class Person { public: Person(T1 name, T2 age); void showPerson(); T1 m_name; T2 m_age; }; template\u0026lt;class T1, class T2\u0026gt; Person\u0026lt;T1, T2\u0026gt;::Person(T1 name, T2 age) { this-\u0026gt;m_name = name; this-\u0026gt;m_age = age; } template\u0026lt;class T1, class T2\u0026gt; void Person\u0026lt;T1, T2\u0026gt;::showPerson() { cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;m_age \u0026lt;\u0026lt; endl; } 6.3.8类模板与友元 学习目标:\n掌握类模板配合友元函数的类内和类外实现 全局函数类内实现-直接在类内声明友元即可 全局函数类外实现–需要提前让编译器知道全局函数的存在\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; template\u0026lt;class T1, class T2\u0026gt; class Person; //通过全局函数 打印Person信息 template\u0026lt;class T1, class T2\u0026gt; void printPerson2(Person\u0026lt;T1, T2\u0026gt;p) { cout \u0026lt;\u0026lt; \u0026#34;类外实现---姓名： \u0026#34; \u0026lt;\u0026lt; p.m_name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; p.m_age \u0026lt;\u0026lt; endl; } template\u0026lt;class T1, class T2\u0026gt; class Person { //全局函数 类内实现 friend void printPerson(Person\u0026lt;T1, T2\u0026gt;p) { cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; p.m_name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; p.m_age \u0026lt;\u0026lt; endl; } //全局函数 类外实现 //加空模板参数列表 // 如果全局函数是类外实现，需要让编译器提前知道这个函数的存在 friend void printPerson2\u0026lt;\u0026gt;(Person\u0026lt;T1, T2\u0026gt;p); public: Person(T1 name, T2 age); private: T1 m_name; T2 m_age; }; template\u0026lt;class T1, class T2\u0026gt; Person\u0026lt;T1, T2\u0026gt;::Person(T1 name, T2 age) { this-\u0026gt;m_name = name; this-\u0026gt;m_age = age; } //全局函数在类内实现 void test01() { Person\u0026lt;string, int\u0026gt;p(\u0026#34;tom\u0026#34;, 20); printPerson(p); } //全局函数在类外实现 void test02() { Person\u0026lt;string, int\u0026gt;p2(\u0026#34;jerry\u0026#34;, 20); printPerson2(p2); } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 6.3.9类模板案例 案例描述:实现一个通用的数组类，要求如下:\n可以对内置数据类型以及自定义数据类型的数据进行存储· 将数组中的数据存储到堆区 构造函数中可以传入数组的容量 提供对应的拷贝构造函数以及operator=防止浅拷贝问题 提供尾插法和尾删法对数组中的数据进行增加和册除可以 通过下标的方式访问数组中的元素 可以获取数组中当前元素个数和数组的容量 main.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; #include\u0026#34;MyArray.hpp\u0026#34; void printIntArray(MyArray\u0026lt;int\u0026gt;\u0026amp; arr) { for (int i = 0; i \u0026lt; arr.getSize(); i++) { cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; endl; } } void test01() { MyArray\u0026lt;int\u0026gt;arr1(5); //MyArray\u0026lt;int\u0026gt;arr2(arr1); //MyArray\u0026lt;int\u0026gt;arr3(100); //arr3 = arr1; for (int i = 0; i \u0026lt; 5; i++) { arr1.Push_Back(i); } cout \u0026lt;\u0026lt; \u0026#34;arr1的打印输出为： \u0026#34; \u0026lt;\u0026lt; endl; printIntArray(arr1); cout \u0026lt;\u0026lt; \u0026#34;arr1的容量为： \u0026#34; \u0026lt;\u0026lt; arr1.getCapacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;arr1的大小为： \u0026#34; \u0026lt;\u0026lt; arr1.getSize() \u0026lt;\u0026lt; endl; MyArray\u0026lt;int\u0026gt;arr2(arr1); //尾删 arr2.Pop_Back(); printIntArray(arr2); cout \u0026lt;\u0026lt; \u0026#34;arr2的容量为： \u0026#34; \u0026lt;\u0026lt; arr2.getCapacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;arr2的大小为： \u0026#34; \u0026lt;\u0026lt; arr2.getSize() \u0026lt;\u0026lt; endl; } //测试自定义数据类型 class Person { public: Person() {}; Person(string name,int age) { this-\u0026gt;m_name = name; this-\u0026gt;m_age = age; }; string m_name; int m_age; }; void printPersonArray(MyArray\u0026lt;Person\u0026gt;\u0026amp; arr) { for (int i = 0; i \u0026lt; arr.getSize(); i++) { cout \u0026lt;\u0026lt; arr[i].m_name \u0026lt;\u0026lt; arr[i].m_age \u0026lt;\u0026lt; endl; } } void test02() { MyArray\u0026lt;Person\u0026gt; arr(10); Person p1(\u0026#34;孙悟空\u0026#34;, 999); Person p2(\u0026#34;韩信\u0026#34;, 30); Person p3(\u0026#34;妲己\u0026#34;, 25); Person p4(\u0026#34;赵云\u0026#34;, 20); Person p5(\u0026#34;安其拉\u0026#34;, 27); arr.Push_Back(p1); arr.Push_Back(p2); arr.Push_Back(p3); arr.Push_Back(p4); arr.Push_Back(p5); printPersonArray(arr); } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } MyArray.hpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 #pragma once #include\u0026lt;iostream\u0026gt; using namespace std; template\u0026lt;class T\u0026gt; class MyArray { public: MyArray(int capacity) { //cout \u0026lt;\u0026lt; \u0026#34;MyArray有参构造调用\u0026#34; \u0026lt;\u0026lt; endl; this-\u0026gt;m_capacity = capacity; this-\u0026gt;m_size = 0; this-\u0026gt;pAddress = new T[this-\u0026gt;m_capacity]; } //拷贝构造 MyArray(const MyArray\u0026amp; arr) { //cout \u0026lt;\u0026lt; \u0026#34;MyArray拷贝构造调用\u0026#34; \u0026lt;\u0026lt; endl; this-\u0026gt;m_capacity = arr.m_capacity; this-\u0026gt;m_size = arr.m_size; //this-\u0026gt;pAddress = arr.pAddress; //深拷贝 this-\u0026gt;pAddress = new T[arr.m_capacity]; //将arr中的数据都拷贝过来 for (int i = 0; i \u0026lt; this-\u0026gt;m_size; i++) { this-\u0026gt;pAddress[i] = arr.pAddress[i]; } } //operator = 防止浅拷贝问题 a=b=c MyArray\u0026amp; operator=(const MyArray\u0026amp; arr) { //cout \u0026lt;\u0026lt; \u0026#34;MyArray的operator=调用\u0026#34; \u0026lt;\u0026lt; endl; //先判断原来堆区是否有数据，如果有先释放 if (this-\u0026gt;pAddress != NULL) { delete[] this-\u0026gt;pAddress; this-\u0026gt;pAddress = NULL; this-\u0026gt;m_capacity = 0; this-\u0026gt;m_size = 0; } //深拷贝 this-\u0026gt;m_capacity = arr.m_capacity; this-\u0026gt;m_size = arr.m_size; this-\u0026gt;pAddress = new T[arr.m_capacity]; //将arr中的数据都拷贝过来 for (int i = 0; i \u0026lt; this-\u0026gt;m_size; i++) { this-\u0026gt;pAddress[i] = arr.pAddress[i]; } return *this; } ~MyArray() { //cout \u0026lt;\u0026lt; \u0026#34;MyArray析构函数调用\u0026#34; \u0026lt;\u0026lt; endl; if (this-\u0026gt;pAddress != NULL) { delete[] this-\u0026gt;pAddress; this-\u0026gt;pAddress = NULL; } } //尾插法 void Push_Back(const T \u0026amp; val) { if (this-\u0026gt;m_capacity == this-\u0026gt;m_size) { return; } this-\u0026gt;pAddress[this-\u0026gt;m_size] = val; this-\u0026gt;m_size++; } //尾删法 void Pop_Back() { if (this-\u0026gt;m_size == 0) { return; } this-\u0026gt;m_size--; } //通过下标方式访问数组中的元素arr[0] = 100 T\u0026amp; operator[](int index) { return this-\u0026gt;pAddress[index]; } //返回数组容量 int getCapacity() { return this-\u0026gt;m_capacity; } //返回数组大小 int getSize() { return this-\u0026gt;m_size; } private: T * pAddress;//指针指向堆区开辟的真实数组 int m_capacity;//数组容量 int m_size;//数组大小 }; 2.STL初识 2.1 STL的诞生 长久以来，软件界一直希望建立—种可重复利用的东西 C++的面向对象和泛型编程思想，目的就是复用性的提升 大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作 为了建立数据结构和算法的一套标准,诞生了STL 2.2 STL基本概念 STL(Standard Template Library,标准模板库) STL从广义上分为:容器(container)算法(algorithm)迭代器(iterator)。 容器和算法之间通过迭代器进行无缝连接。 STL几乎所有的代码都采用了模板类或者模板函教 2.3 STL六大组件 STL大体分为六大组件，分别是:容器、算法、迭代器、仿函数、适配器(配接器)、空间配置器\n容器:各种数据结构，如vector、list.deque、set、map等,用来存放数据。 算法:各种常用的算法，如sort、find、copy、for_each等 迭代器:扮演了容器与算法之间的胶合剂。 仿函故:行为类似函数。可作为算法的某种策略。 适配器:—种用来修饰容器或者仿函教或迭代器接口的东西。 空间配置器:负责空间的配置与管理。 2.4 STL中容器、算法、迭代器 容器:置物之所也\nSTL容器就是将运用最广泛的一些数据结构实现出来\n常用的数据结构:数组,链表,树,栈,队列,集合,映射表 等\n这些容器分为序列式容器和关联式容器两种:\n序列式容器:强调值的排序，序列式容器中的每个元素均有固定的位置。\n关联式容器:二叉树结构，各元素之间没有严格的物理上的顺序关系\n算法:问题之解法也 有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)\n算法分为:质变算法和非质变算法。\n质变算法:是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等\n非质变算法:是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等\n迭代器种类\n常用的容器中迭代器种类为双向迭代器,和随机访问迭代器\n2.5容器算法迭代器初识 了解STL中容器、.算法、迭代器概念之后，我们利用代码感受STL的魅力\nSTL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器\n2.5.1 vector存放内置数据类型 容器:\tvector 算法:\tfor_each 迭代器:\tvector\u0026lt;int\u0026gt;: :iterator\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; void myPrint(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl; } //vector容器存放内置数据类型 void test01() { //创建了一个vector容器，数组 vector\u0026lt;int\u0026gt; v; //向容器中插入数据 v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); ////通过迭代器访问容器中的数据 //vector\u0026lt;int\u0026gt;::iterator itBegin = v.begin();//起始迭代器 指向容器中第一个元素 //vector\u0026lt;int\u0026gt;::iterator itEnd = v.end();//结束迭代器 指向容器中最后一个元素的下一个位置 ////第一种遍历方式 //while (itBegin != itEnd) //{ //\tcout \u0026lt;\u0026lt; *itBegin \u0026lt;\u0026lt; endl; //\titBegin++; //} //第二种遍历方式 /*for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; }*/ //第三种遍历方式 利用STL提供遍历算法 for_each(v.begin(), v.end(), myPrint); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 2.5.2 vector存放自定义数据类型 学习目标:vector中存放自定义数据类型，并打印输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;string\u0026gt; class Person { public: Person(string name, int age) { this-\u0026gt;m_name = name; this-\u0026gt;m_age = age; } string m_name; int m_age; }; void test01() { vector\u0026lt;Person\u0026gt;v; Person p1(\u0026#34;aaa\u0026#34;, 10); Person p2(\u0026#34;bbb\u0026#34;, 20); Person p3(\u0026#34;ccc\u0026#34;, 30); Person p4(\u0026#34;ddd\u0026#34;, 40); Person p5(\u0026#34;eee\u0026#34;, 50); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); for (vector\u0026lt;Person\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { //cout \u0026lt;\u0026lt; (*it).m_name \u0026lt;\u0026lt; (*it).m_age \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; it-\u0026gt;m_name \u0026lt;\u0026lt; it-\u0026gt;m_age \u0026lt;\u0026lt; endl; } } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 2.5.3 vector容器嵌套容器 学习目标:容器中嵌套宕器，我们将所有数据进行遍历输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;string\u0026gt; void test01() { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;v; vector\u0026lt;int\u0026gt;v1; vector\u0026lt;int\u0026gt;v2; vector\u0026lt;int\u0026gt;v3; vector\u0026lt;int\u0026gt;v4; for (int i = 0; i \u0026lt; 4; i++) { v1.push_back(i + 1); v2.push_back(i + 2); v3.push_back(i + 3); v4.push_back(i + 4); } v.push_back(v1); v.push_back(v2); v.push_back(v3); v.push_back(v4); for (vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { for (vector\u0026lt;int\u0026gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) { cout \u0026lt;\u0026lt; *vit \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 3.STL-常用容器 3.1 string容器 3.1.1 string基本概念 本质:\nstring是C++风格的字符串，而string本质上是一个类 string和char区别:\nchar*是一个指针 string是一个类，类内部封装了char**，管理这个字符串，是一个char*型的容器。 特点: string类内部封装了很多成员方法\n例如:查找find，拷贝copy，删除delete替换replace，插入insert\nstring管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责\n3.1.2 string构造函数 构造函数原型:\nstring();\t//创建一个空的字符串例如: string str; string(const char* s);//使用字符串s初始化 string(const string\u0026amp; str);//使用一个string对象初始化另一个string对象 string(int n, char c);//使用n个字符c初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; // string的构造函数 /* string() ;\t//创建一个空的字符串例如: string str; string(const char* s);\t//使用字符串s初始化 string(const string\u0026amp; str);\t//使用一个string对象初始化另一个string对象 string(int n,char c) ;\t//使用n个字符c初始化 */ void test01() { string s1; //默认构造 const char * str = \u0026#34;hello world\u0026#34;; string s2(str); cout \u0026lt;\u0026lt; \u0026#34;s2 = \u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; string s3(s2); cout \u0026lt;\u0026lt; \u0026#34;s3 = \u0026#34; \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; string s4(10, \u0026#39;a\u0026#39;); cout \u0026lt;\u0026lt; \u0026#34;s4 = \u0026#34; \u0026lt;\u0026lt; s4 \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结: string的多种构造方式没有可比性，灵活使用即可\n3.1.3 string赋值操作 功能描述:\n给string字符串进行赋值 赋值的函数原型:\nstring\u0026amp; operator=(const char* s); //char*类型字符串赋值给当前的字符串 string\u0026amp; operator=(const string \u0026amp;s) ;\t//把字符串s赋给当前的字符串 string\u0026amp; operator=(char c);\t//字符赋值给当前的字符串 string\u0026amp; assign(const char *s);\t//把字符串s赋给当前的字符串 string\u0026amp; assign(const char *s, int n);\t//把字符串s的前n个字符赋给当前的字符串 string\u0026amp; assign(const string \u0026amp;s) ;\t//把字符串s赋给当前字符串 string\u0026amp; assign(int n, char c);\t//用n个字符c赋给当前字符串 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; // string的幅值操作 /* string\u0026amp; operator=(const char* s); //char*类型字符串赋值给当前的字符串 string\u0026amp; operator=(const string \u0026amp;s);\t//把字符串s赋给当前的字符串 string\u0026amp; operator=(char c);\t//字符赋值给当前的字符串 string\u0026amp; assign(const char *s);\t//把字符串s赋给当前的字符串 string\u0026amp; assign(const char *s, int n);\t//把字符串s的前n个字符赋给当前的字符串 string\u0026amp; assign(const string \u0026amp;s);\t//把字符串s赋给当前字符串 string\u0026amp; assign(int n, char c);\t//用n个字符c赋给当前字符串 */ void test01() { string str1; str1 = \u0026#34;hello world\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; string str2; str2 = str1; cout \u0026lt;\u0026lt; \u0026#34;str2 = \u0026#34; \u0026lt;\u0026lt; str2 \u0026lt;\u0026lt; endl; string str3; str3 = \u0026#39;a\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;str3 = \u0026#34; \u0026lt;\u0026lt; str3 \u0026lt;\u0026lt; endl; string str4; str4.assign(\u0026#34;hello C++\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;str4 = \u0026#34; \u0026lt;\u0026lt; str4 \u0026lt;\u0026lt; endl; string str5; str5.assign(\u0026#34;hello C++\u0026#34;,5); cout \u0026lt;\u0026lt; \u0026#34;str5 = \u0026#34; \u0026lt;\u0026lt; str5 \u0026lt;\u0026lt; endl; string str6; str6.assign(str5); cout \u0026lt;\u0026lt; \u0026#34;str6 = \u0026#34; \u0026lt;\u0026lt; str6 \u0026lt;\u0026lt; endl; string str7; str7.assign(10, \u0026#39;w\u0026#39;); cout \u0026lt;\u0026lt; \u0026#34;str7 = \u0026#34; \u0026lt;\u0026lt; str7 \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 3.1.4 string字符串拼接 功能描述:\n实现在字符串末尾拼接字符串 函数原型:\nstring\u0026amp; operator+=( const char* str);\t//重载+=操作符\nstring\u0026amp; operator+=( const char c);\t//重载+=操作符\nstring\u0026amp; operator+=( const string\u0026amp; str);\t//重载+=操作符\nstring\u0026amp; append(const char *s );\t//把字符串s连接到当前字符串结尾\nstring\u0026amp; append(const char *s, int n);\t//把字符串s的前n个字符连接到当前字符串结尾\nstring\u0026amp; append(const string \u0026amp;s ) ;\t//同operator+=(const string\u0026amp; str)\nstring\u0026amp; append(const string \u0026amp;s，int pos,int n);//字符串s中从pos开始的n个字符连接到字符串结尾\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; // string的幅值操作 /* string\u0026amp; operator+=( const char* str);\t//重载+=操作符 string\u0026amp; operator+=( const char c);\t//重载+=操作符 string\u0026amp; operator+=( const string\u0026amp; str);\t//重载+=操作符 string\u0026amp; append(const char *s );\t//把字符串s连接到当前字符串结尾 string\u0026amp; append(const char *s, int n);\t//把字符串s的前n个字符连接到当前字符串结尾 string\u0026amp; append(const string \u0026amp;s ) ;\t//同operator+=(const string\u0026amp; str) string\u0026amp; append(const string \u0026amp;s，int pos,int n);\t//字符串s中从pos开始的n个字符连接到字符串结尾 */ void test01() { string str1 = \u0026#34;我\u0026#34;; str1 += \u0026#34;爱学习\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; str1 += \u0026#39;:\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; string str2=\u0026#34;C++ python\u0026#34;; str1 += str2; cout \u0026lt;\u0026lt; \u0026#34;str1 = \u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; string str3 = \u0026#34;I\u0026#34;; str3.append(\u0026#34; love \u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;str3 =\u0026#34; \u0026lt;\u0026lt; str3 \u0026lt;\u0026lt; endl; str3.append(\u0026#34;game abcde\u0026#34;,4); cout \u0026lt;\u0026lt; \u0026#34;str3 =\u0026#34; \u0026lt;\u0026lt; str3 \u0026lt;\u0026lt; endl; //str3.append(str2); cout \u0026lt;\u0026lt; \u0026#34;str3 = \u0026#34; \u0026lt;\u0026lt; str3 \u0026lt;\u0026lt; endl; str3.append(str2,4,6);//从第4个截取6个 cout \u0026lt;\u0026lt; \u0026#34;str3 = \u0026#34; \u0026lt;\u0026lt; str3 \u0026lt;\u0026lt; endl;\t} int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 3.1.5 string查找和替换 功能描述:\n查找:查找指定字符心是否存在 替换:在指定的位置替换字符串 函数原型:\nint find(const string\u0026amp; str, int pos = 0) const;\t//查找str第一次出现位置,从pos开始查找 int find(const char* s , int pos - e) const;\t//查找s第一次出现位置,从pos开始查找 int find(const char* s , int pos, int n) const;\t//从pos位置查找s的前n个字符第一次位置 int find(const char c, int pos = e) const;\t//查找字符c第一次出现位置 int rfind(const string\u0026amp; str， int pos = npos) const;\t//查找str最后一次位置,从pos开始查找 int rfind(const char* s, int pos = npos) const;\t//查找s最后一次出现位置,从pos开始查找 int rfind(const char* s, int pos， int n) const;\t//从pos查找s的前n个字符最后一次位置 int rfind(const char c, int pos = 0) const;\t//查找字符c最后一次出现位置 string\u0026amp; replace(int pos, int n， const string\u0026amp; str);//替换从pos开始n个字符为字符串str string\u0026amp; replace(int pos， int n,const char* s);\t//替换从pos开始的n个字符为字符串s 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; //字符串查找和替换 //1.查找 void test01() { string str1 = \u0026#34;abcdefgde\u0026#34;; int pos = str1.find(\u0026#34;de\u0026#34;); if (pos == -1) { cout \u0026lt;\u0026lt; \u0026#34;未找到字符串\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到字符串，pos = \u0026#34; \u0026lt;\u0026lt; pos \u0026lt;\u0026lt; endl; } //rfind和find区别 //rfind从右往左查找\tfind从左往右查找 序号都是从左边开始 pos = str1.rfind(\u0026#34;de\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;pos = \u0026#34; \u0026lt;\u0026lt; pos \u0026lt;\u0026lt; endl; } //2.替换 void test02() { string str1 = \u0026#34;abcdefg\u0026#34;; //从1号位置起3个字符替换为\u0026#34;1111\u0026#34; str1.replace(1,3, \u0026#34;1111\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;strl =\u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 3.1.6 string字符串比较 功能描述:\n字符串之间的比较 比较方式:\n字符串比较是按字符的ASC!I码进行对比 = 返回0 ​\t\u0026gt; 返回1\n​ \u0026lt; 返回-1 函数原型:\nint compare( const string \u0026amp;s ) const;\t//与字符串s比较\nint compare( const char *s ) const;\t//与字符串s比较\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; //字符串比较 void test01() { string str1 = \u0026#34;hello\u0026#34;; string str2 = \u0026#34;xello\u0026#34;; if (str1.compare(str2) == 0) { cout \u0026lt;\u0026lt; \u0026#34;str1 等于 str2\u0026#34; \u0026lt;\u0026lt; endl; } else if (str1.compare(str2) \u0026gt; 0) { cout \u0026lt;\u0026lt; \u0026#34;str1 大于 str2\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;str1 小于 str2\u0026#34; \u0026lt;\u0026lt; endl; } } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大\n3.1.7 string字符存取 string中单个字符存取方式有两种\nchar\u0026amp; operator[](int n);\t//通过[]方式取字符 char\u0026amp; at(int n);\t//通过at方法获取字符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; //string字符存取 void test01() { string str = \u0026#34;hello\u0026#34;; //1、通过[]访问单个字符 for (int i = 0; i \u0026lt; str.size(); i++) { cout \u0026lt;\u0026lt; str[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //2、通过at方式访问单个字符 for (int i = 0; i \u0026lt; str.size(); i++) { cout \u0026lt;\u0026lt; str.at(i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //修改单个字符 str[0] = \u0026#39;x\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;str = \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结: string字符串中单个字符存取有两种方式，利用[]或at\n3.1.8 string插入和删除 功能描述:\n对string字符串进行插入和删除字符操作 函数原型:\nstring\u0026amp; insert( int pos, const char* s );\t//插入字符串 string\u0026amp; insert(int pos, const string\u0026amp; str);\t//插入字符串 string\u0026amp; insert(int pos, int n, char c);\t//在指定位置插入n个字符c string\u0026amp; erase(int pos, int n = npos);\t//删除从Pos开始的n个字符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; //字符串 插入和删除 void test01() { string str = \u0026#34;hello\u0026#34;; //插入 str.insert(1, \u0026#34;111\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;str = \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; //删除 str.erase(1, 3); cout \u0026lt;\u0026lt; \u0026#34;str = \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:插入和删除的起始下标都是从0开始\n3.1.9 string子串 功能描述:\n从字符串中获取想要的子串 函数原型:\nstring substr(int pos = 0, int n = npos) const;\t//返回由pos开始的n个字符组成的字符串 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; //string求子串 void test01() { string str = \u0026#34;abcdef\u0026#34;; string subStr=str.substr(1, 3); cout \u0026lt;\u0026lt; \u0026#34;str = \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;subStr = \u0026#34; \u0026lt;\u0026lt; subStr \u0026lt;\u0026lt; endl; } //实用操作 void test02() { string email = \u0026#34;zhangsan@sina.com\u0026#34;; //从邮件地址中获取用户名信息 int pos = email.find(\u0026#39;@\u0026#39;); string user = email.substr(0, pos); cout \u0026lt;\u0026lt; \u0026#34;user = \u0026#34; \u0026lt;\u0026lt; user \u0026lt;\u0026lt; endl; } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 3.2 vector容器 3.2.1 vector基本概念 功能:\nvector数据结构和数组非常相似，也称为单端数组 vector与普通数组区别:\n不同之处在于数组是静态空间，而vector可以动态扩展 动态扩展:\n并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间 vector容器的迭代器是支持随机访问的迭代器 3.22 vector构造函数 功能描述:\n创建vector容器 函数原型:\nvector\u0026lt;T\u0026gt; v;\t//采用模板实现类实现，默认构造函数 vector(v.begin(), v.end()); //将vbegin(), end())区间中的元素拷贝给本身 vector(n,elem);\t//构造函数将n个elem拷贝给本身。 vector( const vector \u0026amp;vec ) ;\t//拷贝构造函数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;vector\u0026gt; void printVector(vector\u0026lt;int\u0026gt;\u0026amp;v) { for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //vector容器构造 void test01() { vector\u0026lt;int\u0026gt;v1;//默认构造 无参构造 for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); } printVector(v1); //通过区间方式进行构造 vector\u0026lt;int\u0026gt;v2(v1.begin(), v1.end()); printVector(v2); //n个elem方式构造 vector\u0026lt;int\u0026gt;v3(10,100); printVector(v3); //拷贝构造 vector\u0026lt;int\u0026gt;v4(v3); printVector(v4); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结: vector的多种构造方式没有可比性，灵活使用即可\n3.2.3 vector赋值操作 功能描述:\n给vector容器进行赋值 函数原型:\nvector\u0026amp; operator=(const vector \u0026amp;vec);\t//重载等号操作符\nassign(beg,end) ;\t//将[beg, end)区间中的数据拷贝赋值给本身。\nassign(n,elem);\t//将n个elem拷贝赋值给本身。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;vector\u0026gt; void printVector(vector\u0026lt;int\u0026gt;\u0026amp;v) { for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //vector赋值 void test01() { vector\u0026lt;int\u0026gt;v1;//默认构造 无参构造 for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); } printVector(v1); // 赋值\toperator= vector \u0026lt;int\u0026gt;v2; v2 = v1; printVector(v2); //assign vector\u0026lt;int\u0026gt;v3; v3.assign(v1.begin(),v1.end()); printVector(v3); //n个elem方式赋值 vector\u0026lt;int\u0026gt;v4; v4.assign(19,100); printVector(v4); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结: vector赋值方式比较简单，使用operator=，或者assign都可以\n3.2.4 vector容量和大小 功能描述:\n对vector容器的容量和大小操作 函数原型:\nempty();\t//判断容器是否为空\ncapacity();\t//容器的容量\nsize( );\t//返回容器中元素的个数\nresize(int num);\t//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。\n​\t//如果容器变短，则末尾超出容器长度的元素被删除。\nresize(int num，elem);\t//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。 //如果容器变短，则末尾超出容器长度的元素被删除\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;vector\u0026gt; void printVector(vector\u0026lt;int\u0026gt;\u0026amp;v) { for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //vector容器的容量和大小操作 void test01() { vector\u0026lt;int\u0026gt;v1;//默认构造 无参构造 for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); } printVector(v1); if (v1.empty())//为真代表容器为空 { cout \u0026lt;\u0026lt; \u0026#34;v1为空\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;v1不为空\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;v1的容量为:\u0026#34; \u0026lt;\u0026lt; v1.capacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;v1的大小为:\u0026#34; \u0026lt;\u0026lt; v1.size() \u0026lt;\u0026lt; endl; } //重新指定大小 v1.resize(15, 100);//利用重载版本，可以指定默认填充值，参数2 printVector(v1);//如果重新指定的比原来长了，默认用0填充新的位置 v1.resize(5); printVector(v1);//如果重新指定的比原来短了，超出部分会删除掉 } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:\n判断是否为空\u0026mdash; empty 返回元素个数\u0026mdash; size 返回容器容量\u0026mdash; capacity 重新指定大小 \u0026mdash; resize 3.2.5 vector插入和删除 功能描述:\n对vector容器进行插入、删除操作 函数原型:\npush_back(ele);\t//尾部插入元素ele\npop_back() ;\t//删除最后一个元素\ninsert(const_iterator pos, ele);\t//迭代器指向位置pos插入元素ele\ninsert(const_iterator pos， int count,ele);//迭代器指向位置pos插入count个元素\neleerase(const_iterator pos);\t//删除迭代器指向的元素\nerase(const_iterator start， const_iterator end);//删除迭代器从start到end之间的元素\nclear();\t//删除容器中所有元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;vector\u0026gt; void printVector(vector\u0026lt;int\u0026gt;\u0026amp;v) { for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //vector容器的容量和大小操作 void test01() { vector\u0026lt;int\u0026gt;v1; //尾插 v1.push_back(10); v1.push_back(20); v1.push_back(30); v1.push_back(40); v1.push_back(50); //遍历 printVector(v1); //尾删 v1.pop_back(); printVector(v1); //插入第一个参数是迭代器 v1.insert(v1.begin(),100) ; printVector(v1); v1.insert(v1.begin(),2,1000); printVector(v1); //删除参数也是迭代器 v1.erase(v1.begin()); printVector(v1); //清空 //v1.erase(v1.begin()，_v1.end() ) ; v1.clear(); printVector(v1); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:\n尾插\u0026mdash; push_back 尾删\u0026mdash; pop_back 插入\u0026mdash; insert(位置迭代器) 删除\u0026mdash; erase(位置迭代器) 清空\u0026mdash; clear 3.2.6 vector数据存取 功能描述:\n对vector中的数据的存取操作 函数原型:\nat(iht idx);\t//返回索引idx所指的数据 operator[];\t//返回索引idx所指的数据 front( );\t//返回容器中第一个数据元素 back();\t//返回容器中最后一个数据元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;vector\u0026gt; void test01() { vector\u0026lt;int\u0026gt;v1; for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); } //利用[]方式访问数组中元素 for (int i = 0; i \u0026lt; v1.size(); i++) { cout \u0026lt;\u0026lt; v1[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //利用at方式访问元素 for (int i = 0; i \u0026lt; v1.size(); i++) { cout \u0026lt;\u0026lt; v1.at(i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //获取第一个元素 cout \u0026lt;\u0026lt; \u0026#34;第一个元素为:\u0026#34; \u0026lt;\u0026lt; v1.front() \u0026lt;\u0026lt; endl; //获取最后一个元素 cout \u0026lt;\u0026lt; \u0026#34;最后一个元素为:\u0026#34; \u0026lt;\u0026lt; v1.back() \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 3.2.7 vector互换容器 功能描述:\n实现两个容器内元素进行互换 函数原型:\nwap(vec);\t//将vec与本身的元素互换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;vector\u0026gt; //vector容器互换 void printVector(vector\u0026lt;int\u0026gt;\u0026amp;v) { for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //基本使用 void test01() { vector\u0026lt;int\u0026gt;v1; for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); } cout \u0026lt;\u0026lt; \u0026#34;交换前： \u0026#34; \u0026lt;\u0026lt; endl; printVector(v1); vector\u0026lt;int\u0026gt;v2; for (int i = 10; i \u0026gt; 0; i--) { v2.push_back(i); } printVector(v2); cout \u0026lt;\u0026lt; \u0026#34;交换后： \u0026#34; \u0026lt;\u0026lt; endl; v1.swap(v2); printVector(v1); printVector(v2); } //2、实际用途 //巧用swap可以收缩内存空间 void test02() { vector\u0026lt;int\u0026gt;v; for (int i = 0; i \u0026lt; 100000; i++) { v.push_back(i); } cout \u0026lt;\u0026lt; \u0026#34;v的容量为:\u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;v的大小为:\u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; v.resize(3);//重新指定大小 cout \u0026lt;\u0026lt; \u0026#34;v的容量为:\u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;v的大小为:\u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; //巧用swap收缩内存 vector\u0026lt;int\u0026gt;(v).swap(v);//用v初始化匿名对象，再交换回v cout \u0026lt;\u0026lt; \u0026#34;v的容量为:\u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;v的大小为:\u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结: swap可以使两个容器互换，可以达到实用的收缩内存效果\n3.2.8 vector预留空间 功能描述:\n减少vector在动态扩展容量时的扩展次数 函数原型:\nreserve(int len); //容器预留len个元素长度，预留位置不初始化，元素不可访问。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;vector\u0026gt; void test01() { vector\u0026lt;int\u0026gt;v; //预留空间 v.reserve(100000); int num = 0;//统计开辟次数 int * p = NULL; for (int i = 0; i \u0026lt; 100000; i++) { v.push_back(i); if (p != \u0026amp;v[0]) { p = \u0026amp;v[0]; num++; } } cout \u0026lt;\u0026lt; \u0026#34;num = \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:如果数据量较大，可以一开始利用reserve预留空间\n3.3 deque容器 3.3.1 deque容器基本概念 功能:\n双端数组，可以对头端进行插入删除操作 deque与vector区别:\nvector对于头部的插入删除效率低，数据量越大，效率越低. deque相对而言，对头部的插入删除速度回比vector快 vector访问元素时的速度会比deque快,这和两者内部实现有关 deque内部工作原理:\ndeque内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间\ndeque容器的迭代器也是支持随机访问的 3.3.2 deque构造函数 功能描述:\ndeque容器构造 函数原型:\ndeque\u0026lt;T\u0026gt; deqT;\t//默认构造形式 deque(beg, end) ;\t//构造函数将[beg, end)区间中的元素拷贝给本身。 deque(n, elem) ;\t//构造函数将n个elem拷贝给本身。 deque(const deque \u0026amp;deq); //拷贝构造函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;deque\u0026gt; void printDeque(const deque\u0026lt;int\u0026gt;\u0026amp;d) //限制只读 { for (deque\u0026lt;int\u0026gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t} cout \u0026lt;\u0026lt; endl; } //deque构造函数 void test01() { deque\u0026lt;int\u0026gt;d1; for (int i = 0; i \u0026lt; 10; i++) { d1.push_back(i); } printDeque(d1); deque\u0026lt;int\u0026gt;d2(d1.begin(), d1.end()); printDeque(d2); deque\u0026lt;int\u0026gt;d3(10,100); printDeque(d3); deque\u0026lt;int\u0026gt;d4(d3); printDeque(d4); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结: deque容器和vector容器的构造方式几乎一致，灵活使用即可\n3.3.3 deque赋值操作 功能描述:\n给deque容器进行赋值 函数原型:\ndeque\u0026amp; operator=(const deque \u0026amp;deq);\t//重载等号操作符 assign(beg,end);\t//将[beg, end)区间中的数据拷贝赋值给本身。 assign(n，elem);\t//将n个elem拷贝赋值给本身。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;deque\u0026gt; void printDeque(const deque\u0026lt;int\u0026gt;\u0026amp;d) //限制只读 { for (deque\u0026lt;int\u0026gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t} cout \u0026lt;\u0026lt; endl; } void test01() { deque\u0026lt;int\u0026gt;d1; for (int i = 0; i \u0026lt; 10; i++) { d1.push_back(i); } printDeque(d1); //operator=赋值 deque\u0026lt;int\u0026gt;d2; d2 = d1; printDeque(d2); //assign赋值 deque\u0026lt;int\u0026gt;d3; d3.assign(d1.begin(),d1.end()); printDeque(d3); deque\u0026lt;int\u0026gt;d4; d4.assign(10, 100); printDeque(d4); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 和vector容器的几乎一致\n3.3.4 deque大小操作 功能描述:\n对deque容器的大小进行操作 函数原型:\ndeque.empty();\t//判断容器是否为空 deque.size();\t//返回容器中元素的个数 deque.resize( num);\t//重新指定容器的长度为num,若容器变长，则以默认值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。 deque.resize(num,elem);\t//重新指定容器的长度为num,若容器变长，则以elem值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;deque\u0026gt; void printDeque(const deque\u0026lt;int\u0026gt;\u0026amp;d) //限制只读 { for (deque\u0026lt;int\u0026gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t} cout \u0026lt;\u0026lt; endl; } //deque容器大小操作 void test01() { deque\u0026lt;int\u0026gt;d1; for (int i = 0; i \u0026lt; 10; i++) { d1.push_back(i); } printDeque(d1); if (d1.empty()) { cout \u0026lt;\u0026lt; \u0026#34;d1为空\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;d1不为空\u0026#34;\u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;d1的大小为:\u0026#34; \u0026lt;\u0026lt; d1.size() \u0026lt;\u0026lt; endl; //deque容器没有容量概念 } // 重新指定大小 //d1.resize(15); d1.resize(15,1); printDeque(d1); d1.resize(5); printDeque(d1); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 3.3.5 deque插入和删除 功能描述:\n向deque容器中插入和删除数据 函数原型:\n两端插入操作:\npush_back(elem);\t//在容器尾部添加一个数据 push_front(elem) ;\t//在容器头部插入一个数据 pop_back();\t//删除容器最后一个数据 pop_front();\t//删除容器第一个数据 指定位置操作:\ninsert(pos,elem);\t//在pos位置插入一个elem元素的拷贝，返回新数据的位置。 insert( pos,n,elem);\t//在pos位置插入n个elem数据，无返回值。 insert(pos,beg,end);\t//在pos位置插入[beg,end)区间的数据，无返回值。 clear();\t//清空容器的所有数据 erase(beg,end) ;\t//删除[beg,end)区间的数据，返回下一个数据的位置。 erase(pos);\t//删除pos位置的数据，返回下一个数据的位置。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;deque\u0026gt; void printDeque(const deque\u0026lt;int\u0026gt;\u0026amp;d) //限制只读 { for (deque\u0026lt;int\u0026gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t} cout \u0026lt;\u0026lt; endl; } //deque容器插入和删除 void test01() { deque\u0026lt;int\u0026gt;d1; //尾插 d1.push_back(10); d1.push_back(20); //头插 d1.push_front(100); d1.push_front(200); // 200 100 10 20 printDeque(d1); //尾删 d1.pop_back(); //200 100 10 printDeque(d1) ; //头删 d1.pop_front(); // 100 10 printDeque(d1); } void test02() { deque\u0026lt;int\u0026gt;d1; d1.push_back(10); d1.push_back(20); d1.push_front(100); d1.push_front(200); printDeque(d1); //insert插入 d1.insert(d1.begin(),1000); //1000 200 100 10 20 printDeque(d1); d1.insert(d1.begin(),2,10000); // 10000 10000 1000 200 100 10 20 printDeque(d1) ; //按照区间进行插入 deque\u0026lt;int\u0026gt;d2; d2.push_back(1); d2.push_back(2); d2.push_back(3); d1.insert(d1.begin(),d2.begin(), d2.end()); // 1 2 3 10000 10000 1000 200 100 10 20 printDeque(d1); } void test03() { deque\u0026lt;int\u0026gt;d1; d1.push_back(10); d1.push_back(20); d1.push_front(100); d1.push_front(200); printDeque(d1); //删除 deque\u0026lt;int\u0026gt;::iterator it = d1.begin(); it++; d1.erase(it); // 200 10 20 printDeque (d1) ; //按区间方式删除 //d1.erase(d1.begin(),d1.end()); //清空 d1.clear(); printDeque(d1); } int main() { //test01(); //test02(); test03(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:\n插入和删除提供的位置是迭代器!\n尾插\u0026mdash; push_back 尾删\u0026mdash; pop_back 头插\u0026mdash; push_front 头删\u0026mdash; pop_front 3.3.6 deque数据存取 功能描述:\n对deque中的数据的存取操作\n函数原型:\nat(int idx);\t//返回索引idx所指的数据 operator[];\t//返回索引idx所指的数据 front();\t//返回容器中第一个数据元素 back(); //返回容器中最后一个数据元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;deque\u0026gt; void test01() { deque\u0026lt;int\u0026gt;d1; d1.push_back(10); d1.push_back(20); d1.push_back(30); d1.push_front(100); d1.push_front(200); d1.push_front(300); //通过[]方式访问元素 // 300 200 100 10 20 30 for (int i = 0; i \u0026lt; d1.size(); i++) { cout \u0026lt;\u0026lt; d1[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; ////通过at方式 for (int i = 0; i \u0026lt; d1.size(); i++) { cout \u0026lt;\u0026lt; d1.at(i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;第一个元素为: \u0026#34;\u0026lt;\u0026lt; d1.front() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;最后一个元素: \u0026#34; \u0026lt;\u0026lt; d1.back() \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 3.3.7 deque排序 功能描述:\n利用算法实现对deque容器进行排序 算法:\nsort(iterator beg, iterator end) //对beg和end区间内元素进行排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;deque\u0026gt; #include\u0026lt;algorithm\u0026gt; void printDeque(const deque\u0026lt;int\u0026gt;\u0026amp;d) { for (deque\u0026lt;int\u0026gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //deque容器排序 void test01() { deque\u0026lt;int\u0026gt;d; d.push_back(10); d.push_back(20); d.push_back(30); d.push_front(100); d.push_front(200); d.push_front(300); //300 200 100 10 20 30 printDeque(d); //排序 升序 //对于支持随机访问的迭代器的容器，都可以利用sort算法直接对其进行排序 //vector容器也可以利用sort进行排序 sort(d.begin(),d.end()); cout \u0026lt;\u0026lt; \u0026#34;排序后:\u0026#34; \u0026lt;\u0026lt; endl; printDeque(d); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结: sort算法非常实用，使用时包含头文件algorithm即可\n3.5 stack容器 3.5.1 stack基本概念 概念: stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口\n栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为\n先进后出\n栈可以判断容器是否为空吗?\t可以\tempty\n栈可以返回元素个数吗?\t可以\tsize\n3.5.2 stack常用接口 功能描述:栈容器常用的对外接口\n构造函数︰\nstack\u0026lt;T\u0026gt;stk;\t//stack采用模板类实现, stack对象的默认构造形式 stack(const stack \u0026amp;stk);\t//拷贝构造函数 贼值操作:\nstack\u0026amp; operator=(const stack \u0026amp;stk);\t//重载等号操作符 数据存取:\npush(elem);\t//向栈顶添加元素 pop();\t//从栈顶移除第一个元素 top();\t//返回栈顶元素 大小操作:\nempty();\t//判断堆栈是否为空 size();\t//返回栈的大小 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;stack\u0026gt; //栈stack容器 void test01() { //特点:符合先进后出数据结构 stack\u0026lt;int\u0026gt;s; //入栈 s.push(10); s.push(20); s.push(30); s.push(40); cout \u0026lt;\u0026lt; \u0026#34;栈的大小： \u0026#34; \u0026lt;\u0026lt; s.size() \u0026lt;\u0026lt; endl; //只要栈不为空，查看栈顶，并且执行出栈操作 while (!s.empty()) { //查看栈顶元素 cout \u0026lt;\u0026lt; \u0026#34;栈顶元素为:\u0026#34; \u0026lt;\u0026lt; s.top() \u0026lt;\u0026lt; endl; s.pop(); } cout \u0026lt;\u0026lt; \u0026#34;栈的大小： \u0026#34; \u0026lt;\u0026lt; s.size() \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:\n入栈\u0026mdash; push 出栈\u0026mdash; pop 返回栈顶\u0026mdash; top 判断栈是否为空\u0026mdash; empty 返回栈大小\u0026mdash; size 3.6 queue容器 3.6.1 queue基本概念 **概念:**Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口\n队列容器允许从一端新增元素，从另—端移除元素\n队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为\n队列中进数据称为\u0026mdash;入队push\n队列中出数据称为\u0026mdash;出队pop\n3.6.2 queue常用接口 功能描述:栈容器常用的对外接口\n构造函数:\nqueue\u0026lt;T\u0026gt; que;\t//queue采用模板类实现,queue对象的默认构造形式 queue(const queue \u0026amp;que);\t//拷贝构造函数 赋值操作:\nqueue\u0026amp; operator=(const queue \u0026amp;que);\t//重载等号操作符 数据存取:\npush(elem);\t//往队尾添加元素 pop();\t//从队头移除第一个元素 back();\t//返回最后一个元素 front();\t//返回第一个元素 总结:\n入队\u0026mdash; push 出队\u0026mdash; pop 返回队头元素\u0026mdash; front 返回队尾元素\u0026mdash; back 判断队是否为空\u0026mdash; empty 返回队列大小\u0026mdash; size 3.7 list容器 3.7.1 list基本概念 功能：将数据进行链式存储\n链表(list)是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的\n链表的组成:链表由一系列结点组成\n结点的组成:一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域\nSTL中的链表是一个双向循环链表\n**优点:**可以对任意位置进行快速插入或删除元素\n**缺点:**容器遍历速度，没有数组快\n占用空间比数组大\n由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器\nlist的优点:\n采用动态存储分配，不会造成内存浪费和溢出 链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素 list的缺点:\n链表灵活，但是空间(指针域)和时间(遍历）额外耗费较大 List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的\n总结:STL中List和vector是两个最常被使用的容器，各有优缺点\n3.7.2 list构造函数 功能描述:\n创建list容器 函数原型:\nlist\u0026lt;T\u0026gt;lst;\t//list采用采用模板类实现,对象的默认构造形式: list(beg,end);\t//构造函数将[beg, end)区间中的元素拷贝给本身。 list(n,elem);\t//构造函数将n个elem拷贝给本身。 list(const list \u0026amp;lst);\t//拷贝构造函数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;list\u0026gt; void printList(const list\u0026lt;int\u0026gt;\u0026amp;L) { for (list\u0026lt;int\u0026gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t} cout \u0026lt;\u0026lt; endl; } void test01() { //创建list容器 list\u0026lt;int\u0026gt;L1;//默认构造 //添加数据 L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); //遍历容器 printList(L1); // 区间方式构造 list\u0026lt;int\u0026gt;L2(L1.begin(), L1.end()); printList(L2); //拷贝构造 list\u0026lt;int\u0026gt;L3(L2); printList(L3); //n个elem list\u0026lt;int\u0026gt;L4(10,1000); printList(L4); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:list构造方式同其他几个STL常用容器，熟练掌握即可\n3.7.3 list赋值和交换 功能描述:\n给list容器进行赋值，以及交换list容器 函数原型:\nassign(beg, end);\t//将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem);\t//将n个elem拷贝赋值给本身。 list\u0026amp; operator=(const list \u0026amp;lst);\t//重载等号操作符 swap(lst);\t//将lst与本身的元素互换。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;list\u0026gt; void printList(const list\u0026lt;int\u0026gt;\u0026amp;L) { for (list\u0026lt;int\u0026gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t} cout \u0026lt;\u0026lt; endl; } void test01() { //创建list容器 list\u0026lt;int\u0026gt;L1;//默认构造 //添加数据 L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); //遍历容器 printList(L1); list\u0026lt;int\u0026gt;L2; L2 = L1; // operator=赋值 printList(L2); list\u0026lt;int\u0026gt;L3; L3.assign(L2.begin(),L2.end()); printList(L3); list\u0026lt;int\u0026gt;L4; L4.assign(10,100); printList(L4); } void test02() { list\u0026lt;int\u0026gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); list\u0026lt;int\u0026gt;L2; L2.assign(10, 100); cout \u0026lt;\u0026lt; \u0026#34;交换前: \u0026#34;\u0026lt;\u0026lt;endl; printList(L1); printList(L2); L1.swap(L2); cout \u0026lt;\u0026lt; \u0026#34;交换后: \u0026#34; \u0026lt;\u0026lt;endl; printList(L1); printList(L2); } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 3.7.4 list大小操作 功能描述:\n对list容器的大小进行操作 函数原型:\nsize() ;\t//返回容器中元素的个数 empty( );\t//判断容器是否为空 resize(num ) ;\t//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。 resize(num，elem);\t//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。 empty( );\t//判断容器是否为空 resize(num ) ;\t//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。 resize(num，elem);\t//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;list\u0026gt; void printList(const list\u0026lt;int\u0026gt;\u0026amp;L) { for (list\u0026lt;int\u0026gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t} cout \u0026lt;\u0026lt; endl; } void test01() { //创建list容器 list\u0026lt;int\u0026gt;L1;//默认构造 //添加数据 L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); if (L1.empty()) { cout \u0026lt;\u0026lt; \u0026#34;L1为空\u0026#34;\u0026lt;\u0026lt;endl; } else { cout \u0026lt;\u0026lt; \u0026#34;L1不为空\u0026#34;\u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;L1的大小为:\u0026#34; \u0026lt;\u0026lt; L1.size() \u0026lt;\u0026lt; endl; } //重新指定大小L1.resize(10);printList(L1); L1.resize(2); printList(L1); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 3.7.5 list插入和删除 功能描述:\n对list容器进行数据的插入和删除 函数原型:\npush_back(elem);//在容器尾部加入一个元素 pop_back();//删除容器中最后一个元素. push_front(elem);//在容器开头插入一个元素 pop_front();/l从容器开头移除第一个元素 insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。 insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。 insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。 clear();//移除容器的所有数据 erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。 erase(pos);//删除pos位置的数据，返回下一个数据的位置。 remove(elem);//删除容器中所有与elem值匹配的元素。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;list\u0026gt; void printList(const list\u0026lt;int\u0026gt;\u0026amp;L) { for (list\u0026lt;int\u0026gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t} cout \u0026lt;\u0026lt; endl; } void test01() { list\u0026lt;int\u0026gt;L; //尾插 L.push_back(10); L.push_back(20); L.push_back(30); //头插 L.push_front(100); L.push_front(200); L.push_front(300); printList(L); //尾删 L.pop_back(); printList(L); //头删 L.pop_front(); printList(L); //插入 list\u0026lt;int\u0026gt;::iterator it = L.begin(); L.insert(++it,1000); printList(L); //删除 it = L.begin(); L.erase(++it); printList(L); //移除 L.push_back(10000); L.push_back(10000); L.push_back(10000); printList(L); L.remove(10000); printList(L); //清空 L.clear(); printList(L); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 3.7.6 list 数据存取 功能描述:\n对list容器中数据进行存取\n函数原型;\nfront();\t//返回第一个元素。 back();\t//返回最后一个元素。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;list\u0026gt; //list容器 数据存取 void test01() { list\u0026lt;int\u0026gt;L; L.push_back(10); L.push_back(20); L.push_back(30); L.push_back(30); //L1[0]不可以用[访问list容器中的元素 //L1.at(O)不可以用at方式访问list容器中的元素 //原因是list本质链表，不是用连续线性空间存储数据，迭代器也是不支持随机访问的 cout \u0026lt;\u0026lt; \u0026#34;第一个元素为:\u0026#34; \u0026lt;\u0026lt; L.front() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;最后一个元素为:\u0026#34; \u0026lt;\u0026lt; L.back() \u0026lt;\u0026lt; endl; //验证迭代器是不支持随机访问的 list\u0026lt;int\u0026gt;::iterator it = L.begin(); it++; // 支持双向 it--; //it = it + 1;//不支持随机访问 } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 3.7.7 list反转和排序 功能描述:\n将容器中的元素反转，以及将容器中的数据进行排序 函数原型:\nreverse();\t//反转链表 sort();\t//链表排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;list\u0026gt; #include\u0026lt;algorithm\u0026gt; void printList(const list\u0026lt;int\u0026gt;\u0026amp;L) { for (list\u0026lt;int\u0026gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //list容器 数据存取 void test01() { list\u0026lt;int\u0026gt;L; L.push_back(20); L.push_back(10); L.push_back(50); L.push_back(40); L.push_back(30); cout \u0026lt;\u0026lt; \u0026#34;反转前:\u0026#34; \u0026lt;\u0026lt; endl; printList(L); //反转 L.reverse(); cout \u0026lt;\u0026lt; \u0026#34;反转后:\u0026#34; \u0026lt;\u0026lt; endl; printList(L); } bool myCompare(int v1, int v2) { //降序 就让第一个数 〉第二个数 return v1 \u0026gt; v2; } void test02() { list\u0026lt;int\u0026gt;L; L.push_back(20); L.push_back(10); L.push_back(50); L.push_back(40); L.push_back(30); //所有不支持随机访问迭代器的容器，不可以用标准算法 //不支持随机访问迭代器的容器，内部会提供对应一些算法 // sort(L1.begin()，L1.end ()); L.sort();//升序 printList(L); L.sort(myCompare);//降序 printList(L); } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 3.8 set/multiset容器 3.8.1 set基本概念 简介:\n所有元素都会在插入时自动被排序 本质:\nret/multiset属于关联式容器，底层结构是用二叉树实现。 set和multiset区别:\nset不允许容器中有重复的元素 multiset允许容器中有重复的元素 3.8.2 set构造和赋值 功能描述:创建set容器以及赋值\n构造:\nset\u0026lt;T\u0026gt; st;\t//默认构造函数: set( const set \u0026amp;st);\t//拷贝构造函数 赋值:\nset\u0026amp; operator=( const set \u0026amp;st);\t//重载等号操作符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;set\u0026gt; void printSet(const set\u0026lt;int\u0026gt;\u0026amp;s) { for (set\u0026lt;int\u0026gt;::const_iterator it = s.begin(); it != s.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } void test01() { set\u0026lt;int\u0026gt;s1; s1.insert(10); s1.insert(40); s1.insert(30); s1.insert(20); s1.insert(30); //遍历容器 // set容器特点:所有元素插入时候自动被排序 //set容器不允许插入重复值 printSet(s1); //拷贝构造 set\u0026lt;int\u0026gt;s2(s1); printSet(s2); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 3.8.3 set大小和交换 功能描述:\n统计set容器大小以及交换set容器 函数原型:\nsize();\t//返回容器中元素的数目 empty);\t//判断容器是否为空 swap(st);\t//交换两个集合容器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;set\u0026gt; void printSet(const set\u0026lt;int\u0026gt;\u0026amp;s) { for (set\u0026lt;int\u0026gt;::const_iterator it = s.begin(); it != s.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } void test01() { set\u0026lt;int\u0026gt;s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); printSet(s1); if (s1.empty()) { cout \u0026lt;\u0026lt; \u0026#34;s1为空\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;s1不为空\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;s1的大小为:\u0026#34; \u0026lt;\u0026lt; s1.size() \u0026lt;\u0026lt; endl; } } void test02() { set\u0026lt;int\u0026gt;s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); set\u0026lt;int\u0026gt;s2; s2.insert(100); s2.insert(300); s2.insert(200); s2.insert(400); printSet(s1); printSet(s2); s1.swap(s2); printSet(s1); printSet(s2); } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 3.8.4 set插入和删除 功能描述:\nset容器进行插入数据和删除数据 函数原型:\ninsert(elem);\t//在容器中插入元素。 clear();\t//清除所有元素 erase( pos);\t//删除pos迭代器所指的元素，返回下一个元素的迭代器。 erase(beg, end);\t//删除区间[beg,end)的所有元素，返回下一个元素的迭代器。 erase(elem);\t//删除容器中值为elem的元素。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;set\u0026gt; void printSet(const set\u0026lt;int\u0026gt;\u0026amp;s) { for (set\u0026lt;int\u0026gt;::const_iterator it = s.begin(); it != s.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } void test01() { set\u0026lt;int\u0026gt; s1; //插入 s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); printSet(s1); //删除 s1.erase(s1.begin()); printSet(s1); s1.erase(30); printSet(s1); //清空 //s1.erase(s1.begin(), s1.end()); s1.clear(); printSet(s1); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 3.8.5 set查找和统计 功能描述:\n对set容器进行查找数据以及统计数据 函数原型:\nfind(key) ;\t//查找key是否存在,若存在，返回该键的元素的迭代器;若不存在，返回set.end(); count(key);\t//统计key的元素个数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;set\u0026gt; void printSet(const set\u0026lt;int\u0026gt;\u0026amp;s) { for (set\u0026lt;int\u0026gt;::const_iterator it = s.begin(); it != s.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } void test01() { set\u0026lt;int\u0026gt; s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); printSet(s1); set\u0026lt;int\u0026gt;::iterator pos = s1.find(30); if (pos != s1.end()) { cout \u0026lt;\u0026lt; \u0026#34;找到元素:\u0026#34; \u0026lt;\u0026lt; *pos \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;未找到元素\u0026#34;\u0026lt;\u0026lt; endl; } } void test02() { set\u0026lt;int\u0026gt; s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); s1.insert(30); printSet(s1); //统计30的个数 int num = s1.count(30); //对于set而言统计结果要么是0要么是1 cout \u0026lt;\u0026lt; \u0026#34;num = \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 3.8.6 set和multiset区别 学习目标:\n掌握set和multiset的区别 区别:\nset不可以插入重复数据，而multiset可以 set插入数据的同时会返回插入结果，表示插入是否成功 multiset不会检测数据，因此可以插入重复数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;set\u0026gt; void test01() { set\u0026lt;int\u0026gt; s; pair\u0026lt;set\u0026lt;int\u0026gt;::iterator, bool\u0026gt; ret = s.insert(10); if (ret.second) { cout \u0026lt;\u0026lt; \u0026#34;第一次插入成功\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;第一次插入失败\u0026#34; \u0026lt;\u0026lt; endl; } ret = s.insert(10); if (ret.second) { cout \u0026lt;\u0026lt; \u0026#34;第二次插入成功\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;第二次插入失败\u0026#34; \u0026lt;\u0026lt; endl; } multiset\u0026lt;int\u0026gt;ms; //允许插入重复值 ms.insert(10); ms.insert(10); for (multiset\u0026lt;int\u0026gt;::iterator it = ms.begin(); it != ms.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 3.8.7 pair对组创建 功能描述:\n成对出现的数据，利用对组可以返回两个数据 两种创建方式:\npair\u0026lt;type, type\u0026gt; p (value1,value2 ); pair\u0026lt;type, type\u0026gt; p = make_pair(value1，value2); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; void test01() { //第一种方式 pair\u0026lt;string,int\u0026gt;p(\u0026#34;Tom\u0026#34;,20); cout \u0026lt;\u0026lt; \u0026#34;姓名:\u0026#34; \u0026lt;\u0026lt; p.first \u0026lt;\u0026lt; \u0026#34;年龄:\u0026#34;\u0026lt;\u0026lt; p.second \u0026lt;\u0026lt; endl; //第二种方式 pair\u0026lt;string,int\u0026gt;p2 = make_pair(\u0026#34;Jerry\u0026#34;,30); cout \u0026lt;\u0026lt; \u0026#34;姓名:\u0026#34; \u0026lt;\u0026lt; p2.first \u0026lt;\u0026lt; \u0026#34;年龄:\u0026#34;\u0026lt;\u0026lt; p2.second \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 3.8.8 set容器排序 学习目标:\nset容器默认排序规则为从小到大，掌握如何改变排序规则 主要技术点:\n利用仿函数，可以改变排序规则 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;set\u0026gt; class MyCompare { public: bool operator()(int v1, int v2) { return v1 \u0026gt; v2; } }; void test01() { set\u0026lt;int\u0026gt; s1; s1.insert(10); s1.insert(40); s1.insert(20); s1.insert(50); s1.insert(30); for (set\u0026lt;int\u0026gt;::iterator it = s1.begin(); it != s1.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; set\u0026lt;int,MyCompare\u0026gt; s2; s2.insert(10); s2.insert(40); s2.insert(20); s2.insert(50); s2.insert(30); for (set\u0026lt;int,MyCompare\u0026gt;::iterator it = s2.begin(); it != s2.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;set\u0026gt; #include\u0026lt;string\u0026gt; class Person { public: Person(string name,int age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; } string m_Name; int m_Age; }; class comparePerson { public: bool operator()(const Person \u0026amp;p1, const Person \u0026amp;p2) { //按照年龄 降序 return p1.m_Age \u0026gt; p2.m_Age; } }; void test01() { //自定义数据类型都会指定排序规则 set\u0026lt;Person,comparePerson\u0026gt;s; //创建Person对象 Person p1(\u0026#34;刘备\u0026#34;,24); Person p2(\u0026#34;关羽\u0026#34;,28); Person p3(\u0026#34;张飞\u0026#34;,25); Person p4(\u0026#34;赵云\u0026#34;,21); s.insert(p1); s.insert(p2); s.insert(p3); s.insert(p4); for (set\u0026lt;Person\u0026gt;::iterator it = s.begin(); it != s.end(); it++) { cout \u0026lt;\u0026lt; \u0026#34;姓名:\u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34;年龄:\u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Age \u0026lt;\u0026lt; endl; } } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 3.9 map/multimap容器 3.9.1 map基本概念 简介:\nmap中所有元素都是pair pair中第一个元素为key(键值)，起到索引作用，第二个元素为value(实值) 所有元素都会根据元素的键值自动排序 本质:\nmap/multimap属于关联式容器，底层结构是用二叉树实现。 优点:\n可以根据key值快速找到value值 map和multimap区别:\nmap不允许容器中有重复key值元素 multimap允许容器中有重复key值元素 3.9.2 map构造和赋值 功能描述:\n对map容器进行构造和赋值操作 函数原型:\n构造:\nmap\u0026lt;T1，T2\u0026gt; mp;\t//map默认构造函数; map(const map \u0026amp;mp) ;\t//拷贝构造函数 赋值:\nmap\u0026amp; operator=(const map \u0026amp;mp);\t//重载等号操作符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;map\u0026gt; #include\u0026lt;string\u0026gt; //map容器构造和赋值 void printMap(map\u0026lt;int,int\u0026gt;\u0026amp;m) { for (map\u0026lt;int, int\u0026gt;::iterator it = m.begin(); it != m.end(); it++) { cout \u0026lt;\u0026lt; \u0026#34;key = \u0026#34; \u0026lt;\u0026lt; (*it).first \u0026lt;\u0026lt; \u0026#34; value = \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; } void test01() { //创建map容器 map\u0026lt;int,int\u0026gt; m; m.insert(pair\u0026lt;int,int\u0026gt;(1,10)); m.insert(pair\u0026lt;int,int\u0026gt;(3,30)); m.insert(pair\u0026lt;int,int\u0026gt;(2,20)); m.insert(pair\u0026lt;int,int\u0026gt;(4,40)); printMap(m); //拷贝构造 map\u0026lt;int, int\u0026gt;m2(m); printMap(m2); //赋值 map\u0026lt;int,int\u0026gt;m3; m3 = m2; printMap(m3); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 3.9.3 map大小和交换 功能描述:\n统计map容器大小以及交换map容器\n函数原型:\nsize();\t//返回容器中元素的数目 empty();\t//判断容器是否为空 swap(st);\t//交换两个集合容器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;map\u0026gt; #include\u0026lt;string\u0026gt; //map容器构造和赋值 void printMap(map\u0026lt;int,int\u0026gt;\u0026amp;m) { for (map\u0026lt;int, int\u0026gt;::iterator it = m.begin(); it != m.end(); it++) { cout \u0026lt;\u0026lt; \u0026#34;key = \u0026#34; \u0026lt;\u0026lt; (*it).first \u0026lt;\u0026lt; \u0026#34; value = \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; } void test01() { map\u0026lt;int, int\u0026gt;m; m.insert(pair\u0026lt;int,int\u0026gt;(1,10)); m.insert(pair\u0026lt;int,int\u0026gt;(2,20)); m.insert(pair\u0026lt;int,int\u0026gt;(3,30)); if (m.empty()) { cout \u0026lt;\u0026lt; \u0026#34;m为空\u0026#34;\u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;m不为空\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;m的大小为:\u0026#34; \u0026lt;\u0026lt; m.size() \u0026lt;\u0026lt; endl; } } void test02() { map\u0026lt;int, int\u0026gt;m; m.insert(pair\u0026lt;int, int\u0026gt;(1, 10)); m.insert(pair\u0026lt;int, int\u0026gt;(2, 20)); m.insert(pair\u0026lt;int, int\u0026gt;(3, 30)); map\u0026lt;int,int\u0026gt;m2; m2.insert(pair\u0026lt;int,int\u0026gt;(4,100)); m2.insert(pair\u0026lt;int,int\u0026gt;(5,200)); m2.insert(pair\u0026lt;int,int\u0026gt;(6,380)); cout \u0026lt;\u0026lt; \u0026#34;交换前\u0026#34;\u0026lt;\u0026lt;endl; printMap(m); printMap(m2); cout \u0026lt;\u0026lt; \u0026#34;交换后\u0026#34; \u0026lt;\u0026lt;endl; m.swap(m2); printMap(m); printMap(m2); } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 3.9.4 map插入和删除 功能描述:\nmap容器进行插入数据和删除数据 函数原型:\ninsert(elem);\t//在容器中插入元素。 clear();\t//清除所有元素 erase(pos);\t//删除pos迭代器所指的元素，返回下一个元素的迭代器。 erase(beg,end);\t//删除区间[beg,end)的所有元素，返回下一个元素的迭代器。 erase(key);\t//删除容器中值为key的元素。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;map\u0026gt; #include\u0026lt;string\u0026gt; //map容器构造和赋值 void printMap(map\u0026lt;int,int\u0026gt;\u0026amp;m) { for (map\u0026lt;int, int\u0026gt;::iterator it = m.begin(); it != m.end(); it++) { cout \u0026lt;\u0026lt; \u0026#34;key = \u0026#34; \u0026lt;\u0026lt; (*it).first \u0026lt;\u0026lt; \u0026#34; value = \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; } void test01() { //插入 map\u0026lt;int,int\u0026gt; m; //第一种插入方式 m.insert(pair\u0026lt;int,int\u0026gt;(1,10)); //第二种插入方式 m.insert(make_pair(2,20)); //第三种插入方式 m.insert(map\u0026lt;int,int\u0026gt;::value_type(3,30)); //第四种插入方式 m[4] = 40; printMap(m); //删除 m.erase(m.begin()); printMap(m); m.erase(3); printMap(m); //清空 m.erase(m.begin(), m.end()); m.clear(); printMap(m); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 3.9.5 map查找和统计 功能描述:\n对map容器进行查找数据以及统计数据 函数原型:\nfind(key);\t//查找key是否存在,若存在，返回该键的元素的迭代器;若不存在，返回set.end(); count(key);\t//统计key的元素个数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;map\u0026gt; void test01() { map\u0026lt;int,int\u0026gt;m; m.insert(pair\u0026lt;int,int\u0026gt;(1,10)); m.insert(pair\u0026lt;int,int\u0026gt;(2,20)); m.insert(pair\u0026lt;int,int\u0026gt;(3,30)); //查找 map\u0026lt;int, int\u0026gt;::iterator pos = m.find(3); if (pos != m.end()) { cout \u0026lt;\u0026lt; \u0026#34;找到了元素 key = \u0026#34; \u0026lt;\u0026lt; (*pos).first \u0026lt;\u0026lt; \u0026#34; value = \u0026#34; \u0026lt;\u0026lt; (*pos).second \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;未找到元素\u0026#34; \u0026lt;\u0026lt; endl; } //统计 int num = m.count(3); cout \u0026lt;\u0026lt; \u0026#34;num = \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:\n查找\u0026mdash; find(返回的是迭代器) 统计\u0026mdash; count(对于map，结果为0或者1) 3.9.6 map容器排序 学习目标:\nmap容器默认排序规则为按照key值进行从小到大排序，掌握如何改变排序规则 主要技术点:\n利用仿函数，可以改变排序规则 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;map\u0026gt; class MyCompare { public: bool operator()(int v1, int v2) { return v1 \u0026gt; v2; } }; void test01() { //默认从小到大排序 //利用仿函数实现从大到小排序 map\u0026lt;int,int,MyCompare\u0026gt; m; m.insert(make_pair(1,10)); m.insert(make_pair(2,20)); m.insert(make_pair(3,30)); m.insert(make_pair(4,40)); m.insert(make_pair(5,50)); for (map\u0026lt;int,int,MyCompare\u0026gt;::iterator it = m.begin(); it != m.end(); it++) { cout \u0026lt;\u0026lt; \u0026#34;key : \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; value: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; } } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:\n利用仿函数可以指定map容器的排序规则 对于自定义数据类型，map必须要指定排序规则,同set容器 4.STL-函数对象 4.1函数对象 4.1.1函数对象概念 概念:\n重载函数调用操作符的类，其对象常称为函数对象 函数对象使用重载的()时，行为类似函数调用，也叫仿函数 本质:\n函数对象(仿函数)是一个类，不是一个函数\n4.1.2函数对象使用 特点:\n函数对象在使用时，可以像普通函数那样调用,可以有参数，可以有返回值\n函数对象超出普通函数的概念，函数对象可以有自己的状态\n函数对象可以作为参数传递\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;map\u0026gt; #include\u0026lt;string\u0026gt; //1.函数对象在使用时，可以像普通函数那样调用,可以有参数，可以有返回值 class MyAdd { public: int operator () (int v1, int v2) { return v1 + v2; } }; void test01() { MyAdd myAdd; cout \u0026lt;\u0026lt; myAdd(10, 10) \u0026lt;\u0026lt; endl; } //2、函数对象超出普通函数的概念，函数对象可以有自己的状态 class MyPrint { public: MyPrint() { this-\u0026gt;count = 0; } void operator() (string test) { cout \u0026lt;\u0026lt; test \u0026lt;\u0026lt; endl; this-\u0026gt;count++; } int count;//自己内部的状态 }; void test02() { MyPrint myPrint; myPrint(\u0026#34;hello world\u0026#34;); myPrint(\u0026#34;hello world\u0026#34;); myPrint(\u0026#34;hello wor1d\u0026#34;); myPrint(\u0026#34;hello world\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;myPrint调用次数为:\u0026#34; \u0026lt;\u0026lt; myPrint.count \u0026lt;\u0026lt; endl; } //3、函数对象可以作为参数传递 void doPrint(MyPrint \u0026amp; mp, string test) { mp(test); } void test03() { MyPrint myPrint; doPrint(myPrint,\u0026#34;Hello c++\u0026#34;); } int main() { //test01(); //test02(); test03(); system(\u0026#34;pause\u0026#34;); return 0; } 4.2谓词 4.2.1谓词概念 概念:\n返回bool类型的仿函数称为谓词 如果operator()接受一个参数，那么叫做一元谓词 如果operator()接受两个参数，那么叫做二元谓词 4.2.2一元谓词 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; // 1.—元谓词 struct GreaterFive { bool operator()(int val) { return val \u0026gt; 5; } }; void test01() { vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt;10; i++) { v.push_back(i); } vector\u0026lt;int\u0026gt;::iterator it = find_if(v.begin(),v.end(),GreaterFive()); if (it == v.end()) { cout \u0026lt;\u0026lt; \u0026#34;没找到!\u0026#34;\u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到:\u0026#34; \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.2.3 二元谓词 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; // 1.二元谓词 class MyCompare { public: bool operator()(int num1,int num2) { return num1 \u0026gt; num2; } }; void test01() { vector\u0026lt;int\u0026gt; v; v.push_back(10); v.push_back(40); v.push_back(20); v.push_back(30); v.push_back(50); //默认从小到大 sort(v.begin(),v.end()); for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;-----------------\u0026#34; \u0026lt;\u0026lt; endl; //使用函数对象改变算法策略，排序从大到小 sort(v.begin(), v.end(), MyCompare()); for (vector\u0026lt;int\u0026gt; ::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.3内建函数对象 4.3.1内建函数对象意义 概念:\nSTL内建了一些函数对象 分类:\n算术仿函数 关系仿函数 逻辑仿函数 用法:\n这些仿函数所产生的对象，用法和一般函数完全相同 使用内建函数对象，需要引入头文件#include\u0026lt;functional\u0026gt; 4.3.2算术仿函数 功能描述:\n实现四则运算 其中negate是一元运算，其他都是二元运算 仿函数原型:\ntemplate\u0026lt;class T\u0026gt; T plus\u0026lt;T\u0026gt;\t//加法仿函数 template\u0026lt;class T\u0026gt; T minus\u0026lt;T\u0026gt;()\t//减法仿函数 template\u0026lt;class T\u0026gt; T multiplies\u0026lt;T\u0026gt;\t//乘法仿函数 template\u0026lt;class T\u0026gt; T divides\u0026lt;T\u0026gt;\t//除法仿函数 template\u0026lt;class T\u0026gt; T modulus\u0026lt;T\u0026gt;\t//取模仿函数 template\u0026lt;class T\u0026gt; T negate\u0026lt;T\u0026gt;\t//取反仿函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;functional\u0026gt; void test01() { negate\u0026lt;int\u0026gt;n; cout \u0026lt;\u0026lt; n(50) \u0026lt;\u0026lt; endl; } // plus void test02() { plus\u0026lt;int\u0026gt; p; cout \u0026lt;\u0026lt; p(10,20) \u0026lt;\u0026lt; endl; } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 4.3.3关系仿函数 功能描述:\n实现关系对比 仿函数原型:\ntemplate\u0026lt;class T\u0026gt; bool equal_to\u0026lt;T\u0026gt;\t//等于 template\u0026lt;class T\u0026gt; bool not_equal_to\u0026lt;T\u0026gt;\t//不等于 template\u0026lt;class T\u0026gt; bool greater\u0026lt;T\u0026gt;\t//大于 template\u0026lt;class T\u0026gt; bool greater_equal\u0026lt;T\u0026gt;\t//大于等于 template\u0026lt;class T\u0026gt; bool less\u0026lt;T\u0026gt;\t//小于 template\u0026lt;class T\u0026gt; bool less_equal\u0026lt;T\u0026gt;\t//小于等于 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;functional\u0026gt; class MyCompare { public: bool operator()(int v1, int v2) { return v1 \u0026gt;v2; } }; void test01() { vector\u0026lt;int\u0026gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(40); v.push_back(20); for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; // 自己实现仿函数 //sort(v.begin(), v.end(), MyCompare()); // STL内建仿函数大于仿函数 sort(v.begin(), v.end(), greater\u0026lt;int\u0026gt;()); for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.3.4逻辑仿函数 功能描述:\n实现逻辑运算 函数原型:\ntemplate\u0026lt;class T\u0026gt; bool logical_and\u0026lt;T\u0026gt;\t//逻辑与 template\u0026lt;class T\u0026gt; bool logical_or\u0026lt;T\u0026gt;\t//逻辑或 template\u0026lt;class T\u0026gt; bool logical_not\u0026lt;T\u0026gt;\t//逻辑非 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;functional\u0026gt; void test01() { vector\u0026lt;bool\u0026gt; v; v.push_back(true); v.push_back(false); v.push_back(true); v.push_back(false); for (vector\u0026lt;bool\u0026gt; ::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //逻辑非﹐将v容器搬运到v2中，并执行逻辑非运算 vector\u0026lt;bool\u0026gt;v2; v2.resize(v.size()); transform(v.begin(),v.end(),v2.begin(),logical_not\u0026lt;bool\u0026gt;()); for (vector\u0026lt;bool\u0026gt;::iterator it = v2.begin(); it != v2.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 5.STL-常用算法 概述:\n算法主要是由头文件组成。 是所有STL头文件中最大的一个，范围涉及到比较、交换、查找、遍历操作、复制、修改等等 体积很小，只包括几个在序列上面进行简单数学运算的模板函数 定义了一些模板类,用以声明函数对象。 5.1常用遍历算法 学习目标:\n掌握常用的遍历算法 算法简介:\nfor_each\t//遍历容器 transform\t//搬运容器到另一个容器中 5.1.1 for_each 功能描述:\n实现遍历容器 函数原型:\nfor_each(iterator beg,iterator ene,_func);\n//遍历算法遍历容器元素 //beg 开始迭代器 //end结束迭代器 //_func函数或者函数对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; void myprint01(int val1) { cout \u0026lt;\u0026lt; val1 \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } class myprint02 { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } }; void test01() { vector\u0026lt;int\u0026gt;v; for (int i = 0; i \u0026lt; 10; i++) { v.push_back(i); } for_each(v.begin(), v.end(), myprint01); cout \u0026lt;\u0026lt; endl; for_each(v.begin(), v.end(), myprint02()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结: for_each在实际开发中是最常用遍历算法，需要熟练掌握\n5.1.2 transform 功能描述:\n搬运容器到另一个容器中 函数原型:\ntransform(iterator beg1， iterator endt1， iterator beg2，_func); //beg1源容器开始迭代器\n//end1源容器结束迭代器\n//beg2目标容器开始迭代器\n//_func函数或者函数对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; class Trans { public: int operator()(int v) { return v+100; } }; class myprint { public: void operator()(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } }; void test01() { vector\u0026lt;int\u0026gt;v; for (int i = 0; i \u0026lt; 10; i++) { v.push_back(i); } vector\u0026lt;int\u0026gt;vTarget; vTarget.resize(v.size()); transform(v.begin(), v.end(), vTarget.begin(), Trans()); for_each(vTarget.begin(), vTarget.end(), myprint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:搬运的目标容器必须要提前开辟空间，否则无法正常搬运\n5.2常用查找算法 学习目标:\n掌握常用的查找算法 算法简介:\nfind\t//查找元素 find_if\t//按条件查找元素 adjacent_find\t//查找相邻重复元素 binary_search\t//二分查找法 count\t//统计元素个数 count_if\t//按条件统计元素个数 5.2.1 find 功能描述:\n查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end() 函数原型:\nfind(iterator beg, iterator end，value) ; //按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置\n//beg开始迭代器\n//end结束迭代器\n//value查找的元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;string\u0026gt; void test01() { vector\u0026lt;int\u0026gt;v; for (int i = 0; i \u0026lt; 10; i++) { v.push_back(i); } vector\u0026lt;int\u0026gt;::iterator it = find(v.begin(), v.end(), 5); if (it == v.end()) { cout \u0026lt;\u0026lt; \u0026#34;没有找到!\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到: \u0026#34; \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } } class Person { public: Person(string name, int age) { this-\u0026gt;m_name = name; this-\u0026gt;m_age = age; } bool operator == (const Person \u0026amp;p) { if (this-\u0026gt;m_name == p.m_name \u0026amp;\u0026amp; this-\u0026gt;m_age == p.m_age) { return true; } else { return false; } } string m_name; int m_age; }; void test02() { vector\u0026lt;Person\u0026gt;v; Person p1(\u0026#34;aaa\u0026#34;, 10); Person p2(\u0026#34;bbb\u0026#34;, 20); Person p3(\u0026#34;ccc\u0026#34;, 30); Person p4(\u0026#34;ddd\u0026#34;, 40); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); vector\u0026lt;Person\u0026gt;::iterator it = find(v.begin(), v.end(), p2); if (it == v.end()) { cout \u0026lt;\u0026lt; \u0026#34;没有找到!\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到姓名;\u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_name \u0026lt;\u0026lt; \u0026#34;年龄: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_age \u0026lt;\u0026lt; endl; } } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 5.2.2 find_if 功能描述:\n按条件查找元素 函数原型:\nfind_if(iterator beg, iterator end，_Pred); //按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置_\n//beg 开始迭代器\n//end结束迭代器\n//_Pred函数或者谓词(返回bool类型的仿函数)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;string\u0026gt; //内置数据类型 class GreaterFive { public: bool operator()(int val) { return val \u0026gt; 5; } }; void test01() { vector\u0026lt;int\u0026gt;v; for (int i = 0; i \u0026lt; 10; i++) { v.push_back(i+1); } vector\u0026lt;int\u0026gt;::iterator it=find_if(v.begin(),v.end(),GreaterFive()); if (it == v.end()) { cout \u0026lt;\u0026lt; \u0026#34;没有找到!\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到大于5的数字:\u0026#34; \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } } class Person { public: Person(string name, int age) { this-\u0026gt;m_name = name; this-\u0026gt;m_age = age; } bool operator == (const Person \u0026amp;p) { if (this-\u0026gt;m_name == p.m_name \u0026amp;\u0026amp; this-\u0026gt;m_age == p.m_age) { return true; } else { return false; } } string m_name; int m_age; }; class Greater20 { public: bool operator()(Person \u0026amp;p) { return p.m_age \u0026gt; 20; } }; void test02() { vector\u0026lt;Person\u0026gt;v; Person p1(\u0026#34;aaa\u0026#34;, 10); Person p2(\u0026#34;bbb\u0026#34;, 20); Person p3(\u0026#34;ccc\u0026#34;, 30); Person p4(\u0026#34;ddd\u0026#34;, 40); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); vector\u0026lt;Person\u0026gt;::iterator it = find_if(v.begin(),v.end(),Greater20()); if (it == v.end()) { cout \u0026lt;\u0026lt; \u0026#34;没有找到!\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到姓名:\u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_name \u0026lt;\u0026lt; \u0026#34;年龄:\u0026#34;\u0026lt;\u0026lt; it-\u0026gt;m_age \u0026lt;\u0026lt; endl; } } int main() { test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 5.2.3 adjacent_find 功能描述:\n查找相邻重复元素 函数原型:\nadjacent_find( iterator beg， iterator end ) ; 查找相邻重复元素,返回相邻元素的第一个位置的迭代器\n//beg 开始迭代器 //end结束迭代器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;string\u0026gt; void test01() { vector\u0026lt;int\u0026gt;v; v.push_back(0); v.push_back(2); v.push_back(0); v.push_back(3); v.push_back(1); v.push_back(4); v.push_back(3); v.push_back(3); vector\u0026lt;int\u0026gt;::iterator pos = adjacent_find(v.begin(), v.end()); if (pos == v.end() ){ cout \u0026lt;\u0026lt; \u0026#34;未找到相邻重复元素\u0026#34;\u0026lt;\u0026lt; endl ; } else { cout \u0026lt;\u0026lt; \u0026#34;找到相邻重复元素:\u0026#34; \u0026lt;\u0026lt; *pos \u0026lt;\u0026lt; endl; } } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 5.2.4 binary_search 功能描述:\n查找指定元素是否存在 函数原型:\nbool binary_search(iterator beg, iterator end, value); //查找指定的元素，查到返回true否则false\n//注意:在无序序列中不可用\n//beg 开始迭代器\n//end结束迭代器\n//value查找的元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; void test01() { vector\u0026lt;int\u0026gt;v; for (int i = 0; i \u0026lt; 10; i++) { v.push_back(i); } //二分查找 bool ret = binary_search(v.begin(), v.end(), 2); if (ret) { cout \u0026lt;\u0026lt; \u0026#34;找到了\u0026#34; \u0026lt;\u0026lt;endl; } else { cout \u0026lt;\u0026lt; \u0026#34;未找到\u0026#34; \u0026lt;\u0026lt; endl; } } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:二分查找法查找效率很高，值得注意的是查找的容器中元素必须是有序序列\n5.2.5 count 功能描述:\n统计元素个数 函数原型:\ncount(iterator beg， iterator end，value) ;\t//统计元素出现次数 //beg开始迭代器\t//end结束迭代器\t//value统计的元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;string\u0026gt; void test01() { vector\u0026lt;int\u0026gt; v; v.push_back(1); v.push_back(2); v.push_back(4); v.push_back(5); v.push_back(3); v.push_back(4); v.push_back(4); int num = count(v.begin(), v.end(), 4); cout \u0026lt;\u0026lt; \u0026#34;4的个数为:\u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } class Person { public: Person(string name, int age) { this-\u0026gt;m_name = name; this-\u0026gt;m_age = age; } bool operator == (const Person \u0026amp;p) { if (this-\u0026gt;m_age == p.m_age) { return true; } else { return false; } } string m_name; int m_age; }; void test02() { vector\u0026lt;Person\u0026gt; v; Person p1(\u0026#34;刘备\u0026#34;,35); Person p2(\u0026#34;关羽\u0026#34;,35); Person p3(\u0026#34;张飞\u0026#34;,35); Person p4(\u0026#34;赵云\u0026#34;,30); Person p5(\u0026#34;曹操\u0026#34;,25); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); Person p(\u0026#34;诸葛亮\u0026#34;,35); int num = count(v.begin(), v.end(), p); cout \u0026lt;\u0026lt; \u0026#34;num = \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:统计自定义数据类型时候，需要配合重载operator==\n5.2.6 count_if 功能描述:\n按条件统计元素个数 函数原型:\ncount_if(iterator beg， iterator end，_Pred ) ; //按条件统计元素出现次数\n//beg开始迭代器\t//end结束迭代器\t//_Pred谓词\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;string\u0026gt; //统计内置数据类型 class Greater20 { public: bool operator() (int val) { return val \u0026gt; 20; } }; void test01() { vector\u0026lt;int\u0026gt; v; v.push_back(10); v.push_back(40); v.push_back(30); v.push_back(20); v.push_back(40); v.push_back(20); int num = count_if(v.begin(), v.end(),Greater20()); cout \u0026lt;\u0026lt; \u0026#34;大于20的个数为:\u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } class Person { public: Person(string name, int age) { this-\u0026gt;m_name = name; this-\u0026gt;m_age = age; } bool operator == (const Person \u0026amp;p) { if (this-\u0026gt;m_age == p.m_age) { return true; } else { return false; } } string m_name; int m_age; }; class AgeGreater20 { public: bool operator() (const Person \u0026amp; p) { return p.m_age \u0026gt; 20; } }; void test02() { vector\u0026lt;Person\u0026gt; v; Person p1(\u0026#34;刘备\u0026#34;, 35); Person p2(\u0026#34;关羽\u0026#34;, 35); Person p3(\u0026#34;张飞\u0026#34;, 35); Person p4(\u0026#34;赵云\u0026#34;, 30); Person p5(\u0026#34;曹操\u0026#34;, 25); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); int num = count_if(v.begin(), v.end(), AgeGreater20()); cout \u0026lt;\u0026lt; \u0026#34;num = \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 5.3常用排序算法 学习目标:\n掌握常用的排序算法 算法简介:\nsort\t//对容器内元素进行排序 random_shuffle\t//洗牌指定范围内的元素随机调整次序 merge\t//容器元素合并，并存储到另一容器中 reverse\t//反转指定范围的元素 5.3.1 sort 功能描述:\n对容器内元素进行排序 函数原型:\nsort(iterator beg，iterator end，_Pred ) ; //按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置\n//beg开始迭代器\t//end结束迭代器\t// _Pred 谓词\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;functional\u0026gt; void myPrint(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } void test01() { vector\u0026lt;int\u0026gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(20); v.push_back(40); //sort默认从小到大排序 sort(v.begin(), v.end()); for_each(v.begin(), v.end(), myPrint); cout \u0026lt;\u0026lt; endl; //从大到小排序 sort(v.begin(), v.end(), greater\u0026lt;int\u0026gt;()); for_each(v.begin(), v.end(), myPrint); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结: sort属于开发中最常用的算法之一，需熟练掌握\n5.3.2 random_shuffle 功能描述:\n洗牌指定范围内的元素随机调整次序 函数原型:\nrandom_shuffle(iterator beg, iterator end ) ; //指定范围内的元素随机调整次序\n//beg 开始迭代器\t//end结束迭代器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;ctime\u0026gt; void myPrint(int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } void test01() { srand((unsigned int)time(NULL)); vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 10; i++) { v.push_back(i); } //利用洗牌算法打乱顺序 random_shuffle(v.begin(),v.end()); for_each(v.begin(),v.end(),myPrint); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:random_shuffle洗牌算法比较实用，使用时记得加随机数种子\n5.3.3 merge 功能描述:\n两个容器元素合并，并存储到另一容器中 函数原型:\nmerge(iterator beg1，iterator end1，iterator beg2，iterator end2，iterator dest); //容器元素合并，并存储到另一容器中\n//注意:两个容器必须是有序的\n//beg1容器1开始迭代器\t//end1容器1结束迭代器\n//beg2容器2开始迭代器\t//end2容器2结束迭代器\n//dest目标容器开始迭代器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; class myPrint { public: void operator() (int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v1; vector\u0026lt;int\u0026gt; v2; for (int i =0; i \u0026lt; 10; i++) { v1.push_back(i); v2.push_back(i + 1); } vector\u0026lt;int\u0026gt; vtarget;//目标容器需要提前开辟空间 vtarget.resize(v1.size() + v2.size()); //合并 需要两个有序序列 merge(v1.begin(), v1.end(),v2.begin(),v2.end(),vtarget.begin()); for_each(vtarget.begin(), vtarget.end(), myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:merge合并的两个容器必须的有序序列\n5.3.4 reverse 功能描述:\n将容器内元素进行反转 函数原型:\nreverse(iterator beg, iterator end) ; //反转指定范围的元素\n//beg开始迭代器\t//end结束迭代器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; class myPrint { public: void operator() (int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(20); v.push_back(40); cout \u0026lt;\u0026lt; \u0026#34;反转前:\u0026#34; \u0026lt;\u0026lt; endl; for_each(v.begin(), v.end(), myPrint()); cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;反转后:\u0026#34; \u0026lt;\u0026lt; endl; reverse(v.begin(), v.end()); for_each(v.begin(), v.end(), myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:reverse反转区间内元素，面试题可能湖及到\n5.4常用拷贝和替换算法 学习目标:\n掌握常用的拷贝和替换算法 算法简介:\ncopy\t//容器内指定范围的元素拷贝到另—容器中 replace\t//将容器内指定范围的旧元素修改为新元素 replace_if\t//容器内指定范围满足条件的元素替换为新元素 swap\t//互换两个容器的元素 5.4.1 copy 功能描述:\n容器内指定范围的元素拷贝到另一容器中 函数原型:\ncopy(iterator beg， iterator end， iterator dest); //按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置\n//beg开始迭代器 //end 结束迭代器\t//dest目标起始迭代器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; class myPrint { public: void operator() (int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v1; for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i + 1); } vector\u0026lt;int\u0026gt; v2; v2.resize(v1.size()); copy(v1.begin(),v1.end(),v2.begin()); for_each(v2.begin(), v2.end(),myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 注：提前开辟空间\n5.4.2 replace 功能描述:\n将容器内指定范围的旧元素修改为新元素 函数原型:\nreplace(iterator beg， iterator end，oldvalue，newvalue); //将区间内旧元素替换成新元素\n//beg开始迭代器\t//end结束迭代器\n//oldvalue 旧元素\t//newvalue 新元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; class myPrint { public: void operator() (int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v; v.push_back(20); v.push_back(30); v.push_back(20); v.push_back(40); v.push_back(50); v.push_back(10); v.push_back(20); cout \u0026lt;\u0026lt; \u0026#34;替换前:\u0026#34;\u0026lt;\u0026lt;endl; for_each(v.begin(), v.end(), myPrint()); cout \u0026lt;\u0026lt; endl; //将容器中的20替换成2000 cout\u0026lt;\u0026lt;\u0026#34;替换后:\u0026#34; \u0026lt;\u0026lt; endl; replace(v.begin(), v.end(),20, 2000); for_each(v.begin(), v.end(), myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结: replace会替换区间内满足条件的元素\n5.4.3 replace_if 功能描述:\n将区间内满足条件的元素，替换成指定元素 函数原型:\nreplace_if(iterator beg，iterator end，_pred，newvalue); //按条件替换元素，满足条件的替换成指定元素\n//beg开始迭代器\t//end结束迭代器\n//_pred谓词\t//newvalue替换的新元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; class myPrint { public: void operator() (int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; class ReplaceGreater30 { public: bool operator()(int val) { return val \u0026gt;= 30; } }; void test01() { vector\u0026lt;int\u0026gt; v; v.push_back(20); v.push_back(30); v.push_back(20); v.push_back(40); v.push_back(50); v.push_back(10); v.push_back(20); cout \u0026lt;\u0026lt; \u0026#34;替换前:\u0026#34;\u0026lt;\u0026lt;endl; for_each(v.begin(), v.end(), myPrint()); cout \u0026lt;\u0026lt; endl; //将容器中大于等于的38替换成3000 cout \u0026lt;\u0026lt;\u0026#34;替换后: \u0026#34;\u0026lt;\u0026lt; endl; replace_if(v.begin(), v.end(), ReplaceGreater30(),3000); for_each(v.begin(), v.end(), myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结: replace_if按条件查找，可以利用仿函数灵活筛选满足的条件\n5.4.4 swap 功能描述:\n互换两个容器的元素 函数原型:\nswap( container c1, container c2); //互换两个容器的元素\n//c1容器1\t//c2容器2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; class myPrint { public: void operator() (int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v1; vector\u0026lt;int\u0026gt; v2; for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); v2.push_back(i + 100); } cout \u0026lt;\u0026lt; \u0026#34;交换前:\u0026#34; \u0026lt;\u0026lt; endl; for_each(v1.begin(), v1.end(), myPrint()); cout \u0026lt;\u0026lt; endl; for_each(v2.begin(), v2.end(), myPrint()); cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;交换后:\u0026#34; \u0026lt;\u0026lt; endl; swap(v1, v2); for_each(v1.begin(), v1.end(), myPrint()); cout \u0026lt;\u0026lt; endl; for_each(v2.begin(), v2.end(), myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结: swap交换容器时，注意交换的容器要同种类型\n5.5常用算术生成算法 学习目标:\n掌握常用的算术生成算法 注意:\n算术生成算法属于小型算法，使用时包含的头文件为#include 算法简介:\naccumulate\t//计算容器元素累计总和 fill\t//向容器中添加元素 5.5.1 accumulate 功能描述:\n计算区间内容器元素累计总和 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;numeric\u0026gt; #include\u0026lt;vector\u0026gt; class myPrint { public: void operator() (int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt;= 100; i++) { v.push_back(i); } //参数3 起始累加值 int total = accumulate(v.begin(), v.end(), 0); cout \u0026lt;\u0026lt; total \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结: accumulate使用时头文件注意是numeric，这个算法很实用\n5.5.2 fill 功能描述:\n向容器中填充指定的元素 函数原型:\nfill(iterator beg, iterator end，value) ;//向容器中填充元素 //beg 开始迭代器\t//end结束迭代器\t//value填充的值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;numeric\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; class myPrint { public: void operator() (int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v; v.resize(10); //后期重新填充 fill(v.begin(), v.end(), 100); for_each(v.begin(),v.end(),myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:利用fill可以将容器区间内元素填充指定的值\n5.6常用集合算法 学习目标:\n掌握常用的集合算法 算法简介:\nset_intersection //求两个容器的交集 set_union\t//求两个容器的并集 set_difference\t//求两个容器的差集 5.6.1 set_intersection 功能描述:\n求两个容器的交集 函数原型:\nset_intersection(iterator beg1，iterator end1，iterator beg2，iterator end2，iterator dest); //求两个集合的交集\n//注意:两个集合必须是有序序列\n//beg1容器1开始迭代器\t//end1容器1结束迭代器\n//beg2容器2开始迭代器\t//end2容器2结束迭代器\t//dest目标容器开始迭代器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;numeric\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; class myPrint { public: void operator() (int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v1; vector\u0026lt;int\u0026gt; v2; for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); v2.push_back(i + 5); } vector\u0026lt;int\u0026gt; vTarget; // 取两个里面较小的值给目标容器开辟空间 vTarget.resize(min(v1.size(), v2.size())); // 返回目标容器的最后一个元素的迭代器地址 vector\u0026lt;int\u0026gt;::iterator itEnd = set_intersection(v1.begin(),v1.end(),v2.begin(),v2.end(),vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:\n求交集的两个集合必须的有序序列 目标容器开辟空间需要从两个容器中取小值 set_intersection返回值既是交集中最后一个元素的位置 5.6.2 set_union 功能描述:\n求两个集合的并集 函数原型:\nset_union(iterator beg1， iterator end1，iterator beg2，iterator end2，iterator dest); //求两个集合的并集\n//注意:两个集合必须是有序序列\n// beg1容器1开始迭代器\t//end1容器1结束迭代器\n//beg2容器2开始迭代器\t//end2容器2结束迭代器\t//dest目标容器开始迭代器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; class myPrint { public: void operator() (int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v1; vector\u0026lt;int\u0026gt; v2; for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); v2.push_back(i + 5); } vector\u0026lt;int\u0026gt; vTarget; // 给目标容器开辟空间 vTarget.resize(v1.size() + v2.size()); // 返回目标容器的最后一个元素的迭代器地址 vector\u0026lt;int\u0026gt;::iterator itEnd = set_union(v1.begin(),v1.end(),v2.begin(),v2.end(),vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:\n求并集的两个集合必须的有序序列 目标容器开辟空间需要两个容器相加 set_union返回值既是并集中最后一个元素的位置 5.6.3 set_difference 功能描述:\n求两个集合的差集 函数原型:\nset_difference(iterator beg1，iterator end1，iterator beg2，iterator end2，iterator dest); //求两个集合的差集\n//注意:两个集合必须是有序序列\n//beg1容器1开始迭代器\t//end1容器1结束迭代器\n//beg2容器2开始迭代器\t//end2容器2结束迭代器\t//dest目标容器开始迭代器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; class myPrint { public: void operator() (int val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; void test01() { vector\u0026lt;int\u0026gt; v1; vector\u0026lt;int\u0026gt; v2; for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); v2.push_back(i + 5); } vector\u0026lt;int\u0026gt; vTarget; // 给目标容器开辟空间 vTarget.resize(max(v1.size() , v2.size())); // 返回目标容器的最后一个元素的迭代器地址 vector\u0026lt;int\u0026gt;::iterator itEnd = set_difference(v1.begin(),v1.end(),v2.begin(),v2.end(),vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout \u0026lt;\u0026lt; endl; itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结:\n求差集的两个集合必须的有序序列 目标容器开辟空间需要从两个容器取较大值 set_difference返回值既是差集中最后一个元素的位置 并发与多线程 ","date":"2023-01-01T00:00:00Z","permalink":"https://raff-zeng.github.io/post/reading-notes/notes-at-school/cplusplus-basic/","title":"c++基础"},{"content":"crazyswarm功能包使用 一、Crazyflie + optitrack +ros编队控制实现 参考论文https://link.springer.com/chapter/10.1007/978-3-319-54927-9_3\nhttps://ieeexplore.ieee.org/abstract/document/7989376\n先观看视频https://www.youtube.com/watch?v=9KlfFpv6NIQ\n​\tCrazyflie有一个9轴惯性测量单元（IMU），由陀螺仪、加速度计和磁力计组成。此外，可以使用压力传感器来估计高度。大部分处理在主微控制器（STM32）上完成。它运行FreeRTOS作为其操作系统，状态估计和姿态控制以250Hz执行。第二微控制器（nRF51）用于无线通信并用作电源管理器。这两个微控制器可以通过syslink交换数据，这是一种使用UART作为物理接口的协议。扩展端口允许添加附加硬件。\nCrazyflie配置\n以下均参考https://crazyswarm.readthedocs.io/en/latest/installation.html\n1.crazyradio权限设置 https://www.bitcraze.io/documentation/repository/crazyflie-lib-python/master/installation/usb_permissions/\n2.下载crazyflie-lib-python和crazyflie-client-python包 https://github.com/bitcraze/crazyflie-lib-python.git\nhttps://github.com/bitcraze/crazyflie-clients-python.git\n1 2 3 4 5 6 7 8 #分别在这两个目录下 pip3 install -e . #启动客户端 python3 -m cfclient.gui #说明 #crazyflie命名按顺序修改最后两位，并在crazyflie上做好标记防止忘记地址 #uri1:=radio://0/100/2M/E7E7E7E701 #uri2:=radio://0/100/2M/E7E7E7E702 3. crazyswarm配置 1.安装\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 export CSW_PYTHON=python3 #安装依赖 sudo apt install -y ros-noetic-tf ros-noetic-tf-conversions ros-noetic-joy sudo apt install -y libpcl-dev libusb-1.0-0-dev sudo apt install -y swig lib${CSW_PYTHON}-dev ${CSW_PYTHON}-pip ${CSW_PYTHON} -m pip install pytest numpy PyYAML scipy ${CSW_PYTHON} -m pip install vispy #截图工具 sudo apt install -y ffmpeg ${CSW_PYTHON} -m pip install ffmpeg-python git clone https://github.com/USC-ACTLab/crazyswarm.git #编译 cd crazyswarm ./build.sh #测试 cd ros_ws/src/crazyswarm/scripts source ~/crazyswarm/ros_ws/devel/setup.bash $CSW_PYTHON -m pytest 2.参数设置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #crazyradio固件更新 cd ~/crazyflie_docs git clone https://github.com/bitcraze/crazyradio-firmware.git sudo apt-get install sdcc binutils #编译 cd ~/crazyflie_docs/crazyradio-firmware/firmware make CRPA=1 #烧写前先安装python3-usb包 sudo apt install python3-usb #烧写 python3 ../usbtools/launchBootloader.py sudo python3 ../usbtools/nrfbootload.py flash bin/cradio.bin #重新插拔crazyradio，检查版本应为version 99.55 lsusb -d 1915:7777 -v | grep bcdDevice ros_ws/src/crazyswarm/launch/hover_swarm.launch参数设置\n1 2 motion_capture_type: \u0026#34;optitrack\u0026#34; motion_capture_host_name: \u0026#34;192.168.2.17\u0026#34; # hostname or IP address Motive中设置\n• Up axis: Z\n• 若object_tracking_type:libobjecttracker,关闭all assets和打开labeled or unlabeled markers\ncrazyflies.yaml文件设置（ros_ws/src/crazyswarm/launch/crazyflies.yaml）\ncrazyswarm服务器在启动时读取配置文件crazyflies.yaml\n• 唯一的标记排列，crazyflies.yaml条目的initialPosition字段将被忽略，但仍然应该设置它，因为解析器需要它。\n• 重复的标记排列，initialPosition必须正确。在运动捕捉设备的坐标系中，位置以米为单位指定。不要求CF精确地从这些位置开始，几厘米的变化是可以的。\ncrazyflieTypes.yaml设置（ros_ws/src/crazyswarm/launch/crazyflieTypes.yaml**）**\n• 唯一标记点排列中，markerConfiguration字段不需要，初始位置可以有\n• 复制标记点排列中，每个排列需要用markerConfiguration字段，默认的标记排列为0。1.在运动捕捉空间的原点放置一个具有所需排列的CF。Crazyflie的正面应指向运动捕捉坐标系的x方向。2.获得标记点的坐标，roslaunch crazyswarm mocap_helper.launch。3.修改crazyflieTypes.yaml\nChooser管理编队\n使用配置文件allCrazyflies.yaml\n3.简单悬停\n1 2 3 4 5 6 #启动crazyswarm_server source ros_ws/devel/setup.bash roslaunch crazyswarm hover_swarm.launch #起飞悬停两秒后降落 python3 hello_world.py crazyswarm相关命令\n1 2 3 4 5 6 7 rosrun crazyflie_tools scan --address 0xE7E7E7E701 rosrun crazyflie_tools battery --uri radio://0/100/2M/E7E7E7E701 rosrun crazyflie_tools reboot radio://0/100/2M/E7E7E7E701 --mode sysoff rosrun crazyflie_tools reboot radio://0/100/2M/E7E7E7E701 roslaunch crazyswarm mocap_helper.launch roslaunch crazyswarm hover_swarm.launch 4.例子（~/crazyswarm/ros_ws/src/crazyswarm/scripts/）\n使用python API写脚本实现位置速度轨迹等控制\nPython API接口参考https://crazyswarm.readthedocs.io/en/latest/api.html\n/home/uav2/crazyswarm/ros_ws/src/crazyswarm/scripts/hello_world.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026#34;\u0026#34;\u0026#34;Takeoff-hover-land for one CF. Useful to validate hardware config.\u0026#34;\u0026#34;\u0026#34; from pycrazyswarm import Crazyswarm TAKEOFF_DURATION = 2.5 HOVER_DURATION = 5.0 def main(): swarm = Crazyswarm() timeHelper = swarm.timeHelper cf = swarm.allcfs.crazyflies[0] cf.takeoff(targetHeight=1.0, duration=TAKEOFF_DURATION) timeHelper.sleep(TAKEOFF_DURATION + HOVER_DURATION) cf.land(targetHeight=0.04, duration=2.5) timeHelper.sleep(TAKEOFF_DURATION) if __name__ == \u0026#34;__main__\u0026#34;: main() 5.暂不需要，可选\n创建ROS 工作空间 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 mkdir -p ~/crazyflie_ws/src cd ~/crazyflie_ws/src catkin_init_workspace #下载crazyswarm包，移入ROS工作空间 mkdir -p ~/crazyflie_docs cd ~/crazyflie_docs git clone https://github.com/USC-ACTLab/crazyswarm.git git submodule update --init --recursive git submodule update --recursive mv ~/crazyflie_docs/crazyswarm/ros_ws/src ~/crazyflie_ws/src #编译 cd ~/crazyflie_ws catkin_make source ~/crazyflie_ws/devel/setup.bash 动捕工作空间 1 2 3 4 5 6 7 8 9 10 #代码clone mkdir -p ~/motioncap_ws/src catkin_init_workspace cd ~/motioncap_ws/src git clone https://github.com/ros-drivers/vrpn_client_ros.git cd ~/motioncap_ws catkin_make #运行 roslaunch vrpn_client_ros/launch/sample.launch server:=192.168.2.17 ","date":"2023-01-01T00:00:00Z","permalink":"https://raff-zeng.github.io/post/reading-notes/notes-at-school/crazyswarmusage/","title":"crazyswarm功能包使用"},{"content":"第一章 ROS基础 1.ROS安装 http://wiki.ros.org/cn/noetic/Installation/Ubuntu\nhttps://blog.csdn.net/qq_44339029/article/details/120579608?spm=1001.2101.3001.6650.1\u0026amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-1-120579608-blog-106899359.pc_relevant_baidufeatures_v6\u0026amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-1-120579608-blog-106899359.pc_relevant_baidufeatures_v6\u0026amp;utm_relevant_index=2\n2. 安装rosinstall $ sudo apt-get install python-rosinstall\n3.创建catkin工作空间： 1 2 3 4 5 ~$ mkdir -p ~/catkin_ws/src ~$ cd ~/catkin_ws/src ~/catkin_ws/src$ catkin_init_workspace ~/catkin_ws/src$ cd .. ~/catkin_ws$ catkin_make 4.加载源文件setup.bash 1 2 ~/catkin_ws$ source ~/catkin_ws/devel/setup.bash ~/catkin_ws$ echo \u0026#34;source ~/catkin_ws/devel/setup.bash\u0026#34; \u0026gt;\u0026gt; ~/.bashrc 查看工作空间： ~/catkin_ws$ echo $ROS_PACKAGE_PATH\n5.ROS功能包 http://wiki.ros.org/Packages\n命令：\nrospack 用于获取一个功能包的信息\n$ rospack help | less\nroscd 切换ROS目录\n$ roscd turtlesim\nrosls 列出一个功能包目录下的目录与文件清单\n$ rosls turtlesim\nrospack find 返回指定名称的功能包的路径\n$ rospack find turtlesim\n6.ros节点、话题、消息 rosnode list 列出运行的节点\nrostopic list 列出与运行中的节点相关的话题\n使用帮助 rosnode -h\n​\trosnode list -h\n7.ROS机器人模拟程序 rosrun 在功能包里找到并启动所需要的节点 rosmsg 显示相关消息的信息 rosservice 显示节点的运行时间，并且在请求/响应模式下在节点间传递数据 rosparam 获取或者设置节点参数值 启动ROS节点管理器 roscore 启动节点 rosrun turtlesim turtlesim_node 列出活动节点 rosnode list 查看/turtlesim节点的发布话题、订阅服务和服务相关内容 rosnode info /turtlesim 查看/turtlesim节点的话题 rostopic list 查看话题的话题类型 rostopic type /turtle1/color_sensor 查看消息类型 rosmsg list 查看ROS消息类型的具体内容 rosmsg show turtlesim/Color 查看乌龟背景颜色的数值 rostopic echo /turtle1/color_sensor 8.控制乌龟运动 启动节点管理器，并启动turtlesim_node 1 2 $ roscore $ rosrun turtlesim turtlesim_node turtlesim_node订阅/turtle1/cmd_vel话题，可以通过/turtle1/cmd_vel发送消息来控制乌龟运动\n确定该话题的消息类型\n$ rostopic type /turtle1/cmd_vel\n消息类型为Twist，来自geometry_msgs功能包 geometry_msgs/Twist\n控制乌龟做圆周运动\n$ rostopic pub /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- '[2.0,0.0,0.0]' '[0.0 0.0 1.8]'\n控制乌龟以2m/s的线速度和1.8弧度/s的角速度做圆周运动\n数值参量参考 http://wiki.ros.org/ROS/YAMLCommandLine\n键盘控制rosrun turtlesim turtle_teleop_key\nturtlesim的参数服务器\nrosparam list 列出/turtlesim节点的参数列表\nrosparam get / 获得整个参数服务器上所有参数的数值\n将乌龟背景的颜色改为红色 rosparam set background_b 0\n1 2 3 $ rosparam set background_g 0 $ rosparam set background_r 0 $ rosservice call /clear 控制乌龟移动的ROS服务 通过/turtle1/pose 话题获得乌龟的位置信息\n1 2 $ rostopic type /turtle1/pose $ rosmsg show turtlesim/Pose 获得乌龟的位置坐标、方位角度和速度参数\n​\t$ rostopic echo /turtle1/pose\n使用rossevice远程控制端口移动乌龟\n​\t$ rosservice call /turtle1/teleport_absolute 1 1 0\n更多命令 http://wiki.ros.org/ROS/CommandLineTools\n第二章 构建模拟两轮ROS机器人 rviz是ROS可视化的缩写，查看模拟的机器人模型、来自机器人传感器的传感器日志和重放已记录的传感器信息\n1.安装rviz http://wiki.ros.org/rviz/Tro-ubleshooting\nROS论坛的问题页面http://answers.ros.org/questions/\n检查是否安装 1 2 ~$ roscore ~$ rosrun rviz rviz 安装$ sudo apt-get install ros-kinetic-rviz\n用户指南http://wiki.ros.org/rviz/UserGuide\n2.生成并构建ROS功能包 第一章中的创建catkin工作空间：\n1 2 3 4 5 6 7 8 9 10 ~$ mkdir -p ~/catkin_ws/src ~$ cd ~/catkin_ws/src ~/catkin_ws/src$ catkin_init_workspace ~/catkin_ws/src$ cd .. ~/catkin_ws$ catkin_make ~/catkin_ws$ source ~/catkin_ws/devel/setup.bash ~/catkin_ws$ echo \u0026#34;source ~/catkin_ws/src:opt/ros/noetic/share\u0026#34; ~/catkin_ws$ echo $ROS_PACKAGE_PATH /home/zrf/catkin_ws/src:/opt/ros/noetic/share 切换到catkin工作空间 ~/catkin_ws$ cd src/ 生成ROS功能包ros_robotics ~/catkin_ws/src$ catkin_create_pkg ros_robotics ~/catkin_ws/src$ cd .. ~/catkin_ws$ catkin_make 例 catkin_create_pkg \u0026lt;package_name\u0026gt; [depend1] [depeng2]\n3. 构建机器人URDF URDF是一种特殊定义的XML格式的文件，专门用来对机器人组建级别进行抽象的模型描述，Xacro是XML宏命令语言，能够帮助用户减少文件中的重复信息。\n在ros_robotics功能包下生成/urdf目录\n1 2 3 4 ~/catkin_ws$ cd src/ ~/catkin_ws/src$ cd ros_robotics/ ~/catkin_ws/src/ros_robotics$ mkdir urdf ~/catkin_ws/src/ros_robotics$ cd urdf/ 描述机器人模型，两个基本的URDF组件定义的一个树状结构。\n​\tlink组件描述了刚体的物理学属性（维度、初始位置、颜色等）\n​\tjoint组件描述了连接的运动学以及动态属性（连接的连接杆、关节类型、旋转轴、摩擦力和阻尼的合力等）\n~/catkin_ws/src/ros_robotics/urdf/dd_robotic.urdf:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?xml version=\u0026#39;1.0\u0026#39;?\u0026gt; \u0026lt;robot name=\u0026#34;dd_robot\u0026#34;\u0026gt; \u0026lt;!-- Base Link --\u0026gt; \u0026lt;link name=\u0026#34;base_link\u0026#34;\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 0\u0026#34; rpy=\u0026#34;0 0 0\u0026#34; /\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;0.5 0.5 0.25\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;/link\u0026gt; \u0026lt;/robot\u0026gt; 包含一个link组件，该组件的可视化外形是长宽高为0.5m，0.5m，0.25m的矩形盒子，盒子中心位于初始原点（0，0，0）处，并且在滚转（pitch）、俯仰（pitch）、偏航（yaw）三个轴向上均不存在旋转。连接杆组件命名为base_link。\nroslaunch:ROS提供的一个启动工具。简化启动多个ROS节点，简化ROS参数服务器进行参数设置 ~/catkin_ws/src/ros_robotics/launch/ddrobot_rviz.launch:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;?xml version=\u0026#39;1.0\u0026#39;?\u0026gt; \u0026lt;launch\u0026gt; \u0026lt;!-- values passed by command line input --\u0026gt; \u0026lt;arg name=\u0026#34;model\u0026#34; /\u0026gt; \u0026lt;arg name=\u0026#34;gui\u0026#34; default=\u0026#34;False\u0026#34; /\u0026gt; \u0026lt;!-- set these parameters on Parameter Server --\u0026gt; \u0026lt;param name=\u0026#34;robot_description\u0026#34; textfile=\u0026#34;$(find ros_robotics)/urdf/$(arg model)\u0026#34; /\u0026gt; \u0026lt;param name=\u0026#34;use_gui\u0026#34; value=\u0026#34;$(arg gui)\u0026#34;/\u0026gt; \u0026lt;!-- Start 3 nodes: joint_state_publisher, robot_state_publisher and rviz --\u0026gt; \u0026lt;node name=\u0026#34;joint_state_publisher\u0026#34; pkg=\u0026#34;joint_state_publisher\u0026#34; type=\u0026#34;joint_state_publisher\u0026#34; /\u0026gt; \u0026lt;node name=\u0026#34;robot_state_publisher\u0026#34; pkg=\u0026#34;robot_state_publisher\u0026#34; type=\u0026#34;state_publisher\u0026#34; /\u0026gt; \u0026lt;node name=\u0026#34;rviz\u0026#34; pkg=\u0026#34;rviz\u0026#34; type=\u0026#34;rviz\u0026#34; args=\u0026#34;-d $(find ros_robotics)/urdf.rviz\u0026#34; required=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;!-- (required = \u0026#34;true\u0026#34;) if rviz dies, entire roslaunch will be killed --\u0026gt; \u0026lt;/launch\u0026gt; 在Rviz中查看机器人模型：\n​\t(1) 命令行中设置的模型加载到参数服务器\n​\t(2) 启动发布了JointState和转换的节点\n​\t(3) 启动使用urdf.rviz文件配置的Rviz\n$ roslaunch ros_robotics ddrobot_rviz.launch model:=dd_robot.urdf\n例 roslaunch \u0026lt;package_name\u0026gt; \u0026lt;file.launch\u0026gt;\n机器人描述：robot_description是URDF文件中存储的ROS参数的名称，文件存储于参数服务器中。连接杆组件和关节组件的描述以及两者的连接方式也存储于机器人描述中。\n添加轮子、添加小脚轮、添加颜色、添加碰撞属性、添加物理学属性。\n~/catkin_ws/src/ros_robotics/urdf/dd_robotic6.urdf:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 \u0026lt;?xml version=\u0026#39;1.0\u0026#39;?\u0026gt; \u0026lt;robot name=\u0026#34;dd_robot\u0026#34;\u0026gt; \u0026lt;!-- Base Link --\u0026gt; \u0026lt;link name=\u0026#34;base_link\u0026#34;\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 0\u0026#34; rpy=\u0026#34;0 0 0\u0026#34; /\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;0.5 0.5 0.25\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;material name=\u0026#34;blue\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;0 0.5 1 1\u0026#34;/\u0026gt; \u0026lt;/material\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;!-- Base collision, mass and inertia --\u0026gt; \u0026lt;collision\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 0\u0026#34; rpy=\u0026#34;0 0 0\u0026#34; /\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;0.5 0.5 0.25\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;inertial\u0026gt; \u0026lt;mass value=\u0026#34;5\u0026#34;/\u0026gt; \u0026lt;inertia ixx=\u0026#34;0.13\u0026#34; ixy=\u0026#34;0.0\u0026#34; ixz=\u0026#34;0.0\u0026#34; iyy=\u0026#34;0.21\u0026#34; iyz=\u0026#34;0.0\u0026#34; izz=\u0026#34;0.13\u0026#34;/\u0026gt; \u0026lt;/inertial\u0026gt; \u0026lt;!-- Caster --\u0026gt; \u0026lt;visual name=\u0026#34;caster\u0026#34;\u0026gt; \u0026lt;origin xyz=\u0026#34;0.2 0 -0.125\u0026#34; rpy=\u0026#34;0 0 0\u0026#34; /\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;sphere radius=\u0026#34;0.05\u0026#34; /\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;!-- Caster collision, mass and inertia --\u0026gt; \u0026lt;collision\u0026gt; \u0026lt;origin xyz=\u0026#34;0.2 0 -0.125\u0026#34; rpy=\u0026#34;0 0 0\u0026#34; /\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;sphere radius=\u0026#34;0.05\u0026#34; /\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;inertial\u0026gt; \u0026lt;mass value=\u0026#34;0.5\u0026#34;/\u0026gt; \u0026lt;inertia ixx=\u0026#34;0.0001\u0026#34; ixy=\u0026#34;0.0\u0026#34; ixz=\u0026#34;0.0\u0026#34; iyy=\u0026#34;0.0001\u0026#34; iyz=\u0026#34;0.0\u0026#34; izz=\u0026#34;0.0001\u0026#34;/\u0026gt; \u0026lt;/inertial\u0026gt; \u0026lt;/link\u0026gt; \u0026lt;!-- Right Wheel --\u0026gt; \u0026lt;link name=\u0026#34;right_wheel\u0026#34;\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 0\u0026#34; rpy=\u0026#34;1.570795 0 0\u0026#34; /\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;cylinder length=\u0026#34;0.1\u0026#34; radius=\u0026#34;0.2\u0026#34; /\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;material name=\u0026#34;darkgray\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;.2 .2 .2 1\u0026#34;/\u0026gt; \u0026lt;/material\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;!-- Right Wheel collision, mass and inertia --\u0026gt; \u0026lt;collision\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 0\u0026#34; rpy=\u0026#34;1.570795 0 0\u0026#34; /\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;cylinder length=\u0026#34;0.1\u0026#34; radius=\u0026#34;0.2\u0026#34; /\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;inertial\u0026gt; \u0026lt;mass value=\u0026#34;0.5\u0026#34;/\u0026gt; \u0026lt;inertia ixx=\u0026#34;0.01\u0026#34; ixy=\u0026#34;0.0\u0026#34; ixz=\u0026#34;0.0\u0026#34; iyy=\u0026#34;0.005\u0026#34; iyz=\u0026#34;0.0\u0026#34; izz=\u0026#34;0.005\u0026#34;/\u0026gt; \u0026lt;/inertial\u0026gt; \u0026lt;/link\u0026gt; \u0026lt;!-- Right Wheel joint --\u0026gt; \u0026lt;joint name=\u0026#34;joint_right_wheel\u0026#34; type=\u0026#34;continuous\u0026#34;\u0026gt; \u0026lt;parent link=\u0026#34;base_link\u0026#34;/\u0026gt; \u0026lt;child link=\u0026#34;right_wheel\u0026#34;/\u0026gt; \u0026lt;origin xyz=\u0026#34;0 -0.30 0\u0026#34; rpy=\u0026#34;0 0 0\u0026#34; /\u0026gt; \u0026lt;axis xyz=\u0026#34;0 1 0\u0026#34; /\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;!-- Left Wheel --\u0026gt; \u0026lt;link name=\u0026#34;left_wheel\u0026#34;\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 0\u0026#34; rpy=\u0026#34;1.570795 0 0\u0026#34; /\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;cylinder length=\u0026#34;0.1\u0026#34; radius=\u0026#34;0.2\u0026#34; /\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;material name=\u0026#34;darkgray\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;.2 .2 .2 1\u0026#34;/\u0026gt; \u0026lt;/material\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;!-- Left Wheel collision, mass and inertia --\u0026gt; \u0026lt;collision\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 0\u0026#34; rpy=\u0026#34;1.570795 0 0\u0026#34; /\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;cylinder length=\u0026#34;0.1\u0026#34; radius=\u0026#34;0.2\u0026#34; /\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;inertial\u0026gt; \u0026lt;mass value=\u0026#34;0.5\u0026#34;/\u0026gt; \u0026lt;inertia ixx=\u0026#34;0.01\u0026#34; ixy=\u0026#34;0.0\u0026#34; ixz=\u0026#34;0.0\u0026#34; iyy=\u0026#34;0.005\u0026#34; iyz=\u0026#34;0.0\u0026#34; izz=\u0026#34;0.005\u0026#34;/\u0026gt; \u0026lt;/inertial\u0026gt; \u0026lt;/link\u0026gt; \u0026lt;!-- Left Wheel joint --\u0026gt; \u0026lt;joint name=\u0026#34;joint_left_wheel\u0026#34; type=\u0026#34;continuous\u0026#34;\u0026gt; \u0026lt;parent link=\u0026#34;base_link\u0026#34;/\u0026gt; \u0026lt;child link=\u0026#34;left_wheel\u0026#34;/\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0.30 0\u0026#34; rpy=\u0026#34;0 0 0\u0026#34; /\u0026gt; \u0026lt;axis xyz=\u0026#34;0 1 0\u0026#34; /\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;/robot\u0026gt; $ roslaunch ros_robotics ddrobot_rviz.launch model:=dd_robot6.urdf\n移动轮子（启动GUI接口）\n$ roslaunch ros_robotics ddrobot_rviz.launch model:=dd_robot6.urdf gui:=True\ntf与robot_state_publisher：\n节点robot_state_publisher订阅了JointState消息，并将机器人状态消息发布给tf坐标转换库，tf坐标转换库维护着系统中每个元素的坐标系随时间变化的关系。节点robot_state_publisher接收机器人的关节组件角度作为输入，计算出机器人连接杆组件的3D位姿，并将该位姿结果发布出去。\n物理学属性参考http://en.wikipedia.org/wiki/List_of_moments_of_inertia\nURDF工具：\n安装工具 $ sudo apt-get install liburdfdom-tools\n检查URDF文件的语法是否正确check_urdf:\n~/catkin_ws/src/ros_robotics/urdf$ check_urdf dd_robot6.urdf\n生成URDF文件对应的graphviz图表以及一个.pdf格式的图表文件urdf_to_graphiz: ~/catkin_ws/src/ros_robotics/urdf$ urdf_to_graphiz dd_robot6.urdf\n打开.pdf文件 $ evince dd_robot.pdf\nGazebo 免费的开源机器人模拟环境\n1.安装Gazebo http://answers.gazebosim.org/questions/\nROS论坛的问题页面http://answers.ros.org/questions/\n安装指南http://gazebosim.org/tutorials?cat=install\n用户手册http://gazebosim.org/tutorials\nurdf用户手册（连接杆组件和关节组件相关元素、属性的列表清单）https://classic.gazebosim.org/tutorials?tut=ros_urdf\n检查是否安装\n$ gazebo\n终止Gazebo $ rosnode list\n​ $ rosnode kill -a\n使用roslaunch 启动Gazebo $ roslaunch gazebo_ros empty_world.launch\n2.URDF修改 Gazebo支持的机器人模型文件格式为SDF,通过修改，gazebo能够自动地将URDF代码转换为SDF格式的机器人描述。\n添加gazebo标签\n\u0026lt;gazebo\u0026gt;标签必须要添加到URDF文件中。若\u0026lt;gazebo\u0026gt;标签没有和reference=“”属性一起使用的话，则意味着对应的\u0026lt;gazebo\u0026gt;元素将应用到整个机器人模型之中。\n在gazebo中指定颜色\n在Rviz中指定颜色的方法在gazebo中不适用，需要为每一个连接杆组件指定一个gazebo\u0026lt;material\u0026gt;标签。\ngazebo中的\u0026lt;visual\u0026gt;和\u0026lt;collision\u0026gt;属性描述\n~/catkin_ws/src/ros_robotics/urdf/dd_robotic.gezebo:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 \u0026lt;?xml version=\u0026#39;1.0\u0026#39;?\u0026gt; \u0026lt;robot name=\u0026#34;dd_robot\u0026#34;\u0026gt; \u0026lt;!-- Base Link --\u0026gt; \u0026lt;link name=\u0026#34;base_link\u0026#34;\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 0\u0026#34; rpy=\u0026#34;0 0 0\u0026#34; /\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;0.5 0.5 0.25\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;!-- Base collision, mass and inertia --\u0026gt; \u0026lt;collision\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 0\u0026#34; rpy=\u0026#34;0 0 0\u0026#34; /\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;0.5 0.5 0.25\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;inertial\u0026gt; \u0026lt;mass value=\u0026#34;5\u0026#34;/\u0026gt; \u0026lt;inertia ixx=\u0026#34;0.13\u0026#34; ixy=\u0026#34;0.0\u0026#34; ixz=\u0026#34;0.0\u0026#34; iyy=\u0026#34;0.21\u0026#34; iyz=\u0026#34;0.0\u0026#34; izz=\u0026#34;0.13\u0026#34;/\u0026gt; \u0026lt;/inertial\u0026gt; \u0026lt;!-- Caster --\u0026gt; \u0026lt;visual name=\u0026#34;caster\u0026#34;\u0026gt; \u0026lt;origin xyz=\u0026#34;0.2 0 -0.125\u0026#34; rpy=\u0026#34;0 0 0\u0026#34; /\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;sphere radius=\u0026#34;0.05\u0026#34; /\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;!-- Caster collision, mass and inertia --\u0026gt; \u0026lt;collision\u0026gt; \u0026lt;origin xyz=\u0026#34;0.2 0 -0.125\u0026#34; rpy=\u0026#34;0 0 0\u0026#34; /\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;sphere radius=\u0026#34;0.05\u0026#34; /\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;inertial\u0026gt; \u0026lt;mass value=\u0026#34;0.5\u0026#34;/\u0026gt; \u0026lt;inertia ixx=\u0026#34;0.0001\u0026#34; ixy=\u0026#34;0.0\u0026#34; ixz=\u0026#34;0.0\u0026#34; iyy=\u0026#34;0.0001\u0026#34; iyz=\u0026#34;0.0\u0026#34; izz=\u0026#34;0.0001\u0026#34;/\u0026gt; \u0026lt;/inertial\u0026gt; \u0026lt;/link\u0026gt; \u0026lt;gazebo reference=\u0026#34;base_link\u0026#34;\u0026gt; \u0026lt;material\u0026gt;Gazebo/Blue\u0026lt;/material\u0026gt; \u0026lt;pose\u0026gt;0 0 3 0 0 0\u0026lt;/pose\u0026gt; \u0026lt;/gazebo\u0026gt; \u0026lt;!-- Right Wheel --\u0026gt; \u0026lt;link name=\u0026#34;right_wheel\u0026#34;\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 0\u0026#34; rpy=\u0026#34;1.570795 0 0\u0026#34; /\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;cylinder length=\u0026#34;0.1\u0026#34; radius=\u0026#34;0.2\u0026#34; /\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;!-- Right Wheel collision, mass and inertia --\u0026gt; \u0026lt;collision\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 0\u0026#34; rpy=\u0026#34;1.570795 0 0\u0026#34; /\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;cylinder length=\u0026#34;0.1\u0026#34; radius=\u0026#34;0.2\u0026#34; /\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;inertial\u0026gt; \u0026lt;mass value=\u0026#34;0.5\u0026#34;/\u0026gt; \u0026lt;inertia ixx=\u0026#34;0.01\u0026#34; ixy=\u0026#34;0.0\u0026#34; ixz=\u0026#34;0.0\u0026#34; iyy=\u0026#34;0.005\u0026#34; iyz=\u0026#34;0.0\u0026#34; izz=\u0026#34;0.005\u0026#34;/\u0026gt; \u0026lt;/inertial\u0026gt; \u0026lt;/link\u0026gt; \u0026lt;gazebo reference=\u0026#34;right_wheel\u0026#34;\u0026gt; \u0026lt;material\u0026gt;Gazebo/Black\u0026lt;/material\u0026gt; \u0026lt;/gazebo\u0026gt; \u0026lt;!-- Right Wheel joint --\u0026gt; \u0026lt;joint name=\u0026#34;joint_right_wheel\u0026#34; type=\u0026#34;continuous\u0026#34;\u0026gt; \u0026lt;parent link=\u0026#34;base_link\u0026#34;/\u0026gt; \u0026lt;child link=\u0026#34;right_wheel\u0026#34;/\u0026gt; \u0026lt;origin xyz=\u0026#34;0 -0.30 0.025\u0026#34; rpy=\u0026#34;0 0 0\u0026#34; /\u0026gt; \u0026lt;axis xyz=\u0026#34;0 1 0\u0026#34; /\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;!-- Left Wheel --\u0026gt; \u0026lt;link name=\u0026#34;left_wheel\u0026#34;\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 0\u0026#34; rpy=\u0026#34;1.570795 0 0\u0026#34; /\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;cylinder length=\u0026#34;0.1\u0026#34; radius=\u0026#34;0.2\u0026#34; /\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;!-- Left Wheel collision, mass and inertia --\u0026gt; \u0026lt;collision\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 0\u0026#34; rpy=\u0026#34;1.570795 0 0\u0026#34; /\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;cylinder length=\u0026#34;0.1\u0026#34; radius=\u0026#34;0.2\u0026#34; /\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;inertial\u0026gt; \u0026lt;mass value=\u0026#34;0.5\u0026#34;/\u0026gt; \u0026lt;inertia ixx=\u0026#34;0.01\u0026#34; ixy=\u0026#34;0.0\u0026#34; ixz=\u0026#34;0.0\u0026#34; iyy=\u0026#34;0.005\u0026#34; iyz=\u0026#34;0.0\u0026#34; izz=\u0026#34;0.005\u0026#34;/\u0026gt; \u0026lt;/inertial\u0026gt; \u0026lt;/link\u0026gt; \u0026lt;gazebo reference=\u0026#34;left_wheel\u0026#34;\u0026gt; \u0026lt;material\u0026gt;Gazebo/Black\u0026lt;/material\u0026gt; \u0026lt;/gazebo\u0026gt; \u0026lt;!-- Left Wheel joint --\u0026gt; \u0026lt;joint name=\u0026#34;joint_left_wheel\u0026#34; type=\u0026#34;continuous\u0026#34;\u0026gt; \u0026lt;parent link=\u0026#34;base_link\u0026#34;/\u0026gt; \u0026lt;child link=\u0026#34;left_wheel\u0026#34;/\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0.30 0.025\u0026#34; rpy=\u0026#34;0 0 0\u0026#34; /\u0026gt; \u0026lt;axis xyz=\u0026#34;0 1 0\u0026#34;/\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;/robot\u0026gt; gazebo模型验证：$ gz sdf -p dd_robot.gazebo\n或 $ gzsdf -p $(rospack find ros_robotics)/urdf/dd_robot.gazebo\n~/catkin_ws/src/ros_robotics/launch/ddrobot_gezebo.launch:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;launch\u0026gt; \u0026lt;!-- We resume the logic in gazebo_ros package empty_world.launch, --\u0026gt; \u0026lt;!-- changing only the name of the world to be launched --\u0026gt; \u0026lt;include file=\u0026#34;$(find gazebo_ros)/launch/empty_world.launch\u0026#34;\u0026gt; \u0026lt;arg name=\u0026#34;world_name\u0026#34; value=\u0026#34;$(find ros_robotics)/worlds/ddrobot.world\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;paused\u0026#34; default=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;use_sim_time\u0026#34; default=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;gui\u0026#34; default=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;headless\u0026#34; default=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;debug\u0026#34; default=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/include\u0026gt; \u0026lt;!-- Spawn dd_robot into Gazebo --\u0026gt; \u0026lt;node name=\u0026#34;spawn_urdf\u0026#34; pkg=\u0026#34;gazebo_ros\u0026#34; type=\u0026#34;spawn_model\u0026#34; output=\u0026#34;screen\u0026#34; args=\u0026#34;-file $(find ros_robotics)/urdf/dd_robot.gazebo -urdf -model ddrobot\u0026#34; /\u0026gt; \u0026lt;/launch\u0026gt; 由gazebo_ros功能包中的empty_world.launch修改而来，改变了world_name参数，变为了ddrobot.world。\n基于URDF的dd_robot机器人模型使用来自gazebo_ros ROS节点的spawn_model服务启动于Gazebo中，若想要复用或者分享上述代码，建议在自己的ros_robotics功能包的package.xml文件中添加相应的依赖： \u0026lt;exec_depend\u0026gt;gazebo_ros\u0026lt;/exec_depend\u0026gt;\nddrobot.world环境模型文件包含一个地平面模型和两个圆锥形的建筑模型 ~/catkin_ws/src/ros_robotics/world/ddrobot.world:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; ?\u0026gt; \u0026lt;sdf version=\u0026#34;1.4\u0026#34;\u0026gt; \u0026lt;world name=\u0026#34;default\u0026#34;\u0026gt; \u0026lt;include\u0026gt; \u0026lt;uri\u0026gt;model://ground_plane\u0026lt;/uri\u0026gt; \u0026lt;/include\u0026gt; \u0026lt;include\u0026gt; \u0026lt;uri\u0026gt;model://sun\u0026lt;/uri\u0026gt; \u0026lt;/include\u0026gt; \u0026lt;include\u0026gt; \u0026lt;uri\u0026gt;model://construction_cone\u0026lt;/uri\u0026gt; \u0026lt;name\u0026gt;construction_cone\u0026lt;/name\u0026gt; \u0026lt;pose\u0026gt;-3.0 0 0 0 0 0\u0026lt;/pose\u0026gt; \u0026lt;/include\u0026gt; \u0026lt;include\u0026gt; \u0026lt;uri\u0026gt;model://construction_cone\u0026lt;/uri\u0026gt; \u0026lt;name\u0026gt;construction_cone\u0026lt;/name\u0026gt; \u0026lt;pose\u0026gt;3.0 0 0 0 0 0\u0026lt;/pose\u0026gt; \u0026lt;/include\u0026gt; \u0026lt;/world\u0026gt; \u0026lt;/sdf\u0026gt; 在gazebo中启动机器人模型ddrobot $ roslaunch ros_robotics ddrobot_gazebo.launch\nSDF手册\thttp://sdformat.org/spec 3.MATLAB 机器人系统工具箱的ROS支持http://www.mathworks.com/hardware-support/robot-operating-system.html\n示例http://www.mathworks.com/help/robotics/examples/get-started-with-ros.html\n第三章 TurtleBot机器人操控 机器人运动控制相关http://kobuki.yujinrobot.com/about2/\nTurtleBot维基百科https://wiki.ros.org/Robots/TurtleBot\nTurtleBot相关内容参考手册http://learn.turtlebot.com/\nROS网络连接https://wiki.ros.org/ROS/NetworkSetup\n​\thttps://wiki.ros.org/ROS/Tutorials/MultipleMachines\nROS_MASTER_URI、ROS_IP和ROS_HOSTNAME变量的相关描述https://wiki.ros.org/ROS/EnvironmentVariables\nPython脚本语言 ROS客户端库 http://wiki.ros.org/rospy\n用户手册http://wiki.ros.org/rospy_tutorials\n​\thttp://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber(python)\nrqt界面工具 http://wiki.ros.org/rqt/Plugins\nTurtleBot3 http://turtlebot3.robotis.com/en/latest/\n3D传感器工作原理https://www.youtube.com/watch?v=uq9SEJxZiUg\ngmapping http://openslam.org/gmapping.html\nTurtlebot3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 mkdir -p ~/turtlebot3_ws/src cd ~/turtlebot3_ws/src catkin_init_workspace cd .. catkin_make cd turtlebot3_ws/src/ sudo apt-get install ros-noetic-joy ros-noetic-teleop-twist-joy ros-noetic-teleop-twist-keyboard ros-noetic-laser-proc ros-noetic-rgbd-launch ros-noetic-depthimage-to-laserscan ros-noetic-rosserial-arduino ros-noetic-rosserial-python ros-noetic-rosserial-server ros-noetic-rosserial-client ros-noetic-rosserial-msgs ros-noetic-amcl ros-noetic-map-server ros-noetic-move-base ros-noetic-urdf ros-noetic-xacro ros-noetic-compressed-image-transport ros-noetic-rqt-image-view ros-noetic-gmapping ros-noetic-navigation ros-noetic-interactive-markers git clone https://github.com/ROBOTIS-GIT/turtlebot3_simulations.git git clone https://github.com/ROBOTIS-GIT/turtlebot3_msgs.git git clone https://github.com/ROBOTIS-GIT/turtlebot3.git cd turtlebot3_ws/ catkin_make vim ~/.bashrc\n1 2 3 export ROS_MASTER_URI=http://localhost:11311/ export ROS_HOSTNAME=localhost export TURTLEBOT3_MODEL=burger source ~/.bashrc\n在riviz中启动turtlebot3模拟软件 1 2 3 roslaunch turtlebot3_fake turtlebot3_fake.launch roslaunch turtlebot3_teleop turtlebot3_teleop_key.launch 在gazebo中启动turtlebot3模拟软件 1 2 3 4 5 6 7 8 roslaunch turtlebot3_gazebo turtlebot3_empty_world.launch 终止上述进程，打开一个包含有多个物体的场景 roslaunch turtlebot3_gazebo turtlebot3_world.launch roslaunch turtlebot3_teleop turtlebot3_teleop_key.launch 关闭键盘控制节点，打开自主导航和运动 roslaunch turtlebot3_gazebo turtlebot3_simulation.launch roslaunch turtlebot3_gazebo turtlebot3_gazebo_rviz.launch 实际Turtlebot3机器人 1.远程电脑安装Ubuntu、ROS、Turtlebot3、git克隆turtlebot3的包后，编译 2.SBC上安装Ubuntu、ROS、Turtlebot3、git克隆turtlebot3的包后，编译 3.Turtlebot3设置udev规则，树莓派上的USB口设置为无需root权限，保证外设设备正常运行\nTurtlebot3与远程计算机网络连接 1.Turtlebot： export ROS_MASTER_URI=http://IP_OF_REMOTE_PC:11311/ export ROS_HOSTNAME=IP_OF_Turtlebot 树莓派设置网络中始终连接到指定的网络 2.Remote PC： export ROS_MASTER_URI=http://IP_OF_REMOTE_PC:11311/ export ROS_HOSTNAME=IP_OF_REMOTE_PC\nSSH连接 1.树莓派上检查SSH状态 sudo service ssh status 2.inactive则重启SSH服务：sudo service ssh restart sudo systemctl enable ssh 3.远程计算机上建立连接 ssh \u0026lt;username\u0026gt;@\u0026lt;IP_OF_Turtlebot\u0026gt; 检测ping \u0026lt;IP_OF_Turtlebot\u0026gt; 4.如果ping能够建立但SSH不能正常工作，重新安装SSH\n1 2 sudo apt-get remove openssh-client openssh-server sudo apt-get install openssh-client openssh-server 第四章 Turtlebot机器人导航(记录，没运行过) 配置3D传感器Kinect Kinect的环境变量： export KINECT_DRIVER=freenect export TURTLEBOT_3D_SENSOR=kinect\n独立模式下测试3D传感器 Turtlebot2上运行\n1 2 3 4 5 6 7 8 9 启动turtlebot的minimal launch roslaunch turtlebot3_bringup minimal.launch 启动相机nodelet包 roslaunch freenect_launch freenect.launch ASUS或Carmine: roslaunch openni2_launch openni2.launch Inter RealSense: roslaunch realsense_camera r200_nodelet_default.launch 运行ROS节点进行可视化 使用Image Viewer可视化数据 1 2 3 4 5 6 7 8 9 ssh \u0026lt;username\u0026gt;@\u0026lt;IP_OF_Turtlebot\u0026gt; roslaunch turtlebot_bringup minimal.launch ssh \u0026lt;username\u0026gt;@\u0026lt;IP_OF_Turtlebot\u0026gt; roslaunch freenect_launch freenect.launch rosrun image_view image_view image:=/camera/rgb/image_color 深度图像则是： rosrun image_view image_view image:=/camera/depth/image 使用Riz可视化数据 1 2 3 4 5 6 7 8 ssh \u0026lt;username\u0026gt;@\u0026lt;IP_OF_Turtlebot\u0026gt; roslaunch turtlebot_bringup minimal.launch 启动3D传感器相关软件（设置TURTLEBOT_3D_SENSOR环境变量）： ssh \u0026lt;username\u0026gt;@\u0026lt;IP_OF_Turtlebot\u0026gt; roslaunch turtlebot_bringup 3dsensor.launch rosrun turtlebot_rviz_launchers view_robot.launch Turtlebot机器人导航 构建地图\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ssh \u0026lt;username\u0026gt;@\u0026lt;IP_OF_Turtlebot\u0026gt; roslaunch turtlebot_bringup minimal.launch 启动gmapping ssh \u0026lt;username\u0026gt;@\u0026lt;IP_OF_Turtlebot\u0026gt; roslaunch turtlebot_navigation gmapping_demo.launch 启动Rviz roslaunch turtlebot_rviz_launchers view_navigation.launch Displays(Grid/RobotModel/LaseScan/Bumper Hit/Map/GlobalMap/LocalMap/Amcl Particle Swarm/Full Plan) 键盘控制 roslaunch turtlebot_teleop turtlebot_teleop_key.launch 显示了完整的地图后，保存地图 ssh \u0026lt;username\u0026gt;@\u0026lt;IP_OF_Turtlebot\u0026gt; rosrun map_server map_saver -f /home/\u0026lt;turtlebot\u0026#39;s username\u0026gt;/my_map \u0026lt;turtlebot\u0026#39;s username\u0026gt;SSH登陆Turtlebot后使用pwd命令查看 gmapping功能包基于OpenSlam(http://openslam.org/gmapping.html)\nTurtlebot机器人自主导航 无人控制模式下驱动 1 2 3 4 5 6 7 8 ssh \u0026lt;username\u0026gt;@\u0026lt;IP_OF_Turtlebot\u0026gt; roslaunch turtlebot_bringup minimal.launch 启动amcl处理模块 ssh \u0026lt;username\u0026gt;@\u0026lt;IP_OF_Turtlebot\u0026gt; roslaunch turtlebot_navigation amcl_demo.launch map_file:=home/\u0026lt;turtlebot\u0026#39;s username\u0026gt;/my_map.yaml rosrun turtlebot_rviz_launchers view_navigation.launch 导航至目标点 1 2 3 4 5 6 7 8 9 ssh \u0026lt;username\u0026gt;@\u0026lt;IP_OF_Turtlebot\u0026gt; roslaunch turtlebot_bringup minimal.launch rostopic echo /odom/pose/pose ssh \u0026lt;username\u0026gt;@\u0026lt;IP_OF_Turtlebot\u0026gt; roslaunch turtlebot_navigation gmapping_demo.launch rostopic pub /move_base_simple/goal geometry_msgs/PoseStamped \u0026#39;{header:{ frame_id:\u0026#34;map\u0026#34;} ,pose:{ position:{ x: 1.0,y: 0,z: 0 },orientation:{ x: 1.0,y: 0,z: 0,w: 1 }}}\u0026#39; 基于python脚本与地图实现航路点导航 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ssh \u0026lt;username\u0026gt;@\u0026lt;IP_OF_Turtlebot\u0026gt; roslaunch turtlebot_bringup minimal.launch 启动acml程序 ssh \u0026lt;username\u0026gt;@\u0026lt;IP_OF_Turtlebot\u0026gt; roslaunch turtlebot_navigation amcl_demo.launch map_file:=home/\u0026lt;turtlebot\u0026#39;s username\u0026gt;/my_map.yaml 启动rviz并显示地图 rosrun turtlebot_rviz_launchers view_navigation.launch 地图上第一机器人的位置 rostopic echo /initialpose 定义路径点 rostopic echo /clicked_point 使用Python代码移动机器人 python MoveTBtoGoalPoints.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #!/usr/bin/env python # MoveTBtoGoalPoints import rospy import actionlib # Use the actionlib package for client and server from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal # Define Goal Points and orientations for TurtleBot in a list GoalPoints = [ [(3.0, 0.0, 0.0), (0.0, 0.0, 0.0, 1.0)] , [(3.0, 3.6, 0.0), (0.0, 0.0, 0.707, 0.707)]] # The function assign_goal initializes the goal_pose variable as a MoveBaseGoal action type. # def assign_goal(pose): goal_pose = MoveBaseGoal() goal_pose.target_pose.header.frame_id = \u0026#39;map\u0026#39; goal_pose.target_pose.pose.position.x = pose[0][0] goal_pose.target_pose.pose.position.y = pose[0][1] goal_pose.target_pose.pose.position.z = pose[0][2] goal_pose.target_pose.pose.orientation.x = pose[1][0] goal_pose.target_pose.pose.orientation.y = pose[1][1] goal_pose.target_pose.pose.orientation.z = pose[1][2] goal_pose.target_pose.pose.orientation.w = pose[1][3] return goal_pose if __name__ == \u0026#39;__main__\u0026#39;: rospy.init_node(\u0026#39;MoveTBtoGoalPoints\u0026#39;) # Create a SimpleActionClient of a move_base action type and wait for server. client = actionlib.SimpleActionClient(\u0026#39;move_base\u0026#39;, MoveBaseAction) client.wait_for_server() # for TBpose in GoalPoints: TBgoal = assign_goal(TBpose) # For each goal point assign pose client.send_goal(TBgoal) client.wait_for_result() if(client.get_state() == GoalStatus.SUCCEEDED): rospy.loginfo(\u0026#34;success\u0026#34;) else: rospy.loginfo(\u0026#34;failed\u0026#34;) Turtlebot3机器人的SLAM 远程计算机上启动ROS MASTER roscore\n1 2 3 4 5 6 7 8 9 10 11 12 13 ssh \u0026lt;username\u0026gt;@\u0026lt;IP_OF_Turtlebot\u0026gt; roslaunch turtlebot3_bringup turtlebot3_robot.launch export TURTLEBOT3_MODEL=burger roslaunch turtlebot3_slam turtlebot3_slam.launch 可视化 rosrun rviz rviz -d `rospack find turtlebot3_slam`/rviz/turtlebot3_slam.rviz roslaunch turtlebot3_teleop turtlebot3_teleop_key.launch 保存地图 rosrun map_server map_saver -f ~/map Turtlebot3自主导航\n1 2 3 4 5 6 启动导航软件 export TURTLEBOT3_MODEL=burger roslaunch turtlebot3_navigation turtlebot3_navigation.launch map_file:=map.yaml 可视化 rosrun rviz rviz -d `rospack find turtlebot3_navigation`/rviz/turtlebot3_nav.rviz ROS导航 http://wiki.ros.org/navigation http://wiki.ros.org/navigation/Tutorials/RobotSetup http://wiki.ros.org/navigation/Tutorials/Navigation%20Tuning20Guide\n第五章 构建模拟的机器人手臂 Xacro是用于ROS的XML宏语言，提供一系列的宏操作来替换一些重复性的声明语句。\n1.利用Xacro建立一个关节式机器人手臂URDF ~/catkin_ws/src/ros_robotics/urdf/rrbot.xacro:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;!-- Revolute-Revolute Manipulator --\u0026gt; \u0026lt;robot name=\u0026#34;rrbot\u0026#34; xmlns:xacro=\u0026#34;http://www.ros.org/wiki/xacro\u0026#34;\u0026gt; \u0026lt;!-- Constants for robot dimensions --\u0026gt; \u0026lt;xacro:property name=\u0026#34;width\u0026#34; value=\u0026#34;0.1\u0026#34; /\u0026gt; \u0026lt;!-- Beams are square in length and width --\u0026gt; \u0026lt;xacro:property name=\u0026#34;height1\u0026#34; value=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;!-- Link 1 --\u0026gt; \u0026lt;xacro:property name=\u0026#34;height2\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;!-- Link 2 --\u0026gt; \u0026lt;xacro:property name=\u0026#34;height3\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;!-- Link 3 --\u0026gt; \u0026lt;xacro:property name=\u0026#34;axle_offset\u0026#34; value=\u0026#34;0.05\u0026#34; /\u0026gt; \u0026lt;!-- Space between joint and end of beam --\u0026gt; \u0026lt;xacro:property name=\u0026#34;damp\u0026#34; value=\u0026#34;0.7\u0026#34; /\u0026gt; \u0026lt;!-- damping coefficient --\u0026gt; \u0026lt;!-- Base Link --\u0026gt; \u0026lt;link name=\u0026#34;base_link\u0026#34;\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 ${height1/2}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;${width} ${width} ${height1}\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;collision\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 ${height1/2}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;${width} ${width} ${height1}\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;inertial\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 ${height1/2}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;mass value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;inertia ixx=\u0026#34;1.0\u0026#34; ixy=\u0026#34;0.0\u0026#34; ixz=\u0026#34;0.0\u0026#34; iyy=\u0026#34;1.0\u0026#34; iyz=\u0026#34;0.0\u0026#34; izz=\u0026#34;1.0\u0026#34;/\u0026gt; \u0026lt;/inertial\u0026gt; \u0026lt;/link\u0026gt; \u0026lt;!-- Joint between Base Link and Middle Link --\u0026gt; \u0026lt;joint name=\u0026#34;joint_base_mid\u0026#34; type=\u0026#34;revolute\u0026#34;\u0026gt; \u0026lt;parent link=\u0026#34;base_link\u0026#34;/\u0026gt; \u0026lt;child link=\u0026#34;mid_link\u0026#34;/\u0026gt; \u0026lt;origin xyz=\u0026#34;0 ${width} ${height1 - axle_offset}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;axis xyz=\u0026#34;0 1 0\u0026#34;/\u0026gt; \u0026lt;dynamics damping=\u0026#34;${damp}\u0026#34;/\u0026gt; \u0026lt;limit effort=\u0026#34;100.0\u0026#34; velocity=\u0026#34;0.5\u0026#34; lower=\u0026#34;-3.14\u0026#34; upper=\u0026#34;3.14\u0026#34; /\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;!-- Middle Link --\u0026gt; \u0026lt;link name=\u0026#34;mid_link\u0026#34;\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 ${height2/2 - axle_offset}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;${width} ${width} ${height2}\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;collision\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 ${height2/2 - axle_offset}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;${width} ${width} ${height2}\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;inertial\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 ${height2/2 - axle_offset}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;mass value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;inertia ixx=\u0026#34;1.0\u0026#34; ixy=\u0026#34;0.0\u0026#34; ixz=\u0026#34;0.0\u0026#34; iyy=\u0026#34;1.0\u0026#34; iyz=\u0026#34;0.0\u0026#34; izz=\u0026#34;1.0\u0026#34;/\u0026gt; \u0026lt;/inertial\u0026gt; \u0026lt;/link\u0026gt; \u0026lt;!-- Joint between Middle Link and Top Link --\u0026gt; \u0026lt;joint name=\u0026#34;joint_mid_top\u0026#34; type=\u0026#34;revolute\u0026#34;\u0026gt; \u0026lt;parent link=\u0026#34;mid_link\u0026#34;/\u0026gt; \u0026lt;child link=\u0026#34;top_link\u0026#34;/\u0026gt; \u0026lt;origin xyz=\u0026#34;0 ${width} ${height2 - axle_offset*2}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;axis xyz=\u0026#34;0 1 0\u0026#34;/\u0026gt; \u0026lt;dynamics damping=\u0026#34;${damp}\u0026#34;/\u0026gt; \u0026lt;limit effort=\u0026#34;100.0\u0026#34; velocity=\u0026#34;0.5\u0026#34; lower=\u0026#34;-3.14\u0026#34; upper=\u0026#34;3.14\u0026#34; /\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;!-- Top Link --\u0026gt; \u0026lt;link name=\u0026#34;top_link\u0026#34;\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 ${height3/2 - axle_offset}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;${width} ${width} ${height3}\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;collision\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 ${height3/2 - axle_offset}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;${width} ${width} ${height3}\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;inertial\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 ${height3/2 - axle_offset}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;mass value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;inertia ixx=\u0026#34;1.0\u0026#34; ixy=\u0026#34;0.0\u0026#34; ixz=\u0026#34;0.0\u0026#34; iyy=\u0026#34;1.0\u0026#34; iyz=\u0026#34;0.0\u0026#34; izz=\u0026#34;1.0\u0026#34;/\u0026gt; \u0026lt;/inertial\u0026gt; \u0026lt;/link\u0026gt; \u0026lt;/robot\u0026gt; 包含三连杆元素，长宽均为0.1m，高分别为2m，1m，1m。base_link的原点坐标为（0,0,1），目的在于机械臂在Rviz下能够位于地面之上。\n关节元素两个新的标签： \u0026lt;dynamics damping\u0026gt;和 \u0026lt;limit\u0026gt;，动态阻尼系数设置为0.7Nms/rad，该阻尼是对任意速度的关节施加的反向作用力的数值之和，用于降低机械臂的运动速度。\n2.扩展Xacro 将所有的宏进行扩展，并输出一个生成的URDF文件。\n位于文件相同的目录下运行\t$ rosrun xacro xacro --inorder rrbot.xacro \u0026gt; rrbot.urdf\n通过launch文件生成URDF文件：\n1 2 3 \u0026lt;param name=\u0026#34;robot_description\u0026#34; command=\u0026#34;$(find xacro)/xacro --inorder \u0026#39;$(find ros_robotics)/urdf/$(arg model)\u0026#39;\u0026#34; /\u0026gt; ~/catkin_ws/src/ros_robotics/launch/rrbot_rviz.launch:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;launch\u0026gt; \u0026lt;!-- set parameter on Parameter Server --\u0026gt; \u0026lt;arg name=\u0026#34;model\u0026#34; /\u0026gt; \u0026lt;param name=\u0026#34;robot_description\u0026#34; command=\u0026#34;$(find xacro)/xacro --inorder \u0026#39;$(find ros_robotics)/urdf/$(arg model)\u0026#39;\u0026#34; /\u0026gt; \u0026lt;!-- send joint values from gui --\u0026gt; \u0026lt;node name=\u0026#34;joint_state_publisher\u0026#34; pkg=\u0026#34;joint_state_publisher\u0026#34; type=\u0026#34;joint_state_publisher\u0026#34;\u0026gt; \u0026lt;param name=\u0026#34;use_gui\u0026#34; value=\u0026#34;TRUE\u0026#34;/\u0026gt; \u0026lt;/node\u0026gt; \u0026lt;!-- use joint positions to update tf --\u0026gt; \u0026lt;node name=\u0026#34;robot_state_publisher\u0026#34; pkg=\u0026#34;robot_state_publisher\u0026#34; type=\u0026#34;robot_state_publisher\u0026#34;/\u0026gt; \u0026lt;!-- visualize robot model in 3D --\u0026gt; \u0026lt;node name=\u0026#34;rviz\u0026#34; pkg=\u0026#34;rviz\u0026#34; type=\u0026#34;rviz\u0026#34; args=\u0026#34;-d $(find ros_robotics)/urdf.rviz\u0026#34; required=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/launch\u0026gt; 需要将.bashrc文件(主目录隐藏文件)中已经添加了自己的环境变量ROS_MASTER_URI和ROS_HOSTNAME或ROS_IP注释掉，添加以下两行\n1 2 export ROS_MASTER_URI=http://localhost:11311// export ROS_HOSTNAME=localhost 运行rviz的roslaunch命令:\n$ roslaunch ros_robotics rrbot_rviz.launch model:=rrbot.xzcro\n3.添加颜色 ~/catkin_ws/src/ros_robotics/urdf/materials.xacro:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;robot\u0026gt; \u0026lt;material name=\u0026#34;black\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;0.0 0.0 0.0 1.0\u0026#34;/\u0026gt; \u0026lt;/material\u0026gt; \u0026lt;material name=\u0026#34;blue\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;0.0 0.0 0.8 1.0\u0026#34;/\u0026gt; \u0026lt;/material\u0026gt; \u0026lt;material name=\u0026#34;green\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;0.0 1.0 0.0 1.0\u0026#34;/\u0026gt; \u0026lt;/material\u0026gt; \u0026lt;material name=\u0026#34;grey\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;0.2 0.2 0.2 1.0\u0026#34;/\u0026gt; \u0026lt;/material\u0026gt; \u0026lt;material name=\u0026#34;orange\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;${255/255} ${108/255} ${10/255} 1.0\u0026#34;/\u0026gt; \u0026lt;/material\u0026gt; \u0026lt;material name=\u0026#34;brown\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;${222/255} ${207/255} ${195/255} 1.0\u0026#34;/\u0026gt; \u0026lt;/material\u0026gt; \u0026lt;material name=\u0026#34;red\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;0.8 0.0 0.0 1.0\u0026#34;/\u0026gt; \u0026lt;/material\u0026gt; \u0026lt;material name=\u0026#34;white\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;1.0 1.0 1.0 1.0\u0026#34;/\u0026gt; \u0026lt;/material\u0026gt; \u0026lt;/robot\u0026gt; 在每一个连接杆组件添加\n1 \u0026lt;xacro:include filename=\u0026#34;$(find ros_robotics)/urdf/materials.xacro\u0026#34; /\u0026gt; 4.惯性的宏使用 1 2 3 4 5 6 7 8 9 10 \u0026lt;!-- Default Inertial --\u0026gt; \u0026lt;xacro:macro name=\u0026#34;default_inertial\u0026#34; params=\u0026#34;z_value i_value mass\u0026#34;\u0026gt; \u0026lt;inertial\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 ${z_value}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;mass value=\u0026#34;${mass}\u0026#34; /\u0026gt; \u0026lt;inertia ixx=\u0026#34;${i_value}\u0026#34; ixy=\u0026#34;0.0\u0026#34; ixz=\u0026#34;0.0\u0026#34; iyy=\u0026#34;${i_value}\u0026#34; iyz=\u0026#34;0.0\u0026#34; izz=\u0026#34;${i_value}\u0026#34; /\u0026gt; \u0026lt;/inertial\u0026gt; \u0026lt;/xacro:macro\u0026gt; 在每一个link里，使用以下代码替换完整的\u0026lt;inertial\u0026gt;块：\n1 \u0026lt;xacro:default_inertial z_value=\u0026#34;${height1/2}\u0026#34; i_value=\u0026#34;1.0\u0026#34; mass=\u0026#34;1\u0026#34;/\u0026gt; 5.添加抓手 使用来自PR2机器人的网格文件\n1 2 3 4 **主文件rrbot4.xacro中添加：** ​```xml \u0026lt;xacro:include filename=\u0026#34;$(find ros_robotics)/urdf/gripper.xacro\u0026#34; /\u0026gt; 四个连接杆分别为left_gripper、left_tip、right_gripper、right_tip\npr2_description是ros-kinetic-desktop-full的组成部分，可以在/opt/ros/kinetic/share/pr2_description/meshes/gripper_v0目录找到文件\n需要在ros_robotics功能包目录下创建一个/meshes文件目录，并将1_finger.dae和1_finger_tip.dae复制到该目录下。\nleft_gripper:\n1 2 3 4 5 6 7 \u0026lt;link name=\u0026#34;left_gripper\u0026#34;\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;mesh filename=\u0026#34;package://ros_robotics/meshes/l_finger.dae\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/visual\u0026gt; ~/catkin_ws/src/ros_robotics/urdf/gripper.xacro:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;robot xmlns:xacro=\u0026#34;http://www.ros.org/wiki/xacro\u0026#34;\u0026gt; \u0026lt;!-- Gripper --\u0026gt; \u0026lt;joint name=\u0026#34;left_gripper_joint\u0026#34; type=\u0026#34;revolute\u0026#34;\u0026gt; \u0026lt;parent link=\u0026#34;top_link\u0026#34;/\u0026gt; \u0026lt;child link=\u0026#34;left_gripper\u0026#34;/\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 ${height2 - axle_offset}\u0026#34; rpy=\u0026#34;0 -1.57 0\u0026#34;/\u0026gt; \u0026lt;axis xyz=\u0026#34;0 0 -1\u0026#34;/\u0026gt; \u0026lt;limit effort=\u0026#34;30.0\u0026#34; lower=\u0026#34;-0.548\u0026#34; upper=\u0026#34;0.0\u0026#34; velocity=\u0026#34;0.1\u0026#34;/\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;link name=\u0026#34;left_gripper\u0026#34;\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;mesh filename=\u0026#34;package://ros_robotics/meshes/l_finger.dae\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;collision\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0.05 0.025 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;0.1 0.05 0.05\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;xacro:default_inertial z_value=\u0026#34;0\u0026#34; i_value=\u0026#34;1e-6\u0026#34; mass=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/link\u0026gt; \u0026lt;joint name=\u0026#34;left_tip_joint\u0026#34; type=\u0026#34;fixed\u0026#34;\u0026gt; \u0026lt;parent link=\u0026#34;left_gripper\u0026#34;/\u0026gt; \u0026lt;child link=\u0026#34;left_tip\u0026#34;/\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;link name=\u0026#34;left_tip\u0026#34;\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0.09137 0.00495 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;mesh filename=\u0026#34;package://ros_robotics/meshes/l_finger_tip.dae\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;collision\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0.11 0.005 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;0.02 0.03 0.02\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;xacro:default_inertial z_value=\u0026#34;0\u0026#34; i_value=\u0026#34;1e-6\u0026#34; mass=\u0026#34;1e-5\u0026#34;/\u0026gt; \u0026lt;/link\u0026gt; \u0026lt;joint name=\u0026#34;right_gripper_joint\u0026#34; type=\u0026#34;revolute\u0026#34;\u0026gt; \u0026lt;parent link=\u0026#34;top_link\u0026#34;/\u0026gt; \u0026lt;child link=\u0026#34;right_gripper\u0026#34;/\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 ${height2 - axle_offset}\u0026#34; rpy=\u0026#34;0 -1.57 0\u0026#34;/\u0026gt; \u0026lt;axis xyz=\u0026#34;0 0 1\u0026#34;/\u0026gt; \u0026lt;limit effort=\u0026#34;30.0\u0026#34; lower=\u0026#34;-0.548\u0026#34; upper=\u0026#34;0.0\u0026#34; velocity=\u0026#34;0.1\u0026#34;/\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;link name=\u0026#34;right_gripper\u0026#34;\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;origin rpy=\u0026#34;3.1415 0 0\u0026#34; xyz=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;mesh filename=\u0026#34;package://ros_robotics/meshes/l_finger.dae\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;collision\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0.05 -0.025 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;0.1 0.05 0.05\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;xacro:default_inertial z_value=\u0026#34;0\u0026#34; i_value=\u0026#34;1e-6\u0026#34; mass=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/link\u0026gt; \u0026lt;joint name=\u0026#34;right_tip_joint\u0026#34; type=\u0026#34;fixed\u0026#34;\u0026gt; \u0026lt;parent link=\u0026#34;right_gripper\u0026#34;/\u0026gt; \u0026lt;child link=\u0026#34;right_tip\u0026#34;/\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;link name=\u0026#34;right_tip\u0026#34;\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;origin rpy=\u0026#34;-3.1415 0 0\u0026#34; xyz=\u0026#34;0.09137 0.00495 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;mesh filename=\u0026#34;package://ros_robotics/meshes/l_finger_tip.dae\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;collision\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0.11 -0.005 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;0.02 0.03 0.02\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;xacro:default_inertial z_value=\u0026#34;0\u0026#34; i_value=\u0026#34;1e-6\u0026#34; mass=\u0026#34;1e-5\u0026#34;/\u0026gt; \u0026lt;/link\u0026gt; \u0026lt;transmission name=\u0026#34;gripper_transmission1\u0026#34;\u0026gt; \u0026lt;type\u0026gt;transmission_interface/SimpleTransmission\u0026lt;/type\u0026gt; \u0026lt;joint name=\u0026#34;left_gripper_joint\u0026#34;\u0026gt; \u0026lt;hardwareInterface\u0026gt;hardware_interface/EffortJointInterface\u0026lt;/hardwareInterface\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;actuator name=\u0026#34;gripper_motor1\u0026#34;\u0026gt; \u0026lt;mechanicalReduction\u0026gt;1\u0026lt;/mechanicalReduction\u0026gt; \u0026lt;/actuator\u0026gt; \u0026lt;/transmission\u0026gt; \u0026lt;transmission name=\u0026#34;gripper_transmission2\u0026#34;\u0026gt; \u0026lt;type\u0026gt;transmission_interface/SimpleTransmission\u0026lt;/type\u0026gt; \u0026lt;joint name=\u0026#34;right_gripper_joint\u0026#34;\u0026gt; \u0026lt;hardwareInterface\u0026gt;hardware_interface/EffortJointInterface\u0026lt;/hardwareInterface\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;actuator name=\u0026#34;gripper_motor2\u0026#34;\u0026gt; \u0026lt;mechanicalReduction\u0026gt;1\u0026lt;/mechanicalReduction\u0026gt; \u0026lt;/actuator\u0026gt; \u0026lt;/transmission\u0026gt; \u0026lt;/robot\u0026gt; ~/catkin_ws/src/ros_robotics/urdf/rrbot3.xacro:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;!-- Revolute-Revolute Manipulator --\u0026gt; \u0026lt;robot name=\u0026#34;rrbot\u0026#34; xmlns:xacro=\u0026#34;http://www.ros.org/wiki/xacro\u0026#34;\u0026gt; \u0026lt;!-- Constants for robot dimensions --\u0026gt; \u0026lt;xacro:property name=\u0026#34;width\u0026#34; value=\u0026#34;0.1\u0026#34; /\u0026gt; \u0026lt;!-- Beams are square in length and width --\u0026gt; \u0026lt;xacro:property name=\u0026#34;height1\u0026#34; value=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;!-- Link 1 --\u0026gt; \u0026lt;xacro:property name=\u0026#34;height2\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;!-- Link 2 --\u0026gt; \u0026lt;xacro:property name=\u0026#34;height3\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;!-- Link 3 --\u0026gt; \u0026lt;xacro:property name=\u0026#34;axle_offset\u0026#34; value=\u0026#34;0.05\u0026#34; /\u0026gt; \u0026lt;!-- Space between joint and end of beam --\u0026gt; \u0026lt;xacro:property name=\u0026#34;damp\u0026#34; value=\u0026#34;0.7\u0026#34; /\u0026gt; \u0026lt;!-- damping coefficient --\u0026gt; \u0026lt;!-- Default Inertial --\u0026gt; \u0026lt;xacro:macro name=\u0026#34;default_inertial\u0026#34; params=\u0026#34;z_value i_value mass\u0026#34;\u0026gt; \u0026lt;inertial\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 ${z_value}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;mass value=\u0026#34;${mass}\u0026#34; /\u0026gt; \u0026lt;inertia ixx=\u0026#34;${i_value}\u0026#34; ixy=\u0026#34;0.0\u0026#34; ixz=\u0026#34;0.0\u0026#34; iyy=\u0026#34;${i_value}\u0026#34; iyz=\u0026#34;0.0\u0026#34; izz=\u0026#34;${i_value}\u0026#34; /\u0026gt; \u0026lt;/inertial\u0026gt; \u0026lt;/xacro:macro\u0026gt; \u0026lt;!-- Import Rviz colors --\u0026gt; \u0026lt;xacro:include filename=\u0026#34;$(find ros_robotics)/urdf/materials.xacro\u0026#34; /\u0026gt; \u0026lt;!-- Import gripper URDF --\u0026gt; \u0026lt;xacro:include filename=\u0026#34;$(find ros_robotics)/urdf/gripper.xacro\u0026#34; /\u0026gt; \u0026lt;!-- Base Link --\u0026gt; \u0026lt;link name=\u0026#34;base_link\u0026#34;\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 ${height1/2}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;${width} ${width} ${height1}\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;material name=\u0026#34;red\u0026#34;/\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;collision\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 ${height1/2}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;${width} ${width} ${height1}\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;xacro:default_inertial z_value=\u0026#34;${height1/2}\u0026#34; i_value=\u0026#34;1.0\u0026#34; mass=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/link\u0026gt; \u0026lt;!-- Joint between Base Link and Middle Link --\u0026gt; \u0026lt;joint name=\u0026#34;joint_base_mid\u0026#34; type=\u0026#34;revolute\u0026#34;\u0026gt; \u0026lt;parent link=\u0026#34;base_link\u0026#34;/\u0026gt; \u0026lt;child link=\u0026#34;mid_link\u0026#34;/\u0026gt; \u0026lt;origin xyz=\u0026#34;0 ${width} ${height1 - axle_offset}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;axis xyz=\u0026#34;0 1 0\u0026#34;/\u0026gt; \u0026lt;dynamics damping=\u0026#34;${damp}\u0026#34;/\u0026gt; \u0026lt;limit effort=\u0026#34;100.0\u0026#34; velocity=\u0026#34;0.5\u0026#34; lower=\u0026#34;-3.14\u0026#34; upper=\u0026#34;3.14\u0026#34; /\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;!-- Middle Link --\u0026gt; \u0026lt;link name=\u0026#34;mid_link\u0026#34;\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 ${height2/2 - axle_offset}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;${width} ${width} ${height2}\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;material name=\u0026#34;green\u0026#34;/\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;collision\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 ${height2/2 - axle_offset}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;${width} ${width} ${height2}\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;xacro:default_inertial z_value=\u0026#34;${height2/2 - axle_offset}\u0026#34; i_value=\u0026#34;1.0\u0026#34; mass=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/link\u0026gt; \u0026lt;!-- Joint between Middle Link and Top Link --\u0026gt; \u0026lt;joint name=\u0026#34;joint_mid_top\u0026#34; type=\u0026#34;revolute\u0026#34;\u0026gt; \u0026lt;parent link=\u0026#34;mid_link\u0026#34;/\u0026gt; \u0026lt;child link=\u0026#34;top_link\u0026#34;/\u0026gt; \u0026lt;origin xyz=\u0026#34;0 ${width} ${height2 - axle_offset*2}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;axis xyz=\u0026#34;0 1 0\u0026#34;/\u0026gt; \u0026lt;dynamics damping=\u0026#34;${damp}\u0026#34;/\u0026gt; \u0026lt;limit effort=\u0026#34;100.0\u0026#34; velocity=\u0026#34;0.5\u0026#34; lower=\u0026#34;-3.14\u0026#34; upper=\u0026#34;3.14\u0026#34; /\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;!-- Top Link --\u0026gt; \u0026lt;link name=\u0026#34;top_link\u0026#34;\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 ${height3/2 - axle_offset}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;${width} ${width} ${height3}\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;material name=\u0026#34;blue\u0026#34;/\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;collision\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 ${height3/2 - axle_offset}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;${width} ${width} ${height3}\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;xacro:default_inertial z_value=\u0026#34;${height3/2 - axle_offset}\u0026#34; i_value=\u0026#34;1.0\u0026#34; mass=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/link\u0026gt; \u0026lt;/robot\u0026gt; 运行Rviz的roslaunch命令\n$ roslaunch ros_robotics rrbot_rviz.launch model:=rrbot3.xacro\n6.在Gazebo中控制关节式机器人手臂 gazebo下模拟环境下所独有的特性元素主要有\n\u0026lt;material\u0026gt;标签，指定每一个连接杆的颜色或纹理 \u0026lt;mu1\u0026gt;和\u0026lt;mu2\u0026gt;标签，用于定义四个表面相互接触的机器人连接杆的摩擦系数 用于控制rrbot的旋转副关节的插件 这些特定的Gazebo XML元素，存储在单独的文件中：\n~/catkin_ws/src/ros_robotics/urdf/rrbot.gazebo:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;robot\u0026gt; \u0026lt;!-- ros_control plugin --\u0026gt; \u0026lt;gazebo\u0026gt; \u0026lt;plugin name=\u0026#34;gazebo_ros_control\u0026#34; filename=\u0026#34;libgazebo_ros_control.so\u0026#34;\u0026gt; \u0026lt;robotNamespace\u0026gt;/rrbot\u0026lt;/robotNamespace\u0026gt; \u0026lt;robotSimType\u0026gt;gazebo_ros_control/DefaultRobotHWSim\u0026lt;/robotSimType\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/gazebo\u0026gt; \u0026lt;!-- Base Link --\u0026gt; \u0026lt;gazebo reference=\u0026#34;base_link\u0026#34;\u0026gt; \u0026lt;material\u0026gt;Gazebo/Red\u0026lt;/material\u0026gt; \u0026lt;/gazebo\u0026gt; \u0026lt;!-- Middle Link --\u0026gt; \u0026lt;gazebo reference=\u0026#34;mid_link\u0026#34;\u0026gt; \u0026lt;mu1\u0026gt;0.2\u0026lt;/mu1\u0026gt; \u0026lt;mu2\u0026gt;0.2\u0026lt;/mu2\u0026gt; \u0026lt;material\u0026gt;Gazebo/Green\u0026lt;/material\u0026gt; \u0026lt;/gazebo\u0026gt; \u0026lt;!-- Top Link --\u0026gt; \u0026lt;gazebo reference=\u0026#34;top_link\u0026#34;\u0026gt; \u0026lt;mu1\u0026gt;0.2\u0026lt;/mu1\u0026gt; \u0026lt;mu2\u0026gt;0.2\u0026lt;/mu2\u0026gt; \u0026lt;material\u0026gt;Gazebo/Blue\u0026lt;/material\u0026gt; \u0026lt;/gazebo\u0026gt; \u0026lt;!-- Gripper Elements --\u0026gt; \u0026lt;gazebo reference=\u0026#34;left_gripper\u0026#34;\u0026gt; \u0026lt;mu1\u0026gt;0.2\u0026lt;/mu1\u0026gt; \u0026lt;mu2\u0026gt;0.2\u0026lt;/mu2\u0026gt; \u0026lt;/gazebo\u0026gt; \u0026lt;gazebo reference=\u0026#34;right_gripper\u0026#34;\u0026gt; \u0026lt;mu1\u0026gt;0.2\u0026lt;/mu1\u0026gt; \u0026lt;mu2\u0026gt;0.2\u0026lt;/mu2\u0026gt; \u0026lt;/gazebo\u0026gt; \u0026lt;gazebo reference=\u0026#34;left_tip\u0026#34; /\u0026gt; \u0026lt;gazebo reference=\u0026#34;right_tip\u0026#34; /\u0026gt; \u0026lt;/robot\u0026gt; 在主文件使用Xacro的声明\n\u0026lt;xacro:include filename=\u0026quot;$(find ros_robotics)/urdf/rrbot.gazebo\u0026quot; /\u0026gt;\n将机器人手臂固定在世界坐标系下\n1 2 3 4 5 6 \u0026lt;link name=\u0026#34;world\u0026#34;/\u0026gt; \u0026lt;joint name=\u0026#34;fixed\u0026#34; type=\u0026#34;fixed\u0026#34;\u0026gt; \u0026lt;parent link=\u0026#34;world\u0026#34;/\u0026gt; \u0026lt;child link=\u0026#34;base_link\u0026#34;/\u0026gt; \u0026lt;/joint\u0026gt; ~/catkin_ws/src/ros_robotics/urdf/rrbot4.xacro:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;!-- Revolute-Revolute Manipulator --\u0026gt; \u0026lt;robot name=\u0026#34;rrbot\u0026#34; xmlns:xacro=\u0026#34;http://www.ros.org/wiki/xacro\u0026#34;\u0026gt; \u0026lt;!-- Constants for robot dimensions --\u0026gt; \u0026lt;xacro:property name=\u0026#34;PI\u0026#34; value=\u0026#34;3.14\u0026#34;/\u0026gt; \u0026lt;xacro:property name=\u0026#34;width\u0026#34; value=\u0026#34;0.1\u0026#34; /\u0026gt; \u0026lt;!-- Beams are square in length and width --\u0026gt; \u0026lt;xacro:property name=\u0026#34;height1\u0026#34; value=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;!-- Link 1 --\u0026gt; \u0026lt;xacro:property name=\u0026#34;height2\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;!-- Link 2 --\u0026gt; \u0026lt;xacro:property name=\u0026#34;height3\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;!-- Link 3 --\u0026gt; \u0026lt;xacro:property name=\u0026#34;axle_offset\u0026#34; value=\u0026#34;0.05\u0026#34; /\u0026gt; \u0026lt;!-- Space between joint and end of beam --\u0026gt; \u0026lt;xacro:property name=\u0026#34;damp\u0026#34; value=\u0026#34;0.7\u0026#34; /\u0026gt; \u0026lt;!-- damping coefficient --\u0026gt; \u0026lt;!-- Default Inertial --\u0026gt; \u0026lt;xacro:macro name=\u0026#34;default_inertial\u0026#34; params=\u0026#34;z_value i_value mass\u0026#34;\u0026gt; \u0026lt;inertial\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 ${z_value}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;mass value=\u0026#34;${mass}\u0026#34; /\u0026gt; \u0026lt;inertia ixx=\u0026#34;${i_value}\u0026#34; ixy=\u0026#34;0.0\u0026#34; ixz=\u0026#34;0.0\u0026#34; iyy=\u0026#34;${i_value}\u0026#34; iyz=\u0026#34;0.0\u0026#34; izz=\u0026#34;${i_value}\u0026#34; /\u0026gt; \u0026lt;/inertial\u0026gt; \u0026lt;/xacro:macro\u0026gt; \u0026lt;!-- Import Rviz colors --\u0026gt; \u0026lt;xacro:include filename=\u0026#34;$(find ros_robotics)/urdf/materials.xacro\u0026#34; /\u0026gt; \u0026lt;!-- Import gripper URDF --\u0026gt; \u0026lt;xacro:include filename=\u0026#34;$(find ros_robotics)/urdf/gripper.xacro\u0026#34; /\u0026gt; \u0026lt;!-- Import Gazebo elements, including Gazebo colors --\u0026gt; \u0026lt;xacro:include filename=\u0026#34;$(find ros_robotics)/urdf/rrbot.gazebo\u0026#34; /\u0026gt; \u0026lt;!-- Used for fixing rrbot frame to Gazebo world frame --\u0026gt; \u0026lt;link name=\u0026#34;world\u0026#34;/\u0026gt; \u0026lt;joint name=\u0026#34;fixed\u0026#34; type=\u0026#34;fixed\u0026#34;\u0026gt; \u0026lt;parent link=\u0026#34;world\u0026#34;/\u0026gt; \u0026lt;child link=\u0026#34;base_link\u0026#34;/\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;!-- Base Link --\u0026gt; \u0026lt;link name=\u0026#34;base_link\u0026#34;\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 ${height1/2}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;${width} ${width} ${height1}\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;material name=\u0026#34;red\u0026#34;/\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;collision\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 ${height1/2}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;${width} ${width} ${height1}\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;xacro:default_inertial z_value=\u0026#34;${height1/2}\u0026#34; i_value=\u0026#34;1.0\u0026#34; mass=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/link\u0026gt; \u0026lt;!-- Joint between Base Link and Middle Link --\u0026gt; \u0026lt;joint name=\u0026#34;joint_base_mid\u0026#34; type=\u0026#34;revolute\u0026#34;\u0026gt; \u0026lt;parent link=\u0026#34;base_link\u0026#34;/\u0026gt; \u0026lt;child link=\u0026#34;mid_link\u0026#34;/\u0026gt; \u0026lt;origin xyz=\u0026#34;0 ${width} ${height1 - axle_offset}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;axis xyz=\u0026#34;0 1 0\u0026#34;/\u0026gt; \u0026lt;dynamics damping=\u0026#34;${damp}\u0026#34;/\u0026gt; \u0026lt;limit effort=\u0026#34;100.0\u0026#34; velocity=\u0026#34;0.5\u0026#34; lower=\u0026#34;-3.14\u0026#34; upper=\u0026#34;3.14\u0026#34; /\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;!-- Middle Link --\u0026gt; \u0026lt;link name=\u0026#34;mid_link\u0026#34;\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 ${height2/2 - axle_offset}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;${width} ${width} ${height2}\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;material name=\u0026#34;green\u0026#34;/\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;collision\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 ${height2/2 - axle_offset}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;${width} ${width} ${height2}\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;xacro:default_inertial z_value=\u0026#34;${height2/2 - axle_offset}\u0026#34; i_value=\u0026#34;1.0\u0026#34; mass=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/link\u0026gt; \u0026lt;!-- Joint between Middle Link and Top Link --\u0026gt; \u0026lt;joint name=\u0026#34;joint_mid_top\u0026#34; type=\u0026#34;revolute\u0026#34;\u0026gt; \u0026lt;parent link=\u0026#34;mid_link\u0026#34;/\u0026gt; \u0026lt;child link=\u0026#34;top_link\u0026#34;/\u0026gt; \u0026lt;origin xyz=\u0026#34;0 ${width} ${height2 - axle_offset*2}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;axis xyz=\u0026#34;0 1 0\u0026#34;/\u0026gt; \u0026lt;dynamics damping=\u0026#34;${damp}\u0026#34;/\u0026gt; \u0026lt;limit effort=\u0026#34;100.0\u0026#34; velocity=\u0026#34;0.5\u0026#34; lower=\u0026#34;-3.14\u0026#34; upper=\u0026#34;3.14\u0026#34; /\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;!-- Top Link --\u0026gt; \u0026lt;link name=\u0026#34;top_link\u0026#34;\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 ${height3/2 - axle_offset}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;${width} ${width} ${height3}\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;material name=\u0026#34;blue\u0026#34;/\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;collision\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 ${height3/2 - axle_offset}\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;${width} ${width} ${height3}\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;xacro:default_inertial z_value=\u0026#34;${height3/2 - axle_offset}\u0026#34; i_value=\u0026#34;1.0\u0026#34; mass=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/link\u0026gt; \u0026lt;transmission name=\u0026#34;transmission1\u0026#34;\u0026gt; \u0026lt;type\u0026gt;transmission_interface/SimpleTransmission\u0026lt;/type\u0026gt; \u0026lt;joint name=\u0026#34;joint_base_mid\u0026#34;\u0026gt; \u0026lt;hardwareInterface\u0026gt;hardware_interface/EffortJointInterface\u0026lt;/hardwareInterface\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;actuator name=\u0026#34;motor1\u0026#34;\u0026gt; \u0026lt;mechanicalReduction\u0026gt;1\u0026lt;/mechanicalReduction\u0026gt; \u0026lt;/actuator\u0026gt; \u0026lt;/transmission\u0026gt; \u0026lt;transmission name=\u0026#34;transmission2\u0026#34;\u0026gt; \u0026lt;type\u0026gt;transmission_interface/SimpleTransmission\u0026lt;/type\u0026gt; \u0026lt;joint name=\u0026#34;joint_mid_top\u0026#34;\u0026gt; \u0026lt;hardwareInterface\u0026gt;hardware_interface/EffortJointInterface\u0026lt;/hardwareInterface\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;actuator name=\u0026#34;motor2\u0026#34;\u0026gt; \u0026lt;mechanicalReduction\u0026gt;1\u0026lt;/mechanicalReduction\u0026gt; \u0026lt;/actuator\u0026gt; \u0026lt;/transmission\u0026gt; \u0026lt;/robot\u0026gt; launch文件：\n~/catkin_ws/src/ros_robotics/launch/rrbot_gazebo.launch:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;launch\u0026gt; \u0026lt;!-- We resume the logic in gazebo_ros package empty_world.launch, --\u0026gt; \u0026lt;!-- changing only the name of the world to be launched --\u0026gt; \u0026lt;include file=\u0026#34;$(find gazebo_ros)/launch/empty_world.launch\u0026#34;\u0026gt; \u0026lt;arg name=\u0026#34;world_name\u0026#34; value=\u0026#34;$(find ros_robotics)/worlds/rrbot.world\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;paused\u0026#34; default=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;use_sim_time\u0026#34; default=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;gui\u0026#34; default=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;headless\u0026#34; default=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;debug\u0026#34; default=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/include\u0026gt; \u0026lt;!-- Load the URDF into the ROS Parameter Server --\u0026gt; \u0026lt;param name=\u0026#34;robot_description\u0026#34; command=\u0026#34;$(find xacro)/xacro --inorder \u0026#39;$(find ros_robotics)/urdf/rrbot4.xacro\u0026#39;\u0026#34; /\u0026gt; \u0026lt;!-- Spawn rrbot into Gazebo --\u0026gt; \u0026lt;node name=\u0026#34;spawn_urdf\u0026#34; pkg=\u0026#34;gazebo_ros\u0026#34; type=\u0026#34;spawn_model\u0026#34; respawn=\u0026#34;false\u0026#34; output=\u0026#34;screen\u0026#34; args=\u0026#34;-param robot_description -urdf -model rrbot\u0026#34; /\u0026gt; \u0026lt;/launch\u0026gt; 在gazebo中启动机器人手臂命令\n$ roslaunch ros_robotics rrbot_gazebo.launch\n7.给Xacro添加控制组件 在gazebo模拟环境下为机器人手臂添加控制组件的步骤如下\n为rrbot以及抓手Xacro文件中的关节组件定义为传动元素 为gazebo特性元素添加gazebo_ros_control插件 生成用于控制参数的YAML配置文件 生成用于启动机器人关节控制器的控制启动文件 需要安装四个功能包：gazebo_ros_pkgs、gezebo_ros_control、ros_control、ros_controllers。\ngazebo_ros_pkgs提供gazebo下机器人的接口和控制。ros_control、ros_controllers提供用于ROS机器人控制的基本控制器。\n安装Debian功能包\n$ sudo apt-get install ros-kinetic-gazebo-ros-pkgs ros-kinetic-gazebo-ros-control ros-kinetic-ros-control ros-kinetic-ros-controllers\n参考http://wiki.ros.org/ros_control\n（1）定义关节的传动元素 \u0026lt;transmission\u0026gt;用于定义机器人关节和执行器间的相互关系。每一个旋转副关节(joint_base_mid、joint_mid_top、left_gripper、right_gripper)都需要一个\u0026lt;transmission\u0026gt;元素。\n\u0026lt;transmission\u0026gt;元素的内容相似:\n1 2 3 4 5 6 7 8 9 \u0026lt;transmission name=\u0026#34;transmission1\u0026#34;\u0026gt; \u0026lt;type\u0026gt;transmission_interface/SimpleTransmission\u0026lt;/type\u0026gt; \u0026lt;joint name=\u0026#34;joint_base_mid\u0026#34;\u0026gt; \u0026lt;hardwareInterface\u0026gt;hardware_interface/EffortJointInterface\u0026lt;/hardwareInterface\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;actuator name=\u0026#34;motor1\u0026#34;\u0026gt; \u0026lt;mechanicalReduction\u0026gt;1\u0026lt;/mechanicalReduction\u0026gt; \u0026lt;/actuator\u0026gt; \u0026lt;/transmission\u0026gt; 上述代码在rrbot4.xacro中\n（2）添加Gazebo的ROS控制插件 1 2 3 4 5 6 7 \u0026lt;!-- ros_control plugin --\u0026gt; \u0026lt;gazebo\u0026gt; \u0026lt;plugin name=\u0026#34;gazebo_ros_control\u0026#34; filename=\u0026#34;libgazebo_ros_control.so\u0026#34;\u0026gt; \u0026lt;robotNamespace\u0026gt;/rrbot\u0026lt;/robotNamespace\u0026gt; \u0026lt;robotSimType\u0026gt;gazebo_ros_control/DefaultRobotHWSim\u0026lt;/robotSimType\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/gazebo\u0026gt; 上述代码在rrbot.gazebo中\n（3）生成YAML配置文件 YAML是一种常见于ROS参数中的标记语言。在参数服务器上使用YAML格式的文件对ROS的参数进行设置。创建一个用于存放关节控制器配置参数的YAML文件，该YAML文件由控制启动文件加载。定义四个rrbot控制器的比例积分微分增益。\n~/catkin_ws/src/ros_robotics/config/rrbot_control.yaml:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 rrbot: # Publish all joint states ----------------------------------- joint_state_controller: type: joint_state_controller/JointStateController publish_rate: 50 # Position Controllers --------------------------------------- joint_base_mid_position_controller: type: effort_controllers/JointPositionController joint: joint_base_mid pid: {p: 100.0, i: 0.01, d: 10.0} joint_mid_top_position_controller: type: effort_controllers/JointPositionController joint: joint_mid_top pid: {p: 100.0, i: 0.01, d: 10.0} left_gripper_joint_position_controller: type: effort_controllers/JointPositionController joint: left_gripper_joint pid: {p: 1.0, i: 0.00, d: 0.0} right_gripper_joint_position_controller: type: effort_controllers/JointPositionController joint: right_gripper_joint pid: {p: 1.0, i: 0.00, d: 0.0} （4）创建控制启动文件 初始化机器人手臂rrbot的最佳方法是生成用于将参数加载至参数服务器的启动文件，并通过该文件启动所有的ros_control控制器。配置文件YAML文件对控制器进行设置,rosparam声明将控制器设置加载至参数服务器。然后control_spawner节点使用controller_manager包为rrbot生成五个控制器。此外还将为robot_state_publisher启动另一个节点。\n~/catkin_ws/src/ros_robotics/launch/rrbot_control.launch:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;launch\u0026gt; \u0026lt;!-- Load joint controller configurations from YAML file to parameter server --\u0026gt; \u0026lt;rosparam file=\u0026#34;$(find ros_robotics)/config/rrbot_control.yaml\u0026#34; command=\u0026#34;load\u0026#34;/\u0026gt; \u0026lt;!-- load the controllers --\u0026gt; \u0026lt;node name=\u0026#34;control_spawner\u0026#34; pkg=\u0026#34;controller_manager\u0026#34; type=\u0026#34;spawner\u0026#34; respawn=\u0026#34;false\u0026#34; output=\u0026#34;screen\u0026#34; ns=\u0026#34;/rrbot\u0026#34; args=\u0026#34;joint_state_controller joint_base_mid_position_controller joint_mid_top_position_controller left_gripper_joint_position_controller right_gripper_joint_position_controller\u0026#34;/\u0026gt; \u0026lt;!-- convert joint states to TF transforms for rviz, etc --\u0026gt; \u0026lt;node name=\u0026#34;robot_state_publisher\u0026#34; pkg=\u0026#34;robot_state_publisher\u0026#34; type=\u0026#34;robot_state_publisher\u0026#34; respawn=\u0026#34;false\u0026#34; output=\u0026#34;screen\u0026#34;\u0026gt; \u0026lt;remap from=\u0026#34;/joint_states\u0026#34; to=\u0026#34;/rrbot/joint_states\u0026#34; /\u0026gt; \u0026lt;/node\u0026gt; \u0026lt;/launch\u0026gt; 在节点启动之后，joint_state_controller开始发布通过JointState话题rrbot所有的非固定关节的状态。robot_state_publisher订阅JointState消息并发布机器人的变换信息到tf变换库中。其他关节的位置控制器分别对相应的旋转副关节进行控制。\n在gazebo下启动rrbot： $ roslaunch ros_robotics rrbot_gazebo.launch\n当在gazebo中看到rrbot时，打开第二个终端，并使用以下命令启动控制器\n$ roslaunch ros_robotics rrbot_control.launch\n控制启动文件中使用了controller_manager和robot_state_publisher功能包，需要将它们的依赖添加到ros_robotics功能包的package.xml文件中。在相应的依赖后，需要添加以下声明：\n1 2 \u0026lt;exec_depend\u0026gt;controller_manager\u0026lt;/exec_depend\u0026gt; \u0026lt;exec_depend\u0026gt;robot_state_publisher\u0026lt;/exec_depend\u0026gt; 采用ROS命令行控制机器人手臂 通过第三个终端窗口发送命令来对机器人手臂rrbot进行控制\n（相对于中间的连接杆）把顶部的连接杆移动到1.57弧度（90°）的位置\n$ rostopic pub -1 /rrbot/joint_mid_top_position_controller/command std_msgs/Float64 \u0026quot;data: 1.57\u0026quot;\n由于受到环境重力以及控制器执行精度的影响，可能并非达到90°的位置，适当进行PID增益调节，能够提高执行的精确度。\n持续发送一下两条命令，可以将左右两个抓手从中心位置打开至-0.5弧度的位置： $ rostopic pub -1 /rrbot/right_gripper_joint_position_controller/command std_msgs/Float64 \u0026quot;data: -0.5\u0026quot;;rostopic pub -1 /rrbot/left_gripper_joint_position_controller/command std_msgs/Float64 \u0026quot;data: 1.57\u0026quot;\n采用rqt控制机器人手臂 启动rqt\n$ rosrun rqt_gui rqt_gui 或 $ rqt\nPlugins|Topic|Message Publiser：添加/rrbot/joint_base_mid_position_controller/command，/rrbot/joint_mid_top_position_controller/command到主界面，修改表达式发布消息。\n**Plugins|Visualization|Plot:**joint_xxx_position_controller/command/data或者joint_xxx_position_controller/state/error绘制在屏幕上,误差图可视化的形式显示。\nPlugins|Configuration|Dynamic Reconfigre:Expand all,为任意关节控制器选择pid，对参数进行动态调整，从而调整控制器的性能参数。\n第六章 机器人手臂摇摆的关节控制-Baxter 每个手臂都具有七个自由度 Baxter更多技术规格参数，可见： http://www.rethinkrobotics.com/baxter/tech-specs/ http://sdk.rethinkrobotics.com/wiki/Hardware_Specifications http://www.active8robots.com/wp-content/uploads/BaxterHardware-Specifications-Architecture-Datasheet.pdf 机器人上进行配置和代码执行http://sdk.rethinkrobotics.com/wiki/SSH 演示视频http://sdk.rethinkrobotics.com/wiki/Customer_Videos 研究论文http://sdk.rethinkrobotics.com/wiki/Published_Work Baxter模拟器的ROS功能包和API更多细节性内容 http://sdk.rethinkrobotics.com/wiki/Simulator_Architecture http://sdk.rethinkrobotics.com/wiki/Baxter_Simulator http://sdk.rethinkrobotics.com/wiki/API_Reference#tab.3DSimulator_API https://github.com/RethinkRobotics/baxter_simulator\n下载Baxter软件 安装Baxter SDK软件 SDK下载安装到工作站计算机的ROS的catkin工作空间 http://sdk.rethinkrobotics.com/wiki/Workstation_Setup\n参考 https://blog.csdn.net/weixin_43731206/article/details/114584436#commentBox\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 安装Baxter SDK依赖 sudo apt-get update sudo apt-get install git python-argparse python3-wstool python3-vcstools python3-rosdep ros-noetic-control-msgs ros-noetic-joystick-drivers wstool工具检查 cd ~/baxter_ws/src wstool init sudo wstool merge https://raw.githubusercontent.com/RethinkRobotics/baxter/master/baxter_sdk.rosinstall wstool update (修改github hosts sudo vim /etc/hosts 199.232.28.133 raw.githubusercontent.com) $ cd ~/baxter_ws $ catkin_make $ catkin_make install 安装Baxter模拟器 http://sdk.rethinkrobotics.com/wiki/Simulator_Installation\n1 2 3 4 5 6 7 8 9 10 sudo apt-get update sudo apt-get install gazebo2 ros-indigo-qt-build ros-indigo-driver-common ros-indigo-gazebo-ros-control ros-indigo-gazebo-ros-pkgs ros-indigo-ros-control ros-indigo-control-toolbox ros-indigo-realtime-tools ros-indigo-ros-controllers ros-indigo-xacro python-wstool ros-indigo-tf-conversions ros-indigo-kdl-parser(官网未修改，改为noetic) cd ~/baxter_ws/src wstool init sudo wstool merge https://raw.githubusercontent.com/RethinkRobotics/baxter_simulator/noetic_devel/baxter_simulator.rosinstall wstool update cd ~/baxter_ws catkin_make 配置Baxter shell SDK需要通过baxter.sh脚本建立机器人与工作站计算机之间的连接 模拟器需要使用baxter.sh脚本建立一种模拟模式\n1 2 3 4 5 复制到baxter_ws目录下，权限修改为允许所有用户运行 cp ~/baxter_ws/src/baxter/baxter.sh ~/baxter_ws chmod +x baxter.sh 打开baxter.sh文件，将your_ip的值更改为工作站计算机的IP地址，修改ros_version变量 安装MoveIt ！ http://sdk.rethin-krobotics.com/wiki/MoveIt_Tutorial\n1 2 3 4 5 6 7 cd ~/baxter_ws/src git clone https://github.com/ros.planning/moveit_robots.git sudo apt-get update sudo apt-get install ros-noetic-moveit cd ~/baxter_ws catkin_make 在Gazebo中启动Baxter模拟器 1 2 3 4 5 6 7 8 9 10 启动Baxter模拟器 cd ~/baxter_ws ./baxter.sh sim 检查ROS环境 env | grep ROS 启动控制器，开始模拟操作 roslaunch baxter_gazebo baxter_world.launch (gazebo死机 移除所有gezebo进程 killall gzserver) 故障说明 http://sdk.rethinkrobotics.com/wiki/Troubleshooting\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 第二个终端 cd ~/baxter_ws ./baxter.sh sim 确认状态 rosrun baxter_tools enable_robot.py -s 使能Baxter rosrun baxter_tools enable_robot.py -e 确认状态 rosrun baxter_tools enable_robot.py -s 使能机器人，将手臂设置为一个已知的位置 rosrun baxter_tools tuck_arms.py -u 样例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 在模拟的机器人头部显示屏显示一张图片 rosrun baxter_examples xdisplay_image.py --file=`rospack find baxter_examples`/share/images/baxterworking.png 控制Baxter的头部上下或者左右运动 rosrun baxter_examples head_wobbler.py 1.手臂展开，Baxter到达闭合位置 rosrun baxter_tools tuck_arms.py -u 参考http://sdk.rethinkrobotics.com/wiki/Tuck_Arms_Tool 2.手臂摇摆运动 rosrun baxter_examples joint_velocity_wobbler.py 参考http://sdk.rethinkrobotics.com/wiki/Wobbler_Example 3.键盘控制手臂和抓手 rosrun baxter_examples joint_position_keyboard.py 4.使用游戏手柄控制手臂和抓手 joint_position_joystick程序使用源自joy功能包的ROS驱动程序 检查手柄驱动功能包joy的安装情况 rospack find joy 可使用以下命令安装 sudo apt-get install ros-noetic-joystick-drivers PS3手柄安装ps3joy功能包 参考http://wiki.ros.org/ps3joy/Tutorials/PairingJoystickAndBluetoothDongle 启动joint_position_joystick程序，需要指定手柄类型(xbox/logitech/ps3) roslaunch baxter_examples joint_position_joystick.launch joystick:=\u0026lt;joystick_type\u0026gt; 5.使用Python脚本控制手臂 python home_arms.py 6.记录和重演手臂的运动 rosrun baxter_examples joint_recorder.py -f armRoutine armRoutine为文件名 回放 rosrun baxter_examples joint_position_file_playback.py -f armRoutine home_arms.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #!/usr/bin/env python \u0026#34;\u0026#34;\u0026#34; Script to return Baxter\u0026#39;s arms to a \u0026#34;home\u0026#34; position \u0026#34;\u0026#34;\u0026#34; # rospy - ROS Python API import rospy # baxter_interface - Baxter Python API import baxter_interface # initialize our ROS node, registering it with the Master rospy.init_node(\u0026#39;Home_Arms\u0026#39;) # create instances of baxter_interface\u0026#39;s Limb class limb_right = baxter_interface.Limb(\u0026#39;right\u0026#39;) limb_left = baxter_interface.Limb(\u0026#39;left\u0026#39;) # store the home position of the arms home_right = {\u0026#39;right_s0\u0026#39;: 0.08, \u0026#39;right_s1\u0026#39;: -1.00, \u0026#39;right_w0\u0026#39;: -0.67, \u0026#39;right_w1\u0026#39;: 1.03, \u0026#39;right_w2\u0026#39;: 0.50, \u0026#39;right_e0\u0026#39;: 1.18, \u0026#39;right_e1\u0026#39;: 1.94} home_left = {\u0026#39;left_s0\u0026#39;: -0.08, \u0026#39;left_s1\u0026#39;: -1.00, \u0026#39;left_w0\u0026#39;: 0.67, \u0026#39;left_w1\u0026#39;: 1.03, \u0026#39;left_w2\u0026#39;: -0.50, \u0026#39;left_e0\u0026#39;: -1.18, \u0026#39;left_e1\u0026#39;: 1.94} # move both arms to home position limb_right.move_to_joint_positions(home_right) limb_left.move_to_joint_positions(home_left) quit() Baxter手臂与正向运动 关节与关节状态发布器 有关话题/robot/joint_states\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 cd ~/baxter_ws ./baxter.sh sim roslaunch baxter_gazebo baxter_world.launch cd ~/baxter_ws ./baxter.sh sim rosrun baxter_tools enable_robot.py -e 将Baxter手臂置于home位置 python home_arms.py 显示相关信息 rostopic echo /robot/joint_states -nl 显示左侧手臂末端的位置和朝向 rostopic echo /robot/limb/left/endpoint_state/pose -n1 理解tf 控制Baxter手臂移动到0角度位置的程序 arms_to_zero_angles.py：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/usr/bin/env python # arms_to_zero_angles.py # \u0026#34;\u0026#34;\u0026#34; Script to return Baxter\u0026#39;s arms to a \u0026#34;zero angles\u0026#34; position \u0026#34;\u0026#34;\u0026#34; # rospy - ROS Python API import rospy # baxter_interface - Baxter Python API import baxter_interface # initialize our ROS node, registering it with the Master rospy.init_node(\u0026#39;Zero_Arms\u0026#39;) # create instances of baxter_interface\u0026#39;s Limb class limb_right = baxter_interface.Limb(\u0026#39;right\u0026#39;) limb_left = baxter_interface.Limb(\u0026#39;left\u0026#39;) # store the zero position of the arms zero_right = {\u0026#39;right_s0\u0026#39;: 0.0, \u0026#39;right_s1\u0026#39;: 0.00, \u0026#39;right_w0\u0026#39;: 0.00, \u0026#39;right_w1\u0026#39;: 0.00, \u0026#39;right_w2\u0026#39;: 0.00, \u0026#39;right_e0\u0026#39;: 0.00, \u0026#39;right_e1\u0026#39;: 0.00} zero_left = {\u0026#39;left_s0\u0026#39;: 0.0, \u0026#39;left_s1\u0026#39;: 0.00, \u0026#39;left_w0\u0026#39;: 0.00, \u0026#39;left_w1\u0026#39;: 0.00, \u0026#39;left_w2\u0026#39;: 0.00, \u0026#39;left_e0\u0026#39;: 0.00, \u0026#39;left_e1\u0026#39;: 0.00} # move both arms to home position limb_right.move_to_joint_positions(zero_right) limb_left.move_to_joint_positions(zero_left) quit() 1 2 3 4 5 python编译成可执行 chmod +x arms_to_zero_angles.py 运行脚本 python arms_to_zero_angles.py 直接指定关节组件角度 1 rostopic pub -r 10 /robot/limb/left/joint_command baxter_core_msgs/Jointcommand \u0026#34;{mode:1, command: [0.0, 0.0, 0.0, 0.0], name: [\u0026#39;left_w1\u0026#39;, \u0026#39;left_e1\u0026#39;, \u0026#39;left_s0\u0026#39;, \u0026#39;left_s1\u0026#39;]}\u0026#34; 参考http://sdk.rethinkrobotics.com/wiki/Arm_Control_Modes\n查看机器人元素的tf树 启动view_frames rosrun tf view_frames 查看evince frames.pdf 参考http://wiki.ros.org/tf/Tutorials/Introduction%20to%20tf\nMoveIt 简介 用户手册 http://sdk.rethinkrobotics.com/wiki/MoveIt_Tutorial 对MoveIt!的使用进行演示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 cd ~/baxter_ws ./baxter.sh sim roslaunch baxter_gazebo baxter_world.launch 打开手臂，运行py脚本启动joint_trajectory_action_server cd ~/baxter_ws ./baxter.sh sim rosrun baxter_tools tuck_arms.py -u rosrun baxter_interface joint_trajectory_action_server.py 启动moveit cd ~/baxter_ws ./baxter.sh sim roslaunch baxter_moveit_config baxter_grippers.launch 控制真实的Baxter机器人 1 2 3 4 5 6 7 8 9 10 到达航路点 rosrun baxter_examples joint_position_waypoint.py -l \u0026lt;left or right\u0026gt; 控制关节的力矩弹簧 rosrun baxter_examples joint_torque_springs.py -l \u0026lt;left or right\u0026gt; rqt对关节力矩进行修改和配置 rosrun rqt_reconfigure rqt_reconfigue 控制关节速度 rosrun baxter_examples joint_velocity_puppet.py -l \u0026lt;left or right\u0026gt; 其他示例参考 http://sdk.rethinkrobotics.com/wiki/Examples\n反向运动 正向运动——计算出抓手在任意时刻的位置 反向运动——控制抓手运动到指定位置和朝向，需要计算关节的角度 参考 http://sdk.rethinkrobotics.com/wiki/IK_Service_Example http://sdk.rethinkrobotics.com/wiki/IK_Service_-_Code_\tWalkthrough\n1 2 运行py脚本得到运行到固定位置时左侧手臂有关关节的角度值 rosrun baxter_examples ik_service_client.py -l left 利用反向运动移动Baxter的手臂（真实baxter） 1.启动Baxter，展开手臂，此时位于home位置 2.记录左侧手臂终点状态的位置和朝向 3.将Baxter的左侧手臂移动到任意位置 4.baxter_examples功能包里的ik_service_client.py，输入展开后的左侧手臂位置和朝向，以不同的名字保存在catkin_workspace下 5.执行脚本，获取左侧手臂的关节角度 6.将角度输入到修改后的home_arms.py中，执行该脚本 7.记录新终点位置和朝向，并与步骤2中为的原始值进行对比\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 1. cd ~/baxter_ws ./baxter.sh roslaunch baxter_tools tuck_arms.py -u 2. rostopic echo /robot/limb/left/endpoint_state/pose -n1 -w4 3. 4. roscd baxter_examples/scripts 找到要修改的脚本，以新名字保存 chmod +x ik_home_arms_ch6RealBaxter.py 5.运行相应的例子，获取将Baxter左侧手臂移动到展开位置的关节角度 python ik_home_arms_ch6RealBaxter.py -l left 6.使用编辑过的py脚本home_arms.py得到的角度来控制Baxter手臂的移动，改变左侧手臂关节的角度值，以新文件命名 chmod +x MoveLeftArmToHome.py python MoveLeftArmToHome.py 7. rostopic echo /robot/limb/left/endpoint_state/pose -n1 -w4 MoveLeftArmToHome.py:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #!/usr/bin/env python \u0026#34;\u0026#34;\u0026#34; Script to return Baxter\u0026#39;s arms to a \u0026#34;home\u0026#34; position \u0026#34;\u0026#34;\u0026#34; # rospy - ROS Python API import rospy # baxter_interface - Baxter Python API import baxter_interface # initialize our ROS node, registering it with the Master rospy.init_node(\u0026#39;Home_Arms\u0026#39;) # create instances of baxter_interface\u0026#39;s Limb class limb_right = baxter_interface.Limb(\u0026#39;right\u0026#39;) limb_left = baxter_interface.Limb(\u0026#39;left\u0026#39;) # store the home position of the arms home_right = {\u0026#39;right_s0\u0026#39;: 0.08, \u0026#39;right_s1\u0026#39;: -1.00, \u0026#39;right_w0\u0026#39;: -0.67, \u0026#39;right_w1\u0026#39;: 1.03, \u0026#39;right_w2\u0026#39;: 0.50, \u0026#39;right_e0\u0026#39;: 1.18, \u0026#39;right_e1\u0026#39;: 1.94} home_left = {\u0026#39;left_w0\u0026#39;: -1.8582664616409326, \u0026#39;left_w1\u0026#39;: -1.460468102595922, \u0026#39;left_w2\u0026#39;: 2.2756459061545797, \u0026#39;left_e0\u0026#39;: -1.6081637990992477, \u0026#39;left_e1\u0026#39;: 1.9645288022495901, \u0026#39;left_s0\u0026#39;: 0.044896665837355125, \u0026#39;left_s1\u0026#39;: -0.3326492980686455} # move both arms to home position limb_right.move_to_joint_positions(home_right) limb_left.move_to_joint_positions(home_left) quit() ik_home_arms_ch6RealBaxter.py:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 #!/usr/bin/env python # ik_home_arms_ch6RealBaxter.py # Copyright (c) 2013-2015, Rethink Robotics # All rights reserved. # # Redistribution and use in source and binary forms, with or without # modification, are permitted provided that the following conditions are met: # # 1. Redistributions of source code must retain the above copyright notice, # this list of conditions and the following disclaimer. # 2. Redistributions in binary form must reproduce the above copyright # notice, this list of conditions and the following disclaimer in the # documentation and/or other materials provided with the distribution. # 3. Neither the name of the Rethink Robotics nor the names of its # contributors may be used to endorse or promote products derived from # this software without specific prior written permission. # # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0026#34;AS IS\u0026#34; # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE # ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE # LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE # POSSIBILITY OF SUCH DAMAGE. \u0026#34;\u0026#34;\u0026#34; Baxter RSDK Inverse Kinematics Example \u0026#34;\u0026#34;\u0026#34; import argparse import struct import sys import rospy from geometry_msgs.msg import ( PoseStamped, Pose, Point, Quaternion, ) from std_msgs.msg import Header from baxter_core_msgs.srv import ( SolvePositionIK, SolvePositionIKRequest, ) def ik_test(limb): rospy.init_node(\u0026#34;rsdk_ik_service_client\u0026#34;) ns = \u0026#34;ExternalTools/\u0026#34; + limb + \u0026#34;/PositionKinematicsNode/IKService\u0026#34; iksvc = rospy.ServiceProxy(ns, SolvePositionIK) ikreq = SolvePositionIKRequest() hdr = Header(stamp=rospy.Time.now(), frame_id=\u0026#39;base\u0026#39;) poses = { \u0026#39;left\u0026#39;: PoseStamped( header=hdr, pose=Pose( position=Point( x=0.57, y=0.18, z=0.10, ), orientation=Quaternion( x=0.13, y=0.99, z=0.00, w=0.02, ), ), ), \u0026#39;right\u0026#39;: PoseStamped( header=hdr, pose=Pose( position=Point( x=0.656982770038, y=-0.852598021641, z=0.0388609422173, ), orientation=Quaternion( x=0.367048116303, y=0.885911751787, z=-0.108908281936, w=0.261868353356, ), ), ), } ikreq.pose_stamp.append(poses[limb]) try: rospy.wait_for_service(ns, 5.0) resp = iksvc(ikreq) except (rospy.ServiceException, rospy.ROSException), e: rospy.logerr(\u0026#34;Service call failed: %s\u0026#34; % (e,)) return 1 # Check if result valid, and type of seed ultimately used to get solution # convert rospy\u0026#39;s string representation of uint8[]\u0026#39;s to int\u0026#39;s resp_seeds = struct.unpack(\u0026#39;\u0026lt;%dB\u0026#39; % len(resp.result_type), resp.result_type) if (resp_seeds[0] != resp.RESULT_INVALID): seed_str = { ikreq.SEED_USER: \u0026#39;User Provided Seed\u0026#39;, ikreq.SEED_CURRENT: \u0026#39;Current Joint Angles\u0026#39;, ikreq.SEED_NS_MAP: \u0026#39;Nullspace Setpoints\u0026#39;, }.get(resp_seeds[0], \u0026#39;None\u0026#39;) print(\u0026#34;SUCCESS - Valid Joint Solution Found from Seed Type: %s\u0026#34; % (seed_str,)) # Format solution into Limb API-compatible dictionary limb_joints = dict(zip(resp.joints[0].name, resp.joints[0].position)) print \u0026#34;\\nIK Joint Solution:\\n\u0026#34;, limb_joints print \u0026#34;------------------\u0026#34; print \u0026#34;Response Message:\\n\u0026#34;, resp else: print(\u0026#34;INVALID POSE - No Valid Joint Solution Found.\u0026#34;) return 0 def main(): \u0026#34;\u0026#34;\u0026#34;RSDK Inverse Kinematics Example A simple example of using the Rethink Inverse Kinematics Service which returns the joint angles and validity for a requested Cartesian Pose. Run this example, passing the *limb* to test, and the example will call the Service with a sample Cartesian Pose, pre-defined in the example code, printing the response of whether a valid joint solution was found, and if so, the corresponding joint angles. \u0026#34;\u0026#34;\u0026#34; arg_fmt = argparse.RawDescriptionHelpFormatter parser = argparse.ArgumentParser(formatter_class=arg_fmt, description=main.__doc__) parser.add_argument( \u0026#39;-l\u0026#39;, \u0026#39;--limb\u0026#39;, choices=[\u0026#39;left\u0026#39;, \u0026#39;right\u0026#39;], required=True, help=\u0026#34;the limb to test\u0026#34; ) args = parser.parse_args(rospy.myargv()[1:]) return ik_test(args.limb) if __name__ == \u0026#39;__main__\u0026#39;: sys.exit(main()) home_arms.py:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #!/usr/bin/env python \u0026#34;\u0026#34;\u0026#34; Script to return Baxter\u0026#39;s arms to a \u0026#34;home\u0026#34; position \u0026#34;\u0026#34;\u0026#34; # rospy - ROS Python API import rospy # baxter_interface - Baxter Python API import baxter_interface # initialize our ROS node, registering it with the Master rospy.init_node(\u0026#39;Home_Arms\u0026#39;) # create instances of baxter_interface\u0026#39;s Limb class limb_right = baxter_interface.Limb(\u0026#39;right\u0026#39;) limb_left = baxter_interface.Limb(\u0026#39;left\u0026#39;) # store the home position of the arms home_right = {\u0026#39;right_s0\u0026#39;: 0.08, \u0026#39;right_s1\u0026#39;: -1.00, \u0026#39;right_w0\u0026#39;: -0.67, \u0026#39;right_w1\u0026#39;: 1.03, \u0026#39;right_w2\u0026#39;: 0.50, \u0026#39;right_e0\u0026#39;: 1.18, \u0026#39;right_e1\u0026#39;: 1.94} home_left = {\u0026#39;left_s0\u0026#39;: -0.08, \u0026#39;left_s1\u0026#39;: -1.00, \u0026#39;left_w0\u0026#39;: 0.67, \u0026#39;left_w1\u0026#39;: 1.03, \u0026#39;left_w2\u0026#39;: -0.50, \u0026#39;left_e0\u0026#39;: -1.18, \u0026#39;left_e1\u0026#39;: 1.94} # move both arms to home position limb_right.move_to_joint_positions(home_right) limb_left.move_to_joint_positions(home_left) quit() 使用状态机实现YMCA SMACH-基于python的状态机结构库 参考http://wiki.ros.org/smach http://wiki.ros.org/smach/Tutorials 舞出YMCA以及一个中立位置，实现程序为YMCAStateMach.py YMCAStateMach.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 #!/usr/bin/env python # Using the ROS SMACH package, this Python script creates five states # corresponding to Baxter\u0026#39;s arm poses for each letter Y, M, C, A and a # fifth state for a neutral pose. When one pose of the arms completes, # the state will successfully complete and the next state will begin. # Refer to ROS Robotics By Example 2nd edition for a detailed # explanation of this software. import rospy from smach import State,StateMachine from time import sleep from MoveControl import Baxter_Arms class Y(State): def __init__(self): State.__init__(self, outcomes=[\u0026#39;success\u0026#39;]) self.letter_y = { \u0026#39;letter\u0026#39;: { \u0026#39;left\u0026#39;: [0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0], \u0026#39;right\u0026#39;: [0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0] } } #DoF Key [s0,s1,e0,e1,w0,w1,w2] def execute(self, userdata): rospy.loginfo(\u0026#39;Give me a Y!\u0026#39;) barms.supervised_move(self.letter_y) sleep(2) return \u0026#39;success\u0026#39; class M(State): def __init__(self): State.__init__(self, outcomes=[\u0026#39;success\u0026#39;]) self.letter_m = { \u0026#39;letter\u0026#39;: { \u0026#39;left\u0026#39;: [0.0, -1.50, 1.0, -0.052, 3.0, 2.094, 0.0], \u0026#39;right\u0026#39;: [0.0, -1.50, -1.0, -0.052, -3.0, 2.094, 0.0] } } #DoF Key [s0,s1,e0,e1,w0,w1,w2] def execute(self, userdata): rospy.loginfo(\u0026#39;Give me a M!\u0026#39;) barms.supervised_move(self.letter_m) sleep(2) return \u0026#39;success\u0026#39; class C(State): def __init__(self): State.__init__(self, outcomes=[\u0026#39;success\u0026#39;]) self.letter_c = { \u0026#39;letter\u0026#39;: { \u0026#39;left\u0026#39;: [0.80, 0.0, 0.0, -0.052, 3.0, 1.50, 0.0], \u0026#39;right\u0026#39;: [0.0, -1.50, -1.0, -0.052, -3.0, 1.0, 0.0] } } #DoF Key [s0,s1,e0,e1,w0,w1,w2] def execute(self, userdata): rospy.loginfo(\u0026#39;Give me a C!\u0026#39;) barms.supervised_move(self.letter_c) sleep(2) return \u0026#39;success\u0026#39; class A(State): def __init__(self): State.__init__(self, outcomes=[\u0026#39;success\u0026#39;]) self.letter_a = { \u0026#39;letter\u0026#39;: { \u0026#39;left\u0026#39;: [0.50, -1.0, -3.0, 1.0, 0.0, 0.0, 0.0], \u0026#39;right\u0026#39;: [-0.50, -1.0, 3.0, 1.0, 0.0, 0.0, 0.0] } } #DoF Key [s0,s1,e0,e1,w0,w1,w2] def execute(self, userdata): rospy.loginfo(\u0026#39;Give me an A!\u0026#39;) barms.supervised_move(self.letter_a) sleep(2) return \u0026#39;success\u0026#39; class Zero(State): def __init__(self): State.__init__(self, outcomes=[\u0026#39;success\u0026#39;]) self.zero = { \u0026#39;letter\u0026#39;: { \u0026#39;left\u0026#39;: [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00], \u0026#39;right\u0026#39;: [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00] } } #DoF Key [s0,s1,e0,e1,w0,w1,w2] def execute(self, userdata): rospy.loginfo(\u0026#39;Ta-da\u0026#39;) barms.supervised_move(self.zero) sleep(2) return \u0026#39;success\u0026#39; if __name__ == \u0026#39;__main__\u0026#39;: barms = Baxter_Arms() rospy.on_shutdown(barms.clean_shutdown) sm = StateMachine(outcomes=[\u0026#39;success\u0026#39;]) with sm: StateMachine.add(\u0026#39;Y\u0026#39;, Y(), transitions={\u0026#39;success\u0026#39;:\u0026#39;M\u0026#39;}) StateMachine.add(\u0026#39;M\u0026#39;, M(), transitions={\u0026#39;success\u0026#39;:\u0026#39;C\u0026#39;}) StateMachine.add(\u0026#39;C\u0026#39;, C(), transitions={\u0026#39;success\u0026#39;:\u0026#39;A\u0026#39;}) StateMachine.add(\u0026#39;A\u0026#39;, A(), transitions={\u0026#39;success\u0026#39;:\u0026#39;ZERO\u0026#39;}) StateMachine.add(\u0026#39;ZERO\u0026#39;, Zero(), transitions={\u0026#39;success\u0026#39;:\u0026#39;success\u0026#39;}) sm.execute() MoveControl.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 #!/usr/bin/env python # Origional code from Rethink Robotics, Copyright (c) 2013-2015 # This code has been modified encapsulate Baxter\u0026#39;s arms in a class and # provide methods to control the arms. # It works with the YMCAStateMach.py # Refer to ROS Robotics By Example 2nd edition for a detailed # explanation of this software. import argparse from copy import deepcopy import rospy from std_msgs.msg import ( Empty, Bool, ) import baxter_interface from baxter_core_msgs.msg import ( CollisionAvoidanceState, ) from baxter_interface import CHECK_VERSION class Baxter_Arms(): def __init__(self): rospy.loginfo(\u0026#34;Initializing node now... \u0026#34;) rospy.init_node(\u0026#34;moving_arms\u0026#34;) rospy.loginfo(\u0026#34;Node Initialized. \u0026#34;) self._done = False self._limbs = (\u0026#39;left\u0026#39;, \u0026#39;right\u0026#39;) self._arms = { \u0026#39;left\u0026#39;: baxter_interface.Limb(\u0026#39;left\u0026#39;), \u0026#39;right\u0026#39;: baxter_interface.Limb(\u0026#39;right\u0026#39;), } self._pose_rate = rospy.Rate(20.0) # Hz self._pose_threshold = 0.2 # radians self._peak_angle = -1.6 # radians self._arm_state = { \u0026#39;pose\u0026#39;: {\u0026#39;left\u0026#39;: \u0026#39;none\u0026#39;, \u0026#39;right\u0026#39;: \u0026#39;none\u0026#39;}, \u0026#39;collide\u0026#39;: {\u0026#39;left\u0026#39;: False, \u0026#39;right\u0026#39;: False}, \u0026#39;flipped\u0026#39;: {\u0026#39;left\u0026#39;: False, \u0026#39;right\u0026#39;: False} } #Empty positional library that will be fed in and overwritten as arms_pose. self._joint_moves = { \u0026#39;letter\u0026#39;: { \u0026#39;left\u0026#39;: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], \u0026#39;right\u0026#39;: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0] } #DoF Key [s0,s1,e0,e1,w0,w1,w2] } self._collide_lsub = rospy.Subscriber( \u0026#39;robot/limb/left/collision_avoidance_state\u0026#39;, CollisionAvoidanceState, self._update_collision, \u0026#39;left\u0026#39;) self._collide_rsub = rospy.Subscriber( \u0026#39;robot/limb/right/collision_avoidance_state\u0026#39;, CollisionAvoidanceState, self._update_collision, \u0026#39;right\u0026#39;) self._disable_pub = { \u0026#39;left\u0026#39;: rospy.Publisher( \u0026#39;robot/limb/left/suppress_collision_avoidance\u0026#39;, Empty, queue_size=10), \u0026#39;right\u0026#39;: rospy.Publisher( \u0026#39;robot/limb/right/suppress_collision_avoidance\u0026#39;, Empty, queue_size=10) } self._rs = baxter_interface.RobotEnable(CHECK_VERSION) self._enable_pub = rospy.Publisher(\u0026#39;robot/set_super_enable\u0026#39;, Bool, queue_size=10) def _update_collision(self, data, limb): self._arm_state[\u0026#39;collide\u0026#39;][limb] = len(data.collision_object) \u0026gt; 0 self._check_arm_state() def _check_arm_state(self): \u0026#34;\u0026#34;\u0026#34; Check for goals and behind collision field. If s1 joint is over the peak, collision will need to be disabled to get the arm around the head-arm collision force-field. \u0026#34;\u0026#34;\u0026#34; diff_check = lambda a, b: abs(a - b) \u0026lt;= self._pose_threshold for limb in self._limbs: angles = [self._arms[limb].joint_angle(joint) for joint in self._arms[limb].joint_names()] # Check if in a goal position letter_goal = map(diff_check, angles, self._joint_moves[\u0026#39;letter\u0026#39;][limb]) if all(letter_goal): self._arm_state[\u0026#39;pose\u0026#39;][limb] = \u0026#39;letter\u0026#39; else: self._arm_state[\u0026#39;pose\u0026#39;][limb] = \u0026#39;none\u0026#39; # Check if shoulder is flipped over peak self._arm_state[\u0026#39;flipped\u0026#39;][limb] = ( self._arms[limb].joint_angle(limb + \u0026#39;_s1\u0026#39;) \u0026lt;= self._peak_angle) def _move_to(self, new_pose, disabled): if any(disabled.values()): [pub.publish(Empty()) for pub in self._disable_pub.values()] while (any(self._arm_state[\u0026#39;pose\u0026#39;][limb] != goal for limb, goal in new_pose.viewitems()) and not rospy.is_shutdown()): if self._rs.state().enabled == False: self._enable_pub.publish(True) for limb in self._limbs: if disabled[limb]: self._disable_pub[limb].publish(Empty()) if limb in new_pose: self._arms[limb].set_joint_positions(dict(zip( self._arms[limb].joint_names(), self._joint_moves[new_pose[limb]][limb]))) self._check_arm_state() self._pose_rate.sleep() if any(self._arm_state[\u0026#39;collide\u0026#39;].values()): self._rs.disable() return #Importing data in the form of arms_pose, origionally paired with YMCAStateMach.py def supervised_move(self, arms_pose): self._joint_moves = arms_pose # Updating private variable with new arms_pose self._check_arm_state() #Update our starting state to check if arms are posed? rospy.loginfo(\u0026#34;Movement in progress.\u0026#34;) suppress = deepcopy(self._arm_state[\u0026#39;flipped\u0026#39;]) actions = {\u0026#39;left\u0026#39;: \u0026#39;letter\u0026#39;, \u0026#39;right\u0026#39;: \u0026#39;letter\u0026#39;} self._move_to(actions, suppress) self._done = True return def clean_shutdown(self): \u0026#34;\u0026#34;\u0026#34;Handles ROS shutdown (Ctrl-C) safely.\u0026#34;\u0026#34;\u0026#34; if not self._done: rospy.logwarn(\u0026#39;Aborting: Shutting down safely...\u0026#39;) if any(self._arm_state[\u0026#39;collide\u0026#39;].values()): while self._rs.state().enabled != False: [pub.publish(Empty()) for pub in self._disable_pub.values()] self._enable_pub.publish(False) self._pose_rate.sleep() def main(): barms = Baxter_Arms() rospy.on_shutdown(barms.clean_shutdown) barms.supervised_move() rospy.loginfo(\u0026#34;Finished move.\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() YMCAStateMach_for_Sim.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #!/usr/bin/env python # Using the ROS SMACH package, this Python script creates five states # corresponding to Baxter\u0026#39;s arm poses for each letter Y, M, C, A and a # fifth state for a neutral pose. When one pose of the arms completes, # the state will successfully complete and the next state will begin. # Refer to ROS Robotics By Example 2nd edition for a detailed # explanation of this software. import rospy from smach import State,StateMachine from time import sleep from MoveControl import Baxter_Arms class Y(State): def __init__(self): State.__init__(self, outcomes=[\u0026#39;success\u0026#39;]) self.letter_y = { \u0026#39;letter\u0026#39;: { \u0026#39;left\u0026#39;: [0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0], \u0026#39;right\u0026#39;: [0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0] } } #DoF Key [s0,s1,e0,e1,w0,w1,w2] def execute(self, userdata): rospy.loginfo(\u0026#39;Give me a Y!\u0026#39;) barms.supervised_move(self.letter_y) sleep(2) return \u0026#39;success\u0026#39; class M(State): def __init__(self): State.__init__(self, outcomes=[\u0026#39;success\u0026#39;]) self.letter_m = { \u0026#39;letter\u0026#39;: { \u0026#39;left\u0026#39;: [0.0, -1.50, 1.0, -0.05, 2.4, 2.09, 0.0], \u0026#39;right\u0026#39;: [0.0, -1.50, -1.0, -0.05, -2.4, 2.09, 0.0] } } #DoF Key [s0,s1,e0,e1,w0,w1,w2] # \u0026#39;left\u0026#39;: [0.0, -1.50, 1.0, -0.052, 3.0, 2.094, 0.0], original for real Baxter # \u0026#39;right\u0026#39;: [0.0, -1.50, -1.0, -0.052, -3.0, 2.094, 0.0] original for real Baxter def execute(self, userdata): rospy.loginfo(\u0026#39;Give me a M!\u0026#39;) barms.supervised_move(self.letter_m) sleep(2) return \u0026#39;success\u0026#39; class C(State): def __init__(self): State.__init__(self, outcomes=[\u0026#39;success\u0026#39;]) self.letter_c = { \u0026#39;letter\u0026#39;: { \u0026#39;left\u0026#39;: [0.80, 0.0, 0.0, -0.052, 3.0, 1.50, 0.0], \u0026#39;right\u0026#39;: [0.0, -1.50, -1.0, -0.052, -3.0, 1.0, 0.0] } } #DoF Key [s0,s1,e0,e1,w0,w1,w2] def execute(self, userdata): rospy.loginfo(\u0026#39;Give me a C!\u0026#39;) barms.supervised_move(self.letter_c) sleep(2) return \u0026#39;success\u0026#39; class A(State): def __init__(self): State.__init__(self, outcomes=[\u0026#39;success\u0026#39;]) self.letter_a = { \u0026#39;letter\u0026#39;: { \u0026#39;left\u0026#39;: [0.50, -1.0, -3.0, 1.0, 0.0, 0.0, 0.0], \u0026#39;right\u0026#39;: [-0.50, -1.0, 3.0, 1.0, 0.0, 0.0, 0.0] } } #DoF Key [s0,s1,e0,e1,w0,w1,w2] def execute(self, userdata): rospy.loginfo(\u0026#39;Give me an A!\u0026#39;) barms.supervised_move(self.letter_a) sleep(2) return \u0026#39;success\u0026#39; class Zero(State): def __init__(self): State.__init__(self, outcomes=[\u0026#39;success\u0026#39;]) self.zero = { \u0026#39;letter\u0026#39;: { \u0026#39;left\u0026#39;: [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00], \u0026#39;right\u0026#39;: [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00] } } #DoF Key [s0,s1,e0,e1,w0,w1,w2] def execute(self, userdata): rospy.loginfo(\u0026#39;Ta-da\u0026#39;) barms.supervised_move(self.zero) sleep(2) return \u0026#39;success\u0026#39; if __name__ == \u0026#39;__main__\u0026#39;: barms = Baxter_Arms() rospy.on_shutdown(barms.clean_shutdown) sm = StateMachine(outcomes=[\u0026#39;success\u0026#39;]) with sm: StateMachine.add(\u0026#39;Y\u0026#39;, Y(), transitions={\u0026#39;success\u0026#39;:\u0026#39;M\u0026#39;}) StateMachine.add(\u0026#39;M\u0026#39;, M(), transitions={\u0026#39;success\u0026#39;:\u0026#39;C\u0026#39;}) StateMachine.add(\u0026#39;C\u0026#39;, C(), transitions={\u0026#39;success\u0026#39;:\u0026#39;A\u0026#39;}) StateMachine.add(\u0026#39;A\u0026#39;, A(), transitions={\u0026#39;success\u0026#39;:\u0026#39;ZERO\u0026#39;}) StateMachine.add(\u0026#39;ZERO\u0026#39;, Zero(), transitions={\u0026#39;success\u0026#39;:\u0026#39;success\u0026#39;}) sm.execute() PillarTable.scene：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 (noname)+ * pillar 1 box 0.308 0.13056 0.6528 0.7 -0.01 0.03 0.0108439 0.706876 0.0103685 0.707178 0 0 0 0 * tabletop 1 box 0.7 1.3 0.02 0.7 0.04 -0.13 0 0 0 1 0.705882 0.705882 0.705882 1 . ","date":"2023-01-01T00:00:00Z","permalink":"https://raff-zeng.github.io/post/reading-notes/notes-at-school/ros-robotics-develop/","title":"ROS机器人开发"},{"content":"并发与多线程 笔记参考: https://blog.csdn.net/qq_38231713/article/details/106091597\n代码参考: https://github.com/yunxijun/cpp11_multithread/blob/master/main.cpp\nB站https://www.bilibili.com/video/BV1Yb411L7ak?p=1\u0026amp;vd_source=f8705e057957dafd33c98d31eb54e3cd\n第一节 并发基本概念及实现，进程、线程基本概念 （1）并发、进程、线程的基本概念和综述 并发，线程，进程要求必须掌握\n1.1 并发 两个或者更多的任务（独立的活动）同时发生（进行）：一个程序同时执行多个独立的任务；\n以往计算机，单核cpu（中央处理器）：某一个时刻只能执行一个任务，由操作系统调度，每秒钟进行多次所谓的“任务切换”。\n并发的假象（不是真正的并发），切换（上下文切换）时要保存变量的状态、执行进度等，切换回来时需要复原存在时间开销；\n随着硬件发展，出现了多处理器计算机：用于服务器和高性能计算领域。台式机：在一块芯片上有多核（一个CPU内有多个运算核心，对于操作系统来说，每个核心都是作为单独的CPU对待的）：双核，4核，8核，10核（自己的笔记本是4核8线程的）。能够实现真正的并行执行多个任务（硬件并发）\n使用并发的原因：可以同时干多个事，提高性能\n1.2 可执行程序 磁盘上的一个文件，windows下，扩展名为.exe；linux下，ls -la，rwx（可读可写可执行）\n1.3 进程 运行一个可执行程序，在windows下，可双击；在linux下，./文件名\n进程，一个可执行程序运行起来了，就叫创建了一个进程。进程就是运行起来的可执行程序。\n1.4 线程 a)每个进程（执行起来的可执行程序），都有唯一的一个主线程 b)当执行可执行程序时，产生一个进程后，这个主线程就随着这个进程默默启动起来了\nctrl+F5运行这个程序的时候，实际上是进程的主线程来执行（调用）这个main函数中的代码。主线程和进程同时存在\n线程：用来执行代码的。线程这个东西，可以理解为一条代码的执行通路\n除了主线程之外，可以通过写代码来创建其他线程，其他线程走的是别的道路，甚至去不同的地方\n每创建一个新线程，就可以在同一时刻，多干一个不同的事（多走一条不同的代码执行路径）\n多线程（并发） 线程并不是越多越好，每个线程，都需要一个独立的堆栈空间（大约1M），线程之间的切换要保存很多中间状态，切换也会耗费本该属于程序运行的时间 必须使用多线程的案例\n总结线程: a)线程是用来执行代码的;\nb)把线程这个东西理解成一条代码的执行通路 (道路)，一个新线程代表-条新的通路。\nc)一个进程自动包含一个主线程，主线程随着进程默默的启动并运行，我们可以通过编码来创建多个其他线程(非主线程)\n但是创建的数量最大都不建议超过200-300个， 至于到底多少个合适，大家在实际的项目中可以不断调整和优化，有的时候进程太多的时候效率反而会降低\nd)因为主线程是自动启动的，所以一个进程中最少也是有一个线程(主线程)。\ne)说白了:多线程程序可以同时干多个事，所以运行效率高。但是到底有多高，并不是一个很容易评估和量化的东西。\n1.5 学习心得 开发多线程程序：一个是实力的体现，一个是商用的必须需求 线程开发有一定难度 C++线程会设计很多新概念 网络方向：网络通讯、网络服务器，多线程是绝对绕不开的 （2）并发的实现方法 两个或者更多的任务（独立的活动）同时发生（进行）\n实现并发的手段：\na）通过多个进程实现并发\nb）在单独的进程中，写代码创建除了主线程之外的其他线程来实现并发\n2.1 多进程并发 比如账号服务器一个进程，游戏逻辑服务器一个进程。\n进程之间通信（同一个电脑上：管道，文件，消息队列，共享内存）；（不同电脑上：socket通信技术）\n2.2 多线程并发 线程：感觉像是轻量级的进程。每个进程有自己独立的运行路径，但一个进程中的所有线程共享地址空间（共享内存），全局变量、全局内存、全局指针、全局引用都可以在线程之间传递，所以多线程开销远远小于多进程\n共享内存带来新问题，数据一致性问题：线程A和线程B同时写会发生错误。\n多进程并发和多线程并发可以混合使用，但建议优先考虑多线程技术\n本课程中只讲多线程并发技术\n2.3 总结 和进程比，线程如下优点:\n(1)线程启动速度更快，更轻量级;\n(2)系统资源开销更少，执行速度更快，比如共享内存这种通信方式比任何其他的通信方式都快;\n缺点:\n(1)使用有-定难度，要小心处理数据的一致性问题;\n（3）C++11新标准线程库 以往\nwindows：CreateThread(), _beginthread(),_beginthreadexe()创建线程；\nlinux：pthread_create()创建线程；\n以往的多线程代码不能跨平台运行\n临界区，互斥量\nPOSIX thread(pthread)库:跨平台，但要做一番配置，也不方便\nC++11\n从C++11新标准，C++语言本身增加对多线程的支持，意味着可移植性（跨平台），这大大减少开发人员的工作量 第二节 线程启动、结束，创建线程多法、join，detach （1）范例演示线程运行的开始 程序运行起来，生成一个进程，该进程所属的主线程开始自动运行；当主线程从main（）函数返回，则整个进程执行完毕 主线程从main（）开始执行，那么我们自己创建的线程，也需要从一个函数开始运行（初始函数），一旦这个函数运行完毕，线程也结束运行 整个进程是否执行完毕的标志是：主线程是否执行完，如果主线程执行完毕了，就代表整个进程执行完毕了，此时如果其他子线程还没有执行完，也会被强行终止【此条有例外，以后会解释】 创建一个线程：\n包含头文件thread 写初始函数 在main中创建thread 必须要明白：有两个线程在跑，相当于整个程序中有两条线在同时走，即使一条被阻塞，另一条也能运行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; using namespace std; void myPrint() { cout \u0026lt;\u0026lt; \u0026#34;我的线程开始运行\u0026#34; \u0026lt;\u0026lt; endl; //------------- //------------- cout \u0026lt;\u0026lt; \u0026#34;我的线程运行完毕\u0026#34; \u0026lt;\u0026lt; endl; return; } int main() { //(1)创建了线程，线程执行起点（入口）是myPrint；(2)执行线程 thread myThread(myPrint); //(2)阻塞主线程并等待myPrint执行完，当myPrint执行完毕，join()就执行完毕，主线程继续往下执行 //join意为汇合。阻塞主线程，让主线程等待子线程执行完毕，然后子线程和主线程汇合 myThread.join(); //如果主线程执行完毕了，但子线程没执行完毕，该程序不稳定。应该主线程等待子线程执行完毕后，自己才能最终退出。 //设置断点可看到主线程等待子线程的过程 //F11逐语句，就是每z次执行一行语句，如果碰到函数调用，它就会进入到函数里面 //F10逐过程，碰到函数时，不进入函数，把函数调用当成一条语句执行 //(3)传统多线程程序中，主线程要等待子线程执行完毕，然后自己才能向下执行 //detach:分离，主线程不再与子线程汇合，不再等待子线程 //detach后，子线程和主线程失去关联，驻留在后台，由C++运行时库接管（守护线程） //一旦用了detach(),就不能再用join() //myThread.detach(); //(4)joinable()判断是否可以成功使用join()或者detach() //如果返回true，证明可以调用join()或者detach() //如果返回false，证明调用过join()或者detach()，join()和detach()都不能再调用了 if (myThread.joinable()) { cout \u0026lt;\u0026lt; \u0026#34;可以调用可以调用join()或者detach()\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;不能调用可以调用join()或者detach()\u0026#34; \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 重要补充： 线程类参数是一个可调用对象。\n一组可执行的语句称为可调用对象，c++中的可调用对象可以是函数、函数指针、lambda表达式、bind创建的对象或者重载了函数调用运算符的类对象。\n用detach\n​\t不可以使用主线程中局部变量的引用\n​\t主线程的对象会被拷贝到子线程\n二、其他创建线程的方法\n①创建一个类，并编写圆括号重载函数，初始化一个该类的对象，把该对象作为线程入口地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Ta { public: void operator()() //不能带参数 { cout \u0026lt;\u0026lt; \u0026#34;我的线程开始运行\u0026#34; \u0026lt;\u0026lt; endl; //------------- //------------- cout \u0026lt;\u0026lt; \u0026#34;我的线程运行完毕\u0026#34; \u0026lt;\u0026lt; endl; } }; //main函数里的： Ta ta; thread myThread(ta); myThread.join(); ②lambda表达式创建线程\n1 2 3 4 5 6 7 8 9 10 //main函数中 auto lambdaThread = [] { cout \u0026lt;\u0026lt; \u0026#34;我的线程开始执行了\u0026#34; \u0026lt;\u0026lt; endl; //------------- //------------- cout \u0026lt;\u0026lt; \u0026#34;我的线程开始执行了\u0026#34; \u0026lt;\u0026lt; endl; }; thread myThread(lambdaThread); myThread.join(); ③把某个类中的某个函数作为线程的入口地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Data_ { public: void GetMsg(){} void SaveMsh(){} }; //main函数里 Data_ s; //第一个\u0026amp;意思是取址，第二个\u0026amp;意思是引用，相当于std::ref(s) //thread oneobj(\u0026amp;Data_::SaveMsh,s)传值也是可以的 //在其他的构造函数中\u0026amp;obj是不会代表引用的，会被当成取地址 //调用方式：对象成员函数地址，类实例，[成员函数参数] //第二个参数可以传递对象s，也可以传递引用std::ref(s)或\u0026amp;s //传递s，会调用拷贝构造函数在子线程中生成一个新的对象 //传递\u0026amp;，子线程中还是用的原来的对象，所以就不能detach，因为主线程运行完毕会把该对象释放掉 thread oneobj(\u0026amp;Data_::SaveMsh,\u0026amp;s); thread twoobj(\u0026amp;Data_::GetMsg,\u0026amp;s); oneobj.join(); twoobj.join(); 第三节 线程传参详解，detach()大坑，成员函数做线程函数 (1)传递临时对象作为线程参数\n​\t(1.1)要避免的陷阱(解释1)\n​\t(1.2)要避免的陷阱(解释2)\n​\t(1.3)总结\n(2)临时对象作为线程参数继续讲\n​\t(2.1)线程id概念\n​\t(2.2)临时对象构造时机抓捕\n(3)传递类对象、智能指针作为线程参数\n(4)用成员函数指针做线程函数\n一、传递临时对象作为线程参数 1.1要避免的陷阱1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; using namespace std; void myPrint(const int \u0026amp;i, char* pmybuf) { //如果线程从主线程detach了 //i不是mvar真正的引用，实际上值传递，即使主线程中detach了子线程主线程结束了，子线程用i仍然是安全的，但仍不推荐传递引用 //绝不推荐用指针，detach子线程时一定有问题 //推荐改为const int i cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; //pmybuf还是指向原来的字符串，所以这么写是不安全的 cout \u0026lt;\u0026lt; pmybuf \u0026lt;\u0026lt; endl; } int main() { int mvar = 1; int\u0026amp; mvary = mvar; char mybuf[] = \u0026#34;this is a test\u0026#34;; thread myThread(myPrint, mvar, mybuf);//第一个参数是函数名，后两个参数是函数的参数 myThread.join(); //myThread.detach();\t//子线程和主线程分别执行。 cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; endl; } 1.2要避免的陷阱2： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; void myPrint(const int i, const string\u0026amp; pmybuf) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; pmybuf \u0026lt;\u0026lt; endl; } int main() { int mvar = 1; int\u0026amp; mvary = mvar; char mybuf[] = \u0026#34;this is a test\u0026#34;; //如果detach了，这样仍然是不安全的 //因为存在主线程运行完了，mybuf被回收了，系统采用mybuf隐式类型转换成string //推荐先创建一个临时对象thread myThread(myPrint, mvar, string(mybuf));就绝对安全了。。。。直接将mybuf转换成string thread myThread(myPrint, mvar, mybuf); myThread.join(); //myThread.detach(); cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; endl; } notes：\nmain函数执行完之后才执行类的构造函数（20行） 若构造临时对象（19行），则在detach之前会执行构造函数和拷贝构造函数。 只要用临时构造的对象作为参数传递给线程，就能够在主线程执行完毕前把线程函数的第二个参数构建出来，确保即便detach()子线程也安全运行\n1.3总结 如果传递int这种简单类型，推荐使用值传递（const int i），不要用引用 如果传递类对象，避免使用隐式类型转换，全部都在创建线程这一行就创建出临时对象，然后在函数参数里，用引用来接，否则还会创建出一个对象 终极结论：建议不使用detach()，只使用join() 二、临时对象作为线程参数继续讲 2.1线程id概念 id是个数字，每个线程（不管是主线程还是子线程）实际上都对应着一个数字，而且每个线程对应的这个数字都不一样 线程id可以用C++标准库里的函数来获取。std::this_thread::get_id()来获取 三、传递类对象、智能指针作为线程参数 3.1 使用std::ref修改子线程中对象的值就会影响到主线程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; using namespace std; class A { public: mutable int m_i; //m_i即使实在const中也可以被修改 A(int i) :m_i(i) {} }; void myPrint(const A\u0026amp; pmybuf) { pmybuf.m_i = 199; cout \u0026lt;\u0026lt; \u0026#34;子线程myPrint的参数地址是\u0026#34; \u0026lt;\u0026lt; \u0026amp;pmybuf \u0026lt;\u0026lt; \u0026#34;thread = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; } int main() { A myObj(10); //myPrint(const A\u0026amp; pmybuf)中引用不能去掉，如果去掉会多创建一个对象 //const也不能去掉，去掉会出错 //即使是传递的const引用，但在子线程中还是会调用拷贝构造函数构造一个新的对象， //所以在子线程中修改m_i的值不会影响到主线程 //如果希望子线程中修改m_i的值影响到主线程，可以用thread myThread(myPrint, std::ref(myObj)); //这样const就是真的引用了，myPrint定义中的const就可以去掉了，类A定义中的mutable也可以去掉了 thread myThread(myPrint, myObj); myThread.join(); //myThread.detach(); cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; endl; } 3.2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;memory\u0026gt; using namespace std; void myPrint(unique_ptr\u0026lt;int\u0026gt; pzn) { cout \u0026lt;\u0026lt; \u0026#34;thread = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; } int main() { unique_ptr\u0026lt;int\u0026gt; myp(new int(10)); //独占式指针只能通过std::move()才可以传递给另一个指针 //传递后myp就指向空，新的pzn指向原来的内存 //所以这时就不能用detach了，因为如果主线程先执行完，pzn指向的对象就被释放了 thread myThread(myPrint, std::move(up)); myThread.join(); //myThread.detach(); return 0; } 四、用成员函数指针做线程函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class A { ... void thread_work(int num) { cout \u0026lt;\u0026lt; \u0026#34;子线程thread_work执行\u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34;thread = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; } }; int main() { A myobj(10); std::thread mytobj(\u0026amp;A::thread_work,\u0026amp;myobj,15); mytobj.join(); return 0; } 第四节 创建多个线程、数据共享问题分析、案例代码 一、创建和等待多个线程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;map\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;mutex\u0026gt; using namespace std; void myprint(int inum) { cout \u0026lt;\u0026lt; \u0026#34;myprint线程开始执行了，线程id= \u0026#34; \u0026lt;\u0026lt; inum \u0026lt;\u0026lt;endl; //... cout \u0026lt;\u0026lt; \u0026#34;myprint线程结束执行了，线程id= \u0026#34; \u0026lt;\u0026lt; inum \u0026lt;\u0026lt;endl; return; } int main() { vector\u0026lt;thread\u0026gt; mythreads; for (int i = 0; i \u0026lt; 10; i++) { mythreads.push_back(thread(myprint,i)) } for (auto iter = mythreads.begin(); iter != mythreads.end() ; iter++) { iter.join(); } cout \u0026lt;\u0026lt; \u0026#34;I love china\u0026#34; \u0026lt;\u0026lt; endl; return; } 把thread对象放入到容器中管理，看起来像个thread对象数组，对一次创建大量的线程并对大量线程进行管理有好处 多个线程执行顺序是乱的，跟操作系统内部对线程的运行调度机制有关 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void TextThread() { cout \u0026lt;\u0026lt; \u0026#34;我是线程\u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; /* … */ cout \u0026lt;\u0026lt; \u0026#34;线程\u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; \u0026#34;执行结束\u0026#34; \u0026lt;\u0026lt; endl; } //main函数里 vector threadagg; for (int i = 0; i \u0026lt; 10; ++i) { threadagg.push_back(thread(TextThread)); } for (int i = 0; i \u0026lt; 10; ++i) { threadagg[i].join(); } 二：数据共享问题分析 2.1 只读的数据 是安全稳定的，不需要特别处理，直接读就可以。 2.2 有读有写 若不加处理，就会出错\n最简单的防止崩溃方法：读的时候不能写，写的时候不能读。\n2个线程写，8个线程读时。2个线程不能同时写，8个线程不能同时读\n写的动作分10小步，由于任务切换，导致各种诡异的事情发生（最可能的还是崩溃）\nlist：频繁的按顺序插入和删除数据时效率高。vector：随机的插入和删除数据效率高。\n第五节 互斥量概念、用法、死锁演示及解决详解 保护共享数据，操作时，某个线程用代码把共享数据锁住、操作数据、解锁，\n​\t其他想操作共享数据的线程必须等待解锁，锁定住，操作，解锁。\n一、互斥量（mutex）的基本概念 互斥量就是个类对象，可以理解为一把锁，多个线程尝试用lock()成员函数来加锁，只有一个线程能锁定成功（成功的标志是lock()函数返回），如果没有锁成功，那么流程将卡在lock()这里不断尝试去锁定。 互斥量使用要小心，保护数据不多也不少，少了达不到效果，多了影响效率。 二、互斥量的用法 包含#include \u0026lt;mutex\u0026gt;头文件\n2.1 lock()，unlock() 步骤：1.lock()，2.操作共享数据，3.unlock()。 lock()和unlock()要成对使用，代码的每一个分支都要有unlock() 防止忘记unlock()，引入lock_guard() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include \u0026lt;map\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class A { public: void inMsgRecvQueue() { for (int i = 0; i \u0026lt; 10000; ++i) { cout \u0026lt;\u0026lt; \u0026#34;inMsgRecvQueue()执行，插入一个元素\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; { std::lock_guard\u0026lt;std::mutex\u0026gt; myguard(my_mutex); //my_mutex.lock(); msgRecvQueue.push_back(i); } //my_mutex.unlock(); } return; } bool outMsgNULLProc(int \u0026amp;command) { std::lock_guard\u0026lt;std::mutex\u0026gt; myguard(my_mutex);//构造函数执行mutex::lock(); //在作用域结束时，调用析构函数，执行mutex::unlock() //my_mutex.lock(); if (!msgRecvQueue.empty()) { //消息不为空 command = msgRecvQueue.front(); msgRecvQueue.pop_front(); //my_mutex.unlock(); return true; } //my_mutex.unlock(); return false; } void outMsgRecvQueue() { int command = 0; for (int i = 0; i \u0026lt; 10000; ++i) { bool result = outMsgNULLProc(command); if (result == true) { cout \u0026lt;\u0026lt; \u0026#34;outMsgRecvQueue()执行，取出一个元素\u0026#34; \u0026lt;\u0026lt; command \u0026lt;\u0026lt; endl; //数据处理代码... } else { cout \u0026lt;\u0026lt; \u0026#34;outMsgRecvQueue()执行，但目前消息队列中为空\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } } cout \u0026lt;\u0026lt; \u0026#34;end\u0026#34; \u0026lt;\u0026lt; endl; } private: std::list\u0026lt;int\u0026gt; msgRecvQueue; std::mutex my_mutex; }; int main() { A myobja; std::thread myOutMsgObj(\u0026amp;A::outMsgRecvQueue, \u0026amp;myobja); std::thread myInMsgObj(\u0026amp;A::inMsgRecvQueue, \u0026amp;myobja); myOutMsgObj.join(); myInMsgObj.join(); return 0; } 2.2 lock_guard模板 lock_guard\u0026lt;mutex\u0026gt; sbguard(myMutex);取代lock()和unlock() lock_guard构造函数执行了mutex::lock();在作用域结束时，调用析构函数，执行mutex::unlock() 三、死锁 死锁问题至少有两个互斥量才能产生。\n3.1 死锁演示 死锁至少有两个互斥量mutex1，mutex2。\na.线程A执行时，这个线程先锁mutex1，并且锁成功了，然后去锁mutex2的时候，出现了上下文切换，mutex2没锁成功。 b.线程B执行，这个线程先锁mutex2，因为mutex2没有被锁，即mutex2可以被锁成功，然后线程B要去锁mutex1. c.此时，死锁产生了，A锁着mutex1，需要锁mutex2，B锁着mutex2，需要锁mutex1，两个线程没办法继续运行下去。。。 3.2 死锁的一般解决方案： 只要保证多个互斥量上锁的顺序一样就不会造成死锁。\n3.3 std::lock()函数模板 std::lock(mutex1,mutex2……); 一次锁定多个互斥量（一般这种情况很少），用于处理多个互斥量。 如果互斥量中一个没锁住，它就等着，等所有互斥量都锁住，才能继续执行。如果有一个没锁住，就会把已经锁住的释放掉（要么互斥量都锁住，要么都没锁住，防止死锁） 3.4 std::lock_guard的std::adopt_lock参数 std::lock_guardstd::mutex my_guard(my_mutex,std::adopt_lock);\n加入adopt_lock后，在调用lock_guard的构造函数时，不再进行lock();\nadopt_guard为结构体对象，起一个标记作用，表示这个互斥量已经lock()，不需要在lock()。（必须把互斥量提前lock，否则会报异常。）\n建议一个一个锁\n第六节 unique_lock详解 1.unique_lock取代lock_guard unique_lock是个类模板，工作中一般使用lock_guard。\nunique_lock比lock_guard灵活很多（多出来很多用法），效率差一点，内存占用多一点。\nunique_lock\u0026lt;std::mutex\u0026gt; myUniLock(myMutex);\n2.unique_lock的第二个参数 2.1 参数std::adopt_lock： 表示这个互斥量已经被lock()，即不需要在构造函数中lock这个互斥量了。 前提：必须提前lock，否则会报异常。 unique_lock中也可以用这个参数 1 2 std::chrono::milliseconds dura(20000); std::this_thread::sleep_for(dura); //等待20秒 2.2 参数std::try_to_lock： 尝试用mutex的lock()去锁定这个mutex，但如果没有锁定成功，会立即返回，不会阻塞在那里； 使用try_to_lock的原因是防止其他的线程锁定mutex太长时间，导致本线程一直阻塞在lock这个地方 前提：不能提前lock(); owns_lock()方法判断是否拿到锁，如拿到返回true 2.3 参数std::defer_lock： 如果没有第二个参数就对mutex进行加锁，加上defer_lock是初始化了一个没有加锁的mutex 不给它加锁的目的是以后可以调用unique_lock的一些方法 前提：不能提前lock 3.unique_lock的成员函数（前三个与std::defer_lock联合使用） 3.1 lock()：加锁。 1 2 unique_lock\u0026lt;mutex\u0026gt; myUniLock(myMutex， defer_lock); myUniLock.lock(); 不用自己unlock();\n3.2 unlock()：解锁。 1 2 3 4 5 6 7 unique_lock\u0026lt;mutex\u0026gt; myUniLock(myMutex， defer_lock); myUniLock.lock(); //处理一些共享代码 myUniLock.unlock(); //处理一些非共享代码 myUniLock.lock(); //处理一些共享代码 因为一些非共享代码要处理，可以暂时先unlock()，用其他线程把它们处理了，处理完后再lock()。\n3.3 try_lock()：尝试给互斥量加锁 如果拿不到锁，返回false，否则返回true。\n3.4 release()： unique_lock\u0026lt;mutex\u0026gt; myUniLock(myMutex);相当于把myMutex和myUniLock绑定在了一起，release()就是解除绑定，返回它所管理的mutex对象的指针，并释放所有权 mutex* ptx = myUniLock.release();所有权由ptx接管，如果原来mutex对象处理加锁状态，就需要ptx在以后进行解锁了(ptx-\u0026gt;unlock())。 为什么需要unlock，因为lock的代码段越少，执行越快，整个程序的运行效率越高。\n锁住的多少 称为代码的粗细。\n​\ta.锁住的代码少，叫做粒度细，执行效率高； ​\tb.锁住的代码多，叫做粒度粗，执行效率低；\n4.unique_lock所有权的传递 unique_lock\u0026lt;mutex\u0026gt; myUniLock(myMutex);把myMutex和myUniLock绑定在了一起，也就是myUniLock拥有myMutex的所有权\n1.使用move转移 myUniLock拥有myMutex的所有权，myUniLock可以把自己对myMutex的所有权转移，但是不能复制。 unique_lock\u0026lt;mutex\u0026gt; myUniLock2(std::move(myUniLock)); 现在myUniLock2拥有myMutex的所有权。 2.在函数中return一个临时变量，即可以实现转移 1 2 3 4 5 6 7 8 9 unique_lock\u0026lt;mutex\u0026gt; rtn_unique_lock() { unique_lock\u0026lt;mutex\u0026gt; tempUniLock(myMutex); //移动构造函数那里讲从函数返回一个局部的unique_lock对象是可以的 //返回这种局部对象会导致系统生成临时的unique_lock对象，并调用unique_lock的移动构造函数 return myUniLock; } // 然后就可以在外层调用，在sbguard具有对myMutex的所有权 std::unique_lock\u0026lt;std::mutex\u0026gt; sbguard = rtn_unique_lock(); 第七节 单例设计模式共享数据分析、解决，call_once 1.设计模式 “设计模式”：代码的一些写法\n程序灵活，维护起来可能方便，用设计模式理念写出来的代码很晦涩，但是别人接管、阅读代码都会很痛苦 老外应付特别大的项目时，把项目的开发经验、模块划分经验，总结整理成设计模式（先有开发需求，后有理论总结和整理） 中国零几年设计模式刚开始火时，总喜欢拿一个设计模式往上套，导致一个小小的项目总要加几个设计模式，本末倒置 设计模式有其独特的优点，要活学活用，不要深陷其中，生搬硬套 2.单例设计模式： 单例设计模式使用频率比较高。\n整个项目中，有某个或者某些特殊的类，只能创建一个属于该类的对象。\n单例类：只能生成一个对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;map\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class MyCAS { private: MyCAS() {}\t//私有化构造函数 private: static MyCAS *m_instance; public: static MyCAS *GetInstance() { // 这里多线程下不安全 if (m_instance == NULL) { // 两个线程可能同时执行到这里，这样不好 m_instance = new MyCAS(); // 创建一个静态类对象 static GarbageCollection c; } return m_instance; } void func() { cout \u0026lt;\u0026lt; \u0026#34;test\u0026#34; \u0026lt;\u0026lt; endl; } // 引入一个类，对new的对象进行回收 class GarbageCollection { public: ~GarbageCollection() { if (MyCAS::m_instance) { // 连个线程可能同时 delete MyCAS::m_instance; MyCAS::m_instance = NULL; } } }; }; //类静态变量初始化 MyCAS *MyCAS::m_instance = NULL; int main() { MyCAS *p_a = MyCAS::GetInstance(); p_a-\u0026gt;func(); MyCAS::GetInstance()-\u0026gt;func(); system(\u0026#34;pause\u0026#34;); return 0; } 3.单例设计模式共享数据分析、解决 面临问题：需要在自己创建的线程中来创建单例类的对象，这种线程可能不止一个。我们可能面临GetInstance()这种成员函数需要互斥。\n可以在加锁前判断m_instance是否为空，否则每次调用Singleton::getInstance()都要加锁，十分影响效率。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include \u0026lt;map\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; std::mutex resource_mutex; class MyCAS { private: MyCAS() {}\t//私有化构造函数 private: static MyCAS *m_instance; public: static MyCAS *GetInstance() { //提高效率 //如果if(m_instance != NULL)，条件成立，则肯定表示m_instance已经被new过 //如果if(m_instance == NULL)，条件成立，不代表m_instance一定没被new过 //双重锁定 if (m_instance == NULL) { std::unique_lock\u0026lt;std::mutex\u0026gt; mymutex(resource_mutex); if (m_instance == NULL) { // 两个线程可能同时执行到这里，这样不好 m_instance = new MyCAS(); // 创建一个静态类对象 static GarbageCollection c; } } return m_instance; } void func() { cout \u0026lt;\u0026lt; \u0026#34;test\u0026#34; \u0026lt;\u0026lt; endl; } // 引入一个类，对new的对象进行回收 class GarbageCollection { public: ~GarbageCollection() { if (MyCAS::m_instance) { // 连个线程可能同时 delete MyCAS::m_instance; MyCAS::m_instance = NULL; } } }; }; //类静态变量初始化 MyCAS *MyCAS::m_instance = NULL; int main() { MyCAS *p_a = MyCAS::GetInstance(); p_a-\u0026gt;func(); MyCAS::GetInstance()-\u0026gt;func(); system(\u0026#34;pause\u0026#34;); return 0; } 如果觉得在单例模式new了一个对象，而没有自己delete掉，这样不合理。可以增加一个类中类CGarhuishou，new一个单例类时创建一个静态的CGarhuishou对象，这样在程序结束时会调用CGarhuishou的析构函数，释放掉new出来的单例对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Singelton { public: static Singleton * getInstance() { if (instance == NULL) { static CGarhuishou huishou; instance = new Singelton; } return instance; } class CGarhuishou { public: ~CGarhuishou() { if (Singleton::instance) { delete Singleton::instance; Singleton::instance = NULL; } } }; private: Singleton() {} static Singleton *instance; }; Singleton * Singleton::instance = NULL; 4.std::call_once()： 函数模板，该函数的第一个参数为标记，第二个参数是一个函数名（如a()）。\n功能：能够保证函数a()只被调用一次。\n具备互斥量的能力，而且比互斥量消耗的资源更少，更高效。\ncall_once()需要与一个标记结合使用，这个标记为std::once_flag；其实once_flag是一个结构;\ncall_once()就是通过标记来决定函数是否执行，调用成功后，就把标记设置为一种已调用状态。\n多个线程同时执行时，一个线程会等待另一个线程先执行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 std::once_flag g_flag; class Singleton { public: static void CreateInstance()//call_once保证其只被调用一次 { instance = new Singleton; } //两个线程同时执行到这里，其中一个线程要等另外一个线程执行完毕 static Singleton * getInstance() { call_once(g_flag, CreateInstance); return instance; } private: Singleton() {} static Singleton *instance; }; Singleton * Singleton::instance = NULL; 第八节 condition_variable、wait、notify_one、notify_all 一、条件变量condition_variable、wait、notify_one、notify_all std::condition_variable实际上是一个类，是一个和条件相关的类，说白了就是等待一个条件达成。 需要和互斥量来配合工作，用的时候需要生成这个类的对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;map\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class A { public: void inMsgRecvQueue() { for (int i = 0; i \u0026lt; 10000; ++i) { cout \u0026lt;\u0026lt; \u0026#34;inMsgRecvQueue()执行，插入一个元素\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; std::lock_guard\u0026lt;std::mutex\u0026gt; myguard(my_mutex); msgRecvQueue.push_back(i); my_cond.notify_one();\t//把wait()的线程唤醒 } return; } void outMsgRecvQueue() { int command = 0; while (true) { std::unique_lock\u0026lt;std::mutex\u0026gt; myguard1(my_mutex); //wait()用来等一个东西 //如果第二个参数 lambda表达式返回值为true，那么wait()直接返回并继续执行。 //如果第二个参数 lambda表达式返回值为false，那么wait()将解锁互斥量，并堵塞到本行 //堵塞到其他某个线程调用notify_one()成员函数为止 //如果wait()没有第二个参数，my_cond.wait(myguard1);那么就跟第二个参数lambda表达式返回false效果一样 //wait()将解锁互斥量，并堵塞到本行，堵塞到其他某个线程调用notify_one()成员函数为止 my_cond.wait(myguard1, [this] { if (!msgRecvQueue.empty()) return true; return false; }); command = msgRecvQueue.front();\t//返回第一个元素 msgRecvQueue.pop_front();\t//移除第一个元素 myguard1.unlock();\t//因为unique_lock的灵活性，所以我们可以随时解锁，以免锁住太长时间。 cout \u0026lt;\u0026lt; \u0026#34;outMsgRecvQueue()执行，取出一个元素\u0026#34; \u0026lt;\u0026lt; command \u0026lt;\u0026lt; endl; } } private: std::list\u0026lt;int\u0026gt; msgRecvQueue; std::mutex my_mutex; std::condition_variable my_cond; }; int main() { A myobja; std::thread myOutMsgObj(\u0026amp;A::outMsgRecvQueue, \u0026amp;myobja); std::thread myInMsgObj(\u0026amp;A::inMsgRecvQueue, \u0026amp;myobja); myOutMsgObj.join(); myInMsgObj.join(); return 0; } wait()用来等一个东西\n如果第二个参数的lambda表达式返回值是false，那么wait()将解锁互斥量，并阻塞到本行 如果第二个参数的lambda表达式返回值是true，那么wait()直接返回并继续执行。\n阻塞到什么时候为止呢？阻塞到其他某个线程调用notify_one()成员函数为止；\n如果没有第二个参数，那么效果跟第二个参数lambda表达式返回false效果一样\nwait()将解锁互斥量，并阻塞到本行，阻塞到其他某个线程调用notify_one()成员函数为止。\n当其他线程用notify_one()将本线程wait()唤醒后，这个wait恢复后。wait()不断尝试获取互斥量锁，如果获取不到那么流程就卡在wait()这里等待获取，如果获取到了，那么wait()就继续执行，获取到了锁\nwait被唤醒后，输入和输出队列都尝试获取锁，谁获得锁不确定。\n若outMsgRecvQueue()正在处理一个事务，需要一段时间，而不是正卡在wait()等待被唤醒，那么此时这个notify_once无效。\n2.1、如果wait有第二个参数就判断这个lambda表达式。 a)如果表达式为false，那wait又对互斥量解锁，然后又休眠，等待再次被notify_one()唤醒 b)如果lambda表达式为true，则wait返回，流程可以继续执行（此时互斥量已被锁住）。 2.2、如果wait没有第二个参数，则wait返回，流程走下去。 流程只要走到了wait()下面则互斥量一定被锁住了。\n二、深入思考 上面的代码可能导致出现一种情况：\n因为outMsgRecvQueue()与inMsgRecvQueue()并不是一对一执行的，所以当程序循环执行很多次以后，可能在msgRecvQueue 中已经有了很多消息，但是，outMsgRecvQueue还是被唤醒一次只处理一条数据。这时可以考虑把outMsgRecvQueue多执行几次，或者对inMsgRecvQueue进行限流。\n三、notify_all() notify_one()：通知一个线程的wait()\nnotify_all()：通知所有线程的wait()\n第九节、async、future、packaged_task、promise 本节内容需要包含头文件#include \u0026lt;future\u0026gt;\n一、std::async、std::future创建后台任务并返回值 std::async是一个函数模板，用来启动一个异步任务，启动起来一个异步任务之后，它返回一个std::future对象，这个对象是个类模板。\n什么叫“启动一个异步任务”？\n​\t就是自动创建一个线程，并开始 执行对应的线程入口函数，它返回一个std::future对象，这个std::future对象中就含有线程入口函数所返回的结果，我们可以通过调用future对象的成员函数get()来获取结果。\n“future”将来的意思，也有人称呼std::future提供了一种访问异步操作结果的机制，就是说这个结果你可能没办法马上拿到，在这个线程执行完毕的时候，就能够拿到结果了，所以大家这么理解：future中保存着一个值，这个值是在将来的某个时刻能够拿到。\nstd::future对象的get()成员函数会等待线程执行结束并返回结果，拿不到结果它就会一直等待，感觉有点像join()。但是，它是可以获取结果的。\nget()只能调用一次，不能调用多次 std::future对象的wait()成员函数，用于等待线程返回，本身并不返回结果，这个效果和 std::thread 的join()更像。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;future\u0026gt; using namespace std; class A { public: int mythread(int mypar) { cout \u0026lt;\u0026lt; mypar \u0026lt;\u0026lt; endl; return mypar; } }; int mythread() { cout \u0026lt;\u0026lt; \u0026#34;mythread() start\u0026#34; \u0026lt;\u0026lt; \u0026#34;threadid = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; std::chrono::milliseconds dura(5000); std::this_thread::sleep_for(dura); cout \u0026lt;\u0026lt; \u0026#34;mythread() end\u0026#34; \u0026lt;\u0026lt; \u0026#34;threadid = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; return 5; } int main() { A a; int tmp = 12; cout \u0026lt;\u0026lt; \u0026#34;main\u0026#34; \u0026lt;\u0026lt; \u0026#34;threadid = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; std::future\u0026lt;int\u0026gt; result1 = std::async(mythread); cout \u0026lt;\u0026lt; \u0026#34;continue........\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; result1.get() \u0026lt;\u0026lt; endl; //卡在这里等待mythread()执行完毕，拿到结果 等待拿到返回值 //类成员函数 std::future\u0026lt;int\u0026gt; result2 = std::async(\u0026amp;A::mythread, \u0026amp;a, tmp); //第二个参数是对象引用才能保证线程里执行的是同一个对象 cout \u0026lt;\u0026lt; result2.get() \u0026lt;\u0026lt; endl; //或者result2.wait(); //等待线程返回，但不返回结果 cout \u0026lt;\u0026lt; \u0026#34;good luck\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 我们通过向std::async()传递一个参数，该参数是std::launch类型（枚举类型），来达到一些特殊的目的：\n1、std::launch::deferred： （defer推迟，延期）表示线程入口函数的调用会被延迟，一直到std::future的wait()或者get()函数被调用时（由主线程调用）才会执行；\n如果wait()或者get()没有被调用，则不会执行。\n实际上根本就没有创建新线程。std::launch::deferred意思时延迟调用，并没有创建新线程，是在主线程中调用的线程入口函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include \u0026lt;future\u0026gt; using namespace std; int mythread() { cout \u0026lt;\u0026lt; \u0026#34;mythread() start\u0026#34; \u0026lt;\u0026lt; \u0026#34;threadid = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; std::chrono::milliseconds dura(5000); std::this_thread::sleep_for(dura); cout \u0026lt;\u0026lt; \u0026#34;mythread() end\u0026#34; \u0026lt;\u0026lt; \u0026#34;threadid = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; return 5; } int main() { cout \u0026lt;\u0026lt; \u0026#34;main\u0026#34; \u0026lt;\u0026lt; \u0026#34;threadid = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; std::future\u0026lt;int\u0026gt; result1 = std::async(std::launch::deferred ,mythread); cout \u0026lt;\u0026lt; \u0026#34;continue........\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; result1.get() \u0026lt;\u0026lt; endl; //卡在这里等待mythread()执行完毕，拿到结果 cout \u0026lt;\u0026lt; \u0026#34;good luck\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 永远都会先打印出continue…，然后才会打印出mythread() start和mythread() end等信息。\n2、std::launch::async，在调用async函数的时候就开始创建新线程。 1 2 3 4 5 6 7 8 int main() { cout \u0026lt;\u0026lt; \u0026#34;main\u0026#34; \u0026lt;\u0026lt; \u0026#34;threadid = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; std::future\u0026lt;int\u0026gt; result1 = std::async(std::launch::async ,mythread); cout \u0026lt;\u0026lt; \u0026#34;continue........\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; result1.get() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;good luck\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 二、std::packaged_task：打包任务，把任务包装起来。 类模板，它的模板参数是各种可调用对象，通过packaged_task把各种可调用对象包装起来，方便将来作为线程入口函数来调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;thread\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;future\u0026gt; using namespace std; int mythread(int mypar) { cout \u0026lt;\u0026lt; mypar \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;mythread() start\u0026#34; \u0026lt;\u0026lt; \u0026#34;threadid = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; std::chrono::milliseconds dura(5000); std::this_thread::sleep_for(dura); cout \u0026lt;\u0026lt; \u0026#34;mythread() end\u0026#34; \u0026lt;\u0026lt; \u0026#34;threadid = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; return 5; } int main() { cout \u0026lt;\u0026lt; \u0026#34;main\u0026#34; \u0026lt;\u0026lt; \u0026#34;threadid = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; //我们把函数mythread通过packaged_task包装起来 //参数是一个int，返回值类型是int std::packaged_task\u0026lt;int(int)\u0026gt; mypt(mythread); std::thread t1(std::ref(mypt), 1); t1.join(); std::future\u0026lt;int\u0026gt; result = mypt.get_future(); //std::future对象里包含有线程入口函数的返回结果，这里result保存mythread返回的结果。 cout \u0026lt;\u0026lt; result.get() \u0026lt;\u0026lt; endl; return 0; } 可调用对象可由函数换成lambda表达式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int main() { cout \u0026lt;\u0026lt; \u0026#34;main\u0026#34; \u0026lt;\u0026lt; \u0026#34;threadid = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; std::packaged_task\u0026lt;int(int)\u0026gt; mypt([](int mypar) { cout \u0026lt;\u0026lt; mypar \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;mythread() start\u0026#34; \u0026lt;\u0026lt; \u0026#34;threadid = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; std::chrono::milliseconds dura(5000); std::this_thread::sleep_for(dura); cout \u0026lt;\u0026lt; \u0026#34;mythread() end\u0026#34; \u0026lt;\u0026lt; \u0026#34;threadid = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; return 5; }); std::thread t1(std::ref(mypt), 1); t1.join(); std::future\u0026lt;int\u0026gt; result = mypt.get_future(); //std::future对象里包含有线程入口函数的返回结果，这里result保存mythread返回的结果。 cout \u0026lt;\u0026lt; result.get() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;good luck\u0026#34; \u0026lt;\u0026lt; endl; return 0; } packaged_task包装起来的可调用对象还可以直接调用，从这个角度来讲，packaged_task对象也是一个可调用对象 lambda的直接调用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int main() { cout \u0026lt;\u0026lt; \u0026#34;main\u0026#34; \u0026lt;\u0026lt; \u0026#34;threadid = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; std::packaged_task\u0026lt;int(int)\u0026gt; mypt([](int mypar) { cout \u0026lt;\u0026lt; mypar \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;mythread() start\u0026#34; \u0026lt;\u0026lt; \u0026#34;threadid = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; std::chrono::milliseconds dura(5000); std::this_thread::sleep_for(dura); cout \u0026lt;\u0026lt; \u0026#34;mythread() end\u0026#34; \u0026lt;\u0026lt; \u0026#34;threadid = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; return 5; }); mypt(1); std::future\u0026lt;int\u0026gt; result = mypt.get_future(); cout \u0026lt;\u0026lt; result.get() \u0026lt;\u0026lt; endl; } std::promise，类模板 我们能够在某个线程中给它赋值，然后我们可以在其他线程中，把这个值取出来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;thread\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;future\u0026gt; using namespace std; void mythread(std::promise\u0026lt;int\u0026gt; \u0026amp;tmp, int clac) { cout \u0026lt;\u0026lt; \u0026#34;mythread() start\u0026#34; \u0026lt;\u0026lt; \u0026#34;threadid = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; std::chrono::milliseconds dura(5000); std::this_thread::sleep_for(dura); cout \u0026lt;\u0026lt; \u0026#34;mythread() end\u0026#34; \u0026lt;\u0026lt; \u0026#34;threadid = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; int result = clac; tmp.set_value(result); //结果保存到了tmp这个对象中 return; } vector\u0026lt;std::packaged_task\u0026lt;int(int)\u0026gt;\u0026gt; task_vec; int main() { std::promise\u0026lt;int\u0026gt; myprom; std::thread t1(mythread, std::ref(myprom), 180); t1.join(); //在这里线程已经执行完了 std::future\u0026lt;int\u0026gt; fu1 = myprom.get_future(); //promise和future绑定，用于获取线程返回值 auto result = fu1.get(); cout \u0026lt;\u0026lt; \u0026#34;result = \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; } **总结：**通过promise保存一个值，在将来某个时刻我们通过把一个future绑定到这个promise上，来得到绑定的值\n注意：使用thread时，必须 join() 或者 detach() 否则程序会报异常\n小结：\n我们学习这些东西的目的并不是，要把他们都用到实际开发中。\n相反，如果我们能够用最少的东西写出一个稳定的，高效的多线程程序，更值得赞赏。\n我们为了成长必须阅读一些高手写的代码，从而实现自己代码的积累；\n第十节 future其他成员函数、shared_future、atomic 一、std::future 的成员函数 1、std::future_status status = result.wait_for(std::chrono::seconds(2)); 卡住当前流程，等待std::async()的异步任务运行一段时间，然后返回其状态std::future_status。如果std::async()的参数是std::launch::deferred（延迟执行），则不会卡住主流程。 std::future_status是枚举类型，表示异步任务的执行状态。类型的取值有 std::future_status::timeout std::future_status::ready std::future_status::deferred\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;future\u0026gt; using namespace std; int mythread() { cout \u0026lt;\u0026lt; \u0026#34;mythread() start\u0026#34; \u0026lt;\u0026lt; \u0026#34;threadid = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; std::chrono::milliseconds dura(5000); std::this_thread::sleep_for(dura); cout \u0026lt;\u0026lt; \u0026#34;mythread() end\u0026#34; \u0026lt;\u0026lt; \u0026#34;threadid = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; return 5; } int main() { cout \u0026lt;\u0026lt; \u0026#34;main\u0026#34; \u0026lt;\u0026lt; \u0026#34;threadid = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; std::future\u0026lt;int\u0026gt; result = std::async(mythread); cout \u0026lt;\u0026lt; \u0026#34;continue........\u0026#34; \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; result1.get() \u0026lt;\u0026lt; endl; //卡在这里等待mythread()执行完毕，拿到结果 //等待1秒 std::future_status status = result.wait_for(std::chrono::seconds(1)); if (status == std::future_status::timeout) { //超时：表示线程还没有执行完 cout \u0026lt;\u0026lt; \u0026#34;超时了，线程还没有执行完\u0026#34; \u0026lt;\u0026lt; endl; } //类成员函数 return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; #include \u0026lt;future\u0026gt; using namespace std; int mythread() { cout \u0026lt;\u0026lt; \u0026#34;mythread() start\u0026#34; \u0026lt;\u0026lt; \u0026#34;threadid = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; //std::chrono::milliseconds dura(5000); //std::this_thread::sleep_for(dura); cout \u0026lt;\u0026lt; \u0026#34;mythread() end\u0026#34; \u0026lt;\u0026lt; \u0026#34;threadid = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; return 5; } int main() { cout \u0026lt;\u0026lt; \u0026#34;main\u0026#34; \u0026lt;\u0026lt; \u0026#34;threadid = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; std::future\u0026lt;int\u0026gt; result = std::async(std::launch::deferred, mythread); //std::future\u0026lt;int\u0026gt; result = std::async(mythread); cout \u0026lt;\u0026lt; \u0026#34;continue........\u0026#34; \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; result1.get() \u0026lt;\u0026lt; endl; //卡在这里等待mythread()执行完毕，拿到结果 std::future_status status = result.wait_for(std::chrono::seconds(6)); if (status == std::future_status::timeout) { //超时：表示线程还没有执行完 cout \u0026lt;\u0026lt; \u0026#34;超时了，线程还没有执行完\u0026#34; \u0026lt;\u0026lt; endl; } else if (status == std::future_status::ready) { //表示线程成功返回 cout \u0026lt;\u0026lt; \u0026#34;线程执行成功，返回\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; result.get() \u0026lt;\u0026lt; endl; } else if (status == std::future_status::deferred) { //如果设置 std::future\u0026lt;int\u0026gt; result = std::async(std::launch::deferred, mythread);，则本条件成立 cout \u0026lt;\u0026lt; \u0026#34;线程延迟执行\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; result.get() \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;good luck\u0026#34; \u0026lt;\u0026lt; endl; return 0; } get()只能使用一次，比如如果\n1 2 auto a = result.get(); cout \u0026lt;\u0026lt; result.get() \u0026lt;\u0026lt; endl; 就会报告异常 因为std::future中的get()函数的设计是一个移动语义，相当于将result中的值移动到了a中，再次get就报告了异常。\n二、std::shared_future：也是个类模板 std::future的 get() 成员函数是转移数据\nstd::shared_future 的 get()成员函数是复制数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;thread\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;future\u0026gt; using namespace std; int mythread() { cout \u0026lt;\u0026lt; \u0026#34;mythread() start\u0026#34; \u0026lt;\u0026lt; \u0026#34;threadid = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; std::chrono::milliseconds dura(5000); std::this_thread::sleep_for(dura); cout \u0026lt;\u0026lt; \u0026#34;mythread() end\u0026#34; \u0026lt;\u0026lt; \u0026#34;threadid = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; return 5; } int main() { cout \u0026lt;\u0026lt; \u0026#34;main\u0026#34; \u0026lt;\u0026lt; \u0026#34;threadid = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; endl; std::packaged_task\u0026lt;int()\u0026gt; mypt(mythread); std::thread t1(std::ref(mypt)); std::future\u0026lt;int\u0026gt; result = mypt.get_future(); bool ifcanget = result.valid(); //判断future中的值是不是一个有效值 std::shared_future\u0026lt;int\u0026gt; result_s(result.share()); //执行完毕后result_s里有值，而result里空了 //std::shared_future\u0026lt;int\u0026gt; result_s(std::move(result)); //通过get_future返回值直接构造一个shared_future对象 //std::shared_future\u0026lt;int\u0026gt; result_s(mypt.get_future()); t1.join(); auto myresult1 = result_s.get(); auto myresult2 = result_s.get(); cout \u0026lt;\u0026lt; \u0026#34;good luck\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 三、std::atomic原子操作 3.1 原子操作概念引出范例： 互斥量：多线程编程中 用于保护共享数据：先锁住， 操作共享数据， 解锁。\n有两个线程，对一个变量进行操作，一个线程读这个变量的值，一个线程往这个变量中写值。\n即使是一个简单变量的读取和写入操作，如果不加锁，也有可能会导致读写值混乱（一条C语句会被拆成3、4条汇编语句来执行，所以仍然有可能混乱）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; using namespace std; int g_count = 0; void mythread1() { for (int i = 0; i \u0026lt; 1000000; i++) { g_count++; } } int main() { std::thread t1(mythread1); std::thread t2(mythread1); t1.join(); t2.join(); cout \u0026lt;\u0026lt; \u0026#34;正常情况下结果应该是200 0000次，实际是\u0026#34; \u0026lt;\u0026lt; g_count \u0026lt;\u0026lt; endl; } 使用mutex解决这个问题（但是速度变慢）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; using namespace std; int g_count = 0; std::mutex mymutex; void mythread1() { for (int i = 0; i \u0026lt; 1000000; i++) { std::unique_lock\u0026lt;std::mutex\u0026gt; u1(mymutex); g_count++; } } int main() { std::thread t1(mythread1); std::thread t2(mythread1); t1.join(); t2.join(); cout \u0026lt;\u0026lt; \u0026#34;正常情况下结果应该是200 0000次，实际是\u0026#34; \u0026lt;\u0026lt; g_count \u0026lt;\u0026lt; endl; } 3.2 基本的std::atomic用法范例 可以把原子操作理解成一种：不需要用到互斥量加锁（无锁）技术的多线程并发编程方式。\n原子操作：在多线程中不会被打断的程序执行片段。\n从效率上来说，原子操作要比互斥量的方式效率要高。\n互斥量的加锁一般是针对一个代码段，而原子操作针对的一般都是一个变量。\n原子操作，一般都是指“不可分割的操作”；也就是说这种操作状态要么是完成的，要么是没完成的，不可能出现半完成状态。\nstd::atomic来代表原子操作，是个类模板。其实std::atomic是用来封装某个类型的值的\n需要添加#include \u0026lt;atomic\u0026gt;头文件\n范例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;atomic\u0026gt; using namespace std; std::atomic\u0026lt;int\u0026gt; g_count = 0; //封装了一个类型为int的 对象（值） void mythread1() { for (int i = 0; i \u0026lt; 1000000; i++) { g_count++;\t//对应的操作是原子操作（不会被打断） } } int main() { std::thread t1(mythread1); std::thread t2(mythread1); t1.join(); t2.join(); cout \u0026lt;\u0026lt; \u0026#34;正常情况下结果应该是200 0000次，实际是\u0026#34; \u0026lt;\u0026lt; g_count \u0026lt;\u0026lt; endl; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;atomic\u0026gt; using namespace std; std::atomic\u0026lt;bool\u0026gt; g_ifEnd = false; //封装了一个类型为bool的 对象（值） void mythread() { std::chrono::milliseconds dura(1000); while (g_ifEnd == false) { cout \u0026lt;\u0026lt; \u0026#34;thread id = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; \u0026#34;运行中\u0026#34; \u0026lt;\u0026lt; endl; std::this_thread::sleep_for(dura); } cout \u0026lt;\u0026lt; \u0026#34;thread id = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; \u0026#34;运行结束\u0026#34; \u0026lt;\u0026lt; endl; } int main() { std::thread t1(mythread); std::thread t2(mythread); std::chrono::milliseconds dura(5000); std::this_thread::sleep_for(dura); g_ifEnd = true; cout \u0026lt;\u0026lt; \u0026#34;程序执行完毕\u0026#34; \u0026lt;\u0026lt; endl; t1.join(); t2.join(); } 总结： 1、原子操作一般用于计数或者统计（如累计发送多少个数据包，累计接收到了多少个数据包），多个线程一起统计，这种情况如果不使用原子操作会导致统计发生混乱。\n2、写商业代码时，如果不确定结果的影响，最好自己先写一小段代码调试。或者不要使用。\n第十一节 std::atomic续谈、std::async深入谈 一、std::atomic续谈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;atomic\u0026gt; using namespace std; std::atomic\u0026lt;int\u0026gt; g_count = 0; //封装了一个类型为int的 对象（值） void mythread1() { for (int i = 0; i \u0026lt; 1000000; i++) { //虽然g_count使用了原子操作模板，但是这种写法既读又写， //会导致计数错误 g_count = g_count + 1; } } int main() { std::thread t1(mythread1); std::thread t2(mythread1); t1.join(); t2.join(); cout \u0026lt;\u0026lt; \u0026#34;正常情况下结果应该是200 0000次，实际是\u0026#34; \u0026lt;\u0026lt; g_count \u0026lt;\u0026lt; endl; } 一般atomic原子操作，针对++，--，+=，-=，\u0026amp;=，|=，^=是支持的，其他操作不一定支持。\n二、std::async深入理解 2.1 std::async参数详述，async 用来创建一个异步任务 延迟调用参数 std::launch::deferred【延迟调用】，std::launch::async【强制创建一个线程】 std::thread() 如果系统资源紧张，那么创建线程可能失败，那么执行std::thread()时整个程序可能崩溃。 std::async()我们一般不叫创建线程（他能够创建线程），一般叫它创建一个异步任务。 std::async和std::thread最明显的不同，就是 async 有时候并不创建新线程。 ①如果用std::launch::deferred 来调用async？\n延迟到调用 get() 或者 wait() 时执行，如果不调用就不会执行 ②如果用std::launch::async来调用async？\n强制这个异步任务在新线程上执行，这意味着，系统必须要创建出新线程来运行入口函数。 ③如果同时用 std::launch::async | std::launch::deferred\n这里这个 | 意味着async的行为可能是 std::launch::async 创建新线程立即执行， 也可能是 std::launch::deferred 没有创建新线程并且延迟到调用get()执行，由系统根据实际情况来决定采取哪种方案\n④不带额外参数 std::async(mythread)，只给async 一个入口函数名，此时的系统给的默认值是 std::launch::async | std::launch::deferred 和 ③ 一样，有系统自行决定异步还是同步运行。\n2.2 std::async和std::thread()区别： std::thread()如果系统资源紧张可能出现创建线程失败的情况，如果创建线程失败那么程序就可能崩溃，而且不容易拿到函数返回值（不是拿不到）\nstd::async()创建异步任务。可能创建线程也可能不创建线程，并且容易拿到线程入口函数的返回值；\n由于系统资源限制： ①如果用std::thread创建的线程太多，则可能创建失败，系统报告异常，崩溃。\n②如果用std::async，一般就不会报异常，因为如果系统资源紧张，无法创建新线程的时候，async不加额外参数的调用方式就不会创建新线程。而是在后续调用get()请求结果时执行在这个调用get()的线程上。\n如果你强制async一定要创建新线程就要使用 std::launch::async 标记。承受的代价是，系统资源紧张时可能崩溃。\n③根据经验，一个程序中线程数量 不宜超过100~200 。\n2.3 async不确定性问题的解决 不加额外参数的async调用时让系统自行决定，是否创建新线程。\nstd::future\u0026lt;int\u0026gt; result = std::async(mythread); 问题焦点在于这个写法，任务到底有没有被推迟执行。\n通过wait_for返回状态来判断：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 std::future_status status = result.wait_for(std::chrono::seconds(6)); //std::future_status status = result.wait_for(6s); if (status == std::future_status::timeout) { //超时：表示线程还没有执行完 cout \u0026lt;\u0026lt; \u0026#34;超时了，线程还没有执行完\u0026#34; \u0026lt;\u0026lt; endl; } else if (status == std::future_status::ready) { //表示线程成功放回 cout \u0026lt;\u0026lt; \u0026#34;线程执行成功，返回\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; result.get() \u0026lt;\u0026lt; endl; } else if (status == std::future_status::deferred) { cout \u0026lt;\u0026lt; \u0026#34;线程延迟执行\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; result.get() \u0026lt;\u0026lt; endl; } 第十二节 windows临界区、其他各种mutex互斥量 一和二、windows临界区 Windows临界区，同一个线程是可以重复进入的，但是进入的次数与离开的次数必须相等。 C++互斥量则不允许同一个线程重复加锁。\nwindows临界区是在windows编程中的内容，了解一下即可，效果几乎可以等同于c++11的mutex\n包含#include \u0026lt;windows.h\u0026gt;\nwindows中的临界区同mutex一样，可以保护一个代码段。但windows的临界区可以进入多次，离开多次，但是进入的次数与离开的次数必须相等，不会引起程序报异常出错。\n而C++11中不允许一次性lock()两次，会报异常。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;Windows.h\u0026gt; #define __WINDOWSJQ_ using namespace std; class A { public: // 把收到的消息传入队列 void inMsgRecvQueue() { for (size_t i = 0; i \u0026lt; 1000; ++i) { cout \u0026lt;\u0026lt; \u0026#34;收到消息，并放入队列 \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; #ifdef __WINDOWSJQ_ EnterCriticalSection(\u0026amp;my_winsec);\t//\t进入临界区 //EnterCriticalSection(\u0026amp;my_winsec);\t//\t可以再次进入临界区,程序不会出错 msgRecvQueue.push_back(i); LeaveCriticalSection(\u0026amp;my_winsec);\t//\t离开临界区 //LeaveCriticalSection(\u0026amp;my_winsec);\t//\t如果进入两次，必须离开两次不会报错 #elif my_mutex.lock(); msgRecvQueue.push_back(i); my_mutex.unlock(); #endif // __WINDOWSJQ_ } cout \u0026lt;\u0026lt; \u0026#34;消息入队结束\u0026#34; \u0026lt;\u0026lt; endl; } // 从队列中取出消息 void outMsgRecvQueue() { for (size_t i = 0; i \u0026lt; 1000; ++i) { #ifdef __WINDOWSJQ_ EnterCriticalSection(\u0026amp;my_winsec);\t//\t进入临界区 if (!msgRecvQueue.empty()) { // 队列不为空 int num = msgRecvQueue.front(); cout \u0026lt;\u0026lt; \u0026#34;从消息队列中取出 \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; msgRecvQueue.pop_front(); } else { // 消息队列为空 cout \u0026lt;\u0026lt; \u0026#34;消息队列为空 \u0026#34; \u0026lt;\u0026lt; endl; } LeaveCriticalSection(\u0026amp;my_winsec);\t//\t离开临界区 #elif my_mutex.lock(); if (!msgRecvQueue.empty()) { // 队列不为空 int num = msgRecvQueue.front(); cout \u0026lt;\u0026lt; \u0026#34;从消息队列中取出 \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; msgRecvQueue.pop_front(); my_mutex.unlock(); } else { // 消息队列为空 cout \u0026lt;\u0026lt; \u0026#34;消息队列为空 \u0026#34; \u0026lt;\u0026lt; endl; my_mutex.unlock(); } #endif // __WINDOWSJQ_ } cout \u0026lt;\u0026lt; \u0026#34;消息出队结束\u0026#34; \u0026lt;\u0026lt; endl; } A() { #ifdef __WINDOWSJQ_ InitializeCriticalSection(\u0026amp;my_winsec);\t//\t用临界区之前要初始化 #endif // __WINDOWSJQ_ } private: list\u0026lt;int\u0026gt; msgRecvQueue; mutex my_mutex; #ifdef __WINDOWSJQ_ CRITICAL_SECTION my_winsec;\t//\twindows中的临界区，非常类似C++11中的mutex #endif // __WINDOWSJQ_ }; int main() { A myobj; thread\tmyInMsgObj(\u0026amp;A::inMsgRecvQueue, \u0026amp;myobj); thread\tmyOutMsgObj(\u0026amp;A::outMsgRecvQueue, \u0026amp;myobj); myInMsgObj.join(); myOutMsgObj.join(); getchar(); return 0; } 三、自动析构技术 C++：lock_guard防止忘了释放信号量，自动释放 windows：可以写个类自动释放临界区：\n上述这种类RAII类（Resource Acquisition is initialization），即资源获取及初始化。容器，智能指针属于这种类。\n四、递归独占互斥量 std::recursive_mutex std::mutex 独占式互斥量\nstd::recursive_mutex：允许在同一个线程中同一个互斥量多次被 lock() ，（但是递归加锁的次数是有限制的，太多可能会报异常），效率要比mutex低。\n如果你真的用了 recursive_mutex 要考虑代码是否有优化空间，如果能调用一次 lock()就不要调用多次。\n五、带超时的互斥量 std::timed_mutex 和 std::recursive_timed_mutex 5.1 std::timed_mutex：是待超时的独占互斥量 try_lock_for()： 等待一段时间，如果拿到了锁，或者超时了未拿到锁，就继续执行（有选择执行）如下:\n1 2 3 4 5 6 7 8 9 10 std::chrono::milliseconds timeout(100); if (my_mymutex.try_lock_for(timeout)){ //......拿到锁返回ture //做一些操作 my_mymutex.unlock(); } else{\t//拿不到锁 std::chrono::milliseconds sleeptime(100); std::this_thread::sleep_for(sleeptime); } try_lock_until()： 参数是一个未来的时间点，在这个未来的时间没到的时间内，如果拿到了锁头，流程就走下来，如果时间到了没拿到锁，流程也可以走下来。\n1 2 3 4 5 6 7 8 std::chrono::milliseconds timeout(100); if (my_mymutex.try_lock_until(chrono::steady_clock::now() + timeout)){ //......拿到锁返回ture } else{ std::chrono::milliseconds sleeptime(100); std::this_thread::sleep_for(sleeptime); } 两者的区别就是一个参数是时间段，一个参数是时间点\n5.2 std::recursive_timed_mutex：是待超时的递归独占互斥量 第十三章 补充知识、线程池浅谈、数量谈、总结 一、补充一些知识点 1.1 虚假唤醒： notify_one或者notify_all唤醒wait()后，实际有些线程可能不满足唤醒的条件，就会造成虚假唤醒，可以在wait中再次进行判断解决虚假唤醒。 解决：wait中要有第二个参数（lambda），并且这个lambda中要正确判断所处理的公共数据是否存在。\n2.2 atomic： 1 2 3 std::atomic\u0026lt;int\u0026gt; atm = 0; cout \u0026lt;\u0026lt; atm \u0026lt;\u0026lt; endl; 这里只有读取atm是原子操作，但是整个这一行代码 cout \u0026laquo; atm \u0026laquo; endl; 并不是原子操作，导致最终显示在屏幕上的值是一个“曾经值”。\n1 2 3 std::atomic\u0026lt;int\u0026gt; atm = 0; auto atm2 = atm; //原子量的赋值不允许 这种拷贝初始化不可以，会报错。\n1 atomic\u0026lt;int\u0026gt; atm2(atm.load()); load()：以原子方式读atomic对象的值。\n1 atm2.store(12); 原子操作实质上是：不允许在进行原子对象操作时进行CPU的上下文切换。\n二、浅谈线程池： 场景设想：服务器程序， 每来一个客户端，就创建一个新线程为这个客户提供服务。\n问题：\n1、2万个玩家，不可能给每个玩家创建一个新线程，此程序写法在这种场景下不通。\n2、程序稳定性问题：编写代码中，“时不时地突然”创建一个线程，这种写法，一般情况下不会出错，但是不稳定的；\n**线程池：**把一堆线程弄到一起，统一管理。这种统一管理调度，循环利用的方式，就叫做线程池。\n**实现方式：**程序启动时，一次性创建好一定数量的线程。这种方式让人更放心，觉得程序代码更稳定。\n三、线程创建数量谈： 1、线程创建的数量极限的问题\n一般来讲，2000个线程基本就是极限；再创建就会崩溃。\n2、线程创建数量建议\na、采用某些计数开发程序提供的建议，遵照建议和指示来确保程序高效执行。\nb、创建多线程完成业务；考虑可能被阻塞的线程数量，创建多余最大被阻塞线程数量的线程，如100个线程被阻塞再充值业务，开110个线程就是很合适的\nc、线程创建数量尽量不要超过500个，尽量控制在200个之内；\n","date":"2023-01-01T00:00:00Z","permalink":"https://raff-zeng.github.io/post/reading-notes/notes-at-school/multithread/","title":"并发与多线程 学习笔记"},{"content":"算法题 代码随想录 一、数组 存放在连续内存空间上的相同类型数据的集合。\n1.二分查找 https://leetcode.cn/problems/binary-search/\n给定一个 n 个元素有序的整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0; int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right] while (left \u0026lt;= right) { // 当left==right，区间[left, right]依然有效，所以用 \u0026lt;= int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2 if (nums[middle] \u0026gt; target) { right = middle - 1; // target 在左区间，所以[left, middle - 1] } else if (nums[middle] \u0026lt; target) { left = middle + 1; // target 在右区间，所以[middle + 1, right] } else { // nums[middle] == target return middle; // 数组中找到目标值，直接返回下标 } } // 未找到目标值 return -1; } }; 时间复杂度：O(log n) 空间复杂度：O(1) 2.移除元素 https://leetcode.cn/problems/remove-element/\n给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n双指针法。通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。\n1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: int removeElement(vector\u0026lt;int\u0026gt;\u0026amp; nums, int val) { int slowIndex = 0; for (int fastIndex = 0; fastIndex \u0026lt; nums.size(); fastIndex++) { if (val != nums[fastIndex]) { nums[slowIndex++] = nums[fastIndex]; } } return slowIndex; } }; 时间复杂度：O(n) 空间复杂度：O(1) 3.有序数组的平方 https://leetcode.cn/problems/squares-of-a-sorted-array/\n给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n双指针法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: vector\u0026lt;int\u0026gt; sortedSquares(vector\u0026lt;int\u0026gt;\u0026amp; A) { int k = A.size() - 1; vector\u0026lt;int\u0026gt; result(A.size(), 0); for (int i = 0, j = A.size() - 1; i \u0026lt;= j;) { // 注意这里要i \u0026lt;= j，因为最后要处理两个元素 if (A[i] * A[i] \u0026lt; A[j] * A[j]) { result[k--] = A[j] * A[j]; j--; } else { result[k--] = A[i] * A[i]; i++; } } return result; } }; 时间复杂度为O(n)\n4.长度最小的子数组 https://leetcode.cn/problems/minimum-size-subarray-sum/\n给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。\n滑动窗口。就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int minSubArrayLen(int s, vector\u0026lt;int\u0026gt;\u0026amp; nums) { int result = INT32_MAX; int sum = 0; // 滑动窗口数值之和 int i = 0; // 滑动窗口起始位置 int subLength = 0; // 滑动窗口的长度 for (int j = 0; j \u0026lt; nums.size(); j++) { sum += nums[j]; // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件 while (sum \u0026gt;= s) { subLength = (j - i + 1); // 取子序列的长度 result = result \u0026lt; subLength ? result : subLength; sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置） } } // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列 return result == INT32_MAX ? 0 : result; } }; 时间复杂度：O(n) 空间复杂度：O(1) 一些录友会疑惑为什么时间复杂度是O(n)。\n不要以为for里放一个while就以为是O(n^2)啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)。\n二、链表 链表在内存中可不是连续分布的。通过指针域的指针链接在内存中各个节点。\n链表的定义：\n1 2 3 4 5 6 7 // 单链表 struct ListNode { int val; // 节点上存储的元素 ListNode *next; // 指向下一个节点的指针 ListNode(int x) : val(x), next(NULL) {} // 节点的构造函数 }; ListNode* head = new ListNode(5); //初始化节点 1.移除链表元素 https://leetcode.cn/problems/remove-linked-list-elements/\n题意：删除链表中等于给定值 val 的所有节点。\n设置一个虚拟头结点在进行移除节点操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: ListNode* removeElements(ListNode* head, int val) { ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点 dummyHead-\u0026gt;next = head; // 将虚拟头结点指向head，这样方面后面做删除操作 ListNode* cur = dummyHead; while (cur-\u0026gt;next != NULL) { if(cur-\u0026gt;next-\u0026gt;val == val) { ListNode* tmp = cur-\u0026gt;next; cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; delete tmp; } else { cur = cur-\u0026gt;next; } } head = dummyHead-\u0026gt;next; delete dummyHead; return head; } }; 2.翻转链表 https://leetcode.cn/problems/reverse-linked-list/\n双指针法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* temp; // 保存cur的下一个节点 ListNode* cur = head; ListNode* pre = NULL; while(cur) { temp = cur-\u0026gt;next; // 保存一下 cur的下一个节点，因为接下来要改变cur-\u0026gt;next cur-\u0026gt;next = pre; // 翻转操作 // 更新pre 和 cur指针 pre = cur; cur = temp; } return pre; } }; 时间复杂度: O(n) 空间复杂度: O(1) 3.两两交换链表中的节点 https://leetcode.cn/problems/swap-nodes-in-pairs/\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点 dummyHead-\u0026gt;next = head; // 将虚拟头结点指向head，这样方面后面做删除操作 ListNode* cur = dummyHead; while(cur-\u0026gt;next != nullptr \u0026amp;\u0026amp; cur-\u0026gt;next-\u0026gt;next != nullptr) { ListNode* tmp = cur-\u0026gt;next; // 记录临时节点 ListNode* tmp1 = cur-\u0026gt;next-\u0026gt;next-\u0026gt;next; // 记录临时节点 cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; // 步骤一 cur-\u0026gt;next-\u0026gt;next = tmp; // 步骤二 cur-\u0026gt;next-\u0026gt;next-\u0026gt;next = tmp1; // 步骤三 cur = cur-\u0026gt;next-\u0026gt;next; // cur移动两位，准备下一轮交换 } return dummyHead-\u0026gt;next; } }; 时间复杂度：O(n) 空间复杂度：O(1) 4.删除链表的倒数第N个节点 https://leetcode.cn/problems/remove-nth-node-from-end-of-list/\n给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummyHead = new ListNode(0); dummyHead-\u0026gt;next = head; ListNode* slow = dummyHead; ListNode* fast = dummyHead; while(n-- \u0026amp;\u0026amp; fast != NULL) { fast = fast-\u0026gt;next; } fast = fast-\u0026gt;next; // fast再提前走一步，因为需要让slow指向删除节点的上一个节点 while (fast != NULL) { fast = fast-\u0026gt;next; slow = slow-\u0026gt;next; } slow-\u0026gt;next = slow-\u0026gt;next-\u0026gt;next; // ListNode *tmp = slow-\u0026gt;next; C++释放内存的逻辑 // slow-\u0026gt;next = tmp-\u0026gt;next; // delete nth; return dummyHead-\u0026gt;next; } }; 时间复杂度: O(n) 空间复杂度: O(1) 5.链表相交 https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode* curA = headA; ListNode* curB = headB; int lenA = 0, lenB = 0; while (curA != NULL) { // 求链表A的长度 lenA++; curA = curA-\u0026gt;next; } while (curB != NULL) { // 求链表B的长度 lenB++; curB = curB-\u0026gt;next; } curA = headA; curB = headB; // 让curA为最长链表的头，lenA为其长度 if (lenB \u0026gt; lenA) { swap (lenA, lenB); swap (curA, curB); } // 求长度差 int gap = lenA - lenB; // 让curA和curB在同一起点上（末尾位置对齐） while (gap--) { curA = curA-\u0026gt;next; } // 遍历curA 和 curB，遇到相同则直接返回 while (curA != NULL) { if (curA == curB) { return curA; } curA = curA-\u0026gt;next; curB = curB-\u0026gt;next; } return NULL; } }; 时间复杂度：O(n + m) 空间复杂度：O(1) 6.环形链表 https://leetcode.cn/problems/linked-list-cycle-ii/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; while(fast != NULL \u0026amp;\u0026amp; fast-\u0026gt;next != NULL) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; // 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇 if (slow == fast) { ListNode* index1 = fast; ListNode* index2 = head; while (index1 != index2) { index1 = index1-\u0026gt;next; index2 = index2-\u0026gt;next; } return index2; // 返回环的入口 } } return NULL; } }; 时间复杂度: O(n)，快慢指针相遇前，指针走的次数小于链表长度，快慢指针相遇后，两个index指针走的次数也小于链表长度，总体为走的次数小于 2n 空间复杂度: O(1) 三、哈希表 哈希表是根据关键码的值而直接进行访问的数据结构。\n使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。\n数组 set （集合） map（映射） 在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：\n集合 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::set 红黑树 有序 否 否 O(log n) O(log n) std::multiset 红黑树 有序 是 否 O(logn) O(logn) std::unordered_set 哈希表 无序 否 否 O(1) O(1) std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树。\n映射 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::map 红黑树 key有序 key不可重复 key不可修改 O(logn) O(logn) std::multimap 红黑树 key有序 key可重复 key不可修改 O(log n) O(log n) std::unordered_map 哈希表 key无序 key不可重复 key不可修改 O(1) O(1) 当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。\n1.有效的字母异位词 用数组解决\n给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: bool isAnagram(string s, string t) { int record[26] = {0}; for (int i = 0; i \u0026lt; s.size(); i++) { // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了 record[s[i] - \u0026#39;a\u0026#39;]++; } for (int i = 0; i \u0026lt; t.size(); i++) { record[t[i] - \u0026#39;a\u0026#39;]--; } for (int i = 0; i \u0026lt; 26; i++) { if (record[i] != 0) { // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。 return false; } } // record数组所有元素都为零0，说明字符串s和t是字母异位词 return true; } }; 时间复杂度: O(n) 空间复杂度: O(1) 2.两个数组的交集 https://leetcode.cn/problems/intersection-of-two-arrays/\n题意：给定两个数组，编写一个函数来计算它们的交集。\n使用unordered_set\n没有限制数值大小，无法使用数组来做哈希表。如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: vector\u0026lt;int\u0026gt; intersection(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { unordered_set\u0026lt;int\u0026gt; result_set; // 存放结果，之所以用set是为了给结果集去重 unordered_set\u0026lt;int\u0026gt; nums_set(nums1.begin(), nums1.end()); for (int num : nums2) { // 发现nums2的元素 在nums_set里又出现过 if (nums_set.find(num) != nums_set.end()) { result_set.insert(num); } } return vector\u0026lt;int\u0026gt;(result_set.begin(), result_set.end()); } }; 时间复杂度: O(mn) 空间复杂度: O(n) 3.快乐数 https://leetcode.cn/problems/happy-number/\n编写一个算法来判断一个数 n 是不是快乐数。\n判断sum是否重复出现就可以使用unordered_set。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: // 取数值各个位上的单数之和 int getSum(int n) { int sum = 0; while (n) { sum += (n % 10) * (n % 10); n /= 10; } return sum; } bool isHappy(int n) { unordered_set\u0026lt;int\u0026gt; set; while(1) { int sum = getSum(n); if (sum == 1) { return true; } // 如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false if (set.find(sum) != set.end()) { return false; } else { set.insert(sum); } n = sum; } } }; 时间复杂度: O(logn) 空间复杂度: O(logn) 4.两数之和 https://leetcode.cn/problems/two-sum/\n给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。\n我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适。\n数组中的元素作为key，value用来存下标。map中的存储结构为 {key：数据元素，value：数组元素对应的下标}。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { std::unordered_map \u0026lt;int,int\u0026gt; map; for(int i = 0; i \u0026lt; nums.size(); i++) { // 遍历当前元素，并在map中寻找是否有匹配的key auto iter = map.find(target - nums[i]); if(iter != map.end()) { return {iter-\u0026gt;second, i}; } // 如果没找到匹配对，就把访问过的元素和下标加入到map中 map.insert(pair\u0026lt;int, int\u0026gt;(nums[i], i)); } return {}; } }; 时间复杂度: O(n) 空间复杂度: O(n) 5.四数相加Ⅱ https://leetcode.cn/problems/4sum-ii/\n定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。 统计A、B两个数组元素之和，和出现的次数，放到map中。 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int fourSumCount(vector\u0026lt;int\u0026gt;\u0026amp; A, vector\u0026lt;int\u0026gt;\u0026amp; B, vector\u0026lt;int\u0026gt;\u0026amp; C, vector\u0026lt;int\u0026gt;\u0026amp; D) { unordered_map\u0026lt;int, int\u0026gt; umap; //key:a+b的数值，value:a+b数值出现的次数 // 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中 for (int a : A) { for (int b : B) { umap[a + b]++; } } int count = 0; // 统计a+b+c+d = 0 出现的次数 // 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。 for (int c : C) { for (int d : D) { if (umap.find(0 - (c + d)) != umap.end()) { count += umap[0 - (c + d)]; } } } return count; } }; 时间复杂度: O(n^2) 空间复杂度: O(n^2)，最坏情况下A和B的值各不相同，相加产生的数字个数为 n^2 6.三数之和 https://leetcode.cn/problems/3sum/\n给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。\n哈希法。需要考虑较多情况。——》双指针法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public:\tvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; sort(nums.begin(), nums.end()); // 找出a + b + c = 0 // a = nums[i], b = nums[j], c = -(a + b) for (int i = 0; i \u0026lt; nums.size(); i++) { // 排序之后如果第一个元素已经大于零，那么不可能凑成三元组 if (nums[i] \u0026gt; 0) { break; } if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { //三元组元素a去重 continue; } unordered_set\u0026lt;int\u0026gt; set; for (int j = i + 1; j \u0026lt; nums.size(); j++) { if (j \u0026gt; i + 2 \u0026amp;\u0026amp; nums[j] == nums[j-1] \u0026amp;\u0026amp; nums[j-1] == nums[j-2]) { // 三元组元素b去重 continue; } int c = 0 - (nums[i] + nums[j]); if (set.find(c) != set.end()) { result.push_back({nums[i], nums[j], c}); set.erase(c);// 三元组元素c去重 } else { set.insert(nums[j]); } } } return result; } }; 时间复杂度: O(n^2) 空间复杂度: O(n)，额外的 set 开销 双指针法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; sort(nums.begin(), nums.end()); // 找出a + b + c = 0 // a = nums[i], b = nums[left], c = nums[right] for (int i = 0; i \u0026lt; nums.size(); i++) { // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了 if (nums[i] \u0026gt; 0) { return result; } // 正确去重a方法 if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } int left = i + 1; int right = nums.size() - 1; while (right \u0026gt; left) { if (nums[i] + nums[left] + nums[right] \u0026gt; 0) right--; else if (nums[i] + nums[left] + nums[right] \u0026lt; 0) left++; else { result.push_back(vector\u0026lt;int\u0026gt;{nums[i], nums[left], nums[right]}); // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重 while (right \u0026gt; left \u0026amp;\u0026amp; nums[right] == nums[right - 1]) right--; while (right \u0026gt; left \u0026amp;\u0026amp; nums[left] == nums[left + 1]) left++; // 找到答案时，双指针同时收缩 right--; left++; } } } return result; } }; 时间复杂度: O(n^2) 空间复杂度: O(1) 四、字符串 1.反转字符串 https://leetcode.cn/problems/reverse-string/\n双指针法\n1 2 3 4 5 6 7 8 class Solution { public: void reverseString(vector\u0026lt;char\u0026gt;\u0026amp; s) { for (int i = 0, j = s.size() - 1; i \u0026lt; s.size()/2; i++, j--) { swap(s[i],s[j]); } } }; 时间复杂度: O(n) 空间复杂度: O(1) 反转字符串Ⅱ\nhttps://leetcode.cn/problems/reverse-string-ii/\n给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: string reverseStr(string s, int k) { for (int i = 0; i \u0026lt; s.size(); i += (2 * k)) { // 1. 每隔 2k 个字符的前 k 个字符进行反转 // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符 if (i + k \u0026lt;= s.size()) { reverse(s.begin() + i, s.begin() + i + k ); } else { // 3. 剩余字符少于 k 个，则将剩余字符全部反转。 reverse(s.begin() + i, s.end()); } } return s; } }; 时间复杂度: O(n) 空间复杂度: O(1) 2.替换空格 https://leetcode.cn/problems/ti-huan-kong-ge-lcof/\n双指针法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: string replaceSpace(string s) { int count = 0; // 统计空格的个数 int sOldSize = s.size(); for (int i = 0; i \u0026lt; s.size(); i++) { if (s[i] == \u0026#39; \u0026#39;) { count++; } } // 扩充字符串s的大小，也就是每个空格替换成\u0026#34;%20\u0026#34;之后的大小 s.resize(s.size() + count * 2); int sNewSize = s.size(); // 从后先前将空格替换为\u0026#34;%20\u0026#34; for (int i = sNewSize - 1, j = sOldSize - 1; j \u0026lt; i; i--, j--) { if (s[j] != \u0026#39; \u0026#39;) { s[i] = s[j]; } else { s[i] = \u0026#39;0\u0026#39;; s[i - 1] = \u0026#39;2\u0026#39;; s[i - 2] = \u0026#39;%\u0026#39;; i -= 2; } } return s; } }; 时间复杂度：O(n) 空间复杂度：O(1) 3.翻转字符串里的单词 https://leetcode.cn/problems/reverse-words-in-a-string/\n移除多余空格 将整个字符串反转 将每个单词反转 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { void removeExtraSpaces(string \u0026amp;s) { for (int i = 0; i \u0026lt; s.size(); ++i) { // if (s[i] != \u0026#39; \u0026#39;) { //遇到非空格就处理，即删除所有空格。 if (slow != 0) s[slow++] = \u0026#39; \u0026#39;; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。 while (i \u0026lt; s.size() \u0026amp;\u0026amp; s[i] != \u0026#39; \u0026#39;) { //补上该单词，遇到空格说明单词结束。 s[slow++] = s[i++]; } } } s.resize(slow); //slow的大小即为去除多余空格后的大小。 } string reverseWords(string s) { removeExtraSpaces(s); //去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。 reverse(s, 0, s.size() - 1); int start = 0; //removeExtraSpaces后保证第一个单词的开始下标一定是0。 for (int i = 0; i \u0026lt;= s.size(); ++i) { if (i == s.size() || s[i] == \u0026#39; \u0026#39;) { //到达空格或者串尾，说明一个单词结束。进行翻转。 reverse(s, start, i - 1); //翻转，注意是左闭右闭 []的翻转。 start = i + 1; //更新下一个单词的开始下标start } } return s; } }; 时间复杂度: O(n) 空间复杂度: O(1) 或 O(n)，取决于语言中字符串是否可变 4.左旋转字符串 https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/\n反转区间为前n的子串 反转区间为n到末尾的子串 反转整个字符串 1 2 3 4 5 6 7 8 9 class Solution { public: string reverseLeftWords(string s, int n) { reverse(s.begin(), s.begin() + n); reverse(s.begin() + n, s.end()); reverse(s.begin(), s.end()); return s; } }; 时间复杂度: O(n) 空间复杂度：O(1) 5.实现 strStr() https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/\n**KMP算法:**当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。\nKMP主要应用在字符串匹配上。\nnext数组。前缀表统一减一，记录字符串有多大长度的相同前缀后缀 。j指向前缀末尾位置，i指向后缀末尾位置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: void getNext(int* next, const string\u0026amp; s) { int j = -1; next[0] = j; for(int i = 1; i \u0026lt; s.size(); i++) { // 注意i从1开始 while (j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j + 1]) { // 前后缀不相同了 j = next[j]; // 向前回退 } if (s[i] == s[j + 1]) { // 找到相同的前后缀 j++; } next[i] = j; // 将j（前缀的长度）赋给next[i] } } int strStr(string haystack, string needle) { if (needle.size() == 0) { return 0; } int next[needle.size()]; getNext(next, needle); int j = -1; // // 因为next数组里记录的起始位置为-1 for (int i = 0; i \u0026lt; haystack.size(); i++) { // 注意i就从0开始 while(j \u0026gt;= 0 \u0026amp;\u0026amp; haystack[i] != needle[j + 1]) { // 不匹配 j = next[j]; // j 寻找之前匹配的位置 } if (haystack[i] == needle[j + 1]) { // 匹配，j和i同时向后移动 j++; // i的增加在for循环里 } if (j == (needle.size() - 1) ) { // 文本串s里出现了模式串t return (i - needle.size() + 1); } } return -1; } }; 时间复杂度: O(n + m) 空间复杂度: O(m), 只需要保存字符串needle的前缀表 6.重复的字符串 https://leetcode.cn/problems/repeated-substring-pattern/\n给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。\n移动匹配。要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。\n1 2 3 4 5 6 7 8 9 class Solution { public: bool repeatedSubstringPattern(string s) { string t = s + s; t.erase(t.begin()); t.erase(t.end() - 1); // 掐头去尾 if (t.find(s) != std::string::npos) return true; // r return false; } }; 时间复杂度: O(n) 空间复杂度: O(1) KMP\n数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: void getNext (int* next, const string\u0026amp; s){ next[0] = -1; int j = -1; for(int i = 1;i \u0026lt; s.size(); i++){ while(j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j + 1]) { j = next[j]; } if(s[i] == s[j + 1]) { j++; } next[i] = j; } } bool repeatedSubstringPattern (string s) { if (s.size() == 0) { return false; } int next[s.size()]; getNext(next, s); int len = s.size(); if (next[len - 1] != -1 \u0026amp;\u0026amp; len % (len - (next[len - 1] + 1)) == 0) { return true; } return false; } }; 时间复杂度: O(n) 空间复杂度: O(n) 五、栈与队列 STL 栈 和队列被归类为容器适配器。栈的底层实现可以是vector，deque，list。默认是以deque。\n队列底层实现缺省情况下一样使用deque实现的。\n1 std::stack\u0026lt;int, std::vector\u0026lt;int\u0026gt; \u0026gt; third; // 使用vector为底层容器的栈 1 std::queue\u0026lt;int, std::list\u0026lt;int\u0026gt;\u0026gt; third; // 定义以list为底层容器的队列 1.用栈实现队列 https://leetcode.cn/problems/implement-queue-using-stacks/\n用两个栈模拟队列，一个输入栈，一个输出栈。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class MyQueue { public: stack\u0026lt;int\u0026gt; stIn; stack\u0026lt;int\u0026gt; stOut; /** Initialize your data structure here. */ MyQueue() { } /** Push element x to the back of queue. */ void push(int x) { stIn.push(x); } /** Removes the element from in front of queue and returns that element. */ int pop() { // 只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据） if (stOut.empty()) { // 从stIn导入数据直到stIn为空 while(!stIn.empty()) { stOut.push(stIn.top()); stIn.pop(); } } int result = stOut.top(); stOut.pop(); return result; } /** Get the front element. */ int peek() { int res = this-\u0026gt;pop(); // 直接使用已有的pop函数 stOut.push(res); // 因为pop函数弹出了元素res，所以再添加回去 return res; } /** Returns whether the queue is empty. */ bool empty() { return stIn.empty() \u0026amp;\u0026amp; stOut.empty(); } }; 时间复杂度: push和empty为O(1), pop和peek为O(n)\n空间复杂度: O(n)\n2.用队列实现栈 https://leetcode.cn/problems/implement-stack-using-queues/\n一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class MyStack { public: queue\u0026lt;int\u0026gt; que; /** Initialize your data structure here. */ MyStack() { } /** Push element x onto stack. */ void push(int x) { que.push(x); } /** Removes the element on top of the stack and returns that element. */ int pop() { int size = que.size(); size--; while (size--) { // 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部 que.push(que.front()); que.pop(); } int result = que.front(); // 此时弹出的元素顺序就是栈的顺序了 que.pop(); return result; } /** Get the top element. */ int top() { return que.back(); } /** Returns whether the stack is empty. */ bool empty() { return que.empty(); } }; 时间复杂度: pop为O(n)，其他为O(1) 空间复杂度: O(n) 3.有效的括号 https://leetcode.cn/problems/valid-parentheses/\n括号匹配是使用栈解决的经典问题。\n分析一下 这里有三种不匹配的情况\n第一种情况，字符串里左方向的括号多余了 ，所以不匹配。\n第二种情况，括号没有多余，但是 括号的类型没有匹配上。\n第三种情况，字符串里右方向的括号多余了，所以不匹配。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: bool isValid(string s) { if (s.size() % 2 != 0) return false; // 如果s的长度为奇数，一定不符合要求 stack\u0026lt;char\u0026gt; st; for (int i = 0; i \u0026lt; s.size(); i++) { if (s[i] == \u0026#39;(\u0026#39;) st.push(\u0026#39;)\u0026#39;); else if (s[i] == \u0026#39;{\u0026#39;) st.push(\u0026#39;}\u0026#39;); else if (s[i] == \u0026#39;[\u0026#39;) st.push(\u0026#39;]\u0026#39;); // 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false // 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false else if (st.empty() || st.top() != s[i]) return false; else st.pop(); // st.top() 与 s[i]相等，栈弹出元素 } // 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true return st.empty(); } }; 时间复杂度: O(n) 空间复杂度: O(n) 4.删除字符串中的所有相邻重复项 https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/\n利用栈\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: string removeDuplicates(string S) { stack\u0026lt;char\u0026gt; st; for (char s : S) { if (st.empty() || s != st.top()) { st.push(s); } else { st.pop(); // s 与 st.top()相等的情况 } } string result = \u0026#34;\u0026#34;; while (!st.empty()) { // 将栈中元素放到result字符串汇总 result += st.top(); st.pop(); } reverse (result.begin(), result.end()); // 此时字符串需要反转一下 return result; } }; 时间复杂度: O(n) 空间复杂度: O(n) 拿字符串直接作为栈\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: string removeDuplicates(string S) { string result; for(char s : S) { if(result.empty() || result.back() != s) { result.push_back(s); } else { result.pop_back(); } } return result; } }; 时间复杂度: O(n) 空间复杂度: O(1)，返回值不计空间复杂度 5.逆波兰表达式（后缀）求值 https://leetcode.cn/problems/evaluate-reverse-polish-notation/\n四则表达式（中缀）：9+（3-1）x3+10÷2\n后缀表达式：9 3 1 - 3 x + 10 2 / +\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: int evalRPN(vector\u0026lt;string\u0026gt;\u0026amp; tokens) { // 力扣修改了后台测试数据，需要用longlong stack\u0026lt;long long\u0026gt; st; for (int i = 0; i \u0026lt; tokens.size(); i++) { if (tokens[i] == \u0026#34;+\u0026#34; || tokens[i] == \u0026#34;-\u0026#34; || tokens[i] == \u0026#34;*\u0026#34; || tokens[i] == \u0026#34;/\u0026#34;) { long long num1 = st.top(); st.pop(); long long num2 = st.top(); st.pop(); if (tokens[i] == \u0026#34;+\u0026#34;) st.push(num2 + num1); if (tokens[i] == \u0026#34;-\u0026#34;) st.push(num2 - num1); if (tokens[i] == \u0026#34;*\u0026#34;) st.push(num2 * num1); if (tokens[i] == \u0026#34;/\u0026#34;) st.push(num2 / num1); } else { st.push(stoll(tokens[i])); } } int result = st.top(); st.pop(); // 把栈里最后一个元素弹出（其实不弹出也没事） return result; } }; 时间复杂度: O(n) 空间复杂度: O(n) 6.滑动窗口最大值 https://leetcode.cn/problems/sliding-window-maximum/\n自定义一个队列。双端队列实现。队列单调递减。\npop弹出[i-k]的数。push时把之前小于val的数弹出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { private: class MyQueue { //单调队列（从大到小） public: deque\u0026lt;int\u0026gt; que; // 使用deque来实现单调队列 // 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。 // 同时pop之前判断队列当前是否为空。 void pop(int value) { if (!que.empty() \u0026amp;\u0026amp; value == que.front()) { que.pop_front(); } } // 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。 // 这样就保持了队列里的数值是单调从大到小的了。 void push(int value) { while (!que.empty() \u0026amp;\u0026amp; value \u0026gt; que.back()) { que.pop_back(); } que.push_back(value); } // 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。 int front() { return que.front(); } }; public: vector\u0026lt;int\u0026gt; maxSlidingWindow(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { MyQueue que; vector\u0026lt;int\u0026gt; result; for (int i = 0; i \u0026lt; k; i++) { // 先将前k的元素放进队列 que.push(nums[i]); } result.push_back(que.front()); // result 记录前k的元素的最大值 for (int i = k; i \u0026lt; nums.size(); i++) { que.pop(nums[i - k]); // 滑动窗口移除最前面元素 que.push(nums[i]); // 滑动窗口前加入最后面的元素 result.push_back(que.front()); // 记录对应的最大值 } return result; } }; 时间复杂度: O(n) 空间复杂度: O(k) 7.前k个高频元素 https://leetcode.cn/problems/top-k-frequent-elements/\n建小顶堆（优先级队列实现），维护前k个数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public: // 小顶堆 class mycomparison { public: bool operator()(const pair\u0026lt;int, int\u0026gt;\u0026amp; lhs, const pair\u0026lt;int, int\u0026gt;\u0026amp; rhs) { return lhs.second \u0026gt; rhs.second; } }; vector\u0026lt;int\u0026gt; topKFrequent(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { // 要统计元素出现频率 unordered_map\u0026lt;int, int\u0026gt; map; // map\u0026lt;nums[i],对应出现的次数\u0026gt; for (int i = 0; i \u0026lt; nums.size(); i++) { map[nums[i]]++; } // 对频率排序 // 定义一个小顶堆，大小为k priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, mycomparison\u0026gt; pri_que; // 用固定大小为k的小顶堆，扫面所有频率的数值 for (unordered_map\u0026lt;int, int\u0026gt;::iterator it = map.begin(); it != map.end(); it++) { pri_que.push(*it); if (pri_que.size() \u0026gt; k) { // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k pri_que.pop(); } } // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组 vector\u0026lt;int\u0026gt; result(k); for (int i = k - 1; i \u0026gt;= 0; i--) { result[i] = pri_que.top().first; pri_que.pop(); } return result; } }; 时间复杂度: O(nlogk) 空间复杂度: O(n) 六、二叉树 满二叉树。深度为k，有2^k-1个节点\n完全二叉树。在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。\n二叉搜索树。左子树节点值小于根节点。右子树节点值大于根节点。\n平衡二叉搜索树。又被称为AVL（Adelson-Velsky and Landis）树。左右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉搜索树。\n存储方式：\n链式存储。指针\n顺序存储。数组\n父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。\n二叉树主要有两种遍历方式：\n深度优先遍历：先往深走，遇到叶子节点再往回走。 前序遍历（递归法，迭代法） 中序遍历（递归法，迭代法） 后序遍历（递归法，迭代法） 广度优先遍历：一层一层的去遍历。 层次遍历（迭代法） 定义（链式存储）：\n1 2 3 4 5 6 struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 递归 前序遍历为例：\n确定递归函数的参数和返回值：因为要打印出前序遍历节点的数值，所以参数里需要传入vector来放节点的数值，除了这一点就不需要再处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下： 1 void traversal(TreeNode* cur, vector\u0026lt;int\u0026gt;\u0026amp; vec) 确定终止条件：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下： 1 if (cur == NULL) return; 确定单层递归的逻辑：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下： 1 2 3 vec.push_back(cur-\u0026gt;val); // 中 traversal(cur-\u0026gt;left, vec); // 左 traversal(cur-\u0026gt;right, vec); // 右 单层递归的逻辑就是按照中左右的顺序来处理的，这样二叉树的前序遍历，基本就写完了，再看一下完整代码：\n1.递归遍历 前序遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: void traversal(TreeNode* cur, vector\u0026lt;int\u0026gt;\u0026amp; vec) { if (cur == NULL) return; vec.push_back(cur-\u0026gt;val); // 中 traversal(cur-\u0026gt;left, vec); // 左 traversal(cur-\u0026gt;right, vec); // 右 } vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; result; traversal(root, result); return result; } }; 中序遍历\n1 2 3 4 5 6 void traversal(TreeNode* cur, vector\u0026lt;int\u0026gt;\u0026amp; vec) { if (cur == NULL) return; traversal(cur-\u0026gt;left, vec); // 左 vec.push_back(cur-\u0026gt;val); // 中 traversal(cur-\u0026gt;right, vec); // 右 } 后序遍历\n1 2 3 4 5 6 void traversal(TreeNode* cur, vector\u0026lt;int\u0026gt;\u0026amp; vec) { if (cur == NULL) return; traversal(cur-\u0026gt;left, vec); // 左 traversal(cur-\u0026gt;right, vec); // 右 vec.push_back(cur-\u0026gt;val); // 中 } 2.迭代遍历 前序遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { stack\u0026lt;TreeNode*\u0026gt; st; vector\u0026lt;int\u0026gt; result; if (root == NULL) return result; st.push(root); while (!st.empty()) { TreeNode* node = st.top(); // 中 st.pop(); result.push_back(node-\u0026gt;val); if (node-\u0026gt;right) st.push(node-\u0026gt;right); // 右（空节点不入栈） if (node-\u0026gt;left) st.push(node-\u0026gt;left); // 左（空节点不入栈） } return result; } }; 中序遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; result; stack\u0026lt;TreeNode*\u0026gt; st; TreeNode* cur = root; while (cur != NULL || !st.empty()) { if (cur != NULL) { // 指针来访问节点，访问到最底层 st.push(cur); // 将访问的节点放进栈 cur = cur-\u0026gt;left; // 左 } else { cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据） st.pop(); result.push_back(cur-\u0026gt;val); // 中 cur = cur-\u0026gt;right; // 右 } } return result; } }; 后序遍历\n由先序遍历翻转：中左右-》中右左-》左右中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { stack\u0026lt;TreeNode*\u0026gt; st; vector\u0026lt;int\u0026gt; result; if (root == NULL) return result; st.push(root); while (!st.empty()) { TreeNode* node = st.top(); st.pop(); result.push_back(node-\u0026gt;val); if (node-\u0026gt;left) st.push(node-\u0026gt;left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈） if (node-\u0026gt;right) st.push(node-\u0026gt;right); // 空节点不入栈 } reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了 return result; } }; 统一的迭代法\n要处理的节点放入栈之后，紧接着放入一个空指针作为标记。\n迭代法中序遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; result; stack\u0026lt;TreeNode*\u0026gt; st; if (root != NULL) st.push(root); while (!st.empty()) { TreeNode* node = st.top(); if (node != NULL) { st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 if (node-\u0026gt;right) st.push(node-\u0026gt;right); // 添加右节点（空节点不入栈） st.push(node); // 添加中节点 st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。 if (node-\u0026gt;left) st.push(node-\u0026gt;left); // 添加左节点（空节点不入栈） } else { // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.top(); // 重新取出栈中元素 st.pop(); result.push_back(node-\u0026gt;val); // 加入到结果集 } } return result; } }; 3.层序遍历 https://leetcode.cn/problems/binary-tree-level-order-traversal/\n使用队列实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { queue\u0026lt;TreeNode*\u0026gt; que; if (root != NULL) que.push(root); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; while (!que.empty()) { int size = que.size(); vector\u0026lt;int\u0026gt; vec; // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的 for (int i = 0; i \u0026lt; size; i++) { TreeNode* node = que.front(); que.pop(); vec.push_back(node-\u0026gt;val); if (node-\u0026gt;left) que.push(node-\u0026gt;left); if (node-\u0026gt;right) que.push(node-\u0026gt;right); } result.push_back(vec); } return result; } }; 4.翻转二叉树 https://leetcode.cn/problems/invert-binary-tree/\n把每一个节点的左右孩子翻转\n递归\n1 2 3 4 5 6 7 8 9 10 class Solution { public: TreeNode* invertTree(TreeNode* root) { if (root == NULL) return root; swap(root-\u0026gt;left, root-\u0026gt;right); // 中 invertTree(root-\u0026gt;left); // 左 invertTree(root-\u0026gt;right); // 右 return root; } }; 前序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: TreeNode* invertTree(TreeNode* root) { stack\u0026lt;TreeNode*\u0026gt; st; if (root != NULL) st.push(root); while (!st.empty()) { TreeNode* node = st.top(); if (node != NULL) { st.pop(); if (node-\u0026gt;right) st.push(node-\u0026gt;right); // 右 if (node-\u0026gt;left) st.push(node-\u0026gt;left); // 左 st.push(node); // 中 st.push(NULL); } else { st.pop(); node = st.top(); st.pop(); swap(node-\u0026gt;left, node-\u0026gt;right); // 节点处理逻辑 } } return root; } }; 层序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: TreeNode* invertTree(TreeNode* root) { queue\u0026lt;TreeNode*\u0026gt; que; if (root != NULL) que.push(root); while (!que.empty()) { int size = que.size(); for (int i = 0; i \u0026lt; size; i++) { TreeNode* node = que.front(); que.pop(); swap(node-\u0026gt;left, node-\u0026gt;right); // 节点处理 if (node-\u0026gt;left) que.push(node-\u0026gt;left); if (node-\u0026gt;right) que.push(node-\u0026gt;right); } } return root; } }; 5.对称二叉树 https://leetcode.cn/problems/symmetric-tree/\n只能用后序遍历，左右子树判断对称，再判断中间节点\n左子树的左子树==右子数的右子树；左子树的右子树==右子树的左子树。\n递归\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: bool compare(TreeNode* left, TreeNode* right) { // 首先排除空节点的情况 if (left == NULL \u0026amp;\u0026amp; right != NULL) return false; else if (left != NULL \u0026amp;\u0026amp; right == NULL) return false; else if (left == NULL \u0026amp;\u0026amp; right == NULL) return true; // 排除了空节点，再排除数值不相同的情况 else if (left-\u0026gt;val != right-\u0026gt;val) return false; // 此时就是：左右节点都不为空，且数值相同的情况 // 此时才做递归，做下一层的判断 bool outside = compare(left-\u0026gt;left, right-\u0026gt;right); // 左子树：左、 右子树：右 bool inside = compare(left-\u0026gt;right, right-\u0026gt;left); // 左子树：右、 右子树：左 bool isSame = outside \u0026amp;\u0026amp; inside; // 左子树：中、 右子树：中 （逻辑处理） return isSame; } bool isSymmetric(TreeNode* root) { if (root == NULL) return true; return compare(root-\u0026gt;left, root-\u0026gt;right); } }; 使用队列（栈也可以）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: bool isSymmetric(TreeNode* root) { if (root == NULL) return true; queue\u0026lt;TreeNode*\u0026gt; que; que.push(root-\u0026gt;left); // 将左子树头结点加入队列 que.push(root-\u0026gt;right); // 将右子树头结点加入队列 while (!que.empty()) { // 接下来就要判断这两个树是否相互翻转 TreeNode* leftNode = que.front(); que.pop(); TreeNode* rightNode = que.front(); que.pop(); if (!leftNode \u0026amp;\u0026amp; !rightNode) { // 左节点为空、右节点为空，此时说明是对称的 continue; } // 左右一个节点不为空，或者都不为空但数值不相同，返回false if ((!leftNode || !rightNode || (leftNode-\u0026gt;val != rightNode-\u0026gt;val))) { return false; } que.push(leftNode-\u0026gt;left); // 加入左节点左孩子 que.push(rightNode-\u0026gt;right); // 加入右节点右孩子 que.push(leftNode-\u0026gt;right); // 加入左节点右孩子 que.push(rightNode-\u0026gt;left); // 加入右节点左孩子 } return true; } }; 6.二叉树的最大深度 https://leetcode.cn/problems/maximum-depth-of-binary-tree/\n递归。取左右子树的最大值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class solution { public: int getdepth(TreeNode* node) { if (node == NULL) return 0; int leftdepth = getdepth(node-\u0026gt;left); // 左 int rightdepth = getdepth(node-\u0026gt;right); // 右 int depth = 1 + max(leftdepth, rightdepth); // 中 return depth; } int maxDepth(TreeNode* root) { return getdepth(root); } }; 层序遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class solution { public: int maxDepth(TreeNode* root) { if (root == NULL) return 0; int depth = 0; queue\u0026lt;TreeNode*\u0026gt; que; que.push(root); while(!que.empty()) { int size = que.size(); depth++; // 记录深度 for (int i = 0; i \u0026lt; size; i++) { TreeNode* node = que.front(); que.pop(); if (node-\u0026gt;left) que.push(node-\u0026gt;left); if (node-\u0026gt;right) que.push(node-\u0026gt;right); } } return depth; } }; 7.二叉树的最小深度 https://leetcode.cn/problems/minimum-depth-of-binary-tree/\n后序。必须从树叶节点算最小深度\n左子树为空，右子树不为空，最小深度： 1 + 右子树的深度。\n右子树为空，左子树不为空，最小深度： 1 + 左子树的深度。\n左右子树都不为空，最小深度：左右子树深度最小值 + 1 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: int getDepth(TreeNode* node) { if (node == NULL) return 0; int leftDepth = getDepth(node-\u0026gt;left); // 左 int rightDepth = getDepth(node-\u0026gt;right); // 右 // 中 // 当一个左子树为空，右不为空，这时并不是最低点 if (node-\u0026gt;left == NULL \u0026amp;\u0026amp; node-\u0026gt;right != NULL) { return 1 + rightDepth; } // 当一个右子树为空，左不为空，这时并不是最低点 if (node-\u0026gt;left != NULL \u0026amp;\u0026amp; node-\u0026gt;right == NULL) { return 1 + leftDepth; } int result = 1 + min(leftDepth, rightDepth); return result; } int minDepth(TreeNode* root) { return getDepth(root); } }; 层序遍历\n只有当左右孩子都为空的时候，才说明遍历到最低点了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: int minDepth(TreeNode* root) { if (root == NULL) return 0; int depth = 0; queue\u0026lt;TreeNode*\u0026gt; que; que.push(root); while(!que.empty()) { int size = que.size(); depth++; // 记录最小深度 for (int i = 0; i \u0026lt; size; i++) { TreeNode* node = que.front(); que.pop(); if (node-\u0026gt;left) que.push(node-\u0026gt;left); if (node-\u0026gt;right) que.push(node-\u0026gt;right); if (!node-\u0026gt;left \u0026amp;\u0026amp; !node-\u0026gt;right) { // 当左右孩子都为空的时候，说明是最低点的一层了，退出 return depth; } } } return depth; } }; 8.完全二叉树的节点个数 https://leetcode.cn/problems/count-complete-tree-nodes/\n递归\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { private: int getNodesNum(TreeNode* cur) { if (cur == NULL) return 0; int leftNum = getNodesNum(cur-\u0026gt;left); // 左 int rightNum = getNodesNum(cur-\u0026gt;right); // 右 int treeNum = leftNum + rightNum + 1; // 中 return treeNum; } public: int countNodes(TreeNode* root) { return getNodesNum(root); } }; 层序遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int countNodes(TreeNode* root) { queue\u0026lt;TreeNode*\u0026gt; que; if (root != NULL) que.push(root); int result = 0; while (!que.empty()) { int size = que.size(); for (int i = 0; i \u0026lt; size; i++) { TreeNode* node = que.front(); que.pop(); result++; // 记录节点数量 if (node-\u0026gt;left) que.push(node-\u0026gt;left); if (node-\u0026gt;right) que.push(node-\u0026gt;right); } } return result; } }; 9.平衡二叉树 https://leetcode.cn/problems/balanced-binary-tree/\n给定一个二叉树，判断它是否是高度平衡的二叉树。\n左右子树高度差大与1就返回-1。\n递归\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: // 返回以该节点为根节点的二叉树的高度，如果不是平衡二叉树了则返回-1 int getHeight(TreeNode* node) { if (node == NULL) { return 0; } int leftHeight = getHeight(node-\u0026gt;left); if (leftHeight == -1) return -1; int rightHeight = getHeight(node-\u0026gt;right); if (rightHeight == -1) return -1; return abs(leftHeight - rightHeight) \u0026gt; 1 ? -1 : 1 + max(leftHeight, rightHeight); } bool isBalanced(TreeNode* root) { return getHeight(root) == -1 ? false : true; } }; 10.二叉树的所有路径 https://leetcode.cn/problems/binary-tree-paths/description/\n回溯\n递归函数后弹出前一个结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 版本一 class Solution { private: void traversal(TreeNode* cur, vector\u0026lt;int\u0026gt;\u0026amp; path, vector\u0026lt;string\u0026gt;\u0026amp; result) { path.push_back(cur-\u0026gt;val); // 中，中为什么写在这里，因为最后一个节点也要加入到path中 // 这才到了叶子节点 if (cur-\u0026gt;left == NULL \u0026amp;\u0026amp; cur-\u0026gt;right == NULL) { string sPath; for (int i = 0; i \u0026lt; path.size() - 1; i++) { sPath += to_string(path[i]); sPath += \u0026#34;-\u0026gt;\u0026#34;; } sPath += to_string(path[path.size() - 1]); result.push_back(sPath); return; } if (cur-\u0026gt;left) { // 左 traversal(cur-\u0026gt;left, path, result); path.pop_back(); // 回溯 } if (cur-\u0026gt;right) { // 右 traversal(cur-\u0026gt;right, path, result); path.pop_back(); // 回溯 } } public: vector\u0026lt;string\u0026gt; binaryTreePaths(TreeNode* root) { vector\u0026lt;string\u0026gt; result; vector\u0026lt;int\u0026gt; path; if (root == NULL) return result; traversal(root, path, result); return result; } }; 11.左叶子之和 https://leetcode.cn/problems/sum-of-left-leaves/description/\n判断是不是左叶子：该节点的左节点不为空，该节点的左节点的左节点为空，该节点的左节点的右节点为空\n递归\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: int sumOfLeftLeaves(TreeNode* root) { if (root == NULL) return 0; if (root-\u0026gt;left == NULL \u0026amp;\u0026amp; root-\u0026gt;right== NULL) return 0; int leftValue = sumOfLeftLeaves(root-\u0026gt;left); // 左 if (root-\u0026gt;left \u0026amp;\u0026amp; !root-\u0026gt;left-\u0026gt;left \u0026amp;\u0026amp; !root-\u0026gt;left-\u0026gt;right) { // 左子树就是一个左叶子的情况 leftValue = root-\u0026gt;left-\u0026gt;val; } int rightValue = sumOfLeftLeaves(root-\u0026gt;right); // 右 int sum = leftValue + rightValue; // 中 return sum; } }; 迭代\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int sumOfLeftLeaves(TreeNode* root) { stack\u0026lt;TreeNode*\u0026gt; st; if (root == NULL) return 0; st.push(root); int result = 0; while (!st.empty()) { TreeNode* node = st.top(); st.pop(); if (node-\u0026gt;left != NULL \u0026amp;\u0026amp; node-\u0026gt;left-\u0026gt;left == NULL \u0026amp;\u0026amp; node-\u0026gt;left-\u0026gt;right == NULL) { result += node-\u0026gt;left-\u0026gt;val; } if (node-\u0026gt;right) st.push(node-\u0026gt;right); if (node-\u0026gt;left) st.push(node-\u0026gt;left); } return result; } }; 12.从中序与后序遍历序列构造二叉树 https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/\n以 后序数组的最后一个元素为切割点，先切中序数组，根据中序数组，反过来再切后序数组。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { private: TreeNode* traversal (vector\u0026lt;int\u0026gt;\u0026amp; inorder, vector\u0026lt;int\u0026gt;\u0026amp; postorder) { if (postorder.size() == 0) return NULL; // 后序遍历数组最后一个元素，就是当前的中间节点 int rootValue = postorder[postorder.size() - 1]; TreeNode* root = new TreeNode(rootValue); // 叶子节点 if (postorder.size() == 1) return root; // 找到中序遍历的切割点 int delimiterIndex; for (delimiterIndex = 0; delimiterIndex \u0026lt; inorder.size(); delimiterIndex++) { if (inorder[delimiterIndex] == rootValue) break; } // 切割中序数组 // 左闭右开区间：[0, delimiterIndex) vector\u0026lt;int\u0026gt; leftInorder(inorder.begin(), inorder.begin() + delimiterIndex); // [delimiterIndex + 1, end) vector\u0026lt;int\u0026gt; rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end() ); // postorder 舍弃末尾元素 postorder.resize(postorder.size() - 1); // 切割后序数组 // 依然左闭右开，注意这里使用了左中序数组大小作为切割点 // [0, leftInorder.size) vector\u0026lt;int\u0026gt; leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size()); // [leftInorder.size(), end) vector\u0026lt;int\u0026gt; rightPostorder(postorder.begin() + leftInorder.size(), postorder.end()); root-\u0026gt;left = traversal(leftInorder, leftPostorder); root-\u0026gt;right = traversal(rightInorder, rightPostorder); return root; } public: TreeNode* buildTree(vector\u0026lt;int\u0026gt;\u0026amp; inorder, vector\u0026lt;int\u0026gt;\u0026amp; postorder) { if (inorder.size() == 0 || postorder.size() == 0) return NULL; return traversal(inorder, postorder); } }; 13.最大二叉树 https://leetcode.cn/problems/maximum-binary-tree/description/\n前序遍历，因为先构造中间节点，然后递归构造左子树和右子树。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { private: // 在左闭右开区间[left, right)，构造二叉树 TreeNode* traversal(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right) { if (left \u0026gt;= right) return nullptr; // 分割点下标：maxValueIndex int maxValueIndex = left; for (int i = left + 1; i \u0026lt; right; ++i) { if (nums[i] \u0026gt; nums[maxValueIndex]) maxValueIndex = i; } TreeNode* root = new TreeNode(nums[maxValueIndex]); // 左闭右开：[left, maxValueIndex) root-\u0026gt;left = traversal(nums, left, maxValueIndex); // 左闭右开：[maxValueIndex + 1, right) root-\u0026gt;right = traversal(nums, maxValueIndex + 1, right); return root; } public: TreeNode* constructMaximumBinaryTree(vector\u0026lt;int\u0026gt;\u0026amp; nums) { return traversal(nums, 0, nums.size()); } }; 14.合并二叉树 https://leetcode.cn/problems/merge-two-binary-trees/description/\n前序遍历\n1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) { if (t1 == NULL) return t2; // 如果t1为空，合并之后就应该是t2 if (t2 == NULL) return t1; // 如果t2为空，合并之后就应该是t1 // 修改了t1的数值和结构 t1-\u0026gt;val += t2-\u0026gt;val; // 中 t1-\u0026gt;left = mergeTrees(t1-\u0026gt;left, t2-\u0026gt;left); // 左 t1-\u0026gt;right = mergeTrees(t1-\u0026gt;right, t2-\u0026gt;right); // 右 return t1; } }; 重新定义树\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) { if (t1 == NULL) return t2; if (t2 == NULL) return t1; // 重新定义新的节点，不修改原有两个树的结构 TreeNode* root = new TreeNode(0); root-\u0026gt;val = t1-\u0026gt;val + t2-\u0026gt;val; root-\u0026gt;left = mergeTrees(t1-\u0026gt;left, t2-\u0026gt;left); root-\u0026gt;right = mergeTrees(t1-\u0026gt;right, t2-\u0026gt;right); return root; } }; 层序遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public: TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) { if (t1 == NULL) return t2; if (t2 == NULL) return t1; queue\u0026lt;TreeNode*\u0026gt; que; que.push(t1); que.push(t2); while(!que.empty()) { TreeNode* node1 = que.front(); que.pop(); TreeNode* node2 = que.front(); que.pop(); // 此时两个节点一定不为空，val相加 node1-\u0026gt;val += node2-\u0026gt;val; // 如果两棵树左节点都不为空，加入队列 if (node1-\u0026gt;left != NULL \u0026amp;\u0026amp; node2-\u0026gt;left != NULL) { que.push(node1-\u0026gt;left); que.push(node2-\u0026gt;left); } // 如果两棵树右节点都不为空，加入队列 if (node1-\u0026gt;right != NULL \u0026amp;\u0026amp; node2-\u0026gt;right != NULL) { que.push(node1-\u0026gt;right); que.push(node2-\u0026gt;right); } // 当t1的左节点 为空 t2左节点不为空，就赋值过去 if (node1-\u0026gt;left == NULL \u0026amp;\u0026amp; node2-\u0026gt;left != NULL) { node1-\u0026gt;left = node2-\u0026gt;left; } // 当t1的右节点 为空 t2右节点不为空，就赋值过去 if (node1-\u0026gt;right == NULL \u0026amp;\u0026amp; node2-\u0026gt;right != NULL) { node1-\u0026gt;right = node2-\u0026gt;right; } } return t1; } }; 15.二叉搜索树中的搜索 https://leetcode.cn/problems/search-in-a-binary-search-tree/description/\n递归\n1 2 3 4 5 6 7 8 9 10 class Solution { public: TreeNode* searchBST(TreeNode* root, int val) { if (root == NULL || root-\u0026gt;val == val) return root; TreeNode* result = NULL; if (root-\u0026gt;val \u0026gt; val) result = searchBST(root-\u0026gt;left, val); if (root-\u0026gt;val \u0026lt; val) result = searchBST(root-\u0026gt;right, val); return result; } }; 迭代\n1 2 3 4 5 6 7 8 9 10 11 class Solution { public: TreeNode* searchBST(TreeNode* root, int val) { while (root != NULL) { if (root-\u0026gt;val \u0026gt; val) root = root-\u0026gt;left; else if (root-\u0026gt;val \u0026lt; val) root = root-\u0026gt;right; else return root; } return NULL; } }; 16.验证二叉搜索数 https://leetcode.cn/problems/validate-binary-search-tree/description/\n二叉树转成数组，再判断。二叉搜索树采用中序遍历，就是一个有序数组。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { private: vector\u0026lt;int\u0026gt; vec; void traversal(TreeNode* root) { if (root == NULL) return; traversal(root-\u0026gt;left); vec.push_back(root-\u0026gt;val); // 将二叉搜索树转换为有序数组 traversal(root-\u0026gt;right); } public: bool isValidBST(TreeNode* root) { vec.clear(); // 不加这句在leetcode上也可以过，但最好加上 traversal(root); for (int i = 1; i \u0026lt; vec.size(); i++) { // 注意要小于等于，搜索树里不能有相同元素 if (vec[i] \u0026lt;= vec[i - 1]) return false; } return true; } }; 17.二叉搜索树中的众数 方法一。转成数组，用哈希算\n方法二。遍历时算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { private: int maxCount = 0; // 最大频率 int count = 0; // 统计频率 TreeNode* pre = NULL; vector\u0026lt;int\u0026gt; result; void searchBST(TreeNode* cur) { if (cur == NULL) return ; searchBST(cur-\u0026gt;left); // 左 // 中 if (pre == NULL) { // 第一个节点 count = 1; } else if (pre-\u0026gt;val == cur-\u0026gt;val) { // 与前一个节点数值相同 count++; } else { // 与前一个节点数值不同 count = 1; } pre = cur; // 更新上一个节点 if (count == maxCount) { // 如果和最大值相同，放进result中 result.push_back(cur-\u0026gt;val); } if (count \u0026gt; maxCount) { // 如果计数大于最大值频率 maxCount = count; // 更新最大频率 result.clear(); // 很关键的一步，不要忘记清空result，之前result里的元素都失效了 result.push_back(cur-\u0026gt;val); } searchBST(cur-\u0026gt;right); // 右 return ; } public: vector\u0026lt;int\u0026gt; findMode(TreeNode* root) { count = 0; maxCount = 0; TreeNode* pre = NULL; // 记录前一个节点 result.clear(); searchBST(root); return result; } }; 18.二叉树的最近公共祖先 https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/\n递归回溯\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if (root == q || root == p || root == NULL) return root; TreeNode* left = lowestCommonAncestor(root-\u0026gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-\u0026gt;right, p, q); if (left != NULL \u0026amp;\u0026amp; right != NULL) return root; if (left == NULL \u0026amp;\u0026amp; right != NULL) return right; else if (left != NULL \u0026amp;\u0026amp; right == NULL) return left; else { // (left == NULL \u0026amp;\u0026amp; right == NULL) return NULL; } } }; 19.二叉搜索树的插入操作 https://leetcode.cn/problems/insert-into-a-binary-search-tree/\n数值插入后仍为二叉搜索数\n递归\n1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: TreeNode* insertIntoBST(TreeNode* root, int val) { if (root == NULL) { TreeNode* node = new TreeNode(val); return node; } if (root-\u0026gt;val \u0026gt; val) root-\u0026gt;left = insertIntoBST(root-\u0026gt;left, val); if (root-\u0026gt;val \u0026lt; val) root-\u0026gt;right = insertIntoBST(root-\u0026gt;right, val); return root; } }; 迭代\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: TreeNode* insertIntoBST(TreeNode* root, int val) { if (root == NULL) { TreeNode* node = new TreeNode(val); return node; } TreeNode* cur = root; TreeNode* parent = root; // 这个很重要，需要记录上一个节点，否则无法赋值新节点 while (cur != NULL) { parent = cur; if (cur-\u0026gt;val \u0026gt; val) cur = cur-\u0026gt;left; else cur = cur-\u0026gt;right; } TreeNode* node = new TreeNode(val); if (val \u0026lt; parent-\u0026gt;val) parent-\u0026gt;left = node;// 此时是用parent节点的进行赋值 else parent-\u0026gt;right = node; return root; } }; 20.删除二叉搜索树中的节点 https://leetcode.cn/problems/delete-node-in-a-bst/description/\n五种情况：\n第一种情况：没找到删除的节点，遍历到空节点直接返回了 找到删除的节点 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点 第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点 第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点 第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Solution { public: TreeNode* deleteNode(TreeNode* root, int key) { if (root == nullptr) return root; // 第一种情况：没找到删除的节点，遍历到空节点直接返回了 if (root-\u0026gt;val == key) { // 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点 if (root-\u0026gt;left == nullptr \u0026amp;\u0026amp; root-\u0026gt;right == nullptr) { ///! 内存释放 delete root; return nullptr; } // 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点 else if (root-\u0026gt;left == nullptr) { auto retNode = root-\u0026gt;right; ///! 内存释放 delete root; return retNode; } // 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点 else if (root-\u0026gt;right == nullptr) { auto retNode = root-\u0026gt;left; ///! 内存释放 delete root; return retNode; } // 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置 // 并返回删除节点右孩子为新的根节点。 else { TreeNode* cur = root-\u0026gt;right; // 找右子树最左面的节点 while(cur-\u0026gt;left != nullptr) { cur = cur-\u0026gt;left; } cur-\u0026gt;left = root-\u0026gt;left; // 把要删除的节点（root）左子树放在cur的左孩子的位置 TreeNode* tmp = root; // 把root节点保存一下，下面来删除 root = root-\u0026gt;right; // 返回旧root的右孩子作为新root delete tmp; // 释放节点内存（这里不写也可以，但C++最好手动释放一下吧） return root; } } if (root-\u0026gt;val \u0026gt; key) root-\u0026gt;left = deleteNode(root-\u0026gt;left, key); if (root-\u0026gt;val \u0026lt; key) root-\u0026gt;right = deleteNode(root-\u0026gt;right, key); return root; } }; 普通二叉树的删除\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: TreeNode* deleteNode(TreeNode* root, int key) { if (root == nullptr) return root; if (root-\u0026gt;val == key) { if (root-\u0026gt;right == nullptr) { // 这里第二次操作目标值：最终删除的作用 return root-\u0026gt;left; } TreeNode *cur = root-\u0026gt;right; while (cur-\u0026gt;left) { cur = cur-\u0026gt;left; } swap(root-\u0026gt;val, cur-\u0026gt;val); // 这里第一次操作目标值：交换目标值其右子树最左面节点。 } root-\u0026gt;left = deleteNode(root-\u0026gt;left, key); root-\u0026gt;right = deleteNode(root-\u0026gt;right, key); return root; } }; 21.修剪二叉搜索树 https://leetcode.cn/problems/trim-a-binary-search-tree/description/\n递归\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: TreeNode* trimBST(TreeNode* root, int low, int high) { if (root == nullptr ) return nullptr; if (root-\u0026gt;val \u0026lt; low) { TreeNode* right = trimBST(root-\u0026gt;right, low, high); // 寻找符合区间[low, high]的节点 return right; } if (root-\u0026gt;val \u0026gt; high) { TreeNode* left = trimBST(root-\u0026gt;left, low, high); // 寻找符合区间[low, high]的节点 return left; } root-\u0026gt;left = trimBST(root-\u0026gt;left, low, high); // root-\u0026gt;left接入符合条件的左孩子 root-\u0026gt;right = trimBST(root-\u0026gt;right, low, high); // root-\u0026gt;right接入符合条件的右孩子 return root; } }; 22.有序数组转换成二叉搜索树 https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/\n递归\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { private: TreeNode* traversal(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right) { if (left \u0026gt; right) return nullptr; int mid = left + ((right - left) / 2); TreeNode* root = new TreeNode(nums[mid]); root-\u0026gt;left = traversal(nums, left, mid - 1); root-\u0026gt;right = traversal(nums, mid + 1, right); return root; } public: TreeNode* sortedArrayToBST(vector\u0026lt;int\u0026gt;\u0026amp; nums) { TreeNode* root = traversal(nums, 0, nums.size() - 1); return root; } }; 23.把二叉搜索树转换成累加树 https://leetcode.cn/problems/convert-bst-to-greater-tree/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { private: int pre = 0; // 记录前一个节点的数值 void traversal(TreeNode* cur) { // 右中左遍历 if (cur == NULL) return; traversal(cur-\u0026gt;right); cur-\u0026gt;val += pre; pre = cur-\u0026gt;val; traversal(cur-\u0026gt;left); } public: TreeNode* convertBST(TreeNode* root) { pre = 0; traversal(root); return root; } }; 七、回溯算法 1 2 3 4 5 6 7 8 9 10 11 12 void backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 1.组合问题 https://leetcode.cn/problems/combinations/description/\nfor循环用来横向遍历，递归是纵向遍历。时间复杂度: O(n * 2^n)。空间复杂度: O(n)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { private: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; // 存放符合条件结果的集合 vector\u0026lt;int\u0026gt; path; // 用来存放符合条件结果 void backtracking(int n, int k, int startIndex) { if (path.size() == k) { result.push_back(path); return; } for (int i = startIndex; i \u0026lt;= n; i++) { path.push_back(i); // 处理节点 backtracking(n, k, i + 1); // 递归 path.pop_back(); // 回溯，撤销处理的节点 } } public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combine(int n, int k) { result.clear(); // 可以不写 path.clear(); // 可以不写 backtracking(n, k, 1); return result; } }; 时间复杂度: O(n * 2^n) 空间复杂度: O(n) 优化\n原因：for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了\nfor (int i = startIndex; i \u0026lt;= n - (k - path.size()) + 1; i++) {\n时间复杂度: O(n * 2^n) 空间复杂度: O(n) 2.组合总和Ⅲ https://leetcode.cn/problems/combination-sum-iii/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { private: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; // 存放结果集 vector\u0026lt;int\u0026gt; path; // 符合条件的结果 // targetSum：目标和，也就是题目中的n。 // k：题目中要求k个数的集合。 // sum：已经收集的元素的总和，也就是path里元素的总和。 // startIndex：下一层for循环搜索的起始位置。 void backtracking(int targetSum, int k, int sum, int startIndex) { if (path.size() == k) { if (sum == targetSum) result.push_back(path); return; // 如果path.size() == k 但sum != targetSum 直接返回 } for (int i = startIndex; i \u0026lt;= 9; i++) { sum += i; // 处理 path.push_back(i); // 处理 backtracking(targetSum, k, sum, i + 1); // 注意i+1调整startIndex sum -= i; // 回溯 path.pop_back(); // 回溯 } } public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combinationSum3(int k, int n) { result.clear(); // 可以不加 path.clear(); // 可以不加 backtracking(n, k, 0, 1); return result; } }; 时间复杂度: O(n * 2^n) 空间复杂度: O(n) 3.电话号码的字母组合 https://leetcode.cn/problems/letter-combinations-of-a-phone-number/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // 版本一 class Solution { private: const string letterMap[10] = { \u0026#34;\u0026#34;, // 0 \u0026#34;\u0026#34;, // 1 \u0026#34;abc\u0026#34;, // 2 \u0026#34;def\u0026#34;, // 3 \u0026#34;ghi\u0026#34;, // 4 \u0026#34;jkl\u0026#34;, // 5 \u0026#34;mno\u0026#34;, // 6 \u0026#34;pqrs\u0026#34;, // 7 \u0026#34;tuv\u0026#34;, // 8 \u0026#34;wxyz\u0026#34;, // 9 }; public: vector\u0026lt;string\u0026gt; result; string s; void backtracking(const string\u0026amp; digits, int index) { if (index == digits.size()) { result.push_back(s); return; } int digit = digits[index] - \u0026#39;0\u0026#39;; // 将index指向的数字转为int string letters = letterMap[digit]; // 取数字对应的字符集 for (int i = 0; i \u0026lt; letters.size(); i++) { s.push_back(letters[i]); // 处理 backtracking(digits, index + 1); // 递归，注意index+1，一下层要处理下一个数字了 s.pop_back(); // 回溯 } } vector\u0026lt;string\u0026gt; letterCombinations(string digits) { s.clear(); result.clear(); if (digits.size() == 0) { return result; } backtracking(digits, 0); return result; } }; 时间复杂度: O(3^m * 4^n)，其中 m 是对应四个字母的数字个数，n 是对应三个字母的数字个数 空间复杂度: O(3^m * 4^n) 4.组合总和 https://leetcode.cn/problems/combination-sum/\n数组中和为target的组合。数组无重复，可以重复被选取。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 版本一 class Solution { private: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; vector\u0026lt;int\u0026gt; path; void backtracking(vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target, int sum, int startIndex) { if (sum \u0026gt; target) { return; } if (sum == target) { result.push_back(path); return; } for (int i = startIndex; i \u0026lt; candidates.size(); i++) { sum += candidates[i]; path.push_back(candidates[i]); backtracking(candidates, target, sum, i); // 不用i+1了，表示可以重复读取当前的数 sum -= candidates[i]; path.pop_back(); } } public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combinationSum(vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target) { result.clear(); path.clear(); backtracking(candidates, target, 0, 0); return result; } }; 时间复杂度: O(n * 2^n)，注意这只是复杂度的上界，因为剪枝的存在，真实的时间复杂度远小于此 空间复杂度: O(target) 5.组合总和Ⅱ https://leetcode.cn/problems/combination-sum-ii/description/\n数组有重复数字，不能重复使用数组的元素。\n用used数据记录数组使用情况\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { private: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; vector\u0026lt;int\u0026gt; path; void backtracking(vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target, int sum, int startIndex, vector\u0026lt;bool\u0026gt;\u0026amp; used) { if (sum == target) { result.push_back(path); return; } for (int i = startIndex; i \u0026lt; candidates.size() \u0026amp;\u0026amp; sum + candidates[i] \u0026lt;= target; i++) { // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过 // used[i - 1] == false，说明同一树层candidates[i - 1]使用过 // 要对同一树层使用过的元素进行跳过 if (i \u0026gt; 0 \u0026amp;\u0026amp; candidates[i] == candidates[i - 1] \u0026amp;\u0026amp; used[i - 1] == false) { continue; } sum += candidates[i]; path.push_back(candidates[i]); used[i] = true; backtracking(candidates, target, sum, i + 1, used); // 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次 used[i] = false; sum -= candidates[i]; path.pop_back(); } } public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combinationSum2(vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target) { vector\u0026lt;bool\u0026gt; used(candidates.size(), false); path.clear(); result.clear(); // 首先把给candidates排序，让其相同的元素都挨在一起。 sort(candidates.begin(), candidates.end()); backtracking(candidates, target, 0, 0, used); return result; } }; 时间复杂度: O(n * 2^n) 空间复杂度: O(n) 6.分割回文串 https://leetcode.cn/problems/palindrome-partitioning/description/\n判断字符串区间[startIndex,i]是否是回文\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { private: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; result; vector\u0026lt;string\u0026gt; path; // 放已经回文的子串 void backtracking (const string\u0026amp; s, int startIndex) { // 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了 if (startIndex \u0026gt;= s.size()) { result.push_back(path); return; } for (int i = startIndex; i \u0026lt; s.size(); i++) { if (isPalindrome(s, startIndex, i)) { // 是回文子串 // 获取[startIndex,i]在s中的子串 string str = s.substr(startIndex, i - startIndex + 1); path.push_back(str); backtracking(s, i + 1); // 寻找i+1为起始位置的子串 path.pop_back(); // 回溯过程，弹出本次已经添加的子串 } } } bool isPalindrome(const string\u0026amp; s, int start, int end) { for (int i = start, j = end; i \u0026lt; j; i++, j--) { if (s[i] != s[j]) { return false; } } return true; } public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; partition(string s) { result.clear(); path.clear(); backtracking(s, 0); return result; } }; 时间复杂度: O(n * 2^n) 空间复杂度: O(n) 7.复原IP地址 https://leetcode.cn/problems/restore-ip-addresses/description/\n判断字符串区间的是否是有效IP地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { private: vector\u0026lt;string\u0026gt; result;// 记录结果 // startIndex: 搜索的起始位置，pointNum:添加逗点的数量 void backtracking(string\u0026amp; s, int startIndex, int pointNum) { if (pointNum == 3) { // 逗点数量为3时，分隔结束 // 判断第四段子字符串是否合法，如果合法就放进result中 if (isValid(s, startIndex, s.size() - 1)) { result.push_back(s); } return; } for (int i = startIndex; i \u0026lt; s.size(); i++) { if (isValid(s, startIndex, i)) { // 判断 [startIndex,i] 这个区间的子串是否合法 s.insert(s.begin() + i + 1 , \u0026#39;.\u0026#39;); // 在i的后面插入一个逗点 pointNum++; backtracking(s, i + 2, pointNum); // 插入逗点之后下一个子串的起始位置为i+2 pointNum--; // 回溯 s.erase(s.begin() + i + 1); // 回溯删掉逗点 } else break; // 不合法，直接结束本层循环 } } // 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法 bool isValid(const string\u0026amp; s, int start, int end) { if (start \u0026gt; end) { return false; } if (s[start] == \u0026#39;0\u0026#39; \u0026amp;\u0026amp; start != end) { // 0开头的数字不合法 return false; } int num = 0; for (int i = start; i \u0026lt;= end; i++) { if (s[i] \u0026gt; \u0026#39;9\u0026#39; || s[i] \u0026lt; \u0026#39;0\u0026#39;) { // 遇到非数字字符不合法 return false; } num = num * 10 + (s[i] - \u0026#39;0\u0026#39;); if (num \u0026gt; 255) { // 如果大于255了不合法 return false; } } return true; } public: vector\u0026lt;string\u0026gt; restoreIpAddresses(string s) { result.clear(); if (s.size() \u0026lt; 4 || s.size() \u0026gt; 12) return result; // 算是剪枝了 backtracking(s, 0, 0); return result; } }; 时间复杂度: O(3^4)，IP地址最多包含4个数字，每个数字最多有3种可能的分割方式，则搜索树的最大深度为4，每个节点最多有3个子节点。 空间复杂度: O(n) 8.子集 https://leetcode.cn/problems/subsets/description/\n组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！\n数组元素不重复，结果不能重复\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { private: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; vector\u0026lt;int\u0026gt; path; void backtracking(vector\u0026lt;int\u0026gt;\u0026amp; nums, int startIndex) { result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉自己 if (startIndex \u0026gt;= nums.size()) { // 终止条件可以不加 return; } for (int i = startIndex; i \u0026lt; nums.size(); i++) { path.push_back(nums[i]); backtracking(nums, i + 1); path.pop_back(); } } public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { result.clear(); path.clear(); backtracking(nums, 0); return result; } }; 时间复杂度: O(n * 2^n) 空间复杂度: O(n) 9.子集Ⅱ https://leetcode.cn/problems/subsets-ii/description/\n哈希表记录元素有没有被使用。同一树层上一个元素被使用过则跳过。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { private: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; vector\u0026lt;int\u0026gt; path; void backtracking(vector\u0026lt;int\u0026gt;\u0026amp; nums, int startIndex) { result.push_back(path); unordered_set\u0026lt;int\u0026gt; uset; for (int i = startIndex; i \u0026lt; nums.size(); i++) { if (uset.find(nums[i]) != uset.end()) { continue; } uset.insert(nums[i]); path.push_back(nums[i]); backtracking(nums, i + 1); path.pop_back(); } } z public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsetsWithDup(vector\u0026lt;int\u0026gt;\u0026amp; nums) { result.clear(); path.clear(); sort(nums.begin(), nums.end()); // 去重需要排序 backtracking(nums, 0); return result; } }; 时间复杂度: O(n * 2^n) 空间复杂度: O(n) 10.递增子序列 https://leetcode.cn/problems/non-decreasing-subsequences/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 版本一 class Solution { private: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; vector\u0026lt;int\u0026gt; path; void backtracking(vector\u0026lt;int\u0026gt;\u0026amp; nums, int startIndex) { if (path.size() \u0026gt; 1) { result.push_back(path); // 注意这里不要加return，要取树上的节点 } unordered_set\u0026lt;int\u0026gt; uset; // 使用set对本层元素进行去重 for (int i = startIndex; i \u0026lt; nums.size(); i++) { if ((!path.empty() \u0026amp;\u0026amp; nums[i] \u0026lt; path.back()) || uset.find(nums[i]) != uset.end()) { continue; } uset.insert(nums[i]); // 记录这个元素在本层用过了，本层后面不能再用了 path.push_back(nums[i]); backtracking(nums, i + 1); path.pop_back(); } } public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; findSubsequences(vector\u0026lt;int\u0026gt;\u0026amp; nums) { result.clear(); path.clear(); backtracking(nums, 0); return result; } }; 时间复杂度: O(n * 2^n) 空间复杂度: O(n) 11.全排列 https://leetcode.cn/problems/permutations/description/\n数组记录元素是否使用过。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; vector\u0026lt;int\u0026gt; path; void backtracking (vector\u0026lt;int\u0026gt;\u0026amp; nums, vector\u0026lt;bool\u0026gt;\u0026amp; used) { // 此时说明找到了一组 if (path.size() == nums.size()) { result.push_back(path); return; } for (int i = 0; i \u0026lt; nums.size(); i++) { if (used[i] == true) continue; // path里已经收录的元素，直接跳过 used[i] = true; path.push_back(nums[i]); backtracking(nums, used); path.pop_back(); used[i] = false; } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permute(vector\u0026lt;int\u0026gt;\u0026amp; nums) { result.clear(); path.clear(); vector\u0026lt;bool\u0026gt; used(nums.size(), false); backtracking(nums, used); return result; } }; 时间复杂度: O(n!) 空间复杂度: O(n) 12.全排列Ⅱ https://leetcode.cn/problems/permutations-ii/description/\nused数组记录。同一树枝没使用过存入。该元素与上一元素相等且同一树层使用过跳过。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { private: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; vector\u0026lt;int\u0026gt; path; void backtracking (vector\u0026lt;int\u0026gt;\u0026amp; nums, vector\u0026lt;bool\u0026gt;\u0026amp; used) { // 此时说明找到了一组 if (path.size() == nums.size()) { result.push_back(path); return; } for (int i = 0; i \u0026lt; nums.size(); i++) { // used[i - 1] == true，说明同一树枝nums[i - 1]使用过 // used[i - 1] == false，说明同一树层nums[i - 1]使用过 // 如果同一树层nums[i - 1]使用过则直接跳过 if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1] \u0026amp;\u0026amp; used[i - 1] == false) { continue; } if (used[i] == false) { used[i] = true; path.push_back(nums[i]); backtracking(nums, used); path.pop_back(); used[i] = false; } } } public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permuteUnique(vector\u0026lt;int\u0026gt;\u0026amp; nums) { result.clear(); path.clear(); sort(nums.begin(), nums.end()); // 排序 vector\u0026lt;bool\u0026gt; used(nums.size(), false); backtracking(nums, used); return result; } }; // 时间复杂度: 最差情况所有元素都是唯一的。复杂度和全排列1都是 O(n! * n) 对于 n 个元素一共有 n! 中排列方案。而对于每一个答案，我们需要 O(n) 去复制最终放到 result 数组 // 空间复杂度: O(n) 回溯树的深度取决于我们有多少个元素 时间复杂度: O(n! * n) 空间复杂度: O(n) 13.重新安排行程 https://leetcode.cn/problems/reconstruct-itinerary/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { private: // unordered_map\u0026lt;出发机场, map\u0026lt;到达机场, 航班次数\u0026gt;\u0026gt; targets unordered_map\u0026lt;string, map\u0026lt;string, int\u0026gt;\u0026gt; targets; bool backtracking(int ticketNum, vector\u0026lt;string\u0026gt;\u0026amp; result) { if (result.size() == ticketNum + 1) { return true; } for (pair\u0026lt;const string, int\u0026gt;\u0026amp; target : targets[result[result.size() - 1]]) { if (target.second \u0026gt; 0 ) { // 记录到达机场是否飞过了 result.push_back(target.first); target.second--; if (backtracking(ticketNum, result)) return true; result.pop_back(); target.second++; } } return false; } public: vector\u0026lt;string\u0026gt; findItinerary(vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt;\u0026amp; tickets) { targets.clear(); vector\u0026lt;string\u0026gt; result; for (const vector\u0026lt;string\u0026gt;\u0026amp; vec : tickets) { targets[vec[0]][vec[1]]++; // 记录映射关系 } result.push_back(\u0026#34;JFK\u0026#34;); // 起始机场 backtracking(tickets.size(), result); return result; } }; 优先级队列存储到达地，DFS\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: unordered_map\u0026lt;string, priority_queue\u0026lt;string, vector\u0026lt;string\u0026gt;, std::greater\u0026lt;string\u0026gt;\u0026gt;\u0026gt; vec; vector\u0026lt;string\u0026gt; stk; void dfs(const string\u0026amp; curr) { while (vec.count(curr) \u0026amp;\u0026amp; vec[curr].size() \u0026gt; 0) { string tmp = vec[curr].top(); vec[curr].pop(); dfs(move(tmp)); } stk.emplace_back(curr); } vector\u0026lt;string\u0026gt; findItinerary(vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt;\u0026amp; tickets) { for (auto\u0026amp; it : tickets) { vec[it[0]].emplace(it[1]); } dfs(\u0026#34;JFK\u0026#34;); reverse(stk.begin(), stk.end()); return stk; } }; 14.N皇后 https://leetcode.cn/problems/n-queens/description/\n同一树层为棋盘的行，每次验证有效就放进去。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { private: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; result; // n 为输入的棋盘大小 // row 是当前递归到棋盘的第几行了 void backtracking(int n, int row, vector\u0026lt;string\u0026gt;\u0026amp; chessboard) { if (row == n) { result.push_back(chessboard); return; } for (int col = 0; col \u0026lt; n; col++) { if (isValid(row, col, chessboard, n)) { // 验证合法就可以放 chessboard[row][col] = \u0026#39;Q\u0026#39;; // 放置皇后 backtracking(n, row + 1, chessboard); chessboard[row][col] = \u0026#39;.\u0026#39;; // 回溯，撤销皇后 } } } bool isValid(int row, int col, vector\u0026lt;string\u0026gt;\u0026amp; chessboard, int n) { // 检查列 for (int i = 0; i \u0026lt; row; i++) { // 这是一个剪枝 if (chessboard[i][col] == \u0026#39;Q\u0026#39;) { return false; } } // 检查 45度角是否有皇后 for (int i = row - 1, j = col - 1; i \u0026gt;=0 \u0026amp;\u0026amp; j \u0026gt;= 0; i--, j--) { if (chessboard[i][j] == \u0026#39;Q\u0026#39;) { return false; } } // 检查 135度角是否有皇后 for(int i = row - 1, j = col + 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n; i--, j++) { if (chessboard[i][j] == \u0026#39;Q\u0026#39;) { return false; } } return true; } public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; solveNQueens(int n) { result.clear(); std::vector\u0026lt;std::string\u0026gt; chessboard(n, std::string(n, \u0026#39;.\u0026#39;)); backtracking(n, 0, chessboard); return result; } }; 时间复杂度: O(n!) 空间复杂度: O(n) 15.解数独 https://leetcode.cn/problems/sudoku-solver/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { private: bool backtracking(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board) { for (int i = 0; i \u0026lt; board.size(); i++) { // 遍历行 for (int j = 0; j \u0026lt; board[0].size(); j++) { // 遍历列 if (board[i][j] == \u0026#39;.\u0026#39;) { for (char k = \u0026#39;1\u0026#39;; k \u0026lt;= \u0026#39;9\u0026#39;; k++) { // (i, j) 这个位置放k是否合适 if (isValid(i, j, k, board)) { board[i][j] = k; // 放置k if (backtracking(board)) return true; // 如果找到合适一组立刻返回 board[i][j] = \u0026#39;.\u0026#39;; // 回溯，撤销k } } return false; // 9个数都试完了，都不行，那么就返回false } } } return true; // 遍历完没有返回false，说明找到了合适棋盘位置了 } bool isValid(int row, int col, char val, vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board) { for (int i = 0; i \u0026lt; 9; i++) { // 判断行里是否重复 if (board[row][i] == val) { return false; } } for (int j = 0; j \u0026lt; 9; j++) { // 判断列里是否重复 if (board[j][col] == val) { return false; } } int startRow = (row / 3) * 3; int startCol = (col / 3) * 3; for (int i = startRow; i \u0026lt; startRow + 3; i++) { // 判断9方格里是否重复 for (int j = startCol; j \u0026lt; startCol + 3; j++) { if (board[i][j] == val ) { return false; } } } return true; } public: void solveSudoku(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board) { backtracking(board); } }; 八、贪心 贪心的本质是选择每一阶段的局部最优，从而达到全局最优。\n1.分发饼干 https://leetcode.cn/problems/assign-cookies/\n局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 版本一 class Solution { public: int findContentChildren(vector\u0026lt;int\u0026gt;\u0026amp; g, vector\u0026lt;int\u0026gt;\u0026amp; s) { sort(g.begin(), g.end()); sort(s.begin(), s.end()); int index = s.size() - 1; // 饼干数组的下标 int result = 0; for (int i = g.size() - 1; i \u0026gt;= 0; i--) { // 遍历胃口 if (index \u0026gt;= 0 \u0026amp;\u0026amp; s[index] \u0026gt;= g[i]) { // 遍历饼干 result++; index--; } } return result; } }; 时间复杂度：O(nlogn) 空间复杂度：O(1) 小饼干先喂饱小胃口也可以\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: int findContentChildren(vector\u0026lt;int\u0026gt;\u0026amp; g, vector\u0026lt;int\u0026gt;\u0026amp; s) { sort(g.begin(),g.end()); sort(s.begin(),s.end()); int index = 0; for(int i = 0; i \u0026lt; s.size(); i++) { // 饼干 if(index \u0026lt; g.size() \u0026amp;\u0026amp; g[index] \u0026lt;= s[i]){ // 胃口 index++; } } return index; } }; 时间复杂度：O(nlogn) 空间复杂度：O(1) 2.摆动序列 https://leetcode.cn/problems/wiggle-subsequence/description/\n局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。\n整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 版本二 class Solution { public: int wiggleMaxLength(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (nums.size() \u0026lt;= 1) return nums.size(); int curDiff = 0; // 当前一对差值 int preDiff = 0; // 前一对差值 int result = 1; // 记录峰值个数，序列默认序列最右边有一个峰值 for (int i = 0; i \u0026lt; nums.size() - 1; i++) { curDiff = nums[i + 1] - nums[i]; // 出现峰值 if ((preDiff \u0026lt;= 0 \u0026amp;\u0026amp; curDiff \u0026gt; 0) || (preDiff \u0026gt;= 0 \u0026amp;\u0026amp; curDiff \u0026lt; 0)) { result++; preDiff = curDiff; // 注意这里，只在摆动变化的时候更新prediff } } return result; } }; 时间复杂度：O(n) 空间复杂度：O(1) 动规\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int dp[1005][2]; int wiggleMaxLength(vector\u0026lt;int\u0026gt;\u0026amp; nums) { memset(dp, 0, sizeof dp); dp[0][0] = dp[0][1] = 1; for (int i = 1; i \u0026lt; nums.size(); ++i) { dp[i][0] = dp[i][1] = 1; for (int j = 0; j \u0026lt; i; ++j) { if (nums[j] \u0026gt; nums[i]) dp[i][1] = max(dp[i][1], dp[j][0] + 1); } for (int j = 0; j \u0026lt; i; ++j) { if (nums[j] \u0026lt; nums[i]) dp[i][0] = max(dp[i][0], dp[j][1] + 1); } } return max(dp[nums.size() - 1][0], dp[nums.size() - 1][1]); } }; 设 dp 状态dp[i][0]，表示考虑前 i 个数，第 i 个数作为山峰的摆动子序列的最长长度\n设 dp 状态dp[i][1]，表示考虑前 i 个数，第 i 个数作为山谷的摆动子序列的最长长度\n时间复杂度：O(n^2)\n空间复杂度：O(n)\n3.最大子序和 https://leetcode.cn/problems/maximum-subarray/\n贪心\n局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。\n全局最优：选取最大“连续和”\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: int maxSubArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int result = INT32_MIN; int count = 0; for (int i = 0; i \u0026lt; nums.size(); i++) { count += nums[i]; if (count \u0026gt; result) { // 取区间累计的最大值（相当于不断确定最大子序终止位置） result = count; } if (count \u0026lt;= 0) count = 0; // 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和 } return result; } }; 时间复杂度：O(n) 空间复杂度：O(1) 动规\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: int maxSubArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (nums.size() == 0) return 0; vector\u0026lt;int\u0026gt; dp(nums.size(), 0); // dp[i]表示包括i之前的最大连续子序列和 dp[0] = nums[0]; int result = dp[0]; for (int i = 1; i \u0026lt; nums.size(); i++) { dp[i] = max(dp[i - 1] + nums[i], nums[i]); // 状态转移公式 if (dp[i] \u0026gt; result) result = dp[i]; // result 保存dp[i]的最大值 } return result; } }; 时间复杂度：O(n) 空间复杂度：O(n) 4.买卖股票的最佳时机Ⅱ https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/\n只有一只股票、当前只有买股票或者卖股票的操作、想获得利润至少要两天为一个交易单元。\n贪心\n局部最优：收集每天的正利润，全局最优：求得最大利润。\n1 2 3 4 5 6 7 8 9 10 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int result = 0; for (int i = 1; i \u0026lt; prices.size(); i++) { result += max(prices[i] - prices[i - 1], 0); } return result; } }; 时间复杂度：O(n) 空间复杂度：O(1) 动规\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { // dp[i][1]第i天持有的最多现金 // dp[i][0]第i天持有股票后的最多现金 int n = prices.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(2, 0)); dp[0][0] -= prices[0]; // 持股票 for (int i = 1; i \u0026lt; n; i++) { // 第i天持股票所剩最多现金 = max(第i-1天持股票所剩现金, 第i-1天持现金-买第i天的股票) dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]); // 第i天持有最多现金 = max(第i-1天持有的最多现金，第i-1天持有股票的最多现金+第i天卖出股票) dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]); } return max(dp[n - 1][0], dp[n - 1][1]); } }; 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 5.跳跃游戏 https://leetcode.cn/problems/jump-game/description/\n不管跳几步，转化为跳跃覆盖范围。\n贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点。\n1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: bool canJump(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int cover = 0; if (nums.size() == 1) return true; // 只有一个元素，就是能达到 for (int i = 0; i \u0026lt;= cover; i++) { // 注意这里是小于等于cover cover = max(i + nums[i], cover); if (cover \u0026gt;= nums.size() - 1) return true; // 说明可以覆盖到终点了 } return false; } }; 时间复杂度: O(n) 空间复杂度: O(1) 6.跳跃游戏Ⅱ https://leetcode.cn/problems/jump-game-ii/description/\n需要记录步数。\n当达到了当前覆盖的最远距离下标时，步数就要加一，并且更新最远覆盖距离。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 版本一 class Solution { public: int jump(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (nums.size() == 1) return 0; int curDistance = 0; // 当前覆盖最远距离下标 int ans = 0; // 记录走的最大步数 int nextDistance = 0; // 下一步覆盖最远距离下标 for (int i = 0; i \u0026lt; nums.size(); i++) { nextDistance = max(nums[i] + i, nextDistance); // 更新下一步覆盖最远距离下标 if (i == curDistance) { // 遇到当前覆盖最远距离下标 ans++; // 需要走下一步 curDistance = nextDistance; // 更新当前覆盖最远距离下标（相当于加油了） if (nextDistance \u0026gt;= nums.size() - 1) break; // 当前覆盖最远距到达集合终点，不用做ans++操作了，直接结束 } } return ans; } }; 时间复杂度: O(n) 空间复杂度: O(1) 7.K次取反后最大化的数组和 https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/\n局部最优：让绝对值大的负数变为正数，当前数值达到最大，整体最优：整个数组和达到最大。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { static bool cmp(int a, int b) { return abs(a) \u0026gt; abs(b); } public: int largestSumAfterKNegations(vector\u0026lt;int\u0026gt;\u0026amp; A, int K) { sort(A.begin(), A.end(), cmp); // 第一步 for (int i = 0; i \u0026lt; A.size(); i++) { // 第二步 if (A[i] \u0026lt; 0 \u0026amp;\u0026amp; K \u0026gt; 0) { A[i] *= -1; K--; } } if (K % 2 == 1) A[A.size() - 1] *= -1; // 第三步 int result = 0; for (int a : A) result += a; // 第四步 return result; } }; 时间复杂度: O(nlogn) 空间复杂度: O(1) 8.加油站 https://leetcode.cn/problems/gas-station/\n局部最优：当前累加rest[i]的和curSum一旦小于0，起始位置至少要是i+1，因为从i之前开始一定不行。全局最优：找到可以跑一圈的起始位置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int canCompleteCircuit(vector\u0026lt;int\u0026gt;\u0026amp; gas, vector\u0026lt;int\u0026gt;\u0026amp; cost) { int curSum = 0; int totalSum = 0; int start = 0; for (int i = 0; i \u0026lt; gas.size(); i++) { curSum += gas[i] - cost[i]; totalSum += gas[i] - cost[i]; if (curSum \u0026lt; 0) { // 当前累加rest[i]和 curSum一旦小于0 start = i + 1; // 起始位置更新为i+1 curSum = 0; // curSum从0开始 } } if (totalSum \u0026lt; 0) return -1; // 说明怎么走都不可能跑一圈了 return start; } }; 时间复杂度：O(n) 空间复杂度：O(1) 9.分发糖果 https://leetcode.cn/problems/candy/description/\n一次是从左到右遍历，只比较右边孩子评分比左边大的情况。 一次是从右到左遍历，只比较左边孩子评分比右边大的情况。 这样从局部最优推出了全局最优\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int candy(vector\u0026lt;int\u0026gt;\u0026amp; ratings) { vector\u0026lt;int\u0026gt; candyVec(ratings.size(), 1); // 从前向后 for (int i = 1; i \u0026lt; ratings.size(); i++) { if (ratings[i] \u0026gt; ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1; } // 从后向前 for (int i = ratings.size() - 2; i \u0026gt;= 0; i--) { if (ratings[i] \u0026gt; ratings[i + 1] ) { candyVec[i] = max(candyVec[i], candyVec[i + 1] + 1); } } // 统计结果 int result = 0; for (int i = 0; i \u0026lt; candyVec.size(); i++) result += candyVec[i]; return result; } }; 时间复杂度: O(n) 空间复杂度: O(n) 10.柠檬水找零 https://leetcode.cn/problems/lemonade-change/description/\n局部最优：遇到账单20，优先消耗美元10，完成本次找零。全局最优：完成全部账单的找零。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: bool lemonadeChange(vector\u0026lt;int\u0026gt;\u0026amp; bills) { int five = 0, ten = 0, twenty = 0; for (int bill : bills) { // 情况一 if (bill == 5) five++; // 情况二 if (bill == 10) { if (five \u0026lt;= 0) return false; ten++; five--; } // 情况三 if (bill == 20) { // 优先消耗10美元，因为5美元的找零用处更大，能多留着就多留着 if (five \u0026gt; 0 \u0026amp;\u0026amp; ten \u0026gt; 0) { five--; ten--; twenty++; // 其实这行代码可以删了，因为记录20已经没有意义了，不会用20来找零 } else if (five \u0026gt;= 3) { five -= 3; twenty++; // 同理，这行代码也可以删了 } else return false; } } return true; } }; 时间复杂度: O(n) 空间复杂度: O(1) 11.根据身高重建队列 https://leetcode.cn/problems/queue-reconstruction-by-height/description/\n局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性\n全局最优：最后都做完插入操作，整个队列满足题目队列属性\n使用数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 版本一 class Solution { public: static bool cmp(const vector\u0026lt;int\u0026gt;\u0026amp; a, const vector\u0026lt;int\u0026gt;\u0026amp; b) { if (a[0] == b[0]) return a[1] \u0026lt; b[1]; return a[0] \u0026gt; b[0]; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; reconstructQueue(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; people) { sort (people.begin(), people.end(), cmp); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; que; for (int i = 0; i \u0026lt; people.size(); i++) { int position = people[i][1]; que.insert(que.begin() + position, people[i]); } return que; } }; 时间复杂度：O(nlog n + n^2) 空间复杂度：O(n) vector（动态数组）来insert，是费时的。\n使用链表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 版本二 class Solution { public: // 身高从大到小排（身高相同k小的站前面） static bool cmp(const vector\u0026lt;int\u0026gt;\u0026amp; a, const vector\u0026lt;int\u0026gt;\u0026amp; b) { if (a[0] == b[0]) return a[1] \u0026lt; b[1]; return a[0] \u0026gt; b[0]; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; reconstructQueue(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; people) { sort (people.begin(), people.end(), cmp); list\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; que; // list底层是链表实现，插入效率比vector高的多 for (int i = 0; i \u0026lt; people.size(); i++) { int position = people[i][1]; // 插入到下标为position的位置 std::list\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;::iterator it = que.begin(); while (position--) { // 寻找在插入位置 it++; } que.insert(it, people[i]); } return vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(que.begin(), que.end()); } }; 时间复杂度：O(nlog n + n^2) 空间复杂度：O(n) 首先vector的底层实现也是普通数组。\nvector的大小有两个维度一个是size一个是capicity，size就是我们平时用来遍历vector时候用的。而capicity是vector底层数组（就是普通数组）的大小，capicity可不一定就是size。\n当insert数据的时候，如果已经大于capicity，capicity会成倍扩容，但对外暴漏的size其实仅仅是+1。\nvector底层实现是普通数组，怎么扩容的？\n就是重新申请一个二倍于原数组大小的数组，然后把数据都拷贝过去，并释放原数组内存。\n12.用最少数量的箭引爆气球 https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/\n局部最优：当气球出现重叠，一起射，所用弓箭最少。全局最优：把所有气球射爆所用弓箭最少。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { private: static bool cmp(const vector\u0026lt;int\u0026gt;\u0026amp; a, const vector\u0026lt;int\u0026gt;\u0026amp; b) { return a[0] \u0026lt; b[0]; } public: int findMinArrowShots(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; points) { if (points.size() == 0) return 0; sort(points.begin(), points.end(), cmp); int result = 1; // points 不为空至少需要一支箭 for (int i = 1; i \u0026lt; points.size(); i++) { if (points[i][0] \u0026gt; points[i - 1][1]) { // 气球i和气球i-1不挨着，注意这里不是\u0026gt;= result++; // 需要一支箭 } else { // 气球i和气球i-1挨着 points[i][1] = min(points[i - 1][1], points[i][1]); // 更新重叠气球最小右边界 } } return result; } }; 时间复杂度：O(nlog n)，因为有一个快排 空间复杂度：O(1)，有一个快排，最差情况(倒序)时，需要n次递归调用。因此确实需要O(n)的栈空间 13.无重叠区间 https://leetcode.cn/problems/non-overlapping-intervals/\n右边界排序，从左向右记录非交叉区间的个数。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: // 按照区间右边界排序 static bool cmp (const vector\u0026lt;int\u0026gt;\u0026amp; a, const vector\u0026lt;int\u0026gt;\u0026amp; b) { return a[1] \u0026lt; b[1]; } int eraseOverlapIntervals(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; intervals) { if (intervals.size() == 0) return 0; sort(intervals.begin(), intervals.end(), cmp); int count = 1; // 记录非交叉区间的个数 int end = intervals[0][1]; // 记录区间分割点 for (int i = 1; i \u0026lt; intervals.size(); i++) { if (end \u0026lt;= intervals[i][0]) { end = intervals[i][1]; count++; } } return intervals.size() - count; } }; 时间复杂度：O(nlog n) ，有一个快排 空间复杂度：O(n)，有一个快排，最差情况(倒序)时，需要n次递归调用。因此确实需要O(n)的栈空间 左边界排序 左边界排序我们就是直接求 重叠的区间，count为记录重叠区间数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: static bool cmp (const vector\u0026lt;int\u0026gt;\u0026amp; a, const vector\u0026lt;int\u0026gt;\u0026amp; b) { return a[0] \u0026lt; b[0]; // 改为左边界排序 } int eraseOverlapIntervals(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; intervals) { if (intervals.size() == 0) return 0; sort(intervals.begin(), intervals.end(), cmp); int count = 0; // 注意这里从0开始，因为是记录重叠区间 int end = intervals[0][1]; // 记录区间分割点 for (int i = 1; i \u0026lt; intervals.size(); i++) { if (intervals[i][0] \u0026gt;= end) end = intervals[i][1]; // 无重叠的情况 else { // 重叠情况 end = min(end, intervals[i][1]); count++; } } return count; } }; 14.划分字母区间 https://leetcode.cn/problems/partition-labels/description/\n如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: vector\u0026lt;int\u0026gt; partitionLabels(string S) { int hash[27] = {0}; // i为字符，hash[i]为字符出现的最后位置 for (int i = 0; i \u0026lt; S.size(); i++) { // 统计每一个字符最后出现的位置 hash[S[i] - \u0026#39;a\u0026#39;] = i; } vector\u0026lt;int\u0026gt; result; int left = 0; int right = 0; for (int i = 0; i \u0026lt; S.size(); i++) { right = max(right, hash[S[i] - \u0026#39;a\u0026#39;]); // 找到字符出现的最远边界 if (i == right) { result.push_back(right - left + 1); left = i + 1; } } return result; } }; 时间复杂度：O(n) 空间复杂度：O(1)，使用的hash数组是固定大小 15.合并区间 https://leetcode.cn/problems/merge-intervals/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; merge(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; intervals) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; if (intervals.size() == 0) return result; // 区间集合为空直接返回 // 排序的参数使用了lambda表达式 sort(intervals.begin(), intervals.end(), [](const vector\u0026lt;int\u0026gt;\u0026amp; a, const vector\u0026lt;int\u0026gt;\u0026amp; b){return a[0] \u0026lt; b[0];}); // 第一个区间就可以放进结果集里，后面如果重叠，在result上直接合并 result.push_back(intervals[0]); for (int i = 1; i \u0026lt; intervals.size(); i++) { if (result.back()[1] \u0026gt;= intervals[i][0]) { // 发现重叠区间 // 合并区间，只更新右边界就好，因为result.back()的左边界一定是最小值，因为我们按照左边界排序的 result.back()[1] = max(result.back()[1], intervals[i][1]); } else { result.push_back(intervals[i]); // 区间不重叠 } } return result; } }; 时间复杂度: O(nlogn) 空间复杂度: O(logn)，排序需要的空间开销 16.单调递增的数字 https://leetcode.cn/problems/monotone-increasing-digits/description/\n从后向前遍历332的数值变化为：332 -\u0026gt; 329 -\u0026gt; 299\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int monotoneIncreasingDigits(int N) { string strNum = to_string(N); // flag用来标记赋值9从哪里开始 // 设置为这个默认值，为了防止第二个for循环在flag没有被赋值的情况下执行 int flag = strNum.size(); for (int i = strNum.size() - 1; i \u0026gt; 0; i--) { if (strNum[i - 1] \u0026gt; strNum[i] ) { flag = i; strNum[i - 1]--; } } for (int i = flag; i \u0026lt; strNum.size(); i++) { strNum[i] = \u0026#39;9\u0026#39;; } return stoi(strNum); } }; 时间复杂度：O(n)，n 为数字长度 空间复杂度：O(n)，需要一个字符串，转化为字符串操作更方便 17.监控二叉树 https://leetcode.cn/problems/binary-tree-cameras/\n从下往上看，局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少！\n分别有三个数字来表示：\n0：该节点无覆盖 1：本节点有摄像头 2：本节点有覆盖 空节点的状态是有覆盖\n情况1：左右节点都有覆盖\n情况2：左右节点至少有一个无覆盖的情况\n如果是以下情况，则中间节点（父节点）应该放摄像头：\nleft == 0 \u0026amp;\u0026amp; right == 0 左右节点无覆盖\nleft == 1 \u0026amp;\u0026amp; right == 0 左节点有摄像头，右节点无覆盖\nleft == 0 \u0026amp;\u0026amp; right == 1 左节点有无覆盖，右节点摄像头\nleft == 0 \u0026amp;\u0026amp; right == 2 左节点无覆盖，右节点覆盖\nleft == 2 \u0026amp;\u0026amp; right == 0 左节点覆盖，右节点无覆盖\n情况3：左右节点至少有一个有摄像头\n如果是以下情况，其实就是 左右孩子节点有一个有摄像头了，那么其父节点就应该是2（覆盖的状态）\nleft == 1 \u0026amp;\u0026amp; right == 2 左节点有摄像头，右节点有覆盖\nleft == 2 \u0026amp;\u0026amp; right == 1 左节点有覆盖，右节点有摄像头\nleft == 1 \u0026amp;\u0026amp; right == 1 左右节点都有摄像头\n情况4：头结点没有覆盖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // 版本一 class Solution { private: int result; int traversal(TreeNode* cur) { // 空节点，该节点有覆盖 if (cur == NULL) return 2; int left = traversal(cur-\u0026gt;left); // 左 int right = traversal(cur-\u0026gt;right); // 右 // 情况1 // 左右节点都有覆盖 if (left == 2 \u0026amp;\u0026amp; right == 2) return 0; // 情况2 // left == 0 \u0026amp;\u0026amp; right == 0 左右节点无覆盖 // left == 1 \u0026amp;\u0026amp; right == 0 左节点有摄像头，右节点无覆盖 // left == 0 \u0026amp;\u0026amp; right == 1 左节点有无覆盖，右节点摄像头 // left == 0 \u0026amp;\u0026amp; right == 2 左节点无覆盖，右节点覆盖 // left == 2 \u0026amp;\u0026amp; right == 0 左节点覆盖，右节点无覆盖 if (left == 0 || right == 0) { result++; return 1; } // 情况3 // left == 1 \u0026amp;\u0026amp; right == 2 左节点有摄像头，右节点有覆盖 // left == 2 \u0026amp;\u0026amp; right == 1 左节点有覆盖，右节点有摄像头 // left == 1 \u0026amp;\u0026amp; right == 1 左右节点都有摄像头 // 其他情况前段代码均已覆盖 if (left == 1 || right == 1) return 2; // 以上代码我没有使用else，主要是为了把各个分支条件展现出来，这样代码有助于读者理解 // 这个 return -1 逻辑不会走到这里。 return -1; } public: int minCameraCover(TreeNode* root) { result = 0; // 情况4 if (traversal(root) == 0) { // root 无覆盖 result++; } return result; } }; 时间复杂度: O(n)，需要遍历二叉树上的每个节点 空间复杂度: O(n) 九、动态规划 对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！\n确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组 debug：把dp数组打印出来\n1.斐波那契数 https://leetcode.cn/problems/fibonacci-number/description/\ndp[i]的定义为：第i个数的斐波那契数值是dp[i]\n状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: int fib(int N) { if (N \u0026lt;= 1) return N; int dp[2]; dp[0] = 0; dp[1] = 1; for (int i = 2; i \u0026lt;= N; i++) { int sum = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = sum; } return dp[1]; } }; 时间复杂度：O(n) 空间复杂度：O(1) 递归\n1 2 3 4 5 6 7 class Solution { public: int fib(int N) { if (N \u0026lt; 2) return N; return fib(N - 1) + fib(N - 2); } }; 时间复杂度：O(2^n) 空间复杂度：O(n)，算上了编程语言中实现递归的系统栈所占空间 2.爬楼梯 https://leetcode.cn/problems/climbing-stairs/description/\ndp[i]： 爬到第i层楼梯，有dp[i]种方法\n递推公式dp[i] = dp[i - 1] + dp[i - 2]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 版本一 class Solution { public: int climbStairs(int n) { if (n \u0026lt;= 1) return n; // 因为下面直接对dp[2]操作了，防止空指针 vector\u0026lt;int\u0026gt; dp(n + 1); dp[1] = 1; dp[2] = 2; for (int i = 3; i \u0026lt;= n; i++) { // 注意i是从3开始的 dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; } }; 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 优化空间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 版本二 class Solution { public: int climbStairs(int n) { if (n \u0026lt;= 1) return n; int dp[3]; dp[1] = 1; dp[2] = 2; for (int i = 3; i \u0026lt;= n; i++) { int sum = dp[1] + dp[2]; dp[1] = dp[2]; dp[2] = sum; } return dp[2]; } }; 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 3.使用最小花费爬楼梯 https://leetcode.cn/problems/min-cost-climbing-stairs/description/\ndp[i]的定义：到达第i台阶所花费的最少体力为dp[i]。\ndp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: int minCostClimbingStairs(vector\u0026lt;int\u0026gt;\u0026amp; cost) { vector\u0026lt;int\u0026gt; dp(cost.size() + 1); dp[0] = 0; dp[1] = 0; for (int i = 2; i \u0026lt;= cost.size(); i++) { dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]); } return dp[cost.size()]; } }; 时间复杂度：O(n) 空间复杂度：O(n) 4.不同路径 https://leetcode.cn/problems/unique-paths/description/\ndp[i][j]：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。\ndp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: int uniquePaths(int m, int n) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m, vector\u0026lt;int\u0026gt;(n, 0)); for (int i = 0; i \u0026lt; m; i++) dp[i][0] = 1; for (int j = 0; j \u0026lt; n; j++) dp[0][j] = 1; for (int i = 1; i \u0026lt; m; i++) { for (int j = 1; j \u0026lt; n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; } }; 时间复杂度：O(m × n) 空间复杂度：O(m × n) 5.不同路径Ⅱ https://leetcode.cn/problems/unique-paths-ii/description/\n有障碍物的情况下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int uniquePathsWithObstacles(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; obstacleGrid) { int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) //如果在起点或终点出现了障碍，直接返回0 return 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m, vector\u0026lt;int\u0026gt;(n, 0)); for (int i = 0; i \u0026lt; m \u0026amp;\u0026amp; obstacleGrid[i][0] == 0; i++) dp[i][0] = 1; for (int j = 0; j \u0026lt; n \u0026amp;\u0026amp; obstacleGrid[0][j] == 0; j++) dp[0][j] = 1; for (int i = 1; i \u0026lt; m; i++) { for (int j = 1; j \u0026lt; n; j++) { if (obstacleGrid[i][j] == 1) continue; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; } }; 时间复杂度：O(n × m)，n、m 分别为obstacleGrid 长度和宽度 空间复杂度：O(n × m) 6.整数拆分 https://leetcode.cn/problems/integer-break/description/\ndp[i]：分拆数字i，可以得到的最大乘积为dp[i]。\ndp[i] = max({dp[i], (i - j) * j, dp[i - j] * j});\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int integerBreak(int n) { vector\u0026lt;int\u0026gt; dp(n + 1); dp[2] = 1; for (int i = 3; i \u0026lt;= n ; i++) { for (int j = 1; j \u0026lt;= i / 2; j++) { dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j)); } } return dp[n]; } }; 时间复杂度：$O(n^2)$ 空间复杂度：$O(n)$ 7.不同的二叉搜索树 https://leetcode.cn/problems/unique-binary-search-trees/description/\ndp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]。\ndp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int numTrees(int n) { vector\u0026lt;int\u0026gt; dp(n + 1); dp[0] = 1; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= i; j++) { dp[i] += dp[j - 1] * dp[i - j]; } } return dp[n]; } }; 时间复杂度：$O(n^2)$ 空间复杂度：$O(n)$ 8. 01背包理论基础 有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。\n每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是$o(2^n)$，这里的n表示物品数量。\n所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！\n二维dp数组01背包 dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。\n不放物品i：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。 放物品i：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值 所以递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);\ndp数组如何初始化:\n如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。\nj \u0026lt; weight[0]的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。\n当j \u0026gt;= weight[0]时，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品。\n先遍历物品\n1 2 3 4 5 6 7 8 // weight数组的大小 就是物品个数 for(int i = 1; i \u0026lt; weight.size(); i++) { // 遍历物品 for(int j = 0; j \u0026lt;= bagweight; j++) { // 遍历背包容量 if (j \u0026lt; weight[i]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); } } 先遍历背包\n1 2 3 4 5 6 7 // weight数组的大小 就是物品个数 for(int j = 0; j \u0026lt;= bagweight; j++) { // 遍历背包容量 for(int i = 1; i \u0026lt; weight.size(); i++) { // 遍历物品 if (j \u0026lt; weight[i]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); } } 一维dp数组（滚动数组） dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。\ndp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，\n所以递归公式为：\n1 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); 一维dp遍历的时候，背包是从大到小。倒序遍历是为了保证物品i只被放入一次！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void test_1_wei_bag_problem() { vector\u0026lt;int\u0026gt; weight = {1, 3, 4}; vector\u0026lt;int\u0026gt; value = {15, 20, 30}; int bagWeight = 4; // 初始化 vector\u0026lt;int\u0026gt; dp(bagWeight + 1, 0); for(int i = 0; i \u0026lt; weight.size(); i++) { // 遍历物品 for(int j = bagWeight; j \u0026gt;= weight[i]; j--) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } } cout \u0026lt;\u0026lt; dp[bagWeight] \u0026lt;\u0026lt; endl; } int main() { test_1_wei_bag_problem(); } 9.分割等和子集 https://leetcode.cn/problems/partition-equal-subset-sum/description/\n背包的体积为sum / 2。能否出现总和为 sum / 2 的子集。 01背包\ndp[j]表示 背包总容量（所能装的总重量）是j，放进物品后，背的最大重量为dp[j]。\ndp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);\ndp[0]=0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: bool canPartition(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int sum = 0; // dp[i]中的i表示背包内总和 // 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200 // 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了 vector\u0026lt;int\u0026gt; dp(10001, 0); for (int i = 0; i \u0026lt; nums.size(); i++) { sum += nums[i]; } // 也可以使用库函数一步求和 // int sum = accumulate(nums.begin(), nums.end(), 0); if (sum % 2 == 1) return false; int target = sum / 2; // 开始 01背包 for(int i = 0; i \u0026lt; nums.size(); i++) { for(int j = target; j \u0026gt;= nums[i]; j--) { // 每一个元素一定是不可重复放入，所以从大到小遍历 dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); } } // 集合中的元素正好可以凑成总和target if (dp[target] == target) return true; return false; } }; 时间复杂度：O(n^2) 空间复杂度：O(n)，虽然dp数组大小为一个常数，但是大常数 10.最后一块石头的重量II https://leetcode.cn/problems/last-stone-weight-ii/\n01背包\n分成两堆石头，一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: int lastStoneWeightII(vector\u0026lt;int\u0026gt;\u0026amp; stones) { vector\u0026lt;int\u0026gt; dp(15001, 0); int sum = 0; for (int i = 0; i \u0026lt; stones.size(); i++) sum += stones[i]; int target = sum / 2; for (int i = 0; i \u0026lt; stones.size(); i++) { // 遍历物品 for (int j = target; j \u0026gt;= stones[i]; j--) { // 遍历背包 dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]); } } return sum - dp[target] - dp[target]; } }; 时间复杂度：O(m × n) , m是石头总重量（准确的说是总重量的一半），n为石头块数 空间复杂度：O(m) 11.目标和 https://leetcode.cn/problems/target-sum/\nleft组合 - right组合 = target。\nleft + right = sum，而sum是固定的。right = sum - left\n公式来了， left - (sum - left) = target 推导出 left = (target + sum)/2 。\n装满容量为left的背包，有几种方法\ndp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法\ndp[j]，j 为5，\n已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。 已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。 已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包 已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包 已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包 那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。\ndp[0] =1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int findTargetSumWays(vector\u0026lt;int\u0026gt;\u0026amp; nums, int S) { int sum = 0; for (int i = 0; i \u0026lt; nums.size(); i++) sum += nums[i]; if (abs(S) \u0026gt; sum) return 0; // 此时没有方案 if ((S + sum) % 2 == 1) return 0; // 此时没有方案 int bagSize = (S + sum) / 2; vector\u0026lt;int\u0026gt; dp(bagSize + 1, 0); dp[0] = 1; for (int i = 0; i \u0026lt; nums.size(); i++) { for (int j = bagSize; j \u0026gt;= nums[i]; j--) { dp[j] += dp[j - nums[i]]; } } return dp[bagSize]; } }; 时间复杂度：O(n × m)，n为正数个数，m为背包容量 空间复杂度：O(m)，m为背包容量 12.一和零 https://leetcode.cn/problems/ones-and-zeroes/description/\ndp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]。\ndp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int findMaxForm(vector\u0026lt;string\u0026gt;\u0026amp; strs, int m, int n) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m + 1, vector\u0026lt;int\u0026gt; (n + 1, 0)); // 默认初始化0 for (string str : strs) { // 遍历物品 int oneNum = 0, zeroNum = 0; for (char c : str) { if (c == \u0026#39;0\u0026#39;) zeroNum++; else oneNum++; } for (int i = m; i \u0026gt;= zeroNum; i--) { // 遍历背包容量且从后向前遍历！ for (int j = n; j \u0026gt;= oneNum; j--) { dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1); } } } return dp[m][n]; } }; 时间复杂度: O(kmn)，k 为strs的长度 空间复杂度: O(mn) 13.完全背包 完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void test_CompletePack() { vector\u0026lt;int\u0026gt; weight = {1, 3, 4}; vector\u0026lt;int\u0026gt; value = {15, 20, 30}; int bagWeight = 4; vector\u0026lt;int\u0026gt; dp(bagWeight + 1, 0); for(int i = 0; i \u0026lt; weight.size(); i++) { // 遍历物品 for(int j = weight[i]; j \u0026lt;= bagWeight; j++) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } } cout \u0026lt;\u0026lt; dp[bagWeight] \u0026lt;\u0026lt; endl; } int main() { test_CompletePack(); } 14.零钱兑换II https://leetcode.cn/problems/coin-change-ii/description/\ndp[j]：凑成总金额j的货币组合数为dp[j] dp[j] += dp[j - coins[i]]; dp[0] = 1 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int change(int amount, vector\u0026lt;int\u0026gt;\u0026amp; coins) { vector\u0026lt;int\u0026gt; dp(amount + 1, 0); dp[0] = 1; for (int i = 0; i \u0026lt; coins.size(); i++) { // 遍历物品 for (int j = coins[i]; j \u0026lt;= amount; j++) { // 遍历背包 dp[j] += dp[j - coins[i]]; } } return dp[amount]; } }; 时间复杂度: O(mn)，其中 m 是amount，n 是 coins 的长度 空间复杂度: O(m) 15.组合总和Ⅳ https://leetcode.cn/problems/combination-sum-iv/description/\ndp[i]: 凑成目标正整数为i的排列个数为dp[i] dp[i] += dp[i - nums[j]]; dp[0]=1 如果求组合数就是外层for循环遍历物品，内层for遍历背包。\n如果求排列数就是外层for遍历背包，内层for循环遍历物品。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: int combinationSum4(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { vector\u0026lt;int\u0026gt; dp(target + 1, 0); dp[0] = 1; for (int i = 0; i \u0026lt;= target; i++) { // 遍历背包 for (int j = 0; j \u0026lt; nums.size(); j++) { // 遍历物品 if (i - nums[j] \u0026gt;= 0 \u0026amp;\u0026amp; dp[i] \u0026lt; INT_MAX - dp[i - nums[j]]) { dp[i] += dp[i - nums[j]]; } } } return dp[target]; } }; 时间复杂度: O(target * n)，其中 n 为 nums 的长度 空间复杂度: O(target) 16.零钱兑换 https://leetcode.cn/problems/coin-change/\ndp[j]：凑足总额为j所需钱币的最少个数为dp[j] dp[j] = min(dp[j - coins[i]] + 1, dp[j]); 凑足总金额为0所需钱币的个数一定是0，那么dp[0] = 0; 不强调组合还是排列，遍历顺序都可以\ncoins（物品）放在外循环，target（背包）在内循环。且内循环正序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 版本一 class Solution { public: int coinChange(vector\u0026lt;int\u0026gt;\u0026amp; coins, int amount) { vector\u0026lt;int\u0026gt; dp(amount + 1, INT_MAX); dp[0] = 0; for (int i = 0; i \u0026lt; coins.size(); i++) { // 遍历物品 for (int j = coins[i]; j \u0026lt;= amount; j++) { // 遍历背包 if (dp[j - coins[i]] != INT_MAX) { // 如果dp[j - coins[i]]是初始值则跳过 dp[j] = min(dp[j - coins[i]] + 1, dp[j]); } } } if (dp[amount] == INT_MAX) return -1; return dp[amount]; } }; 时间复杂度: O(n * amount)，其中 n 为 coins 的长度 空间复杂度: O(amount) 遍历方式遍历背包放在外循环，遍历物品放在内循环也是可以的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 版本二 class Solution { public: int coinChange(vector\u0026lt;int\u0026gt;\u0026amp; coins, int amount) { vector\u0026lt;int\u0026gt; dp(amount + 1, INT_MAX); dp[0] = 0; for (int i = 1; i \u0026lt;= amount; i++) { // 遍历背包 for (int j = 0; j \u0026lt; coins.size(); j++) { // 遍历物品 if (i - coins[j] \u0026gt;= 0 \u0026amp;\u0026amp; dp[i - coins[j]] != INT_MAX ) { dp[i] = min(dp[i - coins[j]] + 1, dp[i]); } } } if (dp[amount] == INT_MAX) return -1; return dp[amount]; } }; 17.完全平方数 https://leetcode.cn/problems/perfect-squares/description/\ndp[j]：和为j的完全平方数的最少数量为dp[j] dp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j]。 此时我们要选择最小的dp[j]，所以递推公式：dp[j] = min(dp[j - i * i] + 1, dp[j])\ndp[0]表示 和为0的完全平方数的最小数量，那么dp[0]一定是0。 本题外层for遍历背包，内层for遍历物品，还是外层for遍历物品，内层for遍历背包，都是可以的！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 版本一 class Solution { public: int numSquares(int n) { vector\u0026lt;int\u0026gt; dp(n + 1, INT_MAX); dp[0] = 0; for (int i = 0; i \u0026lt;= n; i++) { // 遍历背包 for (int j = 1; j * j \u0026lt;= i; j++) { // 遍历物品 dp[i] = min(dp[i - j * j] + 1, dp[i]); } } return dp[n]; } }; 时间复杂度: O(n * √n) 空间复杂度: O(n) 同样我在给出先遍历物品，在遍历背包的代码，一样的可以AC的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 版本二 class Solution { public: int numSquares(int n) { vector\u0026lt;int\u0026gt; dp(n + 1, INT_MAX); dp[0] = 0; for (int i = 1; i * i \u0026lt;= n; i++) { // 遍历物品 for (int j = i * i; j \u0026lt;= n; j++) { // 遍历背包 dp[j] = min(dp[j - i * i] + 1, dp[j]); } } return dp[n]; } }; 18.单词拆分 https://leetcode.cn/problems/word-break/description/\ndp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词。 求的是排列数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: bool wordBreak(string s, vector\u0026lt;string\u0026gt;\u0026amp; wordDict) { unordered_set\u0026lt;string\u0026gt; wordSet(wordDict.begin(), wordDict.end()); vector\u0026lt;bool\u0026gt; dp(s.size() + 1, false); dp[0] = true; for (int i = 1; i \u0026lt;= s.size(); i++) { // 遍历背包 for (int j = 0; j \u0026lt; i; j++) { // 遍历物品 string word = s.substr(j, i - j); //substr(起始位置，截取的个数) if (wordSet.find(word) != wordSet.end() \u0026amp;\u0026amp; dp[j]) { dp[i] = true; } } } return dp[s.size()]; } }; 时间复杂度：O(n^3)，因为substr返回子串的副本是O(n)的复杂度（这里的n是substring的长度） 空间复杂度：O(n) 19.打家劫舍 https://leetcode.cn/problems/house-robber/description/\ndp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]。 dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); dp[0= nums[0]，dp[1] = max(nums[0], nums[1]); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: int rob(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; vector\u0026lt;int\u0026gt; dp(nums.size()); dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]); for (int i = 2; i \u0026lt; nums.size(); i++) { dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); } return dp[nums.size() - 1]; } }; 时间复杂度: O(n) 空间复杂度: O(n) 20.打家劫舍III https://leetcode.cn/problems/house-robber-iii/description/\n树形dp\n后序遍历。\n通过递归左节点，得到左节点偷与不偷的金钱。\n通过递归右节点，得到右节点偷与不偷的金钱。\n如果是偷当前节点，那么左右孩子就不能偷，val1 = cur-\u0026gt;val + left[0] + right[0];\n如果不偷当前节点，那么左右孩子就可以偷，至于到底偷不偷一定是选一个最大的，所以：val2 = max(left[0], left[1]) + max(right[0], right[1]);\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int rob(TreeNode* root) { vector\u0026lt;int\u0026gt; result = robTree(root); return max(result[0], result[1]); } // 长度为2的数组，0：不偷，1：偷 vector\u0026lt;int\u0026gt; robTree(TreeNode* cur) { if (cur == NULL) return vector\u0026lt;int\u0026gt;{0, 0}; vector\u0026lt;int\u0026gt; left = robTree(cur-\u0026gt;left); vector\u0026lt;int\u0026gt; right = robTree(cur-\u0026gt;right); // 偷cur，那么就不能偷左右节点。 int val1 = cur-\u0026gt;val + left[0] + right[0]; // 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况 int val2 = max(left[0], left[1]) + max(right[0], right[1]); return {val2, val1}; } }; 时间复杂度：O(n)，每个节点只遍历了一次 空间复杂度：O(log n)，算上递推系统栈的空间 21.买卖股票的最佳时机 https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/\n贪心\n因为股票就买卖一次，那么贪心的想法很自然就是取最左最小值，取最右最大值，那么得到的差值就是最大利润。\n1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int low = INT_MAX; int result = 0; for (int i = 0; i \u0026lt; prices.size(); i++) { low = min(low, prices[i]); // 取最左最小价格 result = max(result, prices[i] - low); // 直接取最大区间利润 } return result; } }; 时间复杂度：O(n) 空间复杂度：O(1) 动态规划\ndp[i][0] 表示第i天持有股票所得最多现金\ndp[i][1] 表示第i天不持有股票所得最多现金\ndp[i][0] = max(dp[i - 1][0], -prices[i]);\ndp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 版本一 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int len = prices.size(); if (len == 0) return 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(len, vector\u0026lt;int\u0026gt;(2)); dp[0][0] -= prices[0]; dp[0][1] = 0; for (int i = 1; i \u0026lt; len; i++) { dp[i][0] = max(dp[i - 1][0], -prices[i]); dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]); } return dp[len - 1][1]; } }; 时间复杂度：O(n) 空间复杂度：O(n) 22.买卖股票的最佳时机II https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int len = prices.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(len, vector\u0026lt;int\u0026gt;(2, 0)); dp[0][0] -= prices[0]; dp[0][1] = 0; for (int i = 1; i \u0026lt; len; i++) { dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]); // 注意这里是和121. 买卖股票的最佳时机唯一不同的地方。 dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]); } return dp[len - 1][1]; } }; 时间复杂度：O(n) 空间复杂度：O(n) 23.买卖股票的最佳时机III https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/\n一天一共就有五个状态，\n没有操作 （其实我们也可以不设置这个状态） 第一次持有股票 第一次不持有股票 第二次持有股票 第二次不持有股票 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 版本一 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { if (prices.size() == 0) return 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(prices.size(), vector\u0026lt;int\u0026gt;(5, 0)); dp[0][1] = -prices[0]; dp[0][3] = -prices[0]; for (int i = 1; i \u0026lt; prices.size(); i++) { dp[i][0] = dp[i - 1][0]; dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]); dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]); dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]); dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]); } return dp[prices.size() - 1][4]; } }; 时间复杂度：O(n) 空间复杂度：O(n × 5) 24.买卖股票的最佳时机IV https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/\n除了0以外，偶数就是卖出，奇数就是买入。\n至多有K笔交易，那么j的范围就定义为 2 * k + 1 就可以了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int maxProfit(int k, vector\u0026lt;int\u0026gt;\u0026amp; prices) { if (prices.size() == 0) return 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(prices.size(), vector\u0026lt;int\u0026gt;(2 * k + 1, 0)); for (int j = 1; j \u0026lt; 2 * k; j += 2) { dp[0][j] = -prices[0]; } for (int i = 1;i \u0026lt; prices.size(); i++) { for (int j = 0; j \u0026lt; 2 * k - 1; j += 2) { dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]); dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]); } } return dp[prices.size() - 1][2 * k]; } }; 时间复杂度: O(n * k)，其中 n 为 prices 的长度 空间复杂度: O(n * k) 25.最佳买卖股票时机含冷冻期 dp[i][j]，第i天状态为j，所剩的最多现金为dp[i][j]。\n状态一：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有） 不持有股票状态，这里就有两种卖出股票状态 状态二：保持卖出股票的状态（两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作） 状态三：今天卖出股票 状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！ j的状态为：\n0：状态一 1：状态二 2：状态三 3：状态四 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); if (n == 0) return 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(4, 0)); dp[0][0] -= prices[0]; // 持股票 for (int i = 1; i \u0026lt; n; i++) { dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i])); dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]); dp[i][2] = dp[i - 1][0] + prices[i]; dp[i][3] = dp[i - 1][2]; } return max(dp[n - 1][3], max(dp[n - 1][1], dp[n - 1][2])); } }; 时间复杂度：O(n) 空间复杂度：O(n) 26.买卖股票的最佳时机含手续费 https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/\ndp[i][0] 表示第i天持有股票所省最多现金。 dp[i][1] 表示第i天不持有股票所得最多现金\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices, int fee) { int n = prices.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(2, 0)); dp[0][0] -= prices[0]; // 持股票 for (int i = 1; i \u0026lt; n; i++) { dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]); dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee); } return max(dp[n - 1][0], dp[n - 1][1]); } }; 时间复杂度：O(n) 空间复杂度：O(n) 27.最长递增子序列 https://leetcode.cn/problems/longest-increasing-subsequence/description/\ndp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度\nif (nums[i] \u0026gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1);\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (nums.size() \u0026lt;= 1) return nums.size(); vector\u0026lt;int\u0026gt; dp(nums.size(), 1); int result = 0; for (int i = 1; i \u0026lt; nums.size(); i++) { for (int j = 0; j \u0026lt; i; j++) { if (nums[i] \u0026gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1); } if (dp[i] \u0026gt; result) result = dp[i]; // 取长的子序列 } return result; } }; 时间复杂度: O(n^2) 空间复杂度: O(n) 28.最长连续递增序列 https://leetcode.cn/problems/longest-continuous-increasing-subsequence/\ndp[i]：以下标i为结尾的连续递增的子序列长度为dp[i]。 dp[i] = dp[i - 1] + 1; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: int findLengthOfLCIS(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (nums.size() == 0) return 0; int result = 1; vector\u0026lt;int\u0026gt; dp(nums.size() ,1); for (int i = 1; i \u0026lt; nums.size(); i++) { if (nums[i] \u0026gt; nums[i - 1]) { // 连续记录 dp[i] = dp[i - 1] + 1; } if (dp[i] \u0026gt; result) result = dp[i]; } return result; } }; 时间复杂度：O(n) 空间复杂度：O(n) 29.最长重复子数组 https://leetcode.cn/problems/maximum-length-of-repeated-subarray/\ndp[i][j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]。 当A[i - 1] 和B[j - 1]相等的时候，dp[i][j] = dp[i - 1][j - 1] + 1; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 版本一 class Solution { public: int findLength(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp (nums1.size() + 1, vector\u0026lt;int\u0026gt;(nums2.size() + 1, 0)); int result = 0; for (int i = 1; i \u0026lt;= nums1.size(); i++) { for (int j = 1; j \u0026lt;= nums2.size(); j++) { if (nums1[i - 1] == nums2[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; } if (dp[i][j] \u0026gt; result) result = dp[i][j]; } } return result; } }; 时间复杂度：O(n × m)，n 为A长度，m为B长度 空间复杂度：O(n × m) 30.最长公共子序列 https://leetcode.cn/problems/longest-common-subsequence/\ndp[i][j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: int longestCommonSubsequence(string text1, string text2) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(text1.size() + 1, vector\u0026lt;int\u0026gt;(text2.size() + 1, 0)); for (int i = 1; i \u0026lt;= text1.size(); i++) { for (int j = 1; j \u0026lt;= text2.size(); j++) { if (text1[i - 1] == text2[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[text1.size()][text2.size()]; } }; 时间复杂度: O(n * m)，其中 n 和 m 分别为 text1 和 text2 的长度 空间复杂度: O(n * m) 31.最大子序和 https://leetcode.cn/problems/maximum-subarray/\ndp[i]：包括下标i（以nums[i]为结尾）的最大连续子序列和为dp[i]。\ndp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和\nnums[i]，即：从头开始计算当前连续子序列和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: int maxSubArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (nums.size() == 0) return 0; vector\u0026lt;int\u0026gt; dp(nums.size()); dp[0] = nums[0]; int result = dp[0]; for (int i = 1; i \u0026lt; nums.size(); i++) { dp[i] = max(dp[i - 1] + nums[i], nums[i]); // 状态转移公式 if (dp[i] \u0026gt; result) result = dp[i]; // result 保存dp[i]的最大值 } return result; } }; 时间复杂度：O(n) 空间复杂度：O(n) 32.判断子序列 https://leetcode.cn/problems/is-subsequence/\ndp[i][j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i][j]。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: bool isSubsequence(string s, string t) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(s.size() + 1, vector\u0026lt;int\u0026gt;(t.size() + 1, 0)); for (int i = 1; i \u0026lt;= s.size(); i++) { for (int j = 1; j \u0026lt;= t.size(); j++) { if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = dp[i][j - 1]; } } if (dp[s.size()][t.size()] == s.size()) return true; return false; } }; 时间复杂度：O(n × m) 空间复杂度：O(n × m) 33.不同的子序列 https://leetcode.cn/problems/distinct-subsequences/\ndp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int numDistinct(string s, string t) { vector\u0026lt;vector\u0026lt;uint64_t\u0026gt;\u0026gt; dp(s.size() + 1, vector\u0026lt;uint64_t\u0026gt;(t.size() + 1)); for (int i = 0; i \u0026lt; s.size(); i++) dp[i][0] = 1; for (int j = 1; j \u0026lt; t.size(); j++) dp[0][j] = 0; for (int i = 1; i \u0026lt;= s.size(); i++) { for (int j = 1; j \u0026lt;= t.size(); j++) { if (s[i - 1] == t[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; } else { dp[i][j] = dp[i - 1][j]; } } } return dp[s.size()][t.size()]; } }; 时间复杂度: O(n * m) 空间复杂度: O(n * m) 34.两个字符串的删除操作 https://leetcode.cn/problems/delete-operation-for-two-strings/\ndp[i][j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。\n当word1[i - 1] 与 word2[j - 1]相同的时候\n当word1[i - 1] 与 word2[j - 1]不相同的时候\n当word1[i - 1] 与 word2[j - 1]相同的时候，dp[i][j] = dp[i - 1][j - 1];\n当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：\n情况一：删word1[i - 1]，最少操作次数为dp[i - 1][j] + 1\n情况二：删word2[j - 1]，最少操作次数为dp[i][j - 1] + 1\n情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp[i - 1][j - 1] +2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int minDistance(string word1, string word2) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(word1.size() + 1, vector\u0026lt;int\u0026gt;(word2.size() + 1)); for (int i = 0; i \u0026lt;= word1.size(); i++) dp[i][0] = i; for (int j = 0; j \u0026lt;= word2.size(); j++) dp[0][j] = j; for (int i = 1; i \u0026lt;= word1.size(); i++) { for (int j = 1; j \u0026lt;= word2.size(); j++) { if (word1[i - 1] == word2[j - 1]) { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1); } } } return dp[word1.size()][word2.size()]; } }; 时间复杂度: O(n * m) 空间复杂度: O(n * m) 35.编辑距离 https://leetcode.cn/problems/edit-distance/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int minDistance(string word1, string word2) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(word1.size() + 1, vector\u0026lt;int\u0026gt;(word2.size() + 1, 0)); for (int i = 0; i \u0026lt;= word1.size(); i++) dp[i][0] = i; for (int j = 0; j \u0026lt;= word2.size(); j++) dp[0][j] = j; for (int i = 1; i \u0026lt;= word1.size(); i++) { for (int j = 1; j \u0026lt;= word2.size(); j++) { if (word1[i - 1] == word2[j - 1]) { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1; } } } return dp[word1.size()][word2.size()]; } }; 时间复杂度: O(n * m) 空间复杂度: O(n * m) 36.回文子串 https://leetcode.cn/problems/palindromic-substrings/description/\n布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。 当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false。\n当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况\n情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串 情况二：下标i 与 j相差为1，例如aa，也是回文子串 情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int countSubstrings(string s) { vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; dp(s.size(), vector\u0026lt;bool\u0026gt;(s.size(), false)); int result = 0; for (int i = s.size() - 1; i \u0026gt;= 0; i--) { // 注意遍历顺序 for (int j = i; j \u0026lt; s.size(); j++) { if (s[i] == s[j]) { if (j - i \u0026lt;= 1) { // 情况一 和 情况二 result++; dp[i][j] = true; } else if (dp[i + 1][j - 1]) { // 情况三 result++; dp[i][j] = true; } } } } return result; } }; 时间复杂度：O(n^2) 空间复杂度：O(n^2) 37.最长回文子序列 https://leetcode.cn/problems/longest-palindromic-subsequence/\ndp[i][j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i][j]。\n如果s[i]与s[j]相同，那么dp[i][j] = dp[i + 1][j - 1] + 2;\n如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子序列的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。\n加入s[j]的回文子序列长度为dp[i + 1][j]。\n加入s[i]的回文子序列长度为dp[i][j - 1]。\n那么dp[i][j]一定是取最大的，即：dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int longestPalindromeSubseq(string s) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(s.size(), vector\u0026lt;int\u0026gt;(s.size(), 0)); for (int i = 0; i \u0026lt; s.size(); i++) dp[i][i] = 1; for (int i = s.size() - 1; i \u0026gt;= 0; i--) { for (int j = i + 1; j \u0026lt; s.size(); j++) { if (s[i] == s[j]) { dp[i][j] = dp[i + 1][j - 1] + 2; } else { dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); } } } return dp[0][s.size() - 1]; } }; 时间复杂度: O(n^2) 空间复杂度: O(n^2) 十、单调栈 1.每日温度 https://leetcode.cn/problems/daily-temperatures/description/\n递增单调栈\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 版本一 class Solution { public: vector\u0026lt;int\u0026gt; dailyTemperatures(vector\u0026lt;int\u0026gt;\u0026amp; T) { // 递增栈 stack\u0026lt;int\u0026gt; st; vector\u0026lt;int\u0026gt; result(T.size(), 0); st.push(0); for (int i = 1; i \u0026lt; T.size(); i++) { if (T[i] \u0026lt; T[st.top()]) { // 情况一 st.push(i); } else if (T[i] == T[st.top()]) { // 情况二 st.push(i); } else { while (!st.empty() \u0026amp;\u0026amp; T[i] \u0026gt; T[st.top()]) { // 情况三 result[st.top()] = i - st.top(); st.pop(); } st.push(i); } } return result; } }; 2.接雨水 https://leetcode.cn/problems/trapping-rain-water/description/\n双指针\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: int trap(vector\u0026lt;int\u0026gt;\u0026amp; height) { if (height.size() \u0026lt;= 2) return 0; vector\u0026lt;int\u0026gt; maxLeft(height.size(), 0); vector\u0026lt;int\u0026gt; maxRight(height.size(), 0); int size = maxRight.size(); // 记录每个柱子左边柱子最大高度 maxLeft[0] = height[0]; for (int i = 1; i \u0026lt; size; i++) { maxLeft[i] = max(height[i], maxLeft[i - 1]); } // 记录每个柱子右边柱子最大高度 maxRight[size - 1] = height[size - 1]; for (int i = size - 2; i \u0026gt;= 0; i--) { maxRight[i] = max(height[i], maxRight[i + 1]); } // 求和 int sum = 0; for (int i = 0; i \u0026lt; size; i++) { int count = min(maxLeft[i], maxRight[i]) - height[i]; if (count \u0026gt; 0) sum += count; } return sum; } }; 单调栈\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: int trap(vector\u0026lt;int\u0026gt;\u0026amp; height) { if (height.size() \u0026lt;= 2) return 0; // 可以不加 stack\u0026lt;int\u0026gt; st; // 存着下标，计算的时候用下标对应的柱子高度 st.push(0); int sum = 0; for (int i = 1; i \u0026lt; height.size(); i++) { if (height[i] \u0026lt; height[st.top()]) { // 情况一 st.push(i); } if (height[i] == height[st.top()]) { // 情况二 st.pop(); // 其实这一句可以不加，效果是一样的，但处理相同的情况的思路却变了。 st.push(i); } else { // 情况三 while (!st.empty() \u0026amp;\u0026amp; height[i] \u0026gt; height[st.top()]) { // 注意这里是while int mid = st.top(); st.pop(); if (!st.empty()) { int h = min(height[st.top()], height[i]) - height[mid]; int w = i - st.top() - 1; // 注意减一，只求中间宽度 sum += h * w; } } st.push(i); } } return sum; } }; 十一、图论 1.深度优先搜索dfs理论基础 dfs的代码框架：\n1 2 3 4 5 6 7 8 9 10 11 12 void dfs(参数) { if (终止条件) { 存放结果; return; } for (选择：本节点所连接的其他节点) { 处理节点; dfs(图，选择的节点); // 递归 回溯，撤销处理结果 } } 2.所有可能的路径 https://leetcode.cn/problems/all-paths-from-source-to-target/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { private: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; // 收集符合条件的路径 vector\u0026lt;int\u0026gt; path; // 0节点到终点的路径 // x：目前遍历的节点 // graph：存当前的图 void dfs (vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; graph, int x) { // 要求从节点 0 到节点 n-1 的路径并输出，所以是 graph.size() - 1 if (x == graph.size() - 1) { // 找到符合条件的一条路径 result.push_back(path); return; } for (int i = 0; i \u0026lt; graph[x].size(); i++) { // 遍历节点n链接的所有节点 path.push_back(graph[x][i]); // 遍历到的节点加入到路径中来 dfs(graph, graph[x][i]); // 进入下一层递归 path.pop_back(); // 回溯，撤销本节点 } } public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; allPathsSourceTarget(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; graph) { path.push_back(0); // 无论什么路径已经是从0节点出发 dfs(graph, 0); // 开始遍历 return result; } }; 3.广度优先搜索bfs理论基础 广搜的搜索方式就适合于解决两个点之间的最短路径问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 表示四个方向 // grid 是地图，也就是一个二维数组 // visited标记访问过的节点，不要重复访问 // x,y 表示开始搜索节点的下标 void bfs(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid, vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;\u0026amp; visited, int x, int y) { queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; que; // 定义队列 que.push({x, y}); // 起始节点加入队列 visited[x][y] = true; // 只要加入队列，立刻标记为访问过的节点 while(!que.empty()) { // 开始遍历队列里的元素 pair\u0026lt;int ,int\u0026gt; cur = que.front(); que.pop(); // 从队列取元素 int curx = cur.first; int cury = cur.second; // 当前节点坐标 for (int i = 0; i \u0026lt; 4; i++) { // 开始想当前节点的四个方向左右上下去遍历 int nextx = curx + dir[i][0]; int nexty = cury + dir[i][1]; // 获取周边四个方向的坐标 if (nextx \u0026lt; 0 || nextx \u0026gt;= grid.size() || nexty \u0026lt; 0 || nexty \u0026gt;= grid[0].size()) continue; // 坐标越界了，直接跳过 if (!visited[nextx][nexty]) { // 如果节点没被访问过 que.push({nextx, nexty}); // 队列添加该节点为下一轮要遍历的节点 visited[nextx][nexty] = true; // 只要加入队列立刻标记，避免重复访问 } } } } 4.岛屿数量dfs https://leetcode.cn/problems/number-of-islands/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { private: int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向 void dfs(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid, vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;\u0026amp; visited, int x, int y) { if (visited[x][y] || grid[x][y] == \u0026#39;0\u0026#39;) return; // 终止条件：访问过的节点 或者 遇到海水 visited[x][y] = true; // 标记访问过 for (int i = 0; i \u0026lt; 4; i++) { int nextx = x + dir[i][0]; int nexty = y + dir[i][1]; if (nextx \u0026lt; 0 || nextx \u0026gt;= grid.size() || nexty \u0026lt; 0 || nexty \u0026gt;= grid[0].size()) continue; // 越界了，直接跳过 dfs(grid, visited, nextx, nexty); } } public: int numIslands(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { int n = grid.size(), m = grid[0].size(); vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited = vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;(n, vector\u0026lt;bool\u0026gt;(m, false)); int result = 0; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { if (!visited[i][j] \u0026amp;\u0026amp; grid[i][j] == \u0026#39;1\u0026#39;) { result++; // 遇到没访问过的陆地，+1 dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true } } } return result; } }; 5.岛屿数量bfs https://leetcode.cn/problems/number-of-islands/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { private: int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向 void bfs(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid, vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;\u0026amp; visited, int x, int y) { queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; que; que.push({x, y}); visited[x][y] = true; // 只要加入队列，立刻标记 while(!que.empty()) { pair\u0026lt;int ,int\u0026gt; cur = que.front(); que.pop(); int curx = cur.first; int cury = cur.second; for (int i = 0; i \u0026lt; 4; i++) { int nextx = curx + dir[i][0]; int nexty = cury + dir[i][1]; if (nextx \u0026lt; 0 || nextx \u0026gt;= grid.size() || nexty \u0026lt; 0 || nexty \u0026gt;= grid[0].size()) continue; // 越界了，直接跳过 if (!visited[nextx][nexty] \u0026amp;\u0026amp; grid[nextx][nexty] == \u0026#39;1\u0026#39;) { que.push({nextx, nexty}); visited[nextx][nexty] = true; // 只要加入队列立刻标记 } } } } public: int numIslands(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { int n = grid.size(), m = grid[0].size(); vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited = vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;(n, vector\u0026lt;bool\u0026gt;(m, false)); int result = 0; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { if (!visited[i][j] \u0026amp;\u0026amp; grid[i][j] == \u0026#39;1\u0026#39;) { result++; // 遇到没访问过的陆地，+1 bfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true } } } return result; } }; 十一、线段树 Hot 100 一、哈希 1.字母异位词分组 https://leetcode.cn/problems/group-anagrams/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; groupAnagrams(vector\u0026lt;string\u0026gt;\u0026amp; strs) { unordered_map\u0026lt;string,vector\u0026lt;string\u0026gt;\u0026gt; mp; for (string\u0026amp; str:strs) { string tmp = str; sort(tmp.begin(),tmp.end()); mp[tmp].push_back(str); } vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; result; for (auto it = mp.begin();it!=mp.end();++it) { result.push_back(it-\u0026gt;second); } return result; } }; 2.最长连续序列 https://leetcode.cn/problems/longest-consecutive-sequence\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: int longestConsecutive(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (nums.size() \u0026lt;= 1) return nums.size(); unordered_set\u0026lt;int\u0026gt; uset; int result = 0; for (int i = 0; i \u0026lt;nums.size();i++) { uset.insert(nums[i]); } for (const auto\u0026amp; item : uset ) { if (!uset.count(item - 1)) { int a = item; int length = 1; while (uset.find(++a) != uset.end()) { length++; } result = result \u0026gt; length ? result : length; } } return result; } }; 二、双指针 1.移动0 https://leetcode.cn/problems/move-zeroes/description/\n1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: void moveZeroes(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int left = 0; for (int right=0;right\u0026lt;nums.size();right++) { if (nums[right] != 0 \u0026amp;\u0026amp; nums[left] == 0) swap(nums[right],nums[left++]); if (nums[left] != 0) left++; } return; } }; 2.盛最多水的容器 https://leetcode.cn/problems/container-with-most-water/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int result = 0, curArea = 0; for (int i = 0, j = height.size() - 1; i\u0026lt;j ;) { curArea = min(height[j],height[i]) * (j - i); result = max(result,curArea); if (height[i] \u0026lt;= height[j]) i++; else j--; } return result; } }; 3.接雨水 https://leetcode.cn/problems/trapping-rain-water/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: int trap(vector\u0026lt;int\u0026gt;\u0026amp; height) { int size = height.size(); if (size \u0026lt;= 2) return 0; int result = 0; vector\u0026lt;int\u0026gt; maxLeft(size,0); vector\u0026lt;int\u0026gt; maxRight(size,0); maxLeft[0] = height[0]; for(int i = 1;i\u0026lt;size;i++) { maxLeft[i] = max(height[i],maxLeft[i-1]); } maxRight[size-1] = height[size-1]; for(int i = size-2;i\u0026gt;=0;i--) { maxRight[i] = max(height[i],maxRight[i+1]); } for(int i = 1;i\u0026lt;size;i++) { result += min(maxLeft[i],maxRight[i]) - height[i]; } return result; } }; 三、滑动窗 1.无重复字符的最长子串 https://leetcode.cn/problems/longest-substring-without-repeating-characters/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int lengthOfLongestSubstring(string s) { if (s.size() \u0026lt;= 1) return s.size(); unordered_set\u0026lt;char\u0026gt; uset; int result=0; int rightIndex = 0; for(int i=0;i\u0026lt;s.size();i++) { if (i!=0) uset.erase(s[i-1]); //左指针增加，移除上一个元素 while (rightIndex \u0026lt; s.size() \u0026amp;\u0026amp; !uset.count(s[rightIndex])) { uset.insert(s[rightIndex]); rightIndex++; } result = max(result,rightIndex-i); //循环结束前右指针多加了1 } return result; } }; 2.找到字符串中所有字母异位词 https://leetcode.cn/problems/find-all-anagrams-in-a-string/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: vector\u0026lt;int\u0026gt; findAnagrams(string s, string p) { int sLen = s.size(), pLen = p.size(); if (sLen \u0026lt; pLen) { return vector\u0026lt;int\u0026gt;(); } vector\u0026lt;int\u0026gt; result; vector\u0026lt;int\u0026gt; sCount(26); vector\u0026lt;int\u0026gt; pCount(26); for (int i = 0; i \u0026lt; pLen; i++) { sCount[s[i] - \u0026#39;a\u0026#39;]++; pCount[p[i]-\u0026#39;a\u0026#39;]++; } if (sCount == pCount) result.push_back(0); //vector的比较方法，为一一比较 for (auto s:result) cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#39; \u0026#39;; for (int i = 0; i \u0026lt; sLen - pLen; i++) { sCount[s[i]-\u0026#39;a\u0026#39;]--; sCount[s[i + pLen]-\u0026#39;a\u0026#39;]++; if (sCount == pCount) result.push_back(i+1); } return result; } }; 3.和为 K 的子数组 https://leetcode.cn/problems/subarray-sum-equals-k/\n前缀和 + 哈希表优化\npre[i]:[0，i]的和；\n[i,j]区间的和为k：pre[j]-pre[i-1] == k\n转化为：pre[i-1] = pre[j]-k\n建哈希map查找\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: int subarraySum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { unordered_map\u0026lt;int, int\u0026gt; mp; //key:[0-i]的和，val:次数 mp[0] = 1; int count = 0, pre = 0; for (auto\u0026amp; x:nums) { pre += x; if (mp.find(pre - k) != mp.end()) count += mp[pre - k]; mp[pre]++; } return count; } }; 四、普通数组 1.轮转数组 https://leetcode.cn/problems/rotate-array/\n方法一：拷贝数组 方法二：翻转数组\n1 2 3 4 5 6 7 8 9 class Solution { public: void rotate(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { k %= nums.size(); reverse(nums.begin(),nums.end()); reverse(nums.begin(),nums.begin() + k); reverse(nums.begin() + k,nums.end()); } }; 2.除自身以外数组的乘积 https://leetcode.cn/problems/product-of-array-except-self\n左右乘积列表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: vector\u0026lt;int\u0026gt; productExceptSelf(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int size = nums.size(); vector\u0026lt;int\u0026gt; L(nums.size(),0); vector\u0026lt;int\u0026gt; R(nums.size(),0); vector\u0026lt;int\u0026gt; result(nums.size(),0); L[0] = 1; for (int i = 1; i\u0026lt;nums.size(); ++i) { L[i] = nums[i-1] * L[i-1]; } R[size - 1] = 1; for (int i = size - 2; i\u0026gt;=0; --i) { R[i] = nums[i+1] * R[i+1]; } for (int i = 0; i\u0026lt;nums.size(); ++i) { result[i] = L[i] * R[i]; } return result; } }; 3.缺失的第一个正数 https://leetcode.cn/problems/first-missing-positive/\n原地哈希\n数值为1的放在0，数值为2的放在1。即数值为i+1的放在索引为i的位置，进行交换。\n再遍历一遍位置错误的就是他\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int firstMissingPositive(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for (int i = 0; i \u0026lt; nums.size(); i++) { while (nums[i] != i + 1) { if (nums[i] \u0026lt;= 0 || nums[i] \u0026gt; nums.size() || nums[i] == nums[nums[i] - 1]) break; // 将nums[i] 放置到对应位置上[1,2,3...] int idx = nums[i] - 1; nums[i] = nums[idx]; nums[idx] = idx + 1; } } for (int i = 0; i \u0026lt; nums.size(); i++) { if (nums[i] != (i + 1)) { return (i + 1); } } return (nums.size() + 1); } }; 面试热题 2.二叉树的直径 https://leetcode.cn/problems/diameter-of-binary-tree/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int ans = 0; int depth(TreeNode* root) { if (root == nullptr) return 0; int L = depth(root-\u0026gt;left); int R = depth(root-\u0026gt;right); ans = max(ans, L+R); return max(L,R)+1; } int diameterOfBinaryTree(TreeNode* root) { ans=0; depth(root); return ans; } }; 3.合并两个有序数组 https://leetcode.cn/problems/merge-sorted-array/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: void merge(vector\u0026lt;int\u0026gt;\u0026amp; nums1, int m, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int n) { int i = nums1.size()-1; m--; n--; while(n\u0026gt;=0) //还有需要合并的元素 { while (m \u0026gt;= 0 \u0026amp;\u0026amp; nums1[m] \u0026gt; nums2[n]) { nums1[i--] = nums1[m--]; } nums1[i--] = nums2[n--]; } } }; ","date":"2023-01-01T00:00:00Z","permalink":"https://raff-zeng.github.io/post/reading-notes/notes-at-school/codealgorithm/","title":"代码随想录 算法"},{"content":"控制算法面试 1.PID算法原理，如何调PID 算法原理 由比例单元、积分单元、微分单元组成。适用于基本上线性，且动态特性不是时变的系统。\n${\\mathrm {u}}(t)={\\mathrm {MV}}(t)=K_{p}{e(t)}+K_{{i}}\\int {{0}}^{{t}}{e(\\tau )},{d\\tau }+K{{d}}{\\frac {d}{dt}}e(t)$\n比例控制考虑当前误差，误差值乘正常数$K_p$。\n$K_p$大，在相同误差量下，会有较大的输出，但若$K_p$太大，会使系统不稳定。相反的，若$K_p$小，若在相同误差量下，其输出较小，因此控制器会较不敏感的。若$K_p$太小，当有干扰出现时，其控制信号可能不够大，无法修正干扰的影响。\n积分控制考虑过去累计误差，误差值的积分乘正常数$K_i$.\n积分控制会加速系统趋近设定值的过程，并且消除纯比例控制器会出现的稳态误差。$K_i$越大，趋近设定值的速度越快。\n因为积分控制会累计过去所有的误差，可能会出现过冲的情形，需要设定积分饱和，防止在刚开始时，就把积分量积得太大，难以控制。\n微分控制考虑将来误差，误差的一阶导数乘正常数$K_d$。\nD的作用就是让物理量的速度趋于0，只要什么时候，这个量具有了速度，D就向相反的方向用力，尽力刹住这个变化。Kd参数越大，向速度相反方向刹车的力道就越强。\nKd参数对减少控制器短期的改变很有帮助。一些实际中的速度缓慢的系统可以不需要Kd参数。可以提升整定时间及系统稳定性。因为纯微分器不是因果系统，在PID系统实现时，一般会为微分控制加上一个低通滤波器以限制高频增益及噪声.\n不过使用PID控制器不一定保证可达到系统的最佳控制，也不保证系统稳定性。\n调参 通过调整控制参数（比例增益、积分增益/时间、微分增益/时间）让系统达到最佳的控制效果。PID参数调试方式人工调试、齐格勒－尼科尔斯方法。\n若有多个（且互相冲突）的目标（例如高稳定性及快速的暂态时间）都要达到的话，在实际上很难完成。\n调整方式 上升时间 超调量 响应时间 稳态误差 稳定性 $K_p$$\\uparrow$ 减小$\\downarrow$ 增加$\\uparrow$ 小幅增加$\\uparrow$ 减小$\\downarrow$ 变差$\\downarrow$ $K_i$$\\uparrow$ 小幅减小$\\downarrow$ 增加$\\uparrow$ 增加$\\uparrow$ 大幅减小$\\downarrow$ 变差$\\downarrow$ $K_d$$\\uparrow$ 小幅减小$\\downarrow$ 减小$\\downarrow$ 减小$\\downarrow$ 变动不大 变好$\\uparrow$ 齐格勒－尼科尔斯方法是另一种启发式的调试方式，一开始将$K_i$$K_d$设定为0，增加$K_p$直到系统出现等幅振荡，记下增益和振荡周期，按图表方法计算增益。\n高频振荡和低频振荡怎么调 高频振荡，意味着有一个过大的D值放大了噪声，这时应适当的减小D值。如果你的系统有较大的噪声，最好保持D值为0值。\n中频振荡可能就是比例的问题\n2.稳定裕度 幅值裕度是相位为-180度对应的伯德图的幅值距离0dB线的幅值差，是可正可负的。\n相位裕度当频率特性幅值满足 $|KG(j\\omega)|=1$ 时相位超前-180的角度。对于一个稳定系统而言它总应该大于0度。是可正可负的。\n相位裕度增大，会导致系统阻尼增大，从而使得系统的调节时间延长。\nGM\u0026gt;0dB，PM\u0026gt;0度，则闭环系统是稳定的。此结论只适用于Nyquist Plot的半闭合曲线只与单位圆和负半实轴相交一次，且系统开环是稳定的，为最小相位系统。\n稳定裕度越小，闭环系统越接近于临界稳定，响应曲线容易产生超调和震荡、调整时间长，响应性能指标也不满足要求。\n3.带宽 带宽高。响应好，噪声大\n带宽大的系统响应速度会快，对高频的正常激励信号有响应，也会带来很多副作用，会对噪声敏感。带宽低，对高频噪声的放大系数很低。\n高带宽系统需要更高速度的传感器和控制器，一般控制器和传感器的速度应该是被控对象的5-20倍。是硬件成本高，对数值计算的精度也更高，对于延迟的忍耐度也更低。\n4.LQR 线性二次调节器 线性二次（LQ）问题:系统动态可以用一组线性微分方程表示，成本为二次泛函\n成本函数一般会定义为状态量和理想值的偏差的和。控制量的大小也会包括在成本函数中。LQR难点在找合适的加权因子。\n令代价函数最小化。给出QR，根据黎卡积方程算出K，得到控制输入u。\nMPC 模型预测控制 模型预测控制的特点是每一次针对目前的时间区块内作最佳化，然后下一个时间再针对时间区块内作最佳化，模型预测控制可以预测未来事件并且进行对应的处理。模型预测控制几乎都是用数位控制来实现，\n利用对象的动态模型、过去的控制量、针对滚动预测域的最小化代价函数$J$来计算最佳化的控制讯号\n$\\displaystyle J=\\sum {i=1}^{N}w{x_{i}}(r_{i}-x_{i})^{2}+\\sum {i=1}^{N}w{u_{i}}{\\Delta u_{i}}^{2}$\n模型预测控制器和LQR控制器的主要差异是LQR控制器针对整个时间区间进行最佳化，而模型预测控制器针对不同的时间区间分别进行最佳化，因此在不同时间区间内，模型预测控制器可能会产生新的解，而LQR控制器会使用针对所有时间区间下的最佳解。因此模型预测控制器可以在存在硬约束的情形下进行实时的最佳化，不过多半是在较小的时间区域中求解最佳化问题，而不是在整个时间区域内求解，因此有时只能徥到次佳的解。\nSMC 用不连续的控制信号来调整非线性系统的特性，强迫系统在二个系统的正常状态之间滑动，最后进入稳态。\n滑动模式控制中存在滑动曲面$s=0$，一开始时，系统会在有限时间内到达滑动曲面，之后就会沿着滑动曲面移动。\n实际系统的实现是用高频切换来让系统近似在滑动曲面上滑动，高频切换的控制信号让系统在很邻近滑动曲面的范围内切跳（chatter），而且其频率是不固定的。\nADRC 自抗扰控制，吸收工程中PID控制，并独立于复杂数学模型提出了一种应对非线性，不确定性和扰动的控制方法。自抗扰控制继承了传统PID控制的优势：误差反馈控制，并且改进了PID控制中的缺点：误差提取法和加权误差。\n自抗扰控制器主要由三部分组成：跟踪微分器(Tracking differentiator)，扩展状态观测器 (Extended state observer) 和非线性组合PID(Nonlinear PID)。\n跟踪微分器解决了快速性和超调之间的矛盾关系，并且提高了调节器应对噪声污染的能力，增强鲁棒性。\n普通状态观测器只观测系统状态，扩展状态观测器还估计外部扰动和未知模型的系统状态。所以此项技术不过于依赖数学模型。\n非线性状态误差反馈控制律\n卡尔曼滤波 高效率的递归滤波器（自回归滤波器），它能够从一系列的不完全及包含噪声的测量中，估计动态系统的状态。卡尔曼滤波会根据各测量量在不同时间下的值，考虑各时间下的联合分布，再产生对未知变数的估计，因此会比只以单一测量量为基础的估计方式要准。\n卡尔曼滤波是一种递归的估计，即只要获知上一时刻状态的估计值以及当前状态的观测值就可以计算出当前状态的估计值，因此不需要记录观测或者估计的历史信息。卡尔曼滤波器与大多数滤波器不同之处，在于它是一种纯粹的时域滤波器，它不需要像低通滤波器等频域滤波器那样，需要在频域设计再转换到时域实现。\n观测器 状态观测器（英语：State observer）是控制理论中配合受控体的系统，在已知受控体架构的情形下，可以根据受控体的输入及输出而估测其内部的状态\n相位裕度\n伯德图\n时域频域稳定性判据\n","date":"2023-01-01T00:00:00Z","permalink":"https://raff-zeng.github.io/post/reading-notes/notes-at-school/controlinterview/","title":"控制算法面试"},{"content":"C 八股 1、关键字register （1）作用：编译器会将register修饰的变量尽可能地放在CPU的寄存器中，以加快其存取速度，一般用于频繁使用的变量。\nregister变量可能不存放在内存中，所以不能用\u0026amp;来获取该变量的地址； 只有局部变量和形参可以作为register变量； 寄存器数量有限，不能定义过多register变量。 2、volatile和extern分别在哪个阶段起作用？ **答案：**volatile在编译阶段，extern在链接阶段。\n4、用变量a给出下面的定义 （1）一个有10个整型数的数组 ：int a[10]。 （2）一个有10个指针的数组，这10个指针是指向整型数的（指针数组）： int *a[10]。 （3）一个指向有10个整型数数组的指针（数组指针）：int (*a)[10]。 （4）一个指向函数的指针，该函数有一个整型参数并返回一个整型数（函数指针）：int (*a)(int)。 （5）一个有10个指针的数组，这10个指针均指向函数，该函数有一个整型参数并返回一 个整型数（函数指针数组）： int (*a[10])(int)。\n5、下面的代码输出是什么，为什么？ 1 2 3 4 5 6 void foo(void) { unsigned int a = 6; int b = -20; (a + b \u0026gt; 6)? printf(\u0026#34;\u0026gt; 6\u0026#34;) : printf(\u0026#34; \u0026lt;= 6\u0026#34;); } **答案：**输出是 “\u0026gt;6”。\n**解读：**当运算表达式中存在有符号数和无符号数时，有符号数隐式转换成了无符号数（即底层的补码不变，但是此数从有符号数变成了无符号数）。注意，正数的补码为其本身，负数的补码为其反码+1。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果 ”\u0026gt;6”。\n6、写出float x与“零值”比较的if语句。 1 if(x \u0026gt; -0.000001 \u0026amp;\u0026amp; x \u0026lt; 0.000001); 因为计算机在处理浮点数的时候是有误差的，所以不能将浮点型变量用“==”或“！=”与数字比较，应该设法转化成“\u0026gt;”或“\u0026lt;”此类形式。\n8、结构体内存对齐的原因？ （1）平台原因：不是所有的硬件平台都能访问任意地址上的任意数据。\n（2）性能原因：数据结构应该尽可能地在自然边界上对齐，因为访问未对齐的内存，处理器需要做两次内存访问，而访问对齐的内存仅需要一次。\n9、结构体struct和联合体union的区别？ 结构体各成员拥有自己的内存，互不干涉，遵循内存对齐原则。 联合体所有成员共用一块内存空间，同时只有一个成员可以得到这块内存的使用权。一个联合体变量的总长度应至少能容纳最大的成员变量，且需要进行内存补齐。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;stdio.h\u0026gt; union Un1 { char c[5];//1个char类型占1字节，5个占5字节 int i;//4字节 }; union Un2 { short c[7];//1个short类型占2字节，7个占14字节 int i;//4字节 }; int main() { printf(\u0026#34;%d\\n\u0026#34;, sizeof(union Un1));//打印8 printf(\u0026#34;%d\\n\u0026#34;, sizeof(union Un2));//打印16 } 10、gcc编译过程 从.c到可执行文件 gcc 是 GNU Compiler Collection 的缩写，是一种广泛使用的 C/C++ 编译器。gcc 的编译过程一般包括以下几个步骤，从 .c 文件到可执行文件：\n预处理：头文件、宏展开；条件编译保留或移除；去除注释。结果以 .i 扩展名命名。\n编译：将预处理后的源代码转换为汇编代码。词法分析；语法分析；语义分析；代码生成。编译后的汇编代码以 .s 扩展名命名。\n汇编：将汇编代码转换为机器代码。词法分析；语法分析；代码生成。汇编后的机器代码以 .o 扩展名命名。\n链接：目标文件和其他库文件链接在一起，生成可执行文件。符号解析；重定位；可执行文件生成。最终生成的可执行文件保存在当前目录下，可以直接运行。\n需要注意的是，gcc 的编译过程可以通过命令行参数控制编译过程的细节，包括指定输出文件名、优化选项、调试信息等。常用的 gcc 命令行参数包括：\n-c：仅编译，不链接，生成目标文件； -o：指定输出文件名； -Wall：打开所有警告； -Werror：将所有警告视为错误； -g：生成调试信息； -O0/-O1/-O2/-O3：控制优化级别； -I：指定头文件搜索路径； -L：指定库文件搜索路径； -l：指定需要链接的库文件。 C++ 八股 一、基本语法 1、常量指针与指针常量 指针常量（底层const指针所指的对象是个常量） 指向的对象的值不可变\nconst 数据类型 *指针变量 = 变量名 数据类型 const *指针变量 = 变量名\n常量指针（顶层const指针本身是个常量） 指向的内存地址不可变\n数据类型 * const 指针变量=变量名\n若要修改const修饰的变量的值，需要加上关键字volatile；\n若想要修改const成员函数中某些与类状态⽆关的数据成员，可以使用mutable关键字来修饰这个数据成员\n2、define、typedef、函数 define\n宏定义在编译的预处理阶段被处理，属于文本插入替换，用于定义常量和书写复杂的内容。\n只是简单的字符替换，没有类型检查，不安全。 宏替换不占运行时间，只占编译时间 带参宏在处理时不分配内存 宏不存在类型问题，宏名无类型，它的参数也是无类型的；而函数中的实参和形参都要定义类型，二者的类型要求一致。 使用宏定义次数多时，宏替换后源程序会变长 可以用来防止头文件重复引用 不需要在最后加分号 typedef\n有对应的数据类型，是要进行判断的 是在编译、运行时候起作用 在静态存储区中分配空间，在程序运行过程中内存中只有⼀个拷贝 函数\n函数在运行时进行调用和返回 函数调用则占运行时间（分配单元、保留现场、值传递、返回） 函数调用会分配临时内存 函数中的实参和形参都要定义类型，二者的类型要求一致 函数调用不使源程序变长 宏展开中的问题\n宏展开错误主要是由于运算符优先级等原因，使得宏展开后的语义与预想发生偏差。\n在宏定义中，最好将参数加上括号。在替换时保证括号内的表达式优先运算。 利用括号将整个宏定义的内容括起来。保证整个宏定义中的表达式优先运算。 尽量不要使用++x这类表达式作为内联函数参数，由于同一个参数在宏展开时进行了两次替换，程序结果与预期不符。 3、重写override 和 重载overload 1、override是子类中存在重新定义的函数。\n以实现不同的功能，用于子类在继承父类时，重写父类方法\n规则：\n函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同。 调用过程中根据对象的类型，调用相应类中的函数。 重写的基类中被重写的函数必须有virtual修饰。 静态方法不能被重写为非静态的方法 重写方法的访问修饰符⼀定要⼤于被重写方法的访问修饰符 （public\u0026gt;protected\u0026gt;default\u0026gt;private） 2、overload是重载，这些方法的名称相同而参数形式不同\n重载函数：同一作用域内的函数名字相同但形参列表不同（数量或者类型不同）\n规则：\n不同的参数类型可以是不同的参数类型，不同的参数个数，不同的参数顺序（参数类型必须不⼀样） 不能通过访问权限、返回类型、抛出的异常进行重载 方法的异常类型和数目不会对重载造成影响 使用多态是为了避免在父类里⼤量重载引起代码臃肿且难于维护。\n重写与重载的本质区别是,加⼊了override的修饰符的方法,此方法始终只有⼀个被你使用的方法。\ntips：\n顶层const不能重载，底层可以。参数本身是不是const对函数重载没有影响。 C++在编译过程中对函数重命名的规则保证了重载函数在重命名后函数名的唯一性。C语言在编译过程中不会对函数重命名。 4、const和constexpr const 表示“只读”的语义，constexpr 表示“常量”的语义\nconstexpr 只能定义编译期常量，而 const 可以定义编译期常量，也可以定义运行期常量。\nconstexpr的好处\n为⼀些不能修改数据提供保障，写成变量则就有被意外修改的风险。 有些场景，编译器可以在编译期对constexpr的代码进行优化，提⾼效率。 相比宏来说，没有额外的开销，但更安全可靠。 5、前置++和后置++ 1 2 3 4 5 const self operator++(int) { self tmp = *this; ++*this; return tmp; } 后置返回对象，而不是引用\n为什么后置前⾯也要加const 其实也可以不加，但是为了防止使用i++++,连续两次的调用后置++重载符\n原因： 它与内置类型行为不⼀致；你⽆法活得你所期望的结果，因为第⼀次返回的是旧值，而不是原对象，你调用两次后置++，结果只累加了⼀次，所以我们必须⼿动禁⽌其合法化，就要在前⾯加上const。\n处理用户的⾃定义类型 最好使用前置++，因为他不会创建临时对象，进而不会带来构造和析构而造成的格外开销\n6、运算符重载 重载运算符函数，本质还是函数调用，所以重载后\n可以是和调用运算符的方式调用，data1+data2 也可以是调用函数的方式，operator+(data1, data2)，这就要注意运算符函数的名字是“operator运算符” 不能重载：. 、 * 、 :: 、 sizeof 、 条件运算符?: 运算符重载的方式有两种：类成员函数和友元函数。\ntips：\n对单目运算符进行重载时使用类成员函数 对双目运算符进行重载时使用友元函数 (),[]重载时必须使用类成员函数，\u0026laquo;,\u0026raquo;重载时必须使用友元函数 当重载的运算符是成员函数时，this绑定到左侧运算符对象。成员运算符函数的参数数量比运算符对象的数量少一个 7、模板全特化和偏特化 模板分为类模板与函数模板，特化分为特例化（全特化）和部分特例化（偏特化）。\n对函数模板：\n模板和特例化版本应该声明在同⼀头文件，所有同名模板的声明应放在前⾯，接着是特例化版本。 ⼀个模板被称为全特化的条件：1.必须有⼀个主模板类 2.模板类型被全部明确化。 对主版本模板类、全特化类、偏特化类的调用优先级从⾼到低进行排序是：全特化类\u0026gt;偏特化类\u0026gt;主版本模板类。\n8、浅拷贝与深拷贝 浅拷贝\n拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。\n深拷贝：\n不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。\n9、野指针和悬空指针 都是是指向无效内存区域(这里的无效指的是\u0026quot;不安全不可控\u0026quot;)的指针，访问行为将会导致未定义行为。\n野指针\n野指针，指的是没有被初始化过的指针。 为了防止出错，及时初始化或者赋值为 nullptr 悬空指针\n悬空指针，指针最初指向的内存已经被释放了的一种指针。 释放操作后立即置空。 C++智能指针的本质就是避免悬空指针的产生。 另一个说法（统称为野指针）\n指针未初始化 指针指向的变量被free或delete后没有置为NULL 指针操作超过所指向变量的生存期 10、内联函数 内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销，并且进行参数类型检查。\n作为类的成员函数时，可以访问类的所有成员，也有this指针。\n内联函数一定要在函数定义时使用inline关键字，在函数声明中使用inline是没有效果的。函数的使用者不需要知道函数是否是内联函数，inline关键字不应该出现在声明中。\n【如果在函数声明的同时给出函数定义，编译器会自动将函数识别为内联函数。不推荐使用。】\n优点：\ninline是先将内联函数编译完成⽣成了函数体直接插⼊被调⽤的地方，减少了压栈，跳转和返回的操作。没有普通函数调⽤时的额外开销； 内联函数是⼀种特殊的函数，会进行类型检查； 缺点：\n​\t会使程序的代码量增大，消耗更多内存空间\n适用场景：函数体内没有循环（执行时间短）且代码简短（占用内存空间小）\nC++中inline编译限制：\n不能存在任何形式的循环语句 不能存在过多的条件判断语句 函数体不能过于庞⼤ 内联函数声明必须在调⽤语句之前 内联函数和宏定义的区别\n都能节省频繁的函数调用产生的时间和空间的开销，提高程序执行的效率。二者都是将函数调用替换成完整的函数体 宏定义是字符串替换。内联函数是个函数，具有函数的基本性质。 宏定义展开在预处理阶段，内联函数展开在编译阶段。 内联函数作为类的成员函数时，可以访问类的所有成员，也有this指针。宏定义没有。 内联函数可以完全替代宏定义 使用内联函数需要注意代码膨胀问题，如果内联函数体非常庞大，且在程序各处都会调用该内联函数，代码展开后的内联函数内嵌到程序各处，造成程序代码体积极度增长。因此定义内联函数时要确保内联函数的函数体十分简单。 11、大小端存储 大端存储：字数据的高字节存储在低地址中\n小端存储：字数据的低字节存储在低地址中\n12、volatile、mutable和explicit关键字 (1)volatile 类型修饰符。用该关键字声明的变量表示该变量随时可能发⽣变化，与该变量有关的运算，不要进行编译优化；每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。\n**作用：**确保本条指令不会因编译器的优化而省略，且要求每次直接读值，保证对特殊地址的稳定访问\n**使用场合：**在中断服务程序和cpu相关寄存器的定义 。\n例子：\n①并行设备的硬件寄存器（如：状态寄存器）。\n②中断服务程序中共享变量和状态标志。\n③多线程中的共享变量（防止死锁）。\n（2）mutable 被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。\n（3）explicit explicit 关键字用于类内部的构造函数声明上 被explicit修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显式的方式进行类型转换。 13、异常处理 常见的异常有：\n数组下标越界 除法计算时除数为0 动态分配空间时空间不足 异常处理\n（1）try、throw和catch关键字\nC++中的异常处理机制主要使用try、throw和catch三个关键字，\n（2）函数的异常声明列表\n在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表，写法如下：\n1 int fun() throw(int,double,A,B,C){...}; 这种写法表名函数可能会抛出int,double型或者A、B、C三种类型的异常，如果throw中为空，表明不会抛出任何异常，如果没有throw则可能抛出任何异常\n（3）C++标准异常类 exception\nC++ 标准库中有一些类代表异常，这些类都是从 exception 类派生而来的。\n14、string与C语言中的 char *有什么区别 数据类型：\nstring 是C++标准库中的字符串类。它是一个类，包含了一组方法和属性。 char* 是C-style字符串，是一种基本数据类型，用于存储字符串的内存地址。 内存管理：\nstring 类自动处理内存管理。它会自动分配和释放内存，无需手动管理字符串的大小或内存释放。 char* 需要手动管理内存。你需要分配足够的内存来存储字符串，并在不再需要时手动释放内存。这容易导致内存泄漏或释放未分配的内存等问题。 可变性：\nstring 是可变的。你可以通过调用成员函数来修改字符串的内容。 char* 本身是可变的，但指向的字符串内容可能是不可变的，具体取决于如何声明和使用 char*。 字符串操作：\nstring 类提供了丰富的字符串操作函数，如拼接、查找、替换、子串提取等。 char* 需要使用标准库函数或自己编写代码来执行这些操作，操作起来更繁琐。 安全性：\nstring 对象提供了一定程度的安全性，因为它包含了长度信息，可以避免缓冲区溢出。 char* 需要特别小心，容易导致缓冲区溢出和其他内存错误。 它是如何实现的？\nstring可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2*n），然后将原字符串拷贝过去，并加上新增的内容。\n15、extern 用于跨文件引用全局变量，即在本文件中引用一个已经在其他文件中定义的全局变量。\n**定义：**声明外部变量【在函数或者文件外部定义的全局变量】\n（1）注意引用时不能初始化，如extern var，而不能是extern var = 0。\n（2）另外，函数默认是extern类型的，表明是整个程序（工程）可见的，加不加都一样。\n16、extern”C”的作用？ extern \u0026ldquo;C\u0026rdquo; 是 C++ 提供的一个关键字，主要是用于在 C++ 中调用 C 语言函数。在 C++ 中，函数名的重载、命名空间等特性会使得 C++ 编译器对函数名的处理与 C 语言不同，导致在 C++ 中调用 C 函数时出现编译错误。\n使用 extern \u0026ldquo;C\u0026rdquo; 可以解决这个问题，它告诉编译器这个函数应该按照 C 语言的规则来编译和链接，从而可以正确地调用 C 函数。同时，extern \u0026ldquo;C\u0026rdquo; 也可以用于解决 C++ 代码中的函数重载问题。\n（1）在C++代码中调用C函数，用法：extern “C”{C函数库头文件/函数声明}。\n（2）在C代码中调用C++函数，用法：在C++的头文件中加extern“C”{头文件/函数声明}。\ntips：\nextern “C”只能用于C++文件中。 17、指针和引用的区别 指针是变量的地址，引用是变量的别名 指针可以不初始化，引用必须初始化绑定到一个变量中 指针变量可以指向NULL，引用不能为NULL 指针在初始化后可以更改指向，引用初始化后就不能够更改了 指针可以由多级，引用只能够有一级 左值和右值\n在赋值语句中，只能出现在等号右边的是右值。既能出现在等号左边又能出现在等号右边的是左值\n18、static 静态局部变量\n改变了其存储位置，存储在静态区； 局部静态变量的生命周期从其第一次初始化开始，直到程序结束。它在函数内部的作用域之外也是可见的，但只能在函数内部访问。 静态全局变量\n全局静态变量的生命周期从程序开始时初始化开始，直到程序结束。\n作用域在文件内部。\n普通全局变量的作用域是整个工程。在头文件声明中使用extern声明普通全局变量，其他文件使用#include包含该文件，就可以在当前文件中使用普通全局变量。\n通常情况下，静态全局变量的声明和定义放在源文件中。如果在头文件中声明静态全局变量，静态全局变量在声明的同时会被初始化。\n如果多个源文件包含了定义了某个静态全局变量的头文件，该静态全局变量在各个源文件中都有一份单独的拷贝。\n静态成员变量\n静态成员变量属于整个类，不属于某个对象，只有唯一的一份拷贝，所有对象共享类中的静态数据成员。 必须在类内声明，在类外部初始化。 静态成员函数\n没有this指针 无法访问类对象的非static成员变量和非static成员函数 静态函数的作用域限定在其所属的类命名空间内。 不依赖于类。 不能被声明为const、虚函数和volatile 19、关键字auto的作用是什么？ 用来定义自动局部变量，自动局部变量在进入声明该变量的语句块时被建立，退出语句块时被注销，仅在语句块内部使用。\n20、结构体数据对齐 成员在内存中的起始地址编码必须是成员类型所占字节数的整数倍。 结构体占用的空间是结构体中占用空间最多的成员所占空间的整数倍 分配内存的顺序是按照声明的顺序 添加了#pragma pack(n)后规则就变成：\n1、 偏移量要是n和当前变量大小中较小值的整数倍\n2、 整体大小要是n和最大变量大小中较小值的整数倍\n3、 n值必须为1,2,4,8…，为其他值时就按照默认的分配规则\nLambda表达式 Lambda表达式是C++11中引入的一种匿名函数定义方式，它可以用于创建临时函数对象，不需要显式定义函数名称。\n表⽰⼀个可调用的代码单元，没有命名的内联函数。不需要函数名，因为我们⼀次性的使用它，不需要其他地方调用它。\n由以下几个部分组成：\n[捕获列表]：捕获Lambda表达式所在作用域内的变量，捕获变量可以是值捕获或引用捕获。 (参数列表)：定义Lambda表达式的参数列表。 mutable：用于指定是否可以修改Lambda表达式所在作用域内的变量。 -\u0026gt; 返回值类型：指定Lambda表达式的返回值类型，可以省略。 {函数体}：Lambda表达式的函数体。 1 2 3 4 5 6 7 [capture list] (parameter list) -\u0026gt; return type {function body } // [捕获列表] (参数列表) -\u0026gt; 返回类型 {函数体 } // 只有 [capture list] 捕获列表和 {function body } 函数体是必选的 auto lam =[]() -\u0026gt; int { cout \u0026lt;\u0026lt; \u0026#34;Hello, World!\u0026#34;; return 88; }; auto ret = lam(); cout\u0026lt;\u0026lt;ret\u0026lt;\u0026lt;endl; // 输出88 strcpy和strncpy的区别 strcpy和strncpy都是C语言中的字符串操作函数，其区别如下：\n函数原型不同 1 2 char* strcpy(char* dest, const char* src); char* strncpy(char* dest, const char* src, size_t n); strncpy需要指定需要拷贝的字符串长度。\n处理方式不同 strcpy的处理方式是将源字符串一直拷贝到遇到\u0026rsquo;\\0\u0026rsquo;为止，会导致堆栈溢出等问题。 strncpy的处理方式是将源字符串拷贝到指定长度或遇到\u0026rsquo;\\0\u0026rsquo;为止。如果目标字符串长度小于指定长度，则会用空字符填充目标字符串直至指定长度。 面向对象和面向过程的区别 从设计思路来看\n面向过程程序设计的重点是分析问题解决的步骤，明确每个步骤的输入和输出以及完成各步骤的流程，是一种结构化的自上而下的程序设计方法。\n面向对象程序设计的重点是把构成问题的事务分解成对象，从局部着手，通过迭代的方法逐步构建出整个程序，是一种以数据为核心，以类设计为主要工作的自下而上的程序设计方法。\n从适用范围来看\n面向过程的程序性能更高，由于不涉及实例化对象等操作，系统开销更小。\n面向对象由于其抽象封装继承多态的特性，使得系统具有更好的可扩展性、可复用性、可维护性。\n从代码复用来看\n虽然都可以代码复用，但是面向过程重用的是函数，面向对象重用的是类。\n#include\u0026lt;\u0026gt;和#include””的区别 #include\u0026lt;\u0026gt;搜索时从编译器指定的路径处搜索，如果找不到，程序直接报错。系统提供的头文件使用#include\u0026lt;\u0026gt;。\n#include\u0026quot;\u0026quot;先从运行程序当前目录中进行搜索，如果搜索失败再从编译器指定的路径搜索，如果仍然搜索失败，则程序报错。用户自定义的头文件使用#include\u0026quot;\u0026quot;引入。\n#和##在define中的作用 宏定义中的#运算符将其后面的参数转换成字符串\n宏定义中的##运算符将前后的参数进行字符串连接\n1 2 3 4 5 6 #define PRINTCUBE(x) cout\u0026lt;\u0026lt;\u0026#34;cube(\u0026#34;\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34;)=\u0026#34; \u0026lt;\u0026lt;(x)*(x)*(x)\u0026lt;\u0026lt;endl; #define LINK3(x,y,z) x##y##z PRINTCUBE(y); LINK3(\u0026#34;C\u0026#34;,\u0026#34;+\u0026#34;,\u0026#34;+\u0026#34;); cout\u0026lt;\u0026lt; \u0026#34;cube(\u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;)=\u0026#34; \u0026lt;\u0026lt;(y)*(y)*(y)\u0026lt;\u0026lt;endl; 输出\n1 2 cube(y)=125 \u0026#34;C++\u0026#34; assert断言 assert用于在程序的DEBUG版本中检测条件表达式，如果结果为假，则输出诊断信息并终止程序运行。\n最好在每个assert中只检测一个条件。否则断言失败无法判断是哪个条件出错。 不要在assert中修改条件变量的值 类型转换符 static_cast、dynamic_cast、const_cast、reinterpret_cast\nstatic_cast可以完全代替C风格的类型转换。在对象指针之间的类型转换时，可以将父类指针转换成子类指针，也可以将子类指针转换为父类指针。\n父类指针指向父类对象，用static_cast将父类指针转换为子类指针时，不安全。如果父类指针原本就指向一个子类对象，则不存在安全性问题。\n用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。\n把空指针转换成目标类型的空指针\n把任何类型的表达式转换成void类型\n比C语言中的转换强在哪里：\n​\ta. 更加安全\n​\tb. 更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误\ndynamic_cast只能用于对象指针之间的类型转换，父类指针转换为子类指针，也可以见子类指针转换为父类指针。转换过程中需要对对象类型进行检查，以保证类型完全匹配。\n只有当父类指针指向子类对象，并且父类中包含虚函数时，使用dynamic_cast将父类指针转换成子类指针才会成功，否则返回空指针，如果是引用则抛出异常。\nconst_cast增加或删除const属性。\nreinterpret_cast将一种类型的指针直接转换为另一种类型的指针，不论两个类型之间是否有继承关系。\nsizeof sizeof是单目运算符，不是一个函数。\n操作数可以是类型名，也可以是表达式。类型名，则获得该类型的字节数。表达式，先分析表达式结果的类型，再确定所占用字节数。\n将数组名作为sizeof运算符的操作数可以获得整个数组所占的空间。\n可以对函数调用表达式进行sizeof运算，会计算函数返回类型所占用的空间。而函数名、没有返回值或返回值为void就不用使用sizeof。\n数组和指针的区别 数组名等价于数组首元素的地址。数组名作为函数参数时，相当于传递了数组首元素的地址。\ntips：\n字符数组不同于字符串，末尾不会自动加上字符串提示符\\0 当定义一个没有显式指明大小的数组时，必须在定义的同时初始化。 (const函数形参)如果指针参数的值不应该在函数调用过程中被修改，可在函数指针形参前面加上const修饰符。这样在函数中一旦有对指针的值进行修改，编译器会报错。 指针数组和数组指针 指针数组：指向变量类型 *数组名称 [数组长度]\tint *p[3]\n数组指针：数组元素类型 (* 指针名称) [数组长度] int (*p)[3]\ntips：\n[]优先级高于* 数组指针p指向的是整个数组a，而非数组a的首元素 数组地址\u0026amp;a和数组首元素地址\u0026amp;a[0]只是在数值上相等。数组地址\u0026amp;a解引用成为\u0026amp;a[0]，数组首元素地址\u0026amp;a[0]解引用后成为a[0]。 int a[2][3]={{1,2,3},{4,5,6}}中函数名a等价于a[0]的地址，类型是int * 函数指针与指针函数 函数指针：可以存储函数地址的指针变量。\n1 int (*functionPtr)(int, int); 每个函数在内存中都占用一段存储单元，这段存储单元的首地址是函数的入口地址，指向这个函数入口地址的指针称为函数指针。\n函数名等价于函数的入口地址。函数的调用可以通过函数名，也可以通过指向函数的指针来调用。函数指针还允许将函数作为变元传递给其他函数；\n指针函数：\n指针函数是指一个返回指针的函数，它本身是一个函数，但返回值是一个指针。\n1 int* createIntArray(int size); memcpy与strcpy的区别 函数strcpy主要用于标准的字符串拷贝，非标准的字符串（没有字符串结尾标志）不能使用该函数。不需要指定长度，它遇到被复制字符的串结束符\u0026quot;\\0\u0026quot;才结束，容易溢出。 函数memcpy主要用于内存块的整体拷贝，在使用时要指定拷贝的长度，拷贝数据的类型没有限制。 回调函数 当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数； 回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。需要做三件事：1，声明；2，定义；3，设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用； 回调函数是一个通过函数指针调用的函数。函数指针作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数； 因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。 静态编译与动态编译 静态编译，编译器在编译可执行文件时，把需要用到的对应动态链接库中的部分提取出来，链接到可执行文件中去，使可执行文件在运行时不需要依赖于动态链接库；\n动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库的命令。\n优点\n缩小了执行文件体积 加快编译速度 缺点\n哪怕是很简单的程序，只用到了链接库的一两条命令，也需要附带一个相对庞大的链接库 如果其他计算机上没有安装对应的运行库，用动态编译的可执行文件就不能运行 函数形参使用值传递、指针或引用 值传递：数据对象很小，如内置数据类型或者小型结构，\nconst指针：如果数据对象是数组\nconst指针或者引用：数据对象是较大的结构，提高程序的效率。这样可以节省结构所需的时间和空间；\nconst引用：数据对象是类对象\n引用传参\n优点(对比值传递)：\n在函数内部可以对该参数进行修改 提高函数调用和运行的效率 限制：\n不能返回局部变量的引用。 不能返回函数内部new分配的内存的引用。 可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。 阻止一个类被实例化的方法 将类定义为抽象基类或者将构造函数声明为private； 不允许类外部创建类对象，只能在类内部创建对象 禁止程序自动生成拷贝构造函数 为了阻止编译器默认生成拷贝构造函数和拷贝赋值函数，我们需要手动去重写这两个函数，某些情况﻿下，为了避免调用拷贝构造函数和﻿拷贝赋值函数，我们需要将他们设置成private，防止被调用。 类的成员函数和friend函数还是可以调用private函数，如果这个private函数只声明不定义，则会产生一个连接错误； 针对上述两种情况，我们可以定一个base类，在base类中将拷贝构造函数和拷贝赋值函数设置成private,那么派生类中编译器将不会自动生成这两个函数，且由于base类中该函数是私有的，因此，派生类将阻止编译器执行相关的操作。 函数调用过程栈的变化 当函数从入口函数main函数开始执行时，编译器会将我们操作系统的运行状态，main函数的返回地址、main的参数、mian函数中的变量、进行依次压栈；\n当main函数开始调用func()函数时，编译器此时会将main函数的运行状态压栈，再将func()函数的返回地址、func()函数的参数从右到左、func()定义变量依次压栈；\n当func()调用f()的时候，编译器此时会将func()函数的运行状态进行压栈，再将的返回地址、f()函数的参数从右到左、f()定义变量依次压栈\n1 printf(\u0026#34;var1=%d,var2=%d\u0026#34;, f(var1), f(var2)); 从代码的输出结果可以看出，函数f(var1)、f(var2)依次入栈，而后先执行f(var2)，再执行f(var1)，最后打印整个字符串，将栈中的变量依次弹出，最后主函数返回。\n函数的调用过程：\n1）从栈空间分配存储空间\n2）从实参的存储空间复制值到形参栈空间\n3）进行运算\n形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。\n模板类一般都是放在一个h文件中 由template\u0026lt;…\u0026gt;处理的任何东西都意味着编译器在当时不为它分配存储空间，仅在需要的时候才会实例化出来。为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。\n重载函数的匹配原则和顺序 名字查找 确定候选函数 寻找最佳匹配 定义和声明的区别 如果是指变量的声明和定义： 声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。而定义就是分配了内存。\n如果是指函数的声明和定义： 声明一般在头文件里，让编译器知道这个函数的存在。 定义一般在源文件里，具体就是函数的实现过程写明函数体。\n段错误原因解决办法 段错误（Segmentation Fault）通常是由于程序试图访问不属于它的内存区域或者试图对只读内存进行写操作而触发的。段错误产生的原因包括：\n访问越界：当程序尝试访问数组、指针或缓冲区之外的内存时，通常会导致段错误。\n对只读内存进行写操作：如果程序试图写入只读内存区域（例如字符串字面量或常量），也会触发段错误。\n空指针引用：尝试通过空指针进行读取或写入操作会导致段错误。\n栈溢出：当递归函数调用过多或者局部变量占用的栈空间过大时，栈溢出也可能导致段错误。\n处理段错误的方法包括：\n检查代码：首先，仔细检查程序的源代码，查找可能导致段错误的地方。特别注意数组和指针的边界问题。\n使用调试工具：使用调试工具（如GDB）来分析段错误。GDB可以帮助你找到引发段错误的具体行号和上下文信息。\n使用内存检测工具：工具如Valgrind可以检测内存泄漏和越界访问等问题，帮助你找到段错误的根本原因。\n避免使用未初始化的指针：确保你的指针都经过正确初始化，不要让它们指向未知内存区域。\n避免对只读内存进行写操作：不要尝试修改只读内存区域，如字符串字面量。\n栈溢出检测：如果你怀疑栈溢出是问题的原因，可以增加栈的大小或者优化递归算法。\n避免使用未定义行为：C/C++中有一些未定义行为，尽量避免使用它们，因为它们可能导致难以预测的结果和段错误。\n处理异常：在C++中，可以使用异常处理机制来捕获和处理异常，防止程序崩溃。\n使用合适的数据结构和算法：使用标准库提供的数据结构和算法，它们经过严格测试和优化，可以减少潜在的段错误。\n二、类 1、C++三大特性 访问权限\nC++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限\n类的内部，⽆论成员被声明为 public、protected 还是 private，都可以互相访问的。\n在类的外部，只能通过对象访问成员，并且通过对象只能访问 public属性的成员，不能访问 private、protected 属性的成员\n⽆论公有继承、私有和保护继承，私有成员不能被“派⽣类”访问，基类中的公有和保护成员能被“派⽣类”访问。\n对于公有继承，只有基类中的公有成员能被“派⽣类对象”访问，保护和私有成员不能被“派 ⽣类对象”访问。对于私有和保护继承，基类中的所有成员不能被“派⽣类对象”访问。\n1.继承 **定义：**让某种类型对象获得另⼀个类型对象的属性和方法 **功能：**它可以使用现有类的所有功能，并在⽆需重新编写原来的类的情况下对这些功能进行扩展\n常见的继承有三种方式： 1、实现继承：指使用基类的属性和方法而⽆需额外编码的能⼒ 2、接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力 3、可视继承：指子窗体（类）使用基窗体（类）的外观和实现代码的能力\n2.封装 **定义：**数据和代码捆绑在⼀起，避免外界⼲扰和不确定性访问; 功能：把客观事物封装成抽象的类。可以将公共的数据或方法使用public修饰，⽽不希望被访问的数据或方法采用private修饰。\n3.多态 **定义：**同⼀事物表现出不同事物的能力，即向不同对象发送同⼀消息，不同的对象在接收时会产⽣不同的行为（重载实现编译时多态，虚函数实现运行时多态） **功能：**多态性是允许你将父对象设置成为和⼀个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作;\n简单⼀句话：允许将子类类型的指针赋值给父类类型的指针。\n实现多态有两种方式\n重写（override）： 是指子类重新定义父类的虚函数的做法 重载（overload）： 是指允许存在多个同名函数，⽽这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同） 2、虚继承 虚继承是为了解决多继承时的命名冲突和冗余数据问题，可以在派⽣类中只保留⼀份间接基类的成员。多继承是指从多个直接基类中产⽣派⽣类的能⼒，多继承的派⽣类继承了所有父类的成员。 虚基类就是某个类做出声明，承诺愿意共享它的基类，其中，这个被共享的基类就称为虚基类。其中A 就是⼀个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派⽣类中都只包含⼀份虚基类的成员。 C++标准库中的 iostream 类就是⼀个虚继承的实际应用案例。\niostream 从 istream 和 ostream 直接继承⽽来，⽽ istream 和 ostream 又都继承⾃⼀个共同的名为 baseios 的类，是典型的菱形继承。\n此时 istream 和 ostream 必须采用虚继承，否则将导致 iostream 类中保留两份 baseios 类的成员。\n使用多继承经常出现⼆义性，必须⼗分⼩⼼；\n⼀般只有在比较简单和不易出现⼆义性或者实在必要情况下才使用多继承，能用单⼀继承解决问题就不要用多继承。\n3、抽象类与接口 接口描述了类的行为和功能，⽽不需要完成类的特定实现； 接口是使用抽象类来实现的 1、类中⾄少有⼀个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 \u0026ldquo;= 0\u0026rdquo; 来指定的。\n2、设计抽象类的目的，是为了给其他类提供⼀个可以继承的适当的基类。抽象类不能被用于实例化对象，只能作为接口使用。\n4、类内的static和const 静态成员变量\n静态成员变量属于整个类，不属于某个对象，只有唯一的一份拷贝，所有对象共享类中的静态数据成员。 必须在类内声明，在类外部初始化。 静态成员函数\n没有this指针，无法访问类对象的非static成员变量和非static成员函数； 不能被声明为const、虚函数和volatile； **作用：**实现多个对象之间的数据共享 + 隐藏，并且使用静态成员还不会破坏隐藏原则；默认初始化为0\nconst成员变量\n只能通过构造函数初始化列表进行初始化 不同类对其const数据成员的值可以不同，不能在类中声明时初始化 const成员函数\n函数不会修改类中的数据成员。 const对象只能调用类的const成员函数，不可以调用非const成员函数，非const对象都可以调用 不可以改变非mutable数据的值 5、this指针 每个非静态成员函数都包含一个this指针，指向调用该函数的对象。 当对象访问类中的非静态成员函数时，编译器会自动将对象的地址隐式的作为第一个参数传递给this指针。 6、友元函数 可以直接访问类的非公有成员和非公有成员函数，友元类的所有成员函数都是另一个类的友元函数。\n友元关系是单向的，不具有交换性。不能继承。不具有传递性。\n7、虚函数的实现 在父类中定义虚函数，在子类中重写该函数。运行时，编译器根据对象的实际类型调用相应的函数。\n使用虚函数表来实现。每个包含虚函数的类都有一个虚函数表，表中存储了类的虚函数指针。\n子类中的虚函数会覆盖父类中的虚函数，因此在子类中重写虚函数时，编译器会把子类中的虚函数地址填入虚函数表中的对应位置。\n对象被创建时，会分配一个指向虚函数表的指针。在调用虚函数时，编译器会查找对象指针指向的虚函数表，根据表中存储的虚函数指针调用相应的函数。\n虚函数表\n如果一个类中有虚函数，那么这个类就对应一个虚函数表。\n虚函数表中的元素是一组指向函数的指针，每一个指针指向虚函数的入口地址。在访问虚函数时，通过虚函数表进行函数调用。\n在含有虚函数的类对象模型中，除了对象的数据成员外，还有一个指向虚函数表的指针，称为虚指针，虚指针位于对象模型的顶部。\n虚函数 当基类希望派⽣类定义适合自己的版本，就将这些函数声明成虚函数（virtual）\n虚函数依赖虚函数表工作，表来保存虚函数地址，当我们用基类指针指向派⽣类时，虚表指针指向派⽣类的虚函数表\n这个机制可以保证派⽣类中的虚函数被调用到\n动态绑定绑定的是动态类型 所对应的函数或属性依赖于对象的动态类型，发⽣在运行期。 构造函数不能是虚函数 ⽽且，在构造函数中调用虚函数，实际执行的是父类的对应函数，因为⾃⼰还没有构造好,多态是被disable的。 析构函数可以是虚函数，⽽且，在⼀个复杂类结构中，这往往是必须的。 inline, static, constructor三种函数都不能带有virtual关键字。 （1）inline是在编译时展开，必须要有实体。 内联函数是指在编译期间用被调用函数体本⾝来代替函数的调用指令，但虚函数的多态特性需要在运行时根据对象类型才知道调用哪个虚函数，所以没法在编译时进行内联函数展开。 （2）static属于class自己的类相关，必须有实体； static成员没有this指针。virtual函数⼀定要通过对象来调用，有隐藏的this指针，实例相关。 析构函数可以是纯虚的 但纯虚析构函数必须有定义体，因为析构函数的调用是在子类中隐含的。 派⽣类的override虚函数定义必须和父类完全⼀致。 除了⼀个特例，如果父类中返回值是⼀个指针或引用，子类override时可以返回这个指针（或引用）的派⽣ 8、纯虚函数与虚函数有哪些区别 虚函数是在基类中声明为虚函数的成员函数，在派生类中可以重载它。当我们使用基类指针或引用调用虚函数时，程序会根据指针或引用所指向的对象的实际类型来调用相应的派生类函数。因此，虚函数允许在运行时动态绑定函数。\n**纯虚函数是在基类中声明的没有定义的虚函数。**它的作用是为了让派生类实现接口。我们可以将纯虚函数看做是一个抽象接口，派生类必须实现这个接口，否则就无法编译通过。\n区别如下：\n虚函数有函数体，而纯虚函数没有函数体。 虚函数可以被重载，而纯虚函数只能被实现。 含有纯虚函数的类是抽象类，无法被实例化，而虚函数所在的类可以被实例化。 派生类必须实现纯虚函数，否则无法编译通过。而对于虚函数，派生类可以选择性地实现或不实现。 对于纯虚函数，可以通过把它定义为 protected 或 private 来防止类被实例化，而虚函数所在的类没有这个选项。 9、虚析构函数 虚析构函数是为了解决父类的指针指向子类对象，并用父类的指针删除子类对象。\n父类指针指向子类对象时，如果子类中有属性在堆中开辟了空间，如果父类析构函数不使用虚函数，会造成内存泄漏。\n这时需要把析构函数设置为虚析构函数或纯析构函数。\n10、构造函数 构造函数是一种特殊的成员函数， 在创建对象时自动调用，用于初始化对象中的数据成员。 构造函数的名称必须与类名相同，并且没有返回值类型，构造函数中禁止使用return语句。 tips：\n只要用户显式地声明了一个构造函数，无论是无参的还是带参的，系统都不会再生成默认的无参构造函数。 构造函数执行分为两个部分：首先执行构造函数的初始化列表，然后执行构造函数的函数体。优先使用初始化列表，避免二次赋值。 11、构造函数，析构函数要设为虚函数吗，为什么？ （1）析构函数 析构函数需要。当派⽣类对象中有内存需要回收时，如果析构函数不是虚函数，不会触发动态绑定，只会调用基类析构函数，导致派⽣类资源无法释放，造成内存泄漏。 （2）构造函数 构造函数不需要，没有意义。虚函数调用是在部分信息下完成工作的机制，允许我们只知道接口而不知道对象的确切类型。 要创建⼀个对象，你需要知道对象的完整信息。 特别是，你需要知道你想要创建的确切类型。 因此，构造函数不应该被定义为虚函数。\n12、移动构造函数 对象a初始化对象b，对象a不再使用的情况下，使用移动构造函数。实际上就是把a对象的内容复制一份到b中，直接使用a的空间。这样就避免了新的空间的分配，大大降低了构造的成本。 移动构造函数中，对于指针，采用浅拷贝。指针复制后，将第一个指针置为NULL。 移动构造函数的参数是一个右值引用。意味着，移动构造函数的参数是一个右值或者将亡值的引用。 move语句就是将一个左值变成一个将亡值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class MyString { private: char* data; public: // 移动构造函数 MyString(MyString\u0026amp;\u0026amp; other) noexcept : data(other.data) { other.data = nullptr; // 将other对象的资源移动，并将其置为空指针 } // 构造函数 MyString(const char* str) { data = new char[strlen(str) + 1]; strcpy(data, str); } // 析构函数 ~MyString() { delete[] data; } }; 13、绑定 多态性的原理是延迟绑定，也就是在函数调用时才绑定函数，这也是虚函数的工作原理。 绑定是指将函数调用和函数体关联起来，早绑定是在编译或链接阶段进行绑定，晚绑定是在程序运行阶段进行绑定。 14、成员初始化列表 在类的构造函数中，不在函数体内对成员变量赋值，而是在构造函数的花括号前面使用冒号和初始化列表赋值。 对象成员变量的初始化发生在进入构造函数之前。如果是在构造函数体内赋值是一次初始化加一次赋值，而初始化列表只做一次赋值操作。 三、内存 1、C++程序内存的分配 当一个程序从硬盘中加载到内存中的时候，就变成了一个进程，对于x86的系统，进程中分成了内核空间和用户空间，内核空间占高地址的1G，用户空间占3个G，用户空间中的内存从低到高依次是**.text段（代码段），.data（存放初始化的全局变量和静态变量），.bss（存放未初始化或者初始化为0的全局或静态变量）**，栈（存放函数内部的局部变量），堆（存放用户自己用new或者malloc动态分配）\nC++编译的程序占用内存分为以下几个部分： 代码段：存放函数体（类成员函数和全局区）的二进制代码。\n全局区及静态存储区：存放全局变量、静态变量，生命周期在程序运行期间始终存在，程序结束时操作系统才会回收这部分空间。全局区分为已初始化全局区（data）和未初始化全局区（bss）。\n堆区（heap）：由程序员负责分配和回收，如果程序员没有释放，程序结束时由操作系统回收。**堆从低地址向高地址增长。是不连续的内存区域。**大小可以灵活调整。堆大小受限于计算机系统中有效的虚拟内存。\n栈区（stack）：由编译器自动分配与释放，存放为运行时函数分配的局部变量、函数参数、返回数据、返回地址等。栈从高地址向低地址增长，后进先出，是一块连续的空间。\n栈空间默认是4M, 堆区一般是 1G - 4G\n三种内存分配方式 从静态存储区分配\n内存在程序编译的时候已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。\n在栈上创建\n在执行函数时，函数内局部变量的存储单元可以在栈上创建，函数执行结束时，这些内存单元会自动被释放。 栈内存分配运算内置于处理器的指令集，效率高，但是分配的内存容量有限。\n从堆上分配\n亦称为动态内存分配。 程序在运行的时候使用malloc或者new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。 动态内存的生命周期有程序员决定，使用非常灵活，但如果在堆上分配了空间，既有责任回收它，否则运行的程序会出现内存泄漏，频繁的分配和释放不同大小的堆空间将会产生内存碎片。\n堆栈的区别 栈空间用于存储函数参数和局部变量，空间由系统自动分配和回收。堆空间存储动态分配的内存，分配和释放空间由程序员控制，有可能产生内存泄漏。 栈空间是后进先出的数据结构，可用空间是一块连续的内存块。堆空间在不断的分配和释放过程中，可用空间链表频繁更新，造成可用空间逐渐碎片化。 栈空间的默认大小只有几M的空间，生长方式是向下的，向着内存地址减小的方向消耗空间。堆空间理论大小有几G的空间，生长方式是向上的，向着内存地址增大的方向消耗空间。 栈效率较高，有寄存器支持。堆空间需要通过可用空间链表的扫描和调整以及相邻空间的合并等操作，效率相对较低。 tips：\n使用递归解决问题要考虑到栈溢出的问题，如果确实有可能发生，可以考虑使用循环代替递归。 2、内存泄漏 内存泄漏是指在程序执行过程中，由于未能正确释放不再使用的动态分配内存，导致这些内存块变得不可访问，从而无法再被回收和重用的情况。内存泄漏可能导致程序在运行时占用越来越多的内存，最终耗尽可用内存资源，导致程序性能下降甚至崩溃。\n产生内存泄漏就是因为分配的内存没有及时回收。由于栈内存由编译器负责分配和回收，因此不存在内存泄漏的原因。而堆内存有程序员负责分配和回收，这种人为的控制导致了内存泄漏的发生。\n具体来讲，内存泄漏是由于在程序中通过malloc或者new从堆中申请了一块空间，但是在使用后并没有调用free或者delete释放，导致这块空间既无法使用也无人回收，从而造成内存泄漏。\n内存泄漏的主要原因：\n未释放动态分配内存 丢失对分配内存的指针：指向动态分配内存的指针赋给其他指针或者重新分配，而没有在合适的时候释放原始内存。 循环引用：如果对象之间存在循环引用，引用计数可能永远不会归零，从而导致对象不会被释放。 函数调用中的内存泄漏：在函数中分配了内存，但在函数返回前没有释放。 如何防止内存泄露? **使用智能指针。**它们可以自动管理内存的分配和释放。当不再需要某个对象时，智能指针会自动释放与之关联的内存，从而防止内存泄漏。\n使用 RAII（资源获取即初始化）：在C++中，RAII 是一种常见的资源管理技术，通过对象的生命周期来管理资源的分配和释放。例如，可以使用对象的析构函数来释放资源，确保资源在对象不再需要时被正确释放。\n将内存的分配封装在类中，构造函数分配内存，析构函数释放内存；\n在动态内存分配后及时释放。使用 new 或 malloc 进行动态内存分配，确保在不再需要内存时调用 delete 或 free 来释放它。通常，使用局部变量和栈分配可以避免显式的内存管理。\n使用内存分析工具：工具如Valgrind。\n一定要将基类的析构函数声明为虚函数。\n对象数组的释放一定要用delete []。\n3、malloc/free 和 new/delete malloc/free是C语言库函数，通过函数调用访问，需要传递参数并接收返回值。new/delete是C++运算符。\nmalloc/free函数只能应用于基本类型。new/delete可以用于自定义类型。\nmalloc/free函数返回void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。\nmalloc函数只负责申请空间，并返回首地址。new/delete还会调用对象的构造函数/析构函数。\nmalloc需要计算需要的内存大小，new自动计算要分配的空间大小。\nnew是类型安全的，malloc不是。\n1 2 int *p = new float[2]; //编译错误 int *p = (int*)malloc(2 * sizeof(double));//编译无错误 new/delete可以被重载，而malloc/free并不允许重载。\nmalloc的底层是如何实现的？\n（1）malloc函数的底层实现是操作系统有一个由可用内存块连接成的空闲链表。调用malloc时，它将遍历该链表寻找足够大的内存空间，将该块一分为二（一块与用户申请的大小相等，另一块为剩下来的碎片，会返回链表），调用free函数时，内存块重新连接回链表。\n（2）若内存块过于琐碎无法满足用户需求，则操作系统会合并相邻的内存块。\n4、delete和delete[] new[]中的数组元素是基本类型时，通过delete和delete[]都可以释放数组空间。（待查证）\nnew[]中的数组元素是自定义类型时，只能通过delete[]释放数组空间\n建议申请和释放空间采用完全配对的形式：new和delete成对使用，new[]与delete[]成对使用，不管数组元素是基本数据类型还是自定义类型。\n当数组元素是自定义类型时使用delete[]，delete在释放空间时只会调用数组中首个元素的析构函数，而delete[]会调用所有元素的析构函数\n当数组元素是基本数据类型时，delete和delete[]释放数组空间是等价的。对于基本数据类型，系统可以根据数组长度和数据类型计算出数组所占的空间，然后一次性释放整个空间，因此不需要区分delete和delete[]。\n5、内存越界 内存越界又称内存访问越界，是指访问了所申请空间之外的内存。\ntips：\nvector中包含三个迭代器：first迭代器指向第一个元素，finish迭代器指向最后一个有效元素的下一个位置，end_of_storage迭代器指向整个vector空间末尾的下一个位置。通过下标访问vector中的元素时不会做边界检查，如果想在访问vector中的元素时首先进行边界检查，可以使用vector中的at函数。 6、智能指针 C++中有三种常见的智能指针，它们用于管理动态分配的内存和自动释放资源，帮助减少内存泄漏和错误的机会。这些智能指针包括：\nstd::shared_ptr（共享指针）：\nstd::shared_ptr 是一种共享所有权的智能指针。多个 std::shared_ptr 可以共享同一块内存，并且会在最后一个拥有者释放资源时自动释放内存。这种指针适用于多个拥有者的情况，例如，在容器中存储对象，或者多个对象需要共享某个资源。 std::unique_ptr（独占指针）：\nstd::unique_ptr 是一种独占所有权的智能指针。每个 std::unique_ptr 拥有其所指向的资源，并且在其生命周期结束时自动释放资源。这种指针适用于单一拥有者的情况，例如，防止多个指针同时管理同一资源，从而提高了程序的安全性。 std::weak_ptr（弱引用指针）：\nstd::weak_ptr 也是一种共享指针，但它不增加资源的引用计数，因此不会影响资源的生命周期。std::weak_ptr 主要用于避免循环引用问题，其中多个对象相互引用，导致资源无法释放。通过将一个或多个 std::weak_ptr 引用添加到已经由 std::shared_ptr 管理的资源上，可以解决这个问题。 作用：\n防止内存泄漏：智能指针可以确保在不再需要资源时自动释放它们，从而防止了内存泄漏。\n简化内存管理：智能指针减轻了程序员手动跟踪和释放内存的负担，降低了出错的风险。\n提高代码安全性：独占指针 std::unique_ptr 防止了多个指针同时管理同一资源，增强了程序的安全性。\n解决循环引用问题：弱引用指针 std::weak_ptr 可以帮助解决多个对象相互引用导致资源无法释放的问题。\n四、STL STL（标准模板库）六⼤组件分别是:容器、算法、迭代器、仿函数、适配器、空间配置器。\n1、容器有哪些 C++标准库提供了多种容器类型，用于存储和组织数据：\n序列容器（Sequence Containers）： std::vector：动态数组，支持快速随机访问，可动态增长。 std::deque：双端队列，支持快速随机访问，可在两端进行插入和删除操作。 std::list：双向链表，支持在任何位置进行插入和删除操作，但不支持随机访问。 std::forward_list：单向链表，支持在前方插入和删除操作。 关联容器（Associative Containers）： std::set：有序集合，不允许重复元素。 std::multiset：有序集合，允许重复元素。 std::map：有序映射（键-值对），不允许重复键。 std::multimap：有序映射，允许重复键。 无序容器（Unordered Containers）： std::unordered_set：无序集合，不允许重复元素，基于哈希表实现。 std::unordered_multiset：无序集合，允许重复元素，基于哈希表实现。 std::unordered_map：无序映射，不允许重复键，基于哈希表实现。 std::unordered_multimap：无序映射，允许重复键，基于哈希表实现。 容器适配器（Container Adapters）： std::stack：栈，基于其他序列容器实现，提供了后进先出（LIFO）的操作。 std::queue：队列，基于其他序列容器实现，提供了先进先出（FIFO）的操作。 std::priority_queue：优先队列，基于其他序列容器实现，元素按照优先级排序。 2、STL的优点 可移植性：STL是C++标准库的一部分，在不同的C++编译器和平台上都有一致的行为和接口。\n这意味着你可以编写可移植的代码，而不必担心不同编译器或操作系统的差异。\n高性能：STL容器和算法经过精心设计和优化，通常具有高效的性能。\n例如，向量（std::vector）提供了O(1)的随机访问时间，列表（std::list）允许快速插入和删除操作。\n可扩展性：STL容器和算法是模板化的。\n意味着你可以轻松地创建自定义的容器和算法，以满足特定的需求。这种扩展性使得STL适用于各种不同的应用场景。\n安全性：STL容器和算法经过严格的测试和验证，可以防止许多常见的错误。\n如缓冲区溢出、内存泄漏等。此外，STL的迭代器和智能指针提供了更安全的内存管理方式。\n丰富的算法库：STL包含了丰富的算法库，包括查找、排序、转换、聚合等操作。\n3、vector容器实现与扩充 1. 底层实现 vector在堆中分配了⼀段连续的内存空间来存放元素。vector 对象本身通常存储在栈上，但它的元素存储在堆上。\n1、三个迭代器 （1）first ： 指向的是vector中对象的起始字节位置 （2）last ： 指向当前最后⼀个元素的末尾字节 （3）end ： 指向整个vector容器所占用内存空间的末尾字节\n2. 扩容 如果集合已满，在新增数据的时候，就要分配⼀块更⼤的内存，将原来的数据复制过来，释放之前的内存，在插⼊新增的元素\n所以对vector的任何操作，⼀旦引起空间重新配置，指向原vector的所有迭代器就都失效了\nsize() 和 capacity()\n（1）堆中分配内存，元素连续存放，内存空间只会增长不会减少\ncapacity()，在不分配新内存下最多可以保存的元素个数\nsize()，返回当前已经存储数据的个数\n（2）对于vector来说，capacity是永远⼤于等于size的\ncapacity和size相等时，vector就会扩容，capacity变⼤（翻倍）\nvector扩容方式\n扩容操作涉及到内存分配和元素复制。\n为新容量分配一块更大的内存空间，通常是原容量的两倍或更多。 将已有的元素从旧的内存位置复制到新的内存位置。 释放旧的内存空间。 resize()和reserve()\nresize()：改变当前容器内含有元素的数量(size())，而不是容器的容量\n当resize(len)中len\u0026gt;v.capacity()，则数组中的size和capacity均设置为len; 当resize(len)中len\u0026lt;=v.capacity()，则数组中的size设置为len，而capacity不变; reserve()：改变当前容器的最⼤容量（capacity）\n如果reserve(len)的值 \u0026gt; 当前的capacity()，那么会重新分配⼀块能存len个对象的 空间，然后把之前的对象通过copy construtor复制过来，销毁之前的内存; 当reserve(len)中len\u0026lt;=当前的capacity()，则数组中的capacity不变，size不变，即不对容器做任何改变。 4、vector和list的区别 vector底层实现是数组；list是双向链表 vector是顺序内存,⽀持随机访问，list不行 vector在中间节点进行插⼊删除会导致内存拷贝，list不会 vector⼀次性分配好内存，不够时才进行翻倍扩容；list每次插⼊新节点都会进行 内存申请 vector随机访问性能好，插⼊删除性能差；list随机访问性能差，插⼊删除性能好 deque（双端数组）\n⽀持快速随机访问，由于deque需要处理内部跳转，因此速度上没有vector快。\n1、deque概述：\ndeque是⼀个双端开口的连续线性空间，其内部为分段连续的空间组成，随时可以增加⼀段新的空间并链接\n注意:\n由于deque的迭代器比vector要复杂，这影响了各个运算层⾯，所以除非必要尽量使用vector；为了提⾼效率，在对deque进行排序操作的时候，我们可以先把deque复制到vector中再进行排序最后在复制回deque\n五、C++11新特性 1、类型推导 1、auto： auto可以让编译器在编译期就推导出变量的类型\n2、 decltype： decltype则用于推导表达式类型，只用于编译器分析表达式的类型，表达式实际不会进行运算 decltype不会像auto⼀样忽略引用和cv属性，decltype会保留表达式的引用和cv属性\n2、右值引用和移动语义 左值右值：\n左值： 可以放在等号左边，可以取地址并有名字 右值： 不可以放在等号左边，不能取地址，没有名字 字符串字⾯值\u0026quot;abcd\u0026quot;也是左值，不是右值\n++i、\u0026ndash;i是左值，i++、i\u0026ndash;是右值\n3、nullptr nullptr是用来代替NULL，用于表示空指针，取代了传统的 NULL 或 0。\nC++11引⼊nullptr关键字来区分空指针和0。nullptr 的类型为 nullptr_t，能够转换为任何指针或成员指针的类型，也可以进行相等或不等的比较。\n4、列表初始化 1 2 3 4 int x = 0; // method1 int x = {0}; // method2 int x{0}; // method3 int x(0); // method4 采用花括号来进行初始化称为列表初始化，⽆论是初始化对象还是为对象赋新值。\n智能指针 新的容器和算法： 引入了新的容器类型（例如 std::unordered_set 和 std::unordered_map）和算法（例如 std::move 和并行算法） Lambda 表达式： Lambda 表达式允许你定义匿名函数。 线程支持和多线程库： C++11引入了对多线程编程的支持，包括 std::thread 类用于创建线程，原子操作、互斥量和条件变量等同步机制。 六、并发 1.线程互斥 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; std::mutex mtx; // 定义一个互斥锁 void shared_resource(int thread_id) { mtx.lock(); // 锁住互斥锁 std::cout \u0026lt;\u0026lt; \u0026#34;Thread \u0026#34; \u0026lt;\u0026lt; thread_id \u0026lt;\u0026lt; \u0026#34; is accessing the shared resource.\u0026#34; \u0026lt;\u0026lt; std::endl; // 这里可以执行共享资源的操作 mtx.unlock(); // 解锁互斥锁 } int main() { std::thread t1(shared_resource, 1); std::thread t2(shared_resource, 2); t1.join(); t2.join(); return 0; } 2.线程同步 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;condition_variable\u0026gt; std::mutex mtx; std::condition_variable cv; bool isAExecuted = false; void printHelloA() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx); std::cout \u0026lt;\u0026lt; \u0026#34;hello a\u0026#34; \u0026lt;\u0026lt; std::endl; isAExecuted = true; cv.notify_one(); } void printHelloB() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx); cv.wait(lock, []{ return isAExecuted; }); std::cout \u0026lt;\u0026lt; \u0026#34;hello b\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { std::thread threadA(printHelloA); std::thread threadB(printHelloB); threadA.join(); threadB.join(); return 0; } 数据结构和算法 数组和链表的关系 内存：数组在内存中是连续的一块区域，通过索引可以直接访问任何一个元素。而链表中的每个节点在内存中可以分布在任何位置，它们通过指针来互相连接。因此，相对于数组而言，链表需要额外的指针来维护节点之间的连接，因此需要更多的内存空间。\n性能：数组的访问时间复杂度为O(1)，即无论要访问哪个元素，都可以通过索引直接访问到，因此访问速度非常快。而链表的访问时间复杂度为O(n)，因为需要从头节点开始遍历，直到找到目标节点。但是链表在插入和删除操作时比数组更快，因为只需要修改指针即可，不需要移动大量的数据。\n操作复杂度：对于数组而言，插入和删除操作需要移动其他元素，因此操作复杂度为O(n)。而对于链表而言，插入和删除操作只需要修改指针，因此操作复杂度为O(1)。\nmap和unordered_map的区别 map和unordered_map都是C++ STL（标准模板库）中的关联容器，用于存储键值对。它们之间的主要区别在于实现方式和性能。\nmap底层实现是红黑树（balanced binary search tree），它保证了元素按照键值的大小有序存储，并且支持快速查找、插入和删除操作。但是，由于红黑树是一种平衡二叉树，它的节点操作需要进行比较和旋转等复杂操作，所以性能相对较低，但仍然具有较好的稳定性和可预测性。\nunordered_map底层实现是哈希表（hash table），它通过哈希函数将键映射到桶（bucket）中，并且在桶内使用链表（linked list）或者平衡树（balanced binary search tree）存储值。哈希表的优势在于对于查找、插入和删除等操作，具有常数时间复杂度（O(1)），但是哈希表需要解决哈希冲突等问题，所以需要更多的空间来保证性能和负载因子的平衡，而且其元素顺序是不稳定的。\n哈希表的实现\n对于哈希表的实现，它通常使用了一个数组来存储桶，每个桶都是一个链表，用于存储具有相同哈希值的元素，从而实现O(1)的访问速度。当桶中的元素数量超过一个阈值时，哈希表就会进行扩容，并重新计算所有元素的哈希值。\n总体而言，如果需要对容器中的元素进行排序或者有序访问，那么使用map是更好的选择；如果需要高效的查找、插入和删除操作，那么unordered_map是更好的选择。\n程序 翻转字符串 可以使用双指针法来实现翻转字符串：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; using namespace std; void reverseString(string\u0026amp; s) { int i = 0, j = s.length() - 1; while (i \u0026lt; j) { char temp = s[i]; s[i++] = s[j]; s[j--] = temp; } } int main() { string s = \u0026#34;hello world\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Original string: \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; reverseString(s); cout \u0026lt;\u0026lt; \u0026#34;Reversed string: \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } 用两个栈，设计queue 使用两个栈实现队列可以参考以下步骤：\n定义两个 stack 对象，命名为 inStack 和 outStack，用于存储队列元素。 入队操作：将元素压入 inStack。 出队操作：从 outStack 弹出元素，如果 outStack 为空，则将 inStack 中的所有元素出栈并压入 outStack，再从 outStack 弹出元素。 获取队首元素：从 outStack 弹出元素，如果 outStack 为空，则将 inStack 中的所有元素出栈并压入 outStack，再从 outStack 弹出元素，但不将其出队。 判断队列是否为空：判断 inStack 和 outStack 是否都为空。 以下是代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;stack\u0026gt; template\u0026lt;typename T\u0026gt; class MyQueue { public: void push(const T\u0026amp; value) { inStack.push(value); } void pop() { if (outStack.empty()) { while (!inStack.empty()) { outStack.push(inStack.top()); inStack.pop(); } } outStack.pop(); } T\u0026amp; front() { if (outStack.empty()) { while (!inStack.empty()) { outStack.push(inStack.top()); inStack.pop(); } } return outStack.top(); } bool empty() const { return inStack.empty() \u0026amp;\u0026amp; outStack.empty(); } private: std::stack\u0026lt;T\u0026gt; inStack; std::stack\u0026lt;T\u0026gt; outStack; }; 这个实现在入队操作时只需要将元素压入 inStack，出队和获取队首元素时会先检查 outStack 是否为空，如果为空则将 inStack 中的所有元素转移到 outStack 中，再弹出元素。这样能够确保出队和获取队首元素的时间复杂度为 $O(1)$，而空间复杂度则为 $O(n)$，其中 $n$ 为队列元素个数。\n字符串拼接 可以使用标准库提供的字符串类或者自己实现字符串拼接函数。\n使用标准库提供的字符串类 使用std::string类可以很方便地实现字符串拼接，其operator+和operator+=操作符可以实现两个字符串的拼接或将一个字符串附加到另一个字符串的末尾。例如：\n1 2 3 4 5 std::string str1 = \u0026#34;Hello\u0026#34;; std::string str2 = \u0026#34;World\u0026#34;; std::string result = str1 + \u0026#34; \u0026#34; + str2; // 字符串拼接 str1 += \u0026#34; \u0026#34;; // 在末尾附加空格 str1 += str2; // 在末尾附加str2 自己实现字符串拼接函数 自己实现字符串拼接函数可以通过动态分配内存来实现，可以使用new和delete操作符或者std::allocator类来实现动态内存分配和释放。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;cstring\u0026gt; // for strlen() #include \u0026lt;memory\u0026gt; // for std::allocator #include \u0026lt;iostream\u0026gt; // 自定义字符串拼接函数 char* strconcat(const char* str1, const char* str2) { size_t len1 = strlen(str1); size_t len2 = strlen(str2); // 动态分配内存 std::allocator\u0026lt;char\u0026gt; alloc; char* result = alloc.allocate(len1 + len2 + 1); // 拷贝字符串 std::copy(str1, str1 + len1, result); std::copy(str2, str2 + len2, result + len1); // 添加结尾的空字符 result[len1 + len2] = \u0026#39;\\0\u0026#39;; return result; } int main() { const char* str1 = \u0026#34;Hello\u0026#34;; const char* str2 = \u0026#34;World\u0026#34;; char* result = strconcat(str1, str2); std::cout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; // 释放动态分配的内存 std::allocator\u0026lt;char\u0026gt; alloc; alloc.deallocate(result, strlen(result) + 1); return 0; } 类的各种构造函数 在C++11中，类可以有以下几种构造函数：\n默认构造函数：当没有为对象提供参数时，将调用默认构造函数。默认构造函数无需参数，可以通过编译器自动生成。\n带参数的构造函数：为对象提供参数，初始化对象的数据成员。可以重载多个参数列表不同的构造函数。\n拷贝构造函数：将一个已经存在的对象的数据成员拷贝到一个新的对象中。可以通过定义自己的拷贝构造函数来复制类的对象。\n移动构造函数：用来转移一个对象的资源所有权，而不是进行拷贝，从而提高程序性能。可以通过定义自己的移动构造函数来转移类的对象。\n虚拟构造函数：用于解决动态多态性的问题，允许基类指针调用派生类的构造函数。\n显式构造函数：通过将构造函数声明为explicit，可以禁止隐式类型转换，只能使用显式类型转换来创建对象。\n下面是一个示例代码，演示了这些构造函数的用法：\n1 2 3 4 5 6 7 8 9 10 11 12 class Point { public: Point() : x(0), y(0) { cout \u0026lt;\u0026lt; \u0026#34;Default constructor called.\u0026#34; \u0026lt;\u0026lt; endl; } Point(int x, int y) : x(x), y(y) { cout \u0026lt;\u0026lt; \u0026#34;Constructor with parameters called.\u0026#34; \u0026lt;\u0026lt; endl; } Point(const Point\u0026amp; p) : x(p.x), y(p.y) { cout \u0026lt;\u0026lt; \u0026#34;Copy constructor called.\u0026#34; \u0026lt;\u0026lt; endl; } Point(Point\u0026amp;\u0026amp; p) : x(p.x), y(p.y) { cout \u0026lt;\u0026lt; \u0026#34;Move constructor called.\u0026#34; \u0026lt;\u0026lt; endl; } virtual ~Point() { cout \u0026lt;\u0026lt; \u0026#34;Destructor called.\u0026#34; \u0026lt;\u0026lt; endl; } virtual void Print() { cout \u0026lt;\u0026lt; \u0026#34;Point (\u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; endl; } explicit Point(int xy) : x(xy), y(xy) { cout \u0026lt;\u0026lt; \u0026#34;Explicit constructor called.\u0026#34; \u0026lt;\u0026lt; endl; } private: int x, y; }; 快排 它的基本思想是通过一组排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据小，然后再按此方法对这两部分数据进行快速排序，整个排序过程可以递归进行，以此使所有数据变成有序序列。\n假设当前的待排序的序列为 R[low,hight] ， 其中 low\u0026lt;=hight。同时选取首元素为基准元素。\n步骤一：选取首元素的第一个元素作为基准元素 pivot=R[low] ，i=low ，j=hight。\n步骤二：从右向左扫描，找到小于等于 pivot 的数，如果找到，R[i] 和 R[j] 交换 ，i++。\n步骤三：从左向右扫描，找到大于 pivot 的数，如果找到，R[i] 和 R[j] 交换，j\u0026ndash;。\n步骤四：重复 步骤二~步骤三，直到 j 与 i 的指针重合 返回位置 mid=i ，该位置的数正好是 pivot 元素。\n至此换成一趟排序，此时以 mid 为界线，将数据分割为两个子序列，左侧子序列都比 pivot 数小，右侧子序列都比 pivot 数大，然后再分别对这两个子序列进行快速排序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int part(vector\u0026lt;int\u0026gt;\u0026amp; nums, int l, int r) { int base = nums[l]; int i = l,j = r; while (i\u0026lt;j) { while(nums[j] \u0026gt; base \u0026amp;\u0026amp; i \u0026lt; j) j--; if (i\u0026lt;j) swap(nums[i++],nums[j]); while(nums[i] \u0026lt;= base \u0026amp;\u0026amp; i \u0026lt; j) i++; if (i\u0026lt;j) swap(nums[i],nums[j--]); } return i; } void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;nums, int l, int r) { if (l\u0026lt;r) { int mid = part(nums,l,r); quickSort(nums, l, mid - 1); quickSort(nums, mid + 1, r); } return; } int main() { vector\u0026lt;int\u0026gt; input; int num; while (cin\u0026gt;\u0026gt;num) { input.push_back(num); } for (const auto\u0026amp; x : input) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;; cout\u0026lt;\u0026lt;endl; quickSort(input,0,input.size()-1); for (const auto\u0026amp; x : input) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;; cout\u0026lt;\u0026lt;endl; return 0; } 交换两个数？你有几种方法 1 2 3 4 5 6 7 8 9 10 11 12 13 1) 算术 x = x + y; y = x - y; x = x - y; 2) 异或 x = x^y;// 只能对int,char.. y = x^y; x = x^y; x ^= y ^= x; 操作系统 来源。小林coding\n一、硬件结构 1.1 冯诺依曼模型 计算机基本结构：运算单元、控制单元、存储器、输入设备、输出设备。\n中央处理器与存储单元和输入输出设备通过总线连接：地址总线、控制总线、数据总线。\n内存\n程序和数据存储在内存，存储的区域是线性的。\n存储数据的基本单位是字节，每一个字节都对应一个内存地址。\n中央处理器\n32 位和 64 位，称为 CPU 的位宽，代表 CPU 一次可以计算的数据量。\nCPU 位宽越大，可以计算的数值就越大。32 位 CPU 一次计算 4 个字节，64 位 CPU 一次可以计算 8 个字节。\nCPU 内部还有一些组件，常见的有控制单元、逻辑运算单元和寄存器等。控制单元负责控制 CPU 工作，逻辑运算单元负责计算，寄存器（通用寄存器、程序计数器、指令寄存器）。\n总线\n用于 CPU 和内存或其他设备之间的通信\n地址总线，将要操作的内存地址；CPU 操作4G的内存，就需要 32 条地址总线 数据总线，读写内存的数据； 控制总线，用于发送和接收信号； 1.2 程序执行的基本过程 一个程序执行，CPU 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。\nCPU 从程序计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束，这个不断循环的过程被称为 CPU 的指令周期。\n指令的执行速度\n1GHz的CPU，指的是时钟频率是1G。时钟频率越高，时钟周期就越短，工作速度也就越快。\n程序的CPU执行时间= CPU 时钟周期数（CPU Cycles）和时钟周期时间（Clock Cycle Time）的乘积。\nCPU时钟周期数我们可以进一步拆解成：「指令数 x 每条指令的平均时钟周期数（Cycles Per Instruction，简称 CPI）」\n1.3 存储器的层次结构 存储器通常可以分为这么几个级别：\n寄存器、CPU Cache（L1/L2/L3）、内存、SSD/HDD 硬盘\n1. 寄存器\n寄存器的数量通常在几十到几百之间。寄存器的访问速度非常快，半个 CPU 时钟周期内完成读写。\n2. CPU Cache\n用的是 SRAM（Static Random-Access Memory，静态随机存储器） 芯片。断电丢失。\nCPU 高速缓存通常分为 L1、L2、L3 这样的三层高速缓存，也称为一级缓存、二级缓存、三级缓存。\n**L1 高速缓存。**访问速度几乎和寄存器一样快，通常只需要 2~4 个时钟周期。\n每个 CPU 核心都有一块属于自己的 L1 高速缓存，指令和数据在 L1 是分开存放的，所以 L1 高速缓存通常分成指令缓存和数据缓存。\nLinux 系统中查看L1 Cache容量大小\n1 2 3 4 5 6 # 数据缓存容量大小 $ cat /sys/devices/system/cpu/cpu0/cache/index0/size 32K # 指令缓存容量大小 $ cat /sys/devices/system/cpu/cpu0/cache/index1/size 32K L2 高速缓存位置比 L1 高速缓存距离 CPU 核心更远，大小比 L1 高速缓存更大，访问速度则更慢，速度在 10~20 个时钟周期。\nL3 高速缓存通常是多个 CPU 核心共用的，访问速度在 20~60个时钟周期。\nL1 Cache 和 L2 Cache 都是每个 CPU 核心独有的，而 L3 Cache 是多个 CPU 核心共享的。\n3. 内存\n使用 DRAM （Dynamic Random Access Memory，动态随机存取存储器） 芯片。\n相比 SRAM，DRAM 的密度更高，功耗更低，有更大的容量，而且造价比 SRAM 芯片便宜很多。\n动态：只有不断刷新，数据才能被存储起来。\nDRAM 访问的速度会更慢，DRAM 的数据访问电路和刷新电路都比 SRAM 更复杂，所以访问的速度会更慢，内存速度大概在 200~300 个 时钟周期之间。\n4. SSD/HDD 硬盘\n固体硬盘，断电后数据还存在。内存的读写速度比 SSD 大概快 10~1000 倍。\n机械硬盘，通过物理读写的方式来访问数据的，访问速度是非常慢的，比内存慢 10W 倍左右。\n当 CPU 需要访问内存中某个数据的时候，如果寄存器有这个数据，CPU 就直接从寄存器取数据即可，如果寄存器没有这个数据，CPU 就会查询 L1 高速缓存，如果 L1 没有，则查询 L2 高速缓存，L2 还是没有的话就查询 L3 高速缓存，L3 依然没有的话，才去内存中取数据。\n1.4 写出让 CPU 跑得更快的代码？ CPU通过直接映射Cache访问内存数据\n一个内存的访问地址，包括组标记、CPU Cache Line 索引、偏移量这三种信息，于是 CPU 就能通过这些信息，在 CPU Cache 中找到缓存的数据。而对于 CPU Cache 里的数据结构，则是由索引 + 有效位 + 组标记 + 数据块组成。\n如果内存中的数据已经在 CPU Cache 中了，那 CPU 访问一个内存地址的时候，会经历这 4 个步骤：\n根据内存地址中索引信息，计算在 CPU Cache 中的索引，也就是找出对应的 CPU Cache Line 的地址； 找到对应 CPU Cache Line 后，判断 CPU Cache Line 中的有效位，确认 CPU Cache Line 中数据是否是有效的，如果是无效的，CPU 就会直接访问内存，并重新加载数据，如果数据有效，则往下执行； 对比内存地址中组标记和 CPU Cache Line 中的组标记，确认 CPU Cache Line 中的数据是我们要访问的内存数据，如果不是的话，CPU 就会直接访问内存，并重新加载数据，如果是的话，则往下执行； 根据内存地址中偏移量信息，从 CPU Cache Line 的数据块中，读取对应的字。 访问的数据在 CPU Cache 中的话，意味着缓存命中，缓存命中率越高的话，代码的性能就会越好，CPU 也就跑的越快。\n遍历数组的情况时，按照内存布局顺序访问，将可以有效的利用 CPU Cache 带来的好处，这样我们代码的性能就会得到很大的提升\n当有多个同时执行「计算密集型」的线程，为了防止因为切换到不同的核心，而导致缓存命中率下降的问题，我们可以把线程绑定在某一个 CPU 核心上，这样性能可以得到非常可观的提升。\n1.5 缓存一致性问题 CPU Cache 是由很多个 Cache Line 组成的，CPU Line 是 CPU 从内存读取数据的基本单位，而 CPU Line 是由各种标志（Tag）+ 数据块（Data Block）组成，\n如果数据写入 Cache 之后，内存与 Cache 相对应的数据将会不同，这种情况下 Cache 和内存数据都不一致了，于是我们肯定是要把 Cache 中的数据同步到内存里的。\n两种针对写入数据的方法：\n保持内存与 Cache 一致性最简单的方式是，把数据同时写入内存和 Cache 中，这种方法称为写直达（*Write Through*）。 为了要减少数据写回内存的频率，就出现了写回（*Write Back*）的方法。 在写回机制中，当发生写操作时，新的数据仅仅被写入 Cache Block 里，只有当修改过的 Cache Block「被替换」时才需要写到内存中，减少了数据写回内存的频率，这样便可以提高系统的性能。\n写回这个方法，在把数据写入到 Cache 的时候，只有在缓存不命中，同时数据对应的 Cache 中的 Cache Block 为脏标记的情况下，才会将数据写到内存中，而在缓存命中的情况下，则在写入后 Cache 后，只需把该数据对应的 Cache Block 标记为脏即可，而不用写到内存里。\n缓存一致性问题，A 号核心和 B 号核心的缓存，在这个时候是不一致，从而会导致执行结果的错误。\n要解决这一问题，就需要一种机制，来同步两个不同核心里面的缓存数据。要实现的这个机制的话，要保证做到下面这 2 点：\n第一点，某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为写传播（Write Propagation）； 第二点，某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为事务的串行化（Transaction Serialization）。 写传播很容易就理解，当某个核心在 Cache 更新了数据，就需要同步到其他核心的 Cache 里。\n要实现事务串行化，要做到 2 点：\nCPU 核心对于 Cache 中数据的操作，需要同步给其他 CPU 核心； 要引入「锁」的概念，如果两个 CPU 核心里有相同数据的 Cache，那么对于这个 Cache 数据的更新，只有拿到了「锁」，才能进行对应的数据更新。 1.6 中断 中断是系统用来响应硬件设备请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求。\n中断处理程序，要尽可能快的执行完，这样可以减少对正常进程运行调度地影响。\n中断请求的处理程序应该要短且快，这样才能减少对正常进程运行调度地影响，而且中断处理程序可能会暂时关闭中断，这时如果中断处理程序执行时间过长，可能在还未执行完中断处理程序前，会丢失当前其他设备的中断请求。\n那 Linux 系统为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段，分别是「上半部和下半部分」。\n上半部用来快速处理中断，一般会暂时关闭中断请求，主要负责处理跟硬件紧密相关或者时间敏感的事情。 下半部用来延迟处理上半部未完成的工作，一般以「内核线程」的方式运行。 中断处理程序的上部分和下半部可以理解为：\n上半部直接处理硬件请求，也就是硬中断，负责耗时短的工作，快速执行； 下半部是由内核触发，也就说软中断，负责上半部未完成的工作，通常都是耗时比较长的事情，延迟执行； 硬中断（上半部）是会打断 CPU 正在执行的任务，然后立即执行中断处理程序，而软中断（下半部）是以内核线程的方式执行，并且每一个 CPU 都对应一个软中断内核线程，名字通常为「ksoftirqd/CPU 编号」\n1.7 操作系统内核 内核作为应用连接硬件设备的桥梁。\n现代操作系统，内核一般会提供 4 个基本能力：\n管理进程、线程，决定哪个进程、线程使用 CPU，也就是进程调度的能力； 管理内存，决定内存的分配和回收，也就是内存管理的能力； 管理硬件设备，为进程与硬件设备之间提供通信能力，也就是硬件通信能力； 提供系统调用，如果应用程序要运行更高权限运行的服务，那么就需要有系统调用，它是用户程序与操作系统之间的接口。 Linux 内核设计的理念主要有这几个点：\nMultiTask，多任务 SMP，对称多处理 ELF，可执行文件链接格式 Monolithic Kernel，宏内核 二、内存管理 2.1 虚拟内存 将不同进程的虚拟地址和不同内存的物理地址映射起来。\n程序访问虚拟地址的时候，由操作系统转换成不同的物理地址，不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。\n程序所使用的内存地址叫做虚拟内存地址（Virtual Memory Address） 实际存在硬件里面的空间地址叫物理内存地址（Physical Memory Address）。 虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址。\n操作系统是如何管理虚拟地址与物理地址之间的关系？\n主要有两种方式，分别是内存分段和内存分页：\n内存分段 分段机制下，虚拟地址和物理地址是如何映射的？\n分段机制下的虚拟地址由两部分组成，段选择因子和段内偏移量。\n段选择因子里面最重要的是段号，用作段表的索引。段表保存这个段的基地址、段的界限和特权等级等。 段内偏移量应该位于 0 和段界限之间，物理内存地址=段基地址+段内偏移量。 不足之处：\n第一个就是内存碎片的问题。 第二个就是内存交换的效率低的问题。 内存分段会出现内存碎片吗？\n内存碎片分为，内部内存碎片和外部内存碎片。\n内存分段管理可以做到段根据实际需求分配内存，有多少需求就分配多大的段，不会出现内部内存碎片。\n多个段未必能恰好使用所有的内存空间，会产生多个不连续的小物理内存，导致新的程序无法被装载，所以会出现外部内存碎片的问题。\n解决「外部内存碎片」的问题就是使用内存交换。\n分段为什么会导致内存交换效率低的问题？\n对于多进程的系统来说，用分段的方式，外部内存碎片是很容易产生的，产生了外部内存碎片，那不得不重新 Swap 内存区域，这个过程会产生性能瓶颈。\n因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。\n内存分页 分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页。在 Linux 下，每一页的大小为 4KB。\n分页机制下，虚拟地址和物理地址是如何映射的？\n在分页机制下，虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，物理内存地址=基地址+页内偏移。\n对于一个内存地址转换，其实就是这样三个步骤：\n把虚拟内存地址，切分成页号和偏移量； 根据页号，从页表里面，查询对应的物理页号； 直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。 虚拟地址与物理地址之间通过页表来映射，\n页表是存储在内存里的，内存管理单元 （MMU）就做将虚拟内存地址转换成物理地址的工作。\n而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。\n分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？\n分页中，页与页之间是紧密排列的，所以不会有外部碎片。\n但是，内存分页机制分配内存的最小单位是一页，即使程序不足一页大小，我们最少只能分配一个页，所以页内会出现内存浪费，所以内存分页机制会有内部内存碎片。\n如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为换出。一旦需要的时候，再加载进来，称为换入。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。\n加载程序的时候，不再需要一次性都把程序加载到物理内存中。只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。\n简单的分页有什么缺陷？\n有空间上的缺陷。\n因为操作系统是可以同时运行非常多的进程的，这意味着页表会非常的庞大。\n在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 4MB 的内存来存储页表。\n每个进程都是有自己的虚拟地址空间的，都有自己的页表。那么，100 个进程的话，就需要 400MB 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。\n要解决上面的问题，就需要采用一种叫作多级页表的解决方案。\n把这个 100 多万个「页表项」的单级页表再分页，将一级页表分为 1024 个二级页表，每个二级页表中包含 1024 个「页表项」，形成二级分页。\n由于局部性原理。如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表。\n保存在内存中的页表承担的职责是将虚拟地址翻译成物理地址。假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了。所以页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项\n对于 64 位的系统，两级分页肯定不够了，就变成了四级目录。\n快表\n程序是有局部性的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。利用这一特性，把最常访问的几个页表项存储到访问速度更快的硬件，于是在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB（Translation Lookaside Buffer） ，通常称为页表缓存、转址旁路缓存、快表等。\n在 CPU 芯片里面，封装了内存管理单元（Memory Management Unit）芯片，它用来完成地址转换和 TLB 的访问与交互。\n有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。\nTLB 的命中率其实是很高的，因为程序最常访问的页就那么几个。\n段页式内存管理\n内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为段页式内存管理。\n段页式内存管理实现的方式：\n先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制； 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页； 这样，地址结构就由段号、段内页号和页内位移三部分组成。\nLinux 的虚拟地址空间是如何分布的？\n在 Linux 操作系统中，虚拟地址空间的内部又被分为内核空间和用户空间两部分，最常见的 32 位和 64 位系统，如下所示：\n可以看出：\n32 位系统的内核空间占用 1G，位于最高处，剩下的 3G 是用户空间； 64 位系统的内核空间和用户空间都是 128T，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。 再来说说，内核空间与用户空间的区别：\n进程在用户态时，只能访问用户空间内存； 只有进入内核态后，才可以访问内核空间的内存； 虽然每个进程都各自有独立的虚拟内存，但是每个虚拟内存中的内核地址，其实关联的都是相同的物理内存。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。\n用户空间分布的情况，以 32 位系统为例\n用户空间内存，从低到高分别是 6 种不同的内存段：\n代码段，包括二进制可执行代码； 数据段，包括已初始化的静态常量和全局变量； BSS 段，包括未初始化的静态变量和全局变量； 堆段，包括动态分配的内存，从低地址开始向上增长； 文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关）； 栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小； 上图中的内存布局可以看到，代码段下面还有一段内存空间的（灰色部分），这一块区域是「保留区」，之所以要有保留区这是因为在大多数的系统里，我们认为比较小数值的地址不是一个合法地址，例如，我们通常在 C 的代码里会将无效的指针赋值为 NULL。因此，这里会出现一段不可访问的内存保留区，防止程序因为出现 bug，导致读或写了一些小内存地址的数据，而使得程序跑飞。\n在这 7 个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 malloc() 或者 mmap() ，就可以分别在堆和文件映射段动态分配内存。\n在 4GB 物理内存的机器上，申请 8G 内存会怎么样？\n在32 位操作系统，进程最多只能申请 3 GB 大小的虚拟内存空间，所以进程申请 8GB 内存的话，在申请虚拟内存阶段就会失败。\n在 64 位操作系统，进程可以使用 128 TB 大小的虚拟内存空间，所以进程申请 8GB 内存是没问题的，因为进程申请内存是申请虚拟内存，只要不读写这个虚拟内存，操作系统就不会分配物理内存。\n2.2 malloc 是如何分配内存的 malloc申请内存的时候，会有两种方式向操作系统申请堆内存。\n方式一：通过 brk() 系统调用从堆分配内存 方式二：通过 mmap() 系统调用在文件映射区域分配内存； 用户分配的内存小于 128 KB，则通过 brk() 申请内存；大于 128 KB，则通过 mmap() 申请内存；\nmalloc() 在分配内存的时候，并不是老老实实按用户预期申请的字节数来分配内存空间大小，而是会预分配更大的空间作为内存池。\nmalloc 申请的内存，free 释放内存会归还给操作系统吗？\nmalloc 通过 brk() 方式申请的内存，free 释放内存的时候，并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用； malloc 通过 mmap() 方式申请的内存，free 释放内存的时候，会把内存归还给操作系统，内存得到真正的释放。 为什么不全部使用 mmap或全用brk？\n频繁通过 mmap 分配的内存的话，不仅每次都会发生运行态的切换，还会发生缺页中断（在第一次访问虚拟地址后），这样会导致 CPU 消耗较大。 brk() 系统调用在堆空间申请内存的时候，由于堆空间是连续的，所以直接预分配更大的内存来作为内存池，当内存释放的时候，就缓存在内存池中。\n随着系统频繁地使用brk，尤其对于小块内存，堆内将产生越来越多不可用的碎片，导致“内存泄露”。\nfree() 函数只传入一个内存地址，为什么能知道要释放多大的内存？\nmalloc 返回给用户态的内存起始地址比进程的堆空间起始地址多 16 字节\n执行 free() 函数时，free 会对传入进来的内存地址向左偏移 16 字节，多出来的 16 字节就是保存了该内存块的描述信息，比如有该内存块的大小。\n2.3 内存分配的过程 应用程序通过 malloc 函数申请内存的时候，实际上申请的是虚拟内存，此时并不会分配物理内存。\n当应用程序读写了这块虚拟内存，CPU 就会去访问这个虚拟内存， 这时会发现这个虚拟内存没有映射到物理内存， CPU 就会产生缺页中断，进程会从用户态切换到内核态，并将缺页中断交给内核的 Page Fault Handler （缺页中断函数）处理。\n缺页中断处理函数会看是否有空闲的物理内存，如果有，就直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系。\n如果没有空闲的物理内存，那么内核就会开始进行回收内存的工作，回收的方式主要是两种：直接内存回收和后台内存回收。\n后台内存回收（kswapd）：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程异步的，不会阻塞进程的执行。 直接内存回收（direct reclaim）：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是同步的，会阻塞进程的执行。 如果直接内存回收后，空闲的物理内存仍然无法满足此次物理内存的申请，那么内核就会放最后的大招了 ——触发 OOM （Out of Memory）机制。\nOOM Killer 机制会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。\n哪些内存可以被回收？\n主要有两类内存可以被回收，而且它们的回收方式也不同。\n文件页：内核缓存的磁盘数据和内核缓存的文件数据都叫作文件页。大部分文件页，都可以直接释放内存，以后有需要时，再从磁盘重新读取就可以了。而那些被应用程序修改过，并且暂时还没写入磁盘的数据（也就是脏页），就得先写入磁盘，然后才能进行内存释放。所以，回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存。 匿名页：这部分内存没有实际载体，比如堆、栈数据等。这部分内存很可能还要再次被访问，所以不能直接释放内存，它们回收的方式是通过 Linux 的 Swap 机制，Swap 会把不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。 文件页和匿名页的回收都是基于 LRU 算法，也就是优先回收不常访问的内存。LRU 回收算法，实际上维护着 active 和 inactive 两个双向链表，其中：\nactive_list 活跃内存页链表，这里存放的是最近被访问过（活跃）的内存页； inactive_list 不活跃内存页链表，这里存放的是很少被访问（非活跃）的内存页； 越接近链表尾部，就表示内存页越不常访问。这样，在回收内存时，系统就可以根据活跃程度，优先回收不活跃的内存。\nNUMA 架构下的内存回收策略\nSMP 指的是一种多个 CPU 处理器共享资源的电脑硬件架构，也就是说每个 CPU 地位平等，它们共享相同的物理资源，包括总线、内存、IO、操作系统等。每个 CPU 访问内存所用时间都是相同的，因此，这种系统也被称为一致存储访问结构（UMA）。\n随着 CPU 处理器核数的增多，多个 CPU 都通过一个总线访问内存，这样总线的带宽压力会越来越大，同时每个 CPU 可用带宽会减少，这也就是 SMP 架构的问题。\n非一致存储访问结构（NUMA）将每个 CPU 进行了分组，每一组 CPU 用 Node 来表示，一个 Node 可能包含多个 CPU 。\n每个 Node 有自己独立的资源，包括内存、IO 等，每个 Node 之间可以通过互联模块总线（QPI）进行通信，所以，也就意味着每个 Node 上的 CPU 都可以访问到整个系统中的所有内存。但是，访问远端 Node 的内存比访问本地内存要耗时很多。\n在 NUMA 架构下，当某个 Node 内存不足时，系统可以从其他 Node 寻找空闲内存，也可以从本地内存中回收内存。\n在使用 NUMA 架构的服务器，如果系统出现还有一半内存的时候，却发现系统频繁触发「直接内存回收」，导致了影响了系统性能，那么大概率是因为当本地内存不足的时候，只选择回收本地内存的方式，而不去使用其他 Node 的空闲内存。\n虽然说访问远端 Node 的内存比访问本地内存要耗时很多，但是相比内存回收的危害而言，访问远端 Node 的内存带来的性能影响还是比较小的。\n如何保护一个进程不被 OOM 杀掉呢？\n在系统空闲内存不足的情况，进程申请了一个很大的内存，如果直接内存回收都无法回收出足够大的空闲内存，那么就会触发 OOM 机制，内核就会根据算法选择一个进程杀掉。\nLinux会把系统中可以被杀掉的进程扫描一遍，并对每个进程打分，得分最高的进程就会被首先杀掉。\n进程得分的结果受下面这两个方面影响：\n第一，进程已经使用的物理内存页面数。 第二，每个进程的 OOM 校准值 oom_score_adj。 每个进程的 oom_score_adj 默认值都为 0，所以最终得分跟进程自身消耗的内存有关，消耗的内存越大越容易被杀掉。\n我们最好将一些很重要的系统服务的 oom_score_adj 配置为 -1000，比如 sshd，因为这些系统服务一旦被杀掉，我们就很难再登陆进系统了。\n但是，不建议将我们自己的业务程序的 oom_score_adj 设置为 -1000，因为业务程序一旦发生了内存泄漏，而它又不能被杀掉，这就会导致随着它的内存开销变大，OOM killer 不停地被唤醒，从而把其他进程一个个给杀掉。\n2.4 改进 LRU 算法 传统的 LRU 算法的实现思路是这样的：\n当访问的页在内存里，就直接把该页对应的 LRU 链表节点移动到链表的头部。 当访问的页不在内存里，除了要把该页放入到 LRU 链表的头部，还要淘汰 LRU 链表末尾的页。 传统的 LRU 算法无法避免下面这两个问题：\n预读失效导致缓存命中率下降； 缓存污染导致缓存命中率下降； 预读失效，怎么办？\n什么是预读机制？\nLinux 操作系统为基于 Page Cache 的读缓存机制提供预读机制，一个例子是：\n应用程序只想读取磁盘上文件 A 的 offset 为 0-3KB 范围内的数据，由于磁盘的基本读写单位为 block（4KB），于是操作系统至少会读 0-4KB 的内容，这恰好可以在一个 page 中装下。 但是操作系统出于空间局部性原理（靠近当前被访问数据的数据，在未来很大概率会被访问到），会选择将磁盘块 offset [4KB,8KB)、[8KB,12KB) 以及 [12KB,16KB) 都加载到内存，于是额外在内存中申请了 3 个 page； 应用程序利用 read 系统调动读取 4KB 数据，实际上内核使用预读机制（ReadaHead） 机制完成了 16KB 数据的读取，也就是通过一次磁盘顺序读将多个 Page 数据装入 Page Cache。\n这样下次读取 4KB 数据后面的数据的时候，就不用从磁盘读取了，直接在 Page Cache 即可命中数据。因此，预读机制带来的好处就是减少了 磁盘 I/O 次数，提高系统磁盘 I/O 吞吐量。\n预读失效会带来什么问题？\n如果这些被提前加载进来的页，并没有被访问，相当于这个预读工作是白做了，这个就是预读失效。\n如果使用传统的 LRU 算法，就会把「预读页」放到 LRU 链表头部，而当内存空间不够的时候，还需要把末尾的页淘汰掉。\n如果这些「预读页」如果一直不会被访问到，就会出现一个很奇怪的问题，不会被访问的预读页却占用了 LRU 链表前排的位置，而末尾淘汰的页，可能是热点数据，这样就大大降低了缓存命中率 。\nLinux 是如何避免预读失效带来的影响？\nLinux 操作系统实现两个了 LRU 链表：活跃 LRU 链表（active_list）和非活跃 LRU 链表（inactive_list）。\nactive list 活跃内存页链表，这里存放的是最近被访问过（活跃）的内存页； inactive list 不活跃内存页链表，这里存放的是很少被访问（非活跃）的内存页； 有了这两个 LRU 链表后，预读页就只需要加入到 inactive list 区域的头部，当页被真正访问的时候，才将页插入 active list 的头部。如果预读的页一直没有被访问，就会从 inactive list 移除，这样就不会影响 active list 中的热点数据。\n缓存污染会带来什么问题？\n缓存污染带来的影响就是很致命的，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 I/O，系统性能就会急剧下降。\n我以 MySQL 举例子，Linux 发生缓存污染的现象也是类似。\n当某一个 SQL 语句扫描了大量的数据时，可能会导致大量热数据被淘汰了，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 I/O，MySQL 性能就会急剧下降。\n注意， 缓存污染并不只是查询语句查询出了大量的数据才出现的问题，即使查询出来的结果集很小，也会造成缓存污染。\n怎么避免缓存污染造成的影响？\n前面的 LRU 算法只要数据被访问一次，就将数据加入活跃 LRU 链表（或者 young 区域），这种 LRU 算法进入活跃 LRU 链表的门槛太低了！正式因为门槛太低，才导致在发生缓存污染的时候，很容就将原本在活跃 LRU 链表里的热点数据淘汰了。\n所以，只要我们提高进入到活跃 LRU 链表的门槛，就能有效地保证活跃 LRU 链表里的热点数据不会被轻易替换掉。\nLinux 操作系统：在内存页被访问第二次的时候，才将页从 inactive list 升级到 active list 里。 在批量读取数据时候，如果这些大量数据只会被访问一次，那么它们就不会进入到活跃 LRU 链表（或者 young 区域），也就不会把热点数据淘汰，只会待在非活跃 LRU 链表中，后续很快也会被淘汰。\n2.5 深入理解Linux虚拟内存 虚拟地址是什么\n32 位虚拟地址的格式为：页目录项（10位）+ 页表项（10位） + 页内偏移（12位）。共 32 位组成的虚拟内存地址。\n进程虚拟内存空间中的每一个字节都有与其对应的虚拟内存地址，一个虚拟内存地址表示进程虚拟内存空间中的一个特定的字节。\n为什么要使用虚拟地址访问内存\n在直接操作物理内存的情况下，我们需要知道每一个变量的位置都被安排在了哪里，而且还要注意和多个进程同时运行的时候，不能共用同一个地址，否则就会造成地址冲突。\n而当 CPU 访问进程的虚拟地址时，虚拟地址转换成不同的物理地址，这样不同的进程运行的时候，虽然操作的是同一虚拟地址，但其实背后写入的是不同的物理地址，这样就不会冲突了。\n程序局部性原理表现为：时间局部性和空间局部性。时间局部性是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某块数据被访问，则不久之后该数据可能再次被访问。空间局部性是指一旦程序访问了某个存储单元，则不久之后，其附近的存储单元也将被访问。\n因此。无论一个进程实际可以占用的内存资源有多大，根据程序局部性原理，在某一段时间内，进程真正需要的物理内存其实是很少的一部分，只需要为每个进程分配很少的物理内存就可以保证进程的正常执行运转。\n虚拟内存引入之后，**每个进程都拥有自己独立的虚拟地址空间，进程与进程之间的虚拟内存地址空间是相互隔离，互不干扰的。**每个进程都认为自己独占所有内存空间。\n可以将多进程之间协同的相关复杂细节统统交给内核中的内存管理模块来处理。这一切都是因为虚拟内存能够提供内存地址空间的隔离，极大地扩展了可用空间。\n任何一个虚拟内存里所存储的数据，本质上还是保存在真实的物理内存里的。只不过内核帮我们做了虚拟内存到物理内存的这一层映射，将不同进程的虚拟地址和不同内存的物理地址映射起来。\n进程虚拟内存空间\n用于存放进程程序二进制文件中的机器指令的代码段 用于存放程序二进制文件中定义的全局变量和静态变量的数据段和 BSS 段。 用于在程序运行过程中动态申请内存的堆。 用于存放动态链接库以及内存映射区域的文件映射与匿名映射区。 用于存放函数调用过程中的局部变量和函数参数的栈。 程序代码事先编写好，然后编译成二进制文件存放在磁盘中，CPU 会执行二进制文件中的机器码来驱动进程的运行。所以在进程运行之前，这些存放在二进制文件中的机器码需要被加载进内存中，而用于存放这些机器码的虚拟内存空间叫做代码段。\n全局变量在程序编译之后也会存储在二进制文件中，在程序运行之前，这些全局变量也需要被加载进内存中供程序访问。\n代码中被我们指定了初始值的全局变量和静态变量在虚拟内存空间中的存储区域我们叫做数据段。\n没有指定初始值的全局变量和静态变量在虚拟内存空间中的存储区域我们叫做 BSS 段。这些未初始化的全局变量被加载进内存之后会被初始化为 0 值。\nBSS 段中的数据也存在于二进制文件中，因为内核知道这些数据是没有初值的，所以在二进制文件中只会记录 BSS 段的大小，在加载进内存时会生成一段 0 填充的内存空间。\n这些全局变量和静态变量都是在编译期间就确定的。\n但是我们程序在运行期间往往需要动态的申请内存，所以在虚拟内存空间中也需要一块区域来存放这些动态申请的内存，这块区域就叫做堆。\n程序在运行过程中还需要依赖动态链接库，这些动态链接库以 .so 文件的形式存放在磁盘中，这些动态链接库也有自己的对应的代码段，数据段，BSS 段，也需要一起被加载进内存中。\n还有用于内存文件映射的系统调用 mmap，会将文件与内存进行映射。\n这些动态链接库中的代码段，数据段，BSS 段，以及通过 mmap 系统调用映射的共享内存区，在虚拟内存空间的存储区域叫做文件映射与匿名映射区。\n在文件映射与匿名映射区的地址增长方向是从高地址向低地址增长。\n程序运行调用各种函数过程中使用到的局部变量和函数参数也需要一块内存区域来保存。这一块区域在虚拟内存空间中叫做栈。\n32 位机器上进程虚拟内存空间分布\n在 32 位机器上，指针的寻址范围为 2^32，所能表达的虚拟内存空间为 4 GB。所以在 32 位机器上进程的虚拟内存地址范围为：0x0000 0000 - 0xFFFF FFFF。\n其中用户态虚拟内存空间为 3 GB，虚拟内存地址范围为：0x0000 0000 - 0xC000 000 。\n内核态虚拟内存空间为 1 GB，虚拟内存地址范围为：0xC000 000 - 0xFFFF FFFF。\n代码段并不是从 0x0000 0000 地址开始的，而是从 0x0804 8000 地址开始。\n0x0000 0000 到 0x0804 8000 这段虚拟内存地址是一段不可访问的保留区，因为在大多数操作系统中，数值比较小的地址通常被认为不是一个合法的地址，这块小地址是不允许访问的。比如在 C 语言中我们通常会将一些无效的指针设置为 NULL，指向这块不允许访问的地址。\n64 位系统下只使用了 48 位来描述虚拟内存空间，寻址范围为 2^48 ，所能表达的虚拟内存空间为 256TB。\n64 位系统中的虚拟内存布局和 32 位系统中的虚拟内存布局大体上是差不多的。主要不同的地方有三点：\n就是前边提到的由高 16 位空闲地址造成的 canonical address 空洞。在这段范围内的虚拟内存地址是不合法的，因为它的高 16 位既不全为 0 也不全为 1，不是一个 canonical address，所以称之为 canonical address 空洞。 在代码段跟数据段的中间还有一段不可以读写的保护段，它的作用是防止程序在读写数据段的时候越界访问到代码段，这个保护段可以让越界访问行为直接崩溃，防止它继续往下运行。 用户态虚拟内存空间与内核态虚拟内存空间分别占用 128T，其中低128T 分配给用户态虚拟内存空间，虚拟内存地址范围为：0x0000 0000 0000 0000 - 0x0000 7FFF FFFF F000 。高 128T 分配给内核态虚拟内存空间，虚拟内存地址范围为：0xFFFF 8000 0000 0000 - 0xFFFF FFFF FFFF FFFF 。 通过 fork() 函数创建出的子进程，它的虚拟内存空间以及相关页表相当于父进程虚拟内存空间的一份拷贝，直接从父进程中拷贝到子进程中。\n通过 vfork 或者 clone 系统调用创建出的子进程，父进程和子进程的虚拟内存空间是共享的。也就是说父子进程之间使用的虚拟内存空间是一样的，并不是一份拷贝。\n内核虚拟内存空间\n内核态虚拟内存空间是所有进程共享的，不同进程进入内核态之后看到的虚拟内存空间是一样的。\n在总共大小 1G 的内核虚拟内存空间中，位于最前边有一块 896M 大小的区域，我们称之为直接映射区或者线性映射区，地址范围为 3G \u0026ndash; 3G + 896m 。\n直接映射区虚拟内存地址会映射到 0 - 896M 这块连续的物理内存上。\n虽然这块区域中的虚拟地址是直接映射到物理地址上，但是内核在访问这段区域的时候还是走的虚拟内存地址，内核也会为这块空间建立映射页表。\n使用 fork 系统调用创建进程的时候，内核会创建一系列进程相关的描述符，比如之前提到的进程的核心数据结构 task_struct，进程的内存空间描述符 mm_struct，以及虚拟内存区域描述符 vm_area_struct 等。进程相关的数据结构也会存放在物理内存前 896M 的这段区域中。\n当进程被创建完毕之后，在内核运行的过程中，会涉及内核栈的分配，内核会为每个进程分配一个固定大小的内核栈，每个进程的整个调用链必须放在自己的内核栈中，内核栈也是分配在直接映射区。\n直接映射区的前 16M 专门让内核用来为 DMA （直接内存存取）分配内存，这块 16M 大小的内存区域我们称之为 ZONE_DMA。\n直接映射区中剩下的部分也就是从 16M 到 896M（不包含 896M）这段区域，我们称之为 ZONE_NORMAL。\n物理内存 896M 以上的区域被内核划分为 ZONE_HIGHMEM 区域，我们称之为高端内存。\n物理内存假设为 4G，高端内存区域为 4G - 896M = 3200M。内核剩余可用的虚拟内存空间就变为了 1G - 896M = 128M。\n物理内存中的 ZONE_HIGHMEM 区域就只能采用动态映射的方式映射到 128M 大小的内核虚拟内存空间中，也就是说只能动态的一部分一部分的分批映射，先映射正在使用的这部分，使用完毕解除映射，接着映射其他部分。\nvmalloc 动态映射区。采用动态映射的方式映射物理内存中的高端内存。\n和用户态进程使用 malloc 申请内存一样，在这块动态映射区内核是使用 vmalloc 进行内存分配。由于之前介绍的动态映射的原因，vmalloc 分配的内存在虚拟内存上是连续的，但是物理内存是不连续的。通过页表来建立物理内存与虚拟内存之间的映射关系，从而可以将不连续的物理内存映射到连续的虚拟内存上。\n永久映射区。在内核的这段虚拟地址空间中允许建立与物理高端内存的长期映射关系。\n在固定映射区中的虚拟内存地址可以自由映射到物理内存的高端地址上，但是与动态映射区以及永久映射区不同的是，在固定映射区中虚拟地址是固定的，而被映射的物理地址是可以改变的。也就是说，有些虚拟地址在编译的时候就固定下来了，是在内核启动过程中被确定的，而这些虚拟地址对应的物理地址不是固定的。 在内核的启动过程中，有些模块需要使用虚拟内存并映射到指定的物理地址上，而且这些模块也没有办法等待完整的内存管理模块初始化之后再进行地址映射。因此，内核固定分配了一些虚拟地址，这些地址有固定的用途，使用该地址的模块在初始化的时候，将这些固定分配的虚拟地址映射到指定的物理地址上去\n在内核虚拟内存空间中的最后一块区域为临时映射区。\n32位体系结构下 Linux 虚拟内存空间整体布局 什么是物理内存\n内存也叫随机访问存储器（ random-access memory ）也叫 RAM 。而 RAM 分为两类：\n一类是静态 RAM（ SRAM ），这类 SRAM 用于 CPU 高速缓存，访问速度快，但是容量小，造价高。 另一类则是动态 RAM ( DRAM )，这类 DRAM 用于我们常说的主存上，其特点的是访问速度慢（相对高速缓存），但是容量大，造价便宜些（相对高速缓存）。 多个存储器模块连接到存储控制器上，就聚合成了主存。DRAM 芯片就包装在存储器模块中，每个存储器模块中包含 8 个 DRAM 芯片。 每一个 DRAM 芯片的存储结构是一个二维矩阵，二维矩阵中存储的元素我们称为超单元（supercell），每个 supercell 大小为一个字节（8 bit）。每个 supercell 都由一个坐标地址（i，j）。i 在计算机中行地址称为 RAS (row access strobe，行访问选通脉冲)。 j 在计算机中列地址称为 CAS (column access strobe,列访问选通脉冲)。 因为 DRAM 芯片的 IO 单位为一个字节（8 bit），所以需要 8 个 data 引脚从 DRAM 芯片传入传出数据。\nDRAM 芯片的访问\n首先存储控制器将行地址 RAS = 2 通过地址引脚发送给 DRAM 芯片。\nDRAM 芯片根据 RAS = 2 将二维矩阵中的第二行的全部内容拷贝到内部行缓冲区中。\n接下来存储控制器会通过地址引脚发送 CAS = 2 到 DRAM 芯片中。\nDRAM芯片从内部行缓冲区中根据 CAS = 2 拷贝出第二列的 supercell 并通过数据引脚发送给存储控制器。\nCPU 是如何访问内存的： CPU 与内存之间的数据交互是通过总线完成的，而数据在总线上的传送是通过一系列的步骤完成的，这些步骤称为总线事务。\n其中数据从内存传送到 CPU 称之为读事务（read transaction），数据从 CPU 传送到内存称之为写事务（write transaction）。\n总线上传输的信号包括：地址信号，数据信号，控制信号。其中控制总线上传输的控制信号可以同步事务，并能够标识出当前正在被执行的事务信息：\n系统总线是连接 CPU 与 IO bridge 的，存储总线是来连接 IO bridge 和主存的。\nIO bridge 负责将系统总线上的电子信号转换成存储总线上的电子信号。IO bridge 也会将系统总线和存储总线连接到IO总线（磁盘等IO设备）上。这里我们看到 IO bridge 其实起的作用就是转换不同总线上的电子信号。\nCPU 从内存读取数据过程\n首先 CPU 芯片中的总线接口会在总线上发起读事务（read transaction）。 该读事务分为以下步骤进行：\nCPU 将物理内存地址 A 放到系统总线上。随后 IO bridge 将信号传递到存储总线上。 主存感受到存储总线上的地址信号并通过存储控制器将存储总线上的物理内存地址 A 读取出来。 存储控制器通过物理内存地址 A 定位到具体的存储器模块，从 DRAM 芯片中取出物理内存地址 A 对应的数据 X。 存储控制器将读取到的数据 X 放到存储总线上，随后 IO bridge 将存储总线上的数据信号转换为系统总线上的数据信号，然后继续沿着系统总线传递。 CPU 芯片感受到系统总线上的数据信号，将数据从系统总线上读取出来并拷贝到寄存器中。 如何根据物理内存地址从主存中读取数据\n存储控制器会将物理内存地址转换为 DRAM 芯片中 supercell 在二维矩阵中的坐标地址(RAS，CAS)。并将这个坐标地址发送给对应的存储器模块。随后存储器模块会将 RAS 和 CAS 广播到存储器模块中的所有 DRAM 芯片。依次通过 (RAS，CAS) 从 DRAM0 到 DRAM7 读取到相应的 supercell 。\n我们知道一个 supercell 存储了一个字节（ 8 bit ） 数据，这里我们从 DRAM0 到 DRAM7 依次读取到了 8 个 supercell 也就是 8 个字节，然后将这 8 个字节返回给存储控制器，由存储控制器将数据放到存储总线上。\nCPU 总是以 word size 为单位从内存中读取数据，在 64 位处理器中的 word size 为 8 个字节。64 位的内存每次只能吞吐 8 个字节。\nCPU 每次会向内存读写一个 cache line 大小的数据（ 64 个字节），但是内存一次只能吞吐 8 个字节。\n内存读取数据只能是按照物理内存地址，8 个字节 8 个字节地顺序读取数据。所以说内存一次读取和写入的单位是 8 个字节。\n在程序员眼里连续的物理内存地址实际上在物理上是不连续的。因为这连续的 8 个字节其实是存储于不同的 DRAM 芯片上的。每个 DRAM 芯片存储一个字节（supercell）。\nCPU 向内存写入数据过程\n我们现在假设 CPU 要将寄存器中的数据 X 写到物理内存地址 A 中。同样的道理，CPU 芯片中的总线接口会向总线发起写事务（write transaction）。写事务步骤如下：\nCPU 将要写入的物理内存地址 A 放入系统总线上。\n通过 IO bridge 的信号转换，将物理内存地址 A 传递到存储总线上。\n存储控制器感受到存储总线上的地址信号，将物理内存地址 A 从存储总线上读取出来，并等待数据的到达。\nCPU 将寄存器中的数据拷贝到系统总线上，通过 IO bridge 的信号转换，将数据传递到存储总线上。\n存储控制器感受到存储总线上的数据信号，将数据从存储总线上读取出来。\n存储控制器通过内存地址 A 定位到具体的存储器模块，最后将数据写入存储器模块中的 8 个 DRAM 芯片中\n2.6 深入理解 Linux 物理内存管理 从CPU 角度看物理内存模型\n为了快速索引到具体的物理内存页，内核为每个物理页 struct page 结构体定义了一个索引编号：PFN（Page Frame Number）。PFN 与 struct page 是一一对应的关系。\n内核提供了两个宏来完成 PFN 与 物理页结构体 struct page 之间的相互转换。它们分别是 page_to_pfn 与 pfn_to_page。\n内核中如何组织管理这些物理内存页 struct page 的方式我们称之为做物理内存模型，不同的物理内存模型，应对的场景以及 page_to_pfn 与 pfn_to_page 的计算逻辑都是不一样的。\nFLATMEM 平坦内存模型\n用一个数组来组织这些连续的物理内存页 struct page 结构，其在数组中对应的下标即为 PFN 。这种内存模型就叫做平坦内存模型 FLATMEM 。 DISCONTIGMEM 非连续内存模型\nFLATMEM 平坦内存模型只适合管理一整块连续的物理内存，而对于多块非连续的物理内存来说使用 FLATMEM 平坦内存模型进行管理则会造成很大的内存空间浪费。\n因为 FLATMEM 平坦内存模型是利用 mem_map 这样一个全局数组来组织这些被划分出来的物理页 page 的，而对于物理内存存在大量不连续的内存地址区间这种情况时，这些不连续的内存地址区间就形成了内存空洞。\n由于用于组织物理页的底层数据结构是 mem_map 数组，数组的特性又要求这些物理页是连续的，所以只能为这些内存地址空洞也分配 struct page 结构用来填充数组使其连续。\n而每个 struct page 结构大部分情况下需要占用 40 字节（struct page 结构在不同场景下内存占用会有所不同，这一点我们后面再说），如果物理内存中存在的大块的地址空洞，那么为这些空洞而分配的 struct page 将会占用大量的内存空间，导致巨大的浪费。\n在 DISCONTIGMEM 非连续内存模型中，内核将物理内存从宏观上划分成了一个一个的节点 node （微观上还是一页一页的物理页），每个 node 节点管理一块连续的物理内存。这样一来这些连续的物理内存页均被划归到了对应的 node 节点中管理，就避免了内存空洞造成的空间浪费。\nDISCONTIGMEM 非连续内存模型其实就是 FLATMEM 平坦内存模型的一种扩展，在面对大块不连续的物理内存管理时，通过将每段连续的物理内存区间划归到 node 节点中进行管理，避免了为内存地址空洞分配 struct page 结构，从而节省了内存资源的开销。 SPARSEMEM 稀疏内存模型\n随着内存技术的发展，内核可以支持物理内存的热插拔了（后面我会介绍），这样一来物理内存的不连续就变为常态了，在上小节介绍的 DISCONTIGMEM 内存模型中，其实每个 node 中的物理内存也不一定都是连续的。\nSPARSEMEM 稀疏内存模型的核心思想就是对粒度更小的连续内存块进行精细的管理，用于管理连续内存块的单元被称作 section 。物理页大小为 4k 的情况下， section 的大小为 128M ，物理页大小为 16k 的情况下， section 的大小为 512M。\n在 SPARSEMEM 稀疏内存模型下 page_to_pfn 与 pfn_to_page 的计算逻辑又发生了变化。\n在 page_to_pfn 的转换中，首先需要通过 page_to_section 根据 struct page 结构定位到 mem_section 数组中具体的 section 结构。然后在通过 section_mem_map 定位到具体的 PFN。 在 pfn_to_page 的转换中，首先需要通过 __pfn_to_section 根据 PFN 定位到 mem_section 数组中具体的 section 结构。然后在通过 PFN 在 section_mem_map 数组中定位到具体的物理页 Page 。 物理内存热插拔\n内核引入了 SPARSEMEM 稀疏内存模型以便应对这种情况，提供对更小粒度的连续物理内存的灵活管理能力。\n集群的规模一大，那么物理内存出故障的几率也会大大增加，物理内存的热插拔对提供集群高可用性也是至关重要的。\n从总体上来讲，内存的热插拔分为两个阶段：\n物理热插拔阶段：这个阶段主要是从物理上将内存硬件插入（hot-add），拔出（hot-remove）主板的过程，其中涉及到硬件和内核的支持。\n逻辑热插拔阶段：这一阶段主要是由内核中的内存管理子系统来负责，涉及到的主要工作为：如何动态的上线启用（online）刚刚 hot-add 的内存，如何动态下线（offline）刚刚 hot-remove 的内存。\n每个 mem_section 都可以在系统运行时改变 offline ，online 状态，以便支持内存的热插拔功能。 当mem_section offline时, 内核会把这部分内存隔离开, 使得该部分内存不可再被使用, 然后再把mem_section中已经分配的内存页迁移到其他 mem_section 的内存上。\n内存的热插拔对进程来说是透明的，迁移后的物理页映射的虚拟内存地址不能变化。\n进程在用户空间访问内存都是根据虚拟内存地址通过页表找到对应的物理内存地址，这些迁移之后的物理页，虽然物理内存地址发生变化，内核通过修改地址之间映射关系，可以保证虚拟内存地址不会改变。\n在内核态的虚拟地址空间的直接映射区。直接映射区中的物理页的虚拟地址会随着物理内存地址变动而变动, 因此这部分物理页是无法轻易迁移的。\n内核是如何解决这个头疼的问题呢？\n将内存按照物理页是否可迁移，划分为不可迁移页，可回收页，可迁移页。在可能会被拔出的内存中只分配那些可迁移的内存页，这些信息会在内存初始化的时候被设置。\n从 CPU 角度看物理内存架构\nNUMA 节点物理内存区域的划分\n我们都知道内核对物理内存的管理都是以页为最小单位来管理的，每页默认 4K 大小，理想状况下任何种类的数据都可以存放在任何页框中，没有什么限制。比如：存放内核数据，用户数据，磁盘缓冲数据等。\n但是实际的计算机体系结构受到硬件方面的制约，间接导致限制了页框的使用方式。\n比如在 X86 体系结构下，ISA 总线的 DMA （直接内存存取）控制器，只能对内存的前16M 进行寻址，这就导致了 ISA 设备不能在整个 32 位地址空间中执行 DMA，只能使用物理内存的前 16M 进行 DMA 操作。\n因此直接映射区的前 16M 专门让内核用来为 DMA 分配内存，这块 16M 大小的内存区域我们称之为 ZONE_DMA。\n而直接映射区中剩下的部分也就是从 16M 到 896M（不包含 896M）这段区域，我们称之为 ZONE_NORMAL。从字面意义上我们可以了解到，这块区域包含的就是正常的页框（没有任何使用限制）。\nZONE_NORMAL 由于也是属于直接映射区的一部分，对应的物理内存 16M 到 896M 这段区域也是被直接映射至内核态虚拟内存空间中的 3G + 16M 到 3G + 896M 这段虚拟内存上。\n而物理内存 896M 以上的区域被内核划分为 ZONE_HIGHMEM 区域，我们称之为高端内存。\n由于内核虚拟内存空间中的前 896M 虚拟内存已经被直接映射区所占用，而在 32 体系结构下内核虚拟内存空间总共也就 1G 的大小，这样一来内核剩余可用的虚拟内存空间就变为了 1G - 896M = 128M。\n显然物理内存中剩下的这 3200M 大小的 ZONE_HIGHMEM 区域无法继续通过直接映射的方式映射到这 128M 大小的虚拟内存空间中。\n这样一来物理内存中的 ZONE_HIGHMEM 区域就只能采用动态映射的方式映射到 128M 大小的内核虚拟内存空间中，也就是说只能动态的一部分一部分的分批映射，先映射正在使用的这部分，使用完毕解除映射，接着映射其他部分。\n所以内核会根据各个物理内存区域的功能不同，将 NUMA 节点内的物理内存主要划分为以下四个物理内存区域：\nZONE_DMA：用于那些无法对全部物理内存进行寻址的硬件设备，进行 DMA 时的内存分配。例如前边介绍的 ISA 设备只能对物理内存的前 16M 进行寻址。该区域的长度依赖于具体的处理器类型。\nZONE_DMA32：与 ZONE_DMA 区域类似，该区域内的物理页面可用于执行 DMA 操作，不同之处在于该区域是提供给 32 位设备（只能寻址 4G 物理内存）执行 DMA 操作时使用的。该区域只在 64 位系统中起作用，因为只有在 64 位系统中才会专门为 32 位设备提供专门的 DMA 区域。\nZONE_NORMAL：这个区域的物理页都可以直接映射到内核中的虚拟内存，由于是线性映射，内核可以直接进行访问。\nZONE_HIGHMEM：这个区域包含的物理页就是我们说的高端内存，内核不能直接访问这些物理页，这些物理页需要动态映射进内核虚拟内存空间中（非线性映射）。该区域只在 32 位系统中才会存在，因为 64 位系统中的内核虚拟内存空间太大了（128T），都可以进行直接映射。\n内核中定义的 zone_type 除了上边为大家介绍的四个物理内存区域，又多出了两个区域：ZONE_MOVABLE 和 ZONE_DEVICE。\nZONE_DEVICE 是为支持热插拔设备而分配的非易失性内存（ Non Volatile Memory ），也可用于内核崩溃时保存相关的调试信息。\nZONE_MOVABLE 是内核定义的一个虚拟内存区域，该区域中的物理页可以来自于上边介绍的几种真实的物理区域。该区域中的页全部都是可以迁移的，主要是为了防止内存碎片和支持内存的热插拔。 因为随着系统的运行会伴随着不同大小的物理内存页的分配和释放，这种内存不规则的分配释放随着系统的长时间运行就会导致内存碎片，内存碎片会使得系统在明明有足够内存的情况下，依然无法为进程分配合适的内存。 如果这些物理页处于 ZONE_MOVABLE 区域，它们就可以被迁移，内核可以通过迁移页面来避免内存碎片的问题。 内核通过迁移页面来规整内存，这样就可以避免内存碎片，从而得到一大片连续的物理内存，以满足内核对大块连续内存分配的请求。所以这就是内核需要根据物理页面是否能够迁移的特性，而划分出 ZONE_MOVABLE 区域的目的。\n事实上只有第一个 NUMA 节点可以包含所有的物理内存区域，其它的节点并不能包含所有的区域类型，因为有些内存区域比如：ZONE_DMA，ZONE_DMA32 必须从物理内存的起点开始。这些在物理内存开始的区域可能已经被划分到第一个 NUMA 节点了，后面的物理内存才会被依次划分给接下来的 NUMA 节点。因此后面的 NUMA 节点并不会包含 ZONE_DMA，ZONE_DMA32 区域。 ZONE_NORMAL、ZONE_HIGHMEM 和 ZONE_MOVABLE 是可以出现在所有 NUMA 节点上的。\n物理内存区域中的水位线\n内存资源是系统中最宝贵的系统资源，是有限的。当内存资源紧张的时候，系统的应对方法无非就是三种：\n产生 OOM，内核直接将系统中占用大量内存的进程，将 OOM 优先级最高的进程干掉，释放出这个进程占用的内存供其他更需要的进程分配使用。\n内存回收，将不经常使用到的内存回收，腾挪出来的内存供更需要的进程分配使用。\n内存规整，将可迁移的物理页面进行迁移规整，消除内存碎片。从而获得更大的一片连续物理内存空间供进程分配。\n内核会为每个 NUMA 节点中的每个物理内存区域定制三条用于指示内存容量的水位线，分别是：WMARK_MIN（页最小阈值）， WMARK_LOW （页低阈值），WMARK_HIGH（页高阈值）。\n当该物理内存区域的剩余内存容量高于 _watermark[WMARK_HIGH] 时，说明此时该物理内存区域中的内存容量非常充足，内存分配完全没有压力。\n当剩余内存容量在 _watermark[WMARK_LOW] 与_watermark[WMARK_HIGH] 之间时，说明此时内存有一定的消耗但是还可以接受，能够继续满足进程的内存分配需求。\n当剩余内容容量在 _watermark[WMARK_MIN] 与 _watermark[WMARK_LOW] 之间时，说明此时内存容量已经有点危险了，内存分配面临一定的压力，但是还可以满足进程的内存分配要求，当给进程分配完内存之后，就会唤醒 kswapd 进程开始内存回收，直到剩余内存高于 _watermark[WMARK_HIGH] 为止。\n在这种情况下，进程的内存分配会触发内存回收，但请求进程本身不会被阻塞，由内核的 kswapd 进程异步回收内存。\n当剩余内容容量低于 _watermark[WMARK_MIN] 时，说明此时的内容容量已经非常危险了，如果进程在这时请求内存分配，内核就会进行直接内存回收，这时请求进程会同步阻塞等待，直到内存回收完毕。 2.7 内核如何描述物理内存页 经过前边几个小节的介绍，我想大家现在应该对 Linux 内核整个内存管理框架有了一个总体上的认识。\n如上图所示，在 NUMA 架构下内存被划分成了一个一个的内存节点（NUMA Node），在每个 NUMA 节点中，内核又根据节点内物理内存的功能用途不同，将 NUMA 节点内的物理内存划分为四个物理内存区域分别是：ZONE_DMA，ZONE_DMA32，ZONE_NORMAL，ZONE_HIGHMEM。其中 ZONE_MOVABLE 区域是逻辑上的划分，主要是为了防止内存碎片和支持内存的热插拔。\n物理内存区域中管理的就是物理内存页（ Linux 内存管理的最小单位），前面我们介绍的内核对物理内存的换入，换出，回收，内存映射等操作的单位就是页。内核为每一个物理内存区域分配了一个伙伴系统，用于管理该物理内存区域下所有物理内存页面的分配和释放。\n匿名页的反向映射\n我们通常所说的内存映射是正向映射，即从虚拟内存到物理内存的映射。而反向映射则是从物理内存到虚拟内存的映射，用于当某个物理内存页需要进行回收或迁移时，此时需要去找到这个物理页被映射到了哪些进程的虚拟地址空间中，并断开它们之间的映射。\n在没有反向映射的机制前，需要去遍历所有进程的虚拟地址空间中的映射页表，这个效率显然是很低下的。有了反向映射机制之后内核就可以直接找到该物理内存页到所有进程映射的虚拟地址空间 VMA ，并从 VMA 使用的进程页表中取消映射\n当进程开始访问这段虚拟内存时，内核会产生缺页中断，在缺页中断处理函数中才会去真正的分配物理内存（这时才会为子进程创建自己的 anon_vma 和 anon_vma_chain），并建立虚拟内存与物理内存之间的映射关系（正向映射）。\n每个匿名页对应唯一的 anon_vma 结构，但是一个匿名物理页可以映射到不同进程的虚拟内存空间中，每个进程的虚拟内存空间都是独立的，也就是说不同的进程就会有不同的 VMA。\n不同的 VMA 意味着同一个匿名页 anon_vma 就会对应多个 anon_vma_chain。那么如何通过一个 anon_vma 找到和他关联的所有 anon_vma_chain 呢？找到了这些 anon_vma_chain 也就意味着 struct page 找到了与它关联的所有进程虚拟内存空间 VMA。 struct anon_vma 结构中管理了一颗红黑树，这颗红黑树上管理的全部都是与该 anon_vma 关联的 anon_vma_chain。我们可以通过 struct page 中的 mapping 指针找到 anon_vma，然后遍历 anon_vma 中的这颗红黑树 rb_root ，从而找到与其关联的所有 anon_vma_chain。\nvm_area_struct 表示的只是进程虚拟内存空间中的一段虚拟内存区域，这块虚拟内存区域中可能会包含多个匿名页，所以 VMA 与物理内存页 page 也是有一对多的映射关系存在。\n三、进程管理 1. 进程 线程 并发：**多个程序、交替执行。**单核的 CPU 在某一个瞬间，只能运行一个进程。但在 1 秒钟期间，运行多个进程。\n1.1 进程的状态 在一个进程的活动期间至少具备三种基本状态，即运行状态、就绪状态、阻塞状态。\n运行状态（Running）：该时刻进程占用 CPU； 就绪状态（Ready）：可运行，由于其他进程处于运行状态而暂时停止运行； 阻塞状态（Blocked）：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行； 还有：\n创建状态（new）：进程正在被创建时的状态； 结束状态（Exit）：进程正在从系统中消失时的状态； 描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态:\n阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现； 就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行； 1.2 进程控制块 PCB 是进程存在的唯一标识。\nPCB 具体包含的信息\n进程描述信息：\n进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符； 用户标识符：进程归属的用户，用户标识符主要为共享和保护服务； 进程控制和管理信息：\n进程当前状态，如 new、ready、running、waiting 或 blocked 等； 进程优先级：进程抢占 CPU 时的优先级； 资源分配清单：\n有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。 CPU 相关信息：\nCPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。 PCB 是如何组织的\n通过链表的方式进行组织，把具有相同状态的进程链在一起，组成各种队列。比如：\n将所有处于就绪状态的进程链在一起，称为就绪队列； 把所有因等待某事件而处于等待状态的进程链在一起就组成各种阻塞队列； 1.3 进程的上下文切换 一个进程切换到另一个进程运行，称为进程的上下文切换。\nCPU 上下文：CPU 寄存器和程序计数器是 CPU 在运行任何任务前，所必须依赖的环境。\nCPU 上下文切换：先把前一个任务的 CPU 上下文（CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。\n根据任务的不同，把 CPU 上下文切换分成：进程上下文切换、线程上下文切换和中断上下文切换。\n进程的上下文切换\n进程是由内核管理和调度的，进程的切换只能发生在内核态。\n**进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。**包括了所有与进程执行状态相关的信息\n寄存器、程序计数器 进程控制块、栈、内存页表 把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行\n进程上下文切换有哪些场景？\n为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行； 进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行； 当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度； 当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行； 发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序； 1.4 线程 线程是进程当中的一条执行流程。\n同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的。\n线程的优缺点？\n线程的优点：\n一个进程中可以同时存在多个线程； 各个线程之间可以并发执行； 各个线程之间可以共享地址空间和文件等资源； 线程的缺点：\n当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（针对 C/C++ 语言）。 例子，对于游戏的用户设计，不应该使用多线程的方式，否则一个用户挂了，会影响其他同个进程的线程。\n1.5 线程与进程的区别 线程与进程的比较如下：\n进程是资源分配的单位，线程是 CPU 调度的单位； 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈； 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系； 线程能减少并发执行的时间和空间开销； 对于，线程相比进程能减少开销，体现在：\n线程的创建时间比进程快。线程共享资源管理信息； 线程的终止时间比进程快。线程释放的资源相比进程少很多； 同一个进程内的线程切换比进程切换快，同一个进程的线程都具有同一个页表，在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的； 由于同一进程的各线程间共享内存和文件资源，在线程之间数据传递不需要经过内核了，数据交互效率更高； 1.6 线程的上下文切换 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源，这些资源在上下文切换时是不需要修改的；\n线程上下文切换的是什么？\n这还得看线程是不是属于同一个进程：\n当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样； 当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据； 线程的上下文切换相比进程，开销要小很多。\n1.7 线程的实现 三种线程的实现方式：\n用户线程：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理； 内核线程：在内核中实现的线程，是由内核管理的线程； 轻量级进程：在内核中来支持用户线程； 用户线程和内核线程的对应关系\n多对一。多个用户线程对应同一个内核线程：\n一对一。一个用户线程对应一个内核线程：\n多对多。多个用户线程对应到多个内核线程：\n用户线程如何理解？存在什么优势和缺陷？\n用户线程是基于用户态的线程管理库来实现的，那么线程控制块（Thread Control Block, TCB） 也是在库里面来实现的，对于操作系统而言是看不到这个 TCB 的，它只能看到整个进程的 PCB。\n用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。\n用户级线程的模型，类似前面提到的多对一的关系，多个用户线程对应同一个内核线程.\n用户线程的优点：\n每个进程都需要有它私有的线程控制块（TCB）列表，用来跟踪记录它各个线程状态信息（PC、栈指针、寄存器），TCB 由用户级线程库函数来维护，可用于不支持线程技术的操作系统； 用户线程的切换也是由线程库函数来完成的，无需用户态与内核态的切换，所以速度特别快； 用户线程的缺点：\n由于操作系统不参与线程的调度，如果一个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行了。 当一个线程开始运行后，除非它主动地交出 CPU 的使用权，否则它所在的进程当中的其他线程无法运行，因为用户态的线程没法打断当前运行中的线程，它没有这个特权，只有操作系统才有，但是用户线程不是由操作系统管理的。 由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会比较慢； 内核线程如何理解？存在什么优势和缺陷？\n内核线程是由操作系统管理的，线程对应的 TCB 自然是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责。\n内核线程的模型，一对一的关系，一个用户线程对应一个内核线程。\n内核线程的优点：\n在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行； 分配给线程，多线程的进程获得更多的 CPU 运行时间； 内核线程的缺点：\n在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息，如 PCB 和 TCB； 线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大； 轻量级进程如何理解？\n轻量级进程（Light-weight process，LWP）是内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持，而且 LWP 是由内核管理并像普通进程一样被调度。\n在大多数系统中，LWP与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息。\n在 LWP 之上也是可以使用用户线程的，那么 LWP 与用户线程的对应关系就有三种：\n1 : 1，即一个 LWP 对应 一个用户线程； N : 1，即一个 LWP 对应多个用户线程； M : N，即多个 LWP 对应多个用户线程； 1 : 1 模式\n一个线程对应到一个 LWP 再对应到一个内核线程，如上图的进程 4，属于此模型。\n优点：实现并行，当一个 LWP 阻塞，不会影响其他 LWP； 缺点：每一个用户线程，就产生一个内核线程，创建线程的开销较大。 N : 1 模式\n多个用户线程对应一个 LWP 再对应一个内核线程，如上图的进程 2，线程管理是在用户空间完成的，此模式中用户的线程对操作系统不可见。\n优点：用户线程要开几个都没问题，且上下文切换发生用户空间，切换的效率较高； 缺点：一个用户线程如果阻塞了，则整个进程都将会阻塞，另外在多核 CPU 中，是没办法充分利用 CPU 的。 M : N 模式\n根据前面的两个模型混搭一起，就形成 M:N 模型，该模型提供了两级控制，首先多个用户线程对应到多个 LWP，LWP 再一一对应到内核线程，如上图的进程 3。\n优点：综合了前两种优点，大部分的线程上下文发生在用户空间，且多个线程又可以充分利用多核 CPU 的资源。 1.8 进程调度 调度时机\n进程从一个运行状态到另外一状态变化时，会触发一次调度。\n比如，以下状态的变化都会触发操作系统的调度：\n从就绪态 -\u0026gt; 运行态：当进程被创建时，会进入到就绪队列，操作系统会从就绪队列选择一个进程运行； 从运行态 -\u0026gt; 阻塞态：当进程发生 I/O 事件而阻塞时，操作系统必须选择另外一个进程运行； 从运行态 -\u0026gt; 结束态：当进程退出结束后，操作系统得从就绪队列选择另外一个进程运行； 因为，这些状态变化的时候，操作系统需要考虑是否要让新的进程给 CPU 运行，或者是否让当前进程从 CPU 上退出来而换另一个进程运行。\n如果硬件时钟提供某个频率的周期性中断，那么可以根据如何处理时钟中断 ，把调度算法分为两类：\n非抢占式调度算法挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情。 抢占式调度算法挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便把 CPU 控制返回给调度程序进行调度，也就是常说的时间片机制。 调度原则\nCPU 利用率：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率； 系统吞吐量：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量； 周转时间：周转时间是进程运行+阻塞时间+等待时间的总和，一个进程的周转时间越小越好； 等待时间：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意； 响应时间：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。 调度\n在单核 CPU 系统中常见的调度算法。\n01 先来先服务调度算法\n非抢占式的先来先服务（First Come First Serve, FCFS）算法。\n先来后到，每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。\n当一个长作业先运行了，后面的短作业等待的时间就会很长，不利于短作业。\nFCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I/O 繁忙型作业的系统。\n02 最短作业优先调度算法\n最短作业优先（Shortest Job First, SJF）调度算法同样也是顾名思义，它会优先选择运行时间最短的进程来运行，这有助于提高系统的吞吐量。\n对长作业不利，很容易造成一种极端现象。一个长作业在就绪队列等待运行，就绪队列有非常多的短作业，就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。\n03 高响应比优先调度算法\n「先来先服务调度算法」和「最短作业优先调度算法」都没有很好的权衡短作业和长作业。\n那么，高响应比优先 （\\Highest Response Ratio Next, HRRN）调度算法主要是权衡了短作业和长作业。\n每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行，「响应比优先级」的计算公式：\n如果两个进程的「等待时间」相同时，「要求的服务时间」越短，「响应比」就越高，这样短作业的进程容易被选中运行； 如果两个进程「要求的服务时间」相同时，「等待时间」越长，「响应比」就越高，这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会； 进程要求服务的时间是不可预知的。所以，高响应比优先调度算法是「理想型」的调度算法，现实中是实现不了的。\n04 时间片轮转调度算法\n最古老、最简单、最公平且使用最广的算法就是时间片轮转（Round Robin, RR）调度算法。\n每个进程被分配一个时间段，称为时间片（Quantum），即允许该进程在该时间段中运行。\n如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配给另外一个进程； 如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换； 另外，时间片的长度就是一个很关键的点：\n如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率； 如果设得太长又可能引起对短作业进程的响应时间变长。将 一般来说，时间片设为 20ms~50ms 通常是一个比较合理的折中值。\n05 最高优先级调度算法\n从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（Highest Priority First，HPF）调度算法。\n进程的优先级可以分为，静态优先级和动态优先级：\n静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化； 动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是随着时间的推移增加等待进程的优先级。 该算法也有两种处理优先级高的方法，非抢占式和抢占式：\n非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。 抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。 缺点。可能会导致低优先级的进程永远不会运行。\n06 多级反馈队列调度算法\n多级反馈队列（Multilevel Feedback Queue）调度算法是「时间片轮转算法」和「最高优先级算法」的综合和发展。\n「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。 「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列； 设置了多个队列，赋予每个队列不同的优先级，每个队列优先级从高到低，同时优先级越高时间片越短； 新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成； 当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行； 可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也变更长了，所以该算法很好的兼顾了长短作业，同时有较好的响应时间。\n2. 进程间的通信方式？ 每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。\n2.1 管道 管道传输数据是单向的，如果想相互通信，我们需要创建两个管道才行。 进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循先进先出原则，不支持 lseek 之类的文件定位操作。 匿名管道，它的通信范围是存在父子关系的进程。 命名管道，它可以在不相关的进程间也能相互通信。\n管道这种通信方式效率低，不适合进程间频繁地交换数据。\n2.2 消息队列 消息队列是保存在内核中的消息链表\n在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。\n消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在。\n不足的地方有两点，一是通信不及时，二是附件也有大小限制\n消息队列不适合比较大数据的传输，因为在内核中每个消息体都有一个最大长度的限制。\n消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。\n2.3 共享内存 消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那共享内存的方式，就很好的解决了这一问题。 共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。 用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。需要互斥访问。\n2.4 信号量 为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，信号量就实现了这一保护机制。 信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。 信号量表示资源的数量，控制信号量的方式有两种原子操作：\n一个是 P 操作，这个操作会把信号量减去 1，相减后如果信号量 \u0026lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 \u0026gt;= 0，则表明还有资源可使用，进程可正常继续执行。 另一个是 V 操作，这个操作会把信号量加上 1，相加后如果信号量 \u0026lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 \u0026gt; 0，则表明当前没有阻塞中的进程； P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。\n信号初始化为 1，就代表着是互斥信号量，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。 信号初始化为 0，就代表着是同步信号量，它可以保证进程 A 应在进程 B 之前执行。\n2.5 信号 对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。\n信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。\n信号是进程间通信机制中唯一的异步通信机制，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。\n1.执行默认操作。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。\n2.捕捉信号。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。\n3.忽略信号。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SEGSTOP，它们用于在任何时候中断或结束某一进程。\n2.6 Socket 跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。\n实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。\n根据创建 socket 类型的不同，通信的方式也就不同：\n实现 TCP 字节流通信： socket 类型是 AF_INET 和 SOCK_STREAM； 实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM； 实现本地进程间通信： 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。 针对 TCP 协议通信的 socket 编程模型\n服务端和客户端初始化 socket，得到文件描述符； 服务端调用 bind，将绑定在 IP 地址和端口; 服务端调用 listen，进行监听； 服务端调用 accept，等待客户端连接； 客户端调用 connect，向服务器端的地址和端口发起连接请求； 服务端 accept 返回用于传输的 socket 的文件描述符； 客户端调用 write 写入数据；服务端调用 read读取数据； 客户端断开连接时，会调用 close，那么服务端 read 读取数据的时候，就会读取到了 EOF，待处理完数据后，服务端调用 close，表示连接关闭。 服务端调用 accept 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。\n监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作监听 socket，一个叫作已完成连接 socket。\n成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。\n针对 UDP 协议通信的 socket 编程模型\nUDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。\n对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。\n另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。\n针对本地进程间通信的 socket 编程模型\n本地 socket 被用于在同一台主机上进程间通信的场景：\n本地 socket 的编程接口和 IPv4 、IPv6 套接字编程接口是一致的，可以支持「字节流」和「数据报」两种协议； 本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现； 本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是绑定一个本地文件，这也就是它们之间的最大区别。\n3. 线程冲突 在单核 CPU 系统里，为了实现多个程序同时运行的假象，操作系统通常以时间片调度的方式，让每个进程执行每次执行一个时间片，时间片用完了，就切换下一个进程运行，由于这个时间片的时间很短，于是就造成了「并发」的现象。\n互斥\n两个线程分别对i++，加10000次，但结果是15173。 上面的情况称为竞争条件（race condition），当多线程相互竞争操作共享变量时，由于运气不好，即在执行过程中发生了上下文切换，我们得到了错误的结果，事实上，每次运行都可能得到不同的结果，因此输出的结果存在不确定性（indeterminate）。\n由于多线程执行操作共享变量的这段代码可能会导致竞争状态，因此我们将此段代码称为临界区（critical section），它是访问共享资源的代码片段，一定不能给多线程同时执行。\n我们希望这段代码是互斥的，也就说保证一个线程在临界区执行时，其他线程应该被阻止进入临界区，\n同步\n所谓同步，就是并发进程/线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程/线程同步。\n同步与互斥是两种不同的概念：\n同步就好比：「操作 A 应在操作 B 之前执行」，「操作 C 必须在操作 A 和操作 B 都完成之后才能执行」等； 互斥就好比：「操作 A 和操作 B 不能在同一时刻执行」； 3.1 互斥与同步的实现和使用 为了实现进程/线程间正确的协作，操作系统必须提供实现进程协作的措施和方法，主要的方法有两种：\n锁：加锁、解锁操作； 信号量：P、V 操作； 这两个都可以方便地实现进程/线程互斥，而信号量比锁的功能更强一些，它还可以方便地实现进程/线程同步。\n锁\n使用加锁操作和解锁操作可以解决并发线程/进程的互斥问题。 任何想进入临界区的线程，必须先执行加锁操作。若加锁操作顺利通过，则线程可进入临界区；在完成对临界资源的访问后再执行解锁操作，以释放该临界资源。\n根据锁的实现不同，可以分为「忙等待锁」和「无忙等待锁」。\n我们先来看看「忙等待锁」的实现\n现代 CPU 体系结构提供的特殊原子操作指令 —— 测试和置位（Test-and-Set）指令。\n如果用 C 代码表示 Test-and-Set 指令，形式如下：\n测试并设置指令做了下述事情:\n把 old_ptr 更新为 new 的新值 返回 old_ptr 的旧值； 关键是这些代码是原子执行。因为既可以测试旧值，又可以设置新值，所以我们把这条指令叫作「测试并设置」。\n原子操作就是要么全部执行，要么都不执行，不能出现执行到一半的中间状态\n可以运用 Test-and-Set 指令来实现「忙等待锁」\n很明显，当获取不到锁时，线程就会一直 while 循环，不做任何事情，所以就被称为「忙等待锁」，也被称为自旋锁（spin lock）。\n这是最简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。在单处理器上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。\n再来看看「无等待锁」的实现\n无等待锁顾明思议就是获取不到锁的时候，不用自旋。\n既然不想自旋，那当没获取到锁的时候，就把当前线程放入到锁的等待队列，然后执行调度程序，把 CPU 让给其他线程执行。\n3.2 信号量 信号量是操作系统提供的一种协调共享资源访问的方法。\n通常信号量表示资源的数量，对应的变量是一个整型（sem）变量。\n另外，还有两个原子操作的系统调用函数来控制信号量的，分别是：\nP 操作：将 sem 减 1，相减后，如果 sem \u0026lt; 0，则进程/线程进入阻塞等待，否则继续，表明 P 操作可能会阻塞； V 操作：将 sem 加 1，相加后，如果 sem \u0026lt;= 0，唤醒一个等待中的进程/线程，表明 V 操作不会阻塞； 信号量不仅可以实现临界区的互斥访问控制，还可以线程间的事件同步。\n信号量实现临界区的互斥访问。\n为每类共享资源设置一个信号量 s，其初值为 1，表示该临界资源未被占用。\n只要把进入临界区的操作置于 P(s) 和 V(s) 之间，即可实现进程/线程互斥：\n信号量实现事件同步。\n同步的方式是设置一个信号量，其初值为 0。\n3.3 生产者-消费者问题 生产者-消费者问题描述：\n生产者在生成数据后，放在一个缓冲区中； 消费者从缓冲区取出数据处理； 任何时刻，只能有一个生产者或消费者可以访问缓冲区； 我们对问题分析可以得出：\n任何时刻只能有一个线程操作缓冲区，说明操作缓冲区是临界代码，需要互斥； 缓冲区空时，消费者必须等待生产者生成数据；缓冲区满时，生产者必须等待消费者取出数据。说明生产者和消费者需要同步。 需要三个信号量，分别是：\n互斥信号量 mutex：用于互斥访问缓冲区，初始化值为 1； 资源信号量 fullBuffers：用于消费者询问缓冲区是否有数据，有数据则读取数据，初始化值为 0（表明缓冲区一开始为空）； 资源信号量 emptyBuffers：用于生产者询问缓冲区是否有空位，有空位则生成数据，初始化值为 n （缓冲区大小）； 3.4经典同步问题 1. 哲学家就餐问题 哲学家要两支叉子才进餐。吃完后，会把两支叉子放回原处，继续思考； 如何保证哲学家们的动作有序进行，而不会出现有人永远拿不到叉子呢？\n方案三\n让偶数编号的哲学家「先拿左边的叉子后拿右边的叉子」，奇数编号的哲学家「先拿右边的叉子后拿左边的叉子」。\n方案四\n另外一种可行的解决方案，我们用一个数组 state 来记录每一位哲学家的三个状态，分别是在进餐状态、思考状态、饥饿状态（正在试图拿叉子）。\n那么，一个哲学家只有在两个邻居都没有进餐时，才可以进入进餐状态。\n第 i 个哲学家的左邻右舍，则由宏 LEFT 和 RIGHT 定义：\nLEFT : ( i + 5 - 1 ) % 5 RIGHT : ( i + 1 ) % 5 2. 读者-写者问题 读者只会读取数据，不会修改数据，而写者即可以读也可以修改数据。\n读者-写者的问题描述：\n「读-读」允许：同一时刻，允许多个读者同时读 「读-写」互斥：没有写者时读者才能读，没有读者时写者才能写 「写-写」互斥：没有其他写者时，写者才能写 方案一\n读者优先的策略，因为只要有读者正在读的状态，后来的读者都可以直接进入，如果读者持续不断进入，则写者会处于饥饿状态。\n使用信号量的方式：\n信号量 wMutex：控制写操作的互斥信号量，初始值为 1 ； 读者计数 rCount：正在进行读操作的读者个数，初始化为 0； 信号量 rCountMutex：控制对 rCount 读者计数器的互斥修改，初始值为 1； 方案二\n写者优先策略：\n只要有写者准备要写入，写者应尽快执行写操作，后来的读者就必须阻塞； 如果有写者持续不断写入，则读者就处于饥饿； 在方案一的基础上新增如下变量：\n信号量 rMutex：控制读者进入的互斥信号量，初始值为 1； 信号量 wDataMutex：控制写者写操作的互斥信号量，初始值为 1； 写者计数 wCount：记录写者数量，初始值为 0； 信号量 wCountMutex：控制 wCount 互斥修改，初始值为 1； 具体实现如下代码：\n方案三\n既然读者优先策略和写者优先策略都会造成饥饿的现象，那么我们就来实现一下公平策略。\n公平策略：\n优先级相同； 写者、读者互斥访问； 只能一个写者访问临界区； 可以有多个读者同时访问临界资源； 具体代码实现：\n开始来了一些读者读数据，它们全部进入读者队列，此时来了一个写者，执行 P(falg) 操作，使得后续到来的读者都阻塞在 flag 上，不能进入读者队列，这会使得读者队列逐渐为空，即 rCount 减为 0。\n这个写者也不能立马开始写（因为此时读者队列不为空），会阻塞在信号量 wDataMutex 上，读者队列中的读者全部读取结束后，最后一个读者进程执行 V(wDataMutex)，唤醒刚才的写者，写者则继续开始进行写操作。\n4.死锁 1. 死锁的产生 当两个线程为了保护两个不同的共享资源而使用了两个互斥锁，那么这两个互斥锁应用不当的时候，可能会造成两个线程都在等待对方释放锁，在没有外力的作用下，这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了死锁。\n死锁只有同时满足以下四个条件才会发生：\n互斥条件； 持有并等待条件； 不可剥夺条件； 环路等待条件； 互斥条件是指多个线程不能同时使用同一个资源。\n持有并等待条件是指线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1。\n不可剥夺条件是指，当线程已经持有了资源 ，在自己使用完之前不能被其他线程获取。\n环路等待条件指的是，在死锁发生的时候，两个线程获取资源的顺序构成了环形链。\n2. 避免死锁 产生死锁的四个必要条件是：互斥条件、持有并等待条件、不可剥夺条件、环路等待条件。\n那么避免死锁问题就只需要破环其中一个条件就可以，最常见的并且可行的就是使用资源有序分配法，来破环环路等待条件。\n5. 悲观锁、乐观锁 「互斥锁、自旋锁、读写锁、乐观锁、悲观锁」的选择和使用。\n1. 互斥锁与自旋锁 当已经有一个线程加锁后，其他线程加锁则就会失败，互斥锁和自旋锁对于加锁失败后的处理方式是不一样的：\n互斥锁加锁失败后，线程会释放 CPU ，给其他线程；\n自旋锁加锁失败后，线程会忙等待，直到它拿到锁；\n互斥锁是「独占锁」，线程加锁就会失败，会释放CPU给其他线程，加锁的代码就被阻塞。\n对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的。加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程。\n互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本：\n会有两次线程上下文切换的成本。线程的状态从「运行」状态设置为「睡眠」状态。「睡眠」状态的线程会变为「就绪」状态。\n线程的上下文切换的是什么？当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。\n如果能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。\n自旋锁。当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 while 循环等待实现，不过最好是使用 CPU 提供的 PAUSE 指令来实现「忙等待」，因为可以减少循环等待时的耗电量。\n自旋锁是最比较简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。\n自旋锁开销少，在多核系统下一般不会主动产生线程切换，如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以自旋的时间和被锁住的代码执行的时间是成「正比」的关系。\n自旋锁与互斥锁使用层面比较相似，但实现层面上完全不同：当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对。\n2.读写锁 由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。读写锁适用于能明确区分读操作和写操作的场景。\n读写锁的工作原理是：\n当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率。 但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。 所以，写锁是独占锁，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而读锁是共享锁，因为读锁可以被多个线程同时持有。\n读写锁在读多写少的场景，能发挥出优势。\n根据实现的不同，读写锁可以分为「读优先锁」和「写优先锁」。\n读优先锁。读锁能被更多的线程持有。写任务只有在读任务全部完成后才会执行。\n写优先锁。优先服务写线程。正在读的线程读取完，写线程才执行，后面的读线程在写进程完成后才执行。（写线程来了之后的读线程都被阻塞）\n不管优先读锁还是写锁，对方可能会出现饿死问题，那么我们就不偏袒任何一方，搞个「公平读写锁」。\n公平读写锁比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。\n3. 乐观锁与悲观锁 互斥锁、自旋锁、读写锁，都是属于悲观锁。\n悲观锁做事比较悲观，它认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。\n乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。\n乐观锁的心态是，不管三七二十一，先改了资源再说。另外，你会发现乐观锁全程并没有加锁，所以它也叫无锁编程。\n常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。\n乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。\n总结 开发过程中，最常见的就是互斥锁的了，互斥锁加锁失败时，会用「线程切换」来应对，当加锁失败的线程再次加锁成功后的这一过程，会有两次线程上下文切换的成本，性能损耗比较大。\n如果我们明确知道被锁住的代码的执行时间很短，那我们应该选择开销比较小的自旋锁，因为自旋锁加锁失败时，并不会主动产生线程切换，而是一直忙等待，直到获取到锁，那么如果被锁住的代码执行时间很短，那这个忙等待的时间相对应也很短。\n如果能区分读操作和写操作的场景，那读写锁就更合适了，它允许多个读线程可以同时持有读锁，提高了读的并发性。根据偏袒读方还是写方，可以分为读优先锁和写优先锁，读优先锁并发性很强，但是写线程会被饿死，而写优先锁会优先服务写线程，读线程也可能会被饿死，那为了避免饥饿的问题，于是就有了公平读写锁，它是用队列把请求锁的线程排队，并保证先入先出的原则来对线程加锁，这样便保证了某种线程不会被饿死，通用性也更好点。\n互斥锁、自旋锁、读写锁都属于悲观锁，悲观锁认为并发访问共享资源时，冲突概率可能非常高，所以在访问共享资源前，都需要先加锁。\n相反的，如果并发访问共享资源时，冲突概率非常低的话，就可以使用乐观锁，它的工作方式是，在访问共享资源时，不用先加锁，修改完共享资源后，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。\n一旦冲突概率上升，就不适合使用乐观锁，因为它解决冲突的重试成本非常高。\n不管使用的哪种锁，我们的加锁的代码范围应该尽可能的小，也就是加锁的粒度要小，这样执行速度会比较快。再来，使用上了合适的锁，就会快上加快了。\n6. 一个进程最多可以创建多少个线程？ 32 位系统，用户态的虚拟空间只有 3G，如果创建线程时分配的栈空间是 10M，那么一个进程最多只能创建 300 个左右的线程。 64 位系统，用户态的虚拟空间大到有 128T，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制。 7. 线程崩溃了，进程也会崩溃吗？ 线程是因为非法访问内存引起的崩溃，那么进程肯定会崩溃。因为在进程中，各个线程的地址空间是共享的，某个线程对地址的非法访问就会导致内存的不确定性，进而可能会影响到其他线程，这种操作是危险的，操作系统会认为这很可能导致一系列严重的后果，于是干脆让整个进程崩溃。\n线程共享代码段，数据段，地址空间，文件非法访问内存有以下几种情况，我们以 C 语言举例来看看。\n1、针对只读内存写入数据\n2、访问了进程没有权限访问的地址空间（比如内核空间）。\n3、访问了不存在的内存。\n以上错误都是访问内存时的错误，所以统一会报 Segment Fault 错误（即段错误），这些都会导致进程崩溃。\n四、进程调度/页面置换/磁盘调度算法 4.1 进程调度算法 常见的调度算法：\n先来先服务调度算法 最短作业优先调度算法 高响应比优先调度算法 时间片轮转调度算法 最高优先级调度算法 多级反馈队列调度算法 4.2 内存页面置换算法 在了解内存页面置换算法前，我们得先谈一下缺页异常（缺页中断）。\n缺页异常（缺页中断）\n当 CPU 访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。\n页面置换算法的功能是，当出现缺页异常，需调入新页面而内存已满时，选择被置换的物理页面，也就是说选择一个物理页面换出到磁盘，然后把需要访问的页面换入到物理页。\n算法目标则是，尽可能减少页面的换入换出的次数，常见的页面置换算法有如下几种：\n最佳页面置换算法（OPT） 先进先出置换算法（FIFO） 最近最久未使用的置换算法（LRU） 时钟页面置换算法（Lock） 最不常用置换算法（LFU） 1. 最佳页面置换算法 最佳页面置换算法基本思路是，置换在「未来」最长时间不访问的页面。\n这很理想，实际系统中无法实现，因为程序访问页面时是动态的，我们是无法预知每个页面在「下一次」访问前的等待时间。\n所以，最佳页面置换算法作用是为了衡量你的算法的效率，你的算法效率越接近该算法的效率，那么说明你的算法是高效的。\n2. 先进先出置换算法 选择在内存驻留时间很长的页面进行中置换。\n3. 最近最久未使用的置换算法 最近最久未使用（LRU）的置换算法的基本思路是，发生缺页时，选择最长时间没有被访问的页面进行置换。\n虽然 LRU 在理论上是可以实现的，但代价很高。为了完全实现 LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。\n困难的是，在每次访问内存时都必须要更新「整个链表」。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作。\n所以，LRU 虽然看上去不错，但是由于开销比较大，实际应用中比较少使用。\n4. 时钟页面置换算法 该算法的思路是，把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。\n当发生缺页中断时，算法首先检查表针指向的页面：\n如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置； 如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止 5.最不常用算法 最不常用（LFU）算法，这名字听起来很调皮，但是它的意思不是指这个算法不常用，而是当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰。\n它的实现方式是，对每个页面设置一个「访问计数器」，每当一个页面被访问时，该页面的访问计数器就累加 1。在发生缺页中断时，淘汰计数器值最小的那个页面。\n要增加一个计数器来实现，这个硬件成本是比较高的，另外如果要对这个计数器查找哪个页面访问次数最小，查找链表本身，如果链表长度很大，是非常耗时的，效率不高。\n但还有个问题，LFU 算法只考虑了频率问题，没考虑时间的问题，比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。\n那这个问题的解决的办法还是有的，可以定期减少访问的次数，比如当发生时间中断时，把过去时间访问的页面的访问次数除以 2，也就说，随着时间的流失，以前的高访问次数的页面会慢慢减少，相当于加大了被置换的概率。\n4.3 磁盘调度算法 寻道的时间是磁盘访问最耗时的部分，如果请求顺序优化的得当，必然可以节省一些不必要的寻道时间，从而提高磁盘的访问性能。\n假设有下面一个请求序列，每个数字代表磁道的位置：\n98，183，37，122，14，124，65，67\n初始磁头当前的位置是在第 53 磁道。\n接下来，分别对以上的序列，作为每个调度算法的例子，那常见的磁盘调度算法有：\n先来先服务算法 最短寻道时间优先算法 扫描算法 循环扫描算法 LOOK 与 C-LOOK 算法 1. 先来先服务 先来先服务（First-Come，First-Served，FCFS），顾名思义，先到来的请求，先被服务。\n先来先服务算法总共移动了 640 个磁道的距离，这么一看这种算法，比较简单粗暴，但是如果大量进程竞争使用磁盘，请求访问的磁道可能会很分散，性能上就会显得很差，因为寻道时间过长。\n2. 最短寻道时间优先 最短寻道时间优先（Shortest Seek First，SSF）算法的工作方式是，优先选择从当前磁头位置所需寻道时间最短的请求\n磁头移动的总距离是 236 磁道，相比先来先服务性能提高了不少。\n但这个算法可能存在某些请求的饥饿，因为本次例子我们是静态的序列，看不出问题，假设是一个动态的请求，如果后续来的请求都是小于 183 磁道的，那么 183 磁道可能永远不会被响应，于是就产生了饥饿现象，这里产生饥饿的原因是磁头在一小块区域来回移动。\n3. 扫描算法 最短寻道时间优先算法会产生饥饿的原因在于：磁头有可能再一个小区域内来回得移动。\n为了防止这个问题，可以规定：磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向，这就是扫描（*Scan*）算法。也叫做电梯算法。\n扫描调度算法性能较好，不会产生饥饿现象，但是存在这样的问题，中间部分的磁道会比较占便宜，中间部分相比其他部分响应的频率会比较多，也就是说每个磁道的响应频率存在差异。\n4. 循环扫描算法 扫描算法使得每个磁道响应的频率存在差异，那么要优化这个问题的话，可以总是按相同的方向进行扫描，使得每个磁道的响应频率基本一致。\n循环扫描（Circular Scan, CSCAN ）规定：只有磁头朝某个特定方向移动时，才处理磁道访问请求，而返回时直接快速移动至最靠边缘的磁道，也就是复位磁头，这个过程是很快的，并且返回中途不处理任何请求，该算法的特点，就是磁道只响应一个方向上的请求。\n磁头先响应了右边的请求，直到碰到了最右端的磁道 199，就立即回到磁盘的开始处（磁道 0），但这个返回的途中是不响应任何请求的，直到到达最开始的磁道后，才继续顺序响应右边的请求。\n循环扫描算法相比于扫描算法，对于各个位置磁道响应频率相对比较平均。\n5.LOOK 与 C-LOOK算法 我们前面说到的扫描算法和循环扫描算法，都是磁头移动到磁盘「最始端或最末端」才开始调换方向。\n那这其实是可以优化的，优化的思路就是磁头在移动到「最远的请求」位置，然后立即反向移动。\n那针对 SCAN 算法的优化则叫 LOOK 算法，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，反向移动的途中会响应请求。\n而针 C-SCAN 算法的优化则叫 C-LOOK，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，反向移动的途中不会响应请求。\n五、文件系统 1. 文件系统的基本组成 Linux 最经典的一句话是：「一切皆文件」\nLinux 文件系统会为每个文件分配两个数据结构：索引节点（index node）和目录项（directory entry），它们主要用来记录文件的元信息和目录层次结构。\n索引节点，也就是 inode，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。 目录项，也就是 dentry，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。 由于索引节点唯一标识一个文件，而目录项记录着文件的名字，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别名。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。\n目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。\n目录项和目录是一个东西吗？\n虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。\n如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。\n注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。\n那文件数据是如何存储在磁盘的呢？\n磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。\n所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。\n索引节点是存储在硬盘上的数据，那么为了加速文件的访问，通常会把索引节点加载到内存中。\n另外，磁盘进行格式化的时候，会被分成三个存储区域，分别是超级块、索引节点区和数据块区。\n超级块，用来存储文件系统的详细信息，比如块个数、块大小、空闲块等等。 索引节点区，用来存储索引节点； 数据块区，用来存储文件或目录数据； 我们不可能把超级块和索引节点区全部加载到内存，这样内存肯定撑不住，所以只有当需要使用的时候，才将其加载进内存，它们加载进内存的时机是不同的：\n超级块：当文件系统挂载时进入内存； 索引节点区：当文件被访问时进入内存； 2. 虚拟文件系统 文件系统的种类众多，而操作系统希望对用户提供一个统一的接口，于是在用户层与文件系统层引入了中间层，这个中间层就称为虚拟文件系统（Virtual File System，VFS）。\nVFS 定义了一组所有文件系统都支持的数据结构和标准接口，这样程序员不需要了解文件系统的工作原理，只需要了解 VFS 提供的统一接口即可。\nLinux 支持的文件系统也不少，根据存储位置的不同，可以把文件系统分为三类：\n磁盘的文件系统，它是直接把数据存储在磁盘中，比如 Ext 2/3/4、XFS 等都是这类文件系统。 内存的文件系统，这类文件系统的数据不是存储在硬盘的，而是占用内存空间，我们经常用到的 /proc 和 /sys 文件系统都属于这一类，读写这类文件，实际上是读写内核中相关的数据。 网络的文件系统，用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等等。 文件系统首先要先挂载到某个目录才可以正常使用，比如 Linux 系统在启动时，会把文件系统挂载到根目录。\n3. 文件的使用 首先，我们得通过系统调用来打开一个文件。\n1 2 3 4 5 fd = open(name, flag); # 打开文件 ... write(fd,...); # 写数据 ... close(fd); # 关闭文件 上面简单的代码是读取一个文件的过程：\n首先用 open 系统调用打开文件，open 的参数中包含文件的路径名和文件名。 使用 write 写数据，其中 write 使用 open 所返回的文件描述符，并不使用文件名作为参数。 使用完文件后，要用 close 系统调用关闭文件，避免资源的泄露。 打开了一个文件后，操作系统会跟踪进程打开的所有文件，所谓的跟踪呢，就是操作系统为每个进程维护一个打开文件表，文件表里的每一项代表「文件描述符」，所以说文件描述符是打开文件的标识。\n操作系统在打开文件表中维护着打开文件的状态和信息：\n文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的； 文件打开计数器：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目； 文件磁盘位置：绝大多数文件操作都要求系统修改文件数据，该信息保存在内存中，以免每个操作都从磁盘中读取； 访问权限：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等），该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I/O 请求； 文件系统的基本操作单位是数据块。\n4. 文件的存储 文件的数据是要存储在硬盘上面的，数据在磁盘上的存放方式，就像程序在内存中存放的方式那样，有以下两种：\n连续空间存放方式 非连续空间存放方式：「链表方式」和「索引方式」。 连续空间存放方式\n前提，必须先知道一个文件的大小。\n所以，文件头里需要指定「起始块的位置」和「长度」.\n优点：读写效率高，\n缺点：磁盘空间碎片、文件长度不易扩展\n非连续空间存放方式\n分为「链表方式」和「索引方式」。\n链表\n可以消除磁盘碎片，提高磁盘空间的利用率，同时文件的长度可以动态扩展。\n分为「隐式链表」和「显式链接」两种形式。\n「隐式链表」。实现的方式是文件头要包含「第一块」和「最后一块」的位置，并且每个数据块里面留出一个指针空间，用来存放下一个数据块的位置。\n缺点：无法直接访问数据块，只能通过指针顺序访问文件。以及数据块指针消耗了一定的存储空间。稳定性较差，系统在运行过程中由于软件或者硬件错误导致链表中的指针丢失或损坏，会导致文件数据的丢失。\n「显式链接」。把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中**，该表在整个磁盘仅设置一张，**每个表项中存放链接指针，指向下一个数据块号。\n由于查找记录的过程是在内存中进行的，提高了检索速度，而且减少了访问磁盘的次数。缺点是不适用于大磁盘。\n链表的方式解决了连续分配的磁盘碎片和文件动态扩展的问题，但是不能有效支持直接访问。\n索引\n索引的实现是为每个文件创建一个「索引数据块」，里面存放的是指向文件数据块的指针列表，\n文件头需要包含指向「索引数据块」的指针，这样就可以通过文件头知道索引数据块的位置，再通过索引数据块里的索引信息找到对应的数据块。\n索引的方式优点在于：\n文件的创建、增大、缩小很方便； 不会有碎片的问题； 支持顺序读写和随机读写； 缺陷之一就是存储索引带来的开销。\n如果文件很大，大到一个索引数据块放不下索引信息，如何处理大文件的存放呢？可以通过组合的方式，来处理大文件的存储。\n\\链表 + 索引的组合，这种组合称为「链式索引块」，它的实现方式是在索引数据块留出一个存放下一个索引数据块的指针。 、索引 + 索引的方式，这种组合称为「多级索引块」，实现方式是通过一个索引块来存放多个索引数据块， 5.空闲空间管理 空闲表法 空闲链表法 位图法 空闲表法\n空闲表法就是为所有空闲空间建立一张表，表内容包括空闲区的第一个块号和该空闲区的块个数，注意，这个方式是连续分配的。\n当请求分配磁盘空间时，系统依次扫描空闲表里的内容，\n系统回收文件空间。也需顺序扫描空闲表，寻找一个空闲表条目并将释放空间的第一个物理块号及它占用的块数填到这个条目中。\n这种方法仅当有少量的空闲区时才有较好的效果。因为，如果存储空间中有着大量的小的空闲区，则空闲表变得很大，这样查询效率会很低。另外，这种分配技术适用于建立连续文件。\n空闲链表法\n使用「链表」的方式来管理空闲空间，每一个空闲块里有一个指针指向下一个空闲块。\n当创建文件需要一块或几块时，就从链头上依次取下一块或几块。反之，当回收空间时，把这些空闲块依次接到链头上。\n这种技术只要在主存中保存一个指针，令它指向第一个空闲块。其特点是简单，但不能随机访问，工作效率低。\n空闲表法和空闲链表法都不适合用于大型文件系统，因为这会使空闲表或空闲链表太大。\n位图法\n位图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。\n当值为 0 时，表示对应的盘块空闲，值为 1 时，表示对应的盘块已分配。\n在 Linux 文件系统就采用了位图的方式来管理空闲空间，不仅用于数据空闲块的管理，还用于 inode 空闲块的管理，因为 inode 也是存储在磁盘的。Linux文件系统中位图由块组组成。\n6. 目录的存储 和普通文件不同的是，普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。\n在目录文件的块中，最简单的保存格式就是列表，就是一项一项地将目录下的文件信息（如文件名、文件 inode、文件类型等）列在表里。\n列表中每一项就代表该目录下的文件的文件名和对应的 inode，通过这个 inode，就可以找到真正的文件。\n如果一个目录有超级多的文件，我们要想在这个目录下找文件，按照列表一项一项的找，效率就不高了。\n于是，保存目录的格式改成哈希表，对文件名进行哈希计算，把哈希值保存起来，如果我们要查找一个目录下面的文件名，可以通过名称取哈希。如果哈希能够匹配上，就说明这个文件的信息在相应的块里面。\nLinux 系统的 ext 文件系统就是采用了哈希表，来保存目录的内容，这种方法的优点是查找非常迅速，插入和删除也较简单，不过需要一些预备措施来避免哈希冲突。\n7.软链接和硬链接 有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。\n硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。\n软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。\n8. 文件 I/O 文件的读写方式各有千秋，对于文件的 I/O 分类也非常多，常见的有\n缓冲与非缓冲 I/O 直接与非直接 I/O 阻塞与非阻塞 I/O VS 同步与异步 I/O 缓冲与非缓冲 I/O\n文件操作的标准库是可以实现数据的缓存，那么根据「是否利用标准库缓冲」，可以把文件 I/O 分为缓冲 I/O 和非缓冲 I/O：\n缓冲 I/O，利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件。 非缓冲 I/O，直接通过系统调用访问文件，不经过标准库缓存。 「缓冲」特指标准库内部实现的缓冲。\n比方说，很多程序遇到换行时才真正输出，而换行前的内容，其实就是被标准库暂时缓存了起来，这样做的目的是，减少系统调用的次数，毕竟系统调用是有 CPU 上下文切换的开销的。\n直接与非直接 I/O\n根据是「否利用操作系统的缓存」，可以把文件 I/O 分为直接 I/O 与非直接 I/O：\n直接 I/O，不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘。 非直接 I/O，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。 系统调用函数指定了 O_DIRECT 标志，则表示使用直接 I/O。如果没有设置过，默认使用的是非直接 I/O。\n如果用了非直接 I/O 进行写数据操作，内核什么情况下才会把缓存数据写入到磁盘？\n以下几种场景会触发内核缓存的数据写入磁盘：\n在调用 write 的最后，当发现内核缓存的数据太多的时候，内核会把数据写到磁盘上； 用户主动调用 sync，内核缓存会刷到磁盘上； 当内存十分紧张，无法再分配页面时，也会把内核缓存的数据刷到磁盘上； 内核缓存的数据的缓存时间超过某个时间时，也会把数据刷到磁盘上； 阻塞与非阻塞 I/O VS 同步与异步 I/O\n阻塞 I/O，当用户程序执行 read ，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，当拷贝过程完成，read 才会返回。\n阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程。\n非阻塞 I/O，非阻塞的 read 请求在数据未准备好的情况下立即返回，可以继续往下执行，此时应用程序不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序缓冲区，read 调用才可以获取到结果。\n访问管道或 socket 时，如果设置了 O_NONBLOCK 标志，那么就表示使用的是非阻塞 I/O 的方式访问，而不做任何设置的话，默认是阻塞 I/O。\n应用程序每次轮询内核的 I/O 是否准备好，轮询的过程中，应用程序啥也做不了，只是在循环。为了解决这种傻乎乎轮询方式，于是 I/O 多路复用技术就出来了，如 select、poll，它是通过 I/O 事件分发，当内核数据准备好时，再以事件通知应用程序进行操作。\n这个做法大大改善了 CPU 的利用率，因为当调用了 I/O 多路复用接口，如果没有事件发生，那么当前线程就会发生阻塞，这时 CPU 会切换其他线程执行任务，等内核发现有事件到来的时候，会唤醒阻塞在 I/O 多路复用接口的线程，然后用户可以进行后续的事件处理。\nI/O 多路复用接口最大的优势在于，用户可以在一个线程内同时处理多个 socket 的 IO 请求。\n无论是阻塞 I/O、非阻塞 I/O，还是基于非阻塞 I/O 的多路复用都是同步调用。因为它们在 read 调用时，内核将数据从内核空间拷贝到应用程序空间，过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，read 调用就会在这个同步过程中等待比较长的时间。\n异步 I/O 是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程都不用等待。\n当我们发起 aio_read 之后，就立即返回，内核自动将数据从内核空间拷贝到应用程序空间，这个拷贝过程同样是异步的，内核自动完成的，和前面的同步操作不一样，应用程序并不需要主动发起拷贝动作。\nI/O 是分为两个过程的：\n数据准备的过程 数据从内核空间拷贝到用户进程缓冲区的过程 阻塞 I/O 会阻塞在「过程 1 」和「过程 2」，而非阻塞 I/O 和基于非阻塞 I/O 的多路复用只会阻塞在「过程 2」，所以这三个都可以认为是同步 I/O。\n异步 I/O 则不同，「过程 1 」和「过程 2 」都不会阻塞。\n9. 写文件时，进程发生了崩溃，已写入的数据会丢失吗 进程写文件时（使用缓冲 IO），进程发生了崩溃，已写入的数据会丢失吗？\n不会的。\n进程在执行 write （使用缓冲 IO）系统调用的时候，实际上是将文件数据写到了内核的 page cache，它是文件系统中用于缓存文件数据的缓冲，所以即使进程崩溃了，文件数据还是保留在内核的 page cache，我们读数据的时候，也是从内核的 page cache 读取，因此还是依然读的进程崩溃前写入的数据。\n内核会找个合适的时机，将 page cache 中的数据持久化到磁盘。但是如果 page cache 里的文件数据，在持久化到磁盘之前，系统发生了崩溃，那这部分数据就会丢失了。\n我们也可以在程序里调用 fsync 函数，在写文文件的时候，立刻将文件数据持久化到磁盘，这样就可以解决系统崩溃导致的文件数据丢失的问题。\nSwap 与缺页中断\nSwap 机制指的是当物理内存不够用，内存管理单元（Memory Mangament Unit，MMU）需要提供调度算法来回收相关内存空间，然后将清理出来的内存空间给当前内存申请方。\nSwap 机制存在的本质原因是 Linux 系统提供了虚拟内存管理机制，每一个进程认为其独占内存空间，因此所有进程的内存空间之和远远大于物理内存。所有进程的内存空间之和超过物理内存的部分就需要交换到磁盘上。\n操作系统以 page 为单位管理内存，当进程发现需要访问的数据不在内存时，操作系统可能会将数据以页的方式加载到内存中。上述过程被称为缺页中断，当操作系统发生缺页中断时，就会通过系统调用将 page 再次读到内存中。\n但主内存的空间是有限的，当主内存中不包含可以使用的空间时，操作系统会从选择合适的物理内存页驱逐回磁盘，为新的内存页让出位置，选择待驱逐页的过程在操作系统中叫做页面替换（Page Replacement），替换操作又会触发 swap 机制。\n如果物理内存足够大，那么可能不需要 Swap 机制，但是 Swap 在这种情况下还是有一定优势：对于有发生内存泄漏几率的应用程序（进程），Swap 交换分区更是重要，这可以确保内存泄露不至于导致物理内存不够用，最终导致系统崩溃。但内存泄露会引起频繁的 swap，此时非常影响操作系统的性能。\n需要我们理解一下文件的数据。文件 = 数据 + 元数据。元数据用来描述文件的各种属性，也必须存储在磁盘上。因此，我们说保证文件一致性其实包含了两个方面：数据一致+元数据一致。\n文件的元数据包括：文件大小、创建时间、访问时间、属主属组等信息。\n我们考虑如下一致性问题：如果发生写操作并且对应的数据在 Page Cache 中，那么写操作就会直接作用于 Page Cache 中，此时如果数据还没刷新到磁盘，那么内存中的数据就领先于磁盘，此时对应 page 就被称为 Dirty page。\n当前 Linux 下以两种方式实现文件一致性：\nWrite Through（写穿）：向用户层提供特定接口，应用程序可主动调用接口来保证文件一致性； Write back（写回）：系统中存在定期任务（表现形式为内核线程），周期性地同步文件系统中文件脏数据块，这是默认的 Linux 一致性方案； Write Through 与 Write back 在持久化的可靠性上有所不同：\nWrite Through 以牺牲系统 I/O 吞吐量作为代价，向上层应用确保一旦写入，数据就已经落盘，不会丢失； Write back 在系统发生宕机的情况下无法确保数据已经落盘，因此存在数据丢失的问题。不过，在程序挂了，例如被 kill -9，Page Cache 中的数据操作系统还是会确保落盘； Page Cache 的优劣势 优势\n1.加快数据访问\n数据在内存中进行缓存，由于内存访问比磁盘访问快很多。\n2.减少 I/O 次数，提高系统磁盘 I/O 吞吐量\nPage Cache 的缓存以及预读能力，而程序又往往符合局部性原理，因此通过一次 I/O 将多个 page 装入 Page Cache 能够减少磁盘 I/O 次数， 进而提高系统磁盘 I/O 吞吐量。\n劣势\n最直接的缺点是需要占用额外物理内存空间，物理内存在比较紧俏的时候可能会导致频繁的 swap 操作，最终导致系统的磁盘 I/O 负载的上升。\n另一个缺陷是对应用层并没有提供很好的管理 API，几乎是透明管理。应用层即使想优化 Page Cache 的使用策略也很难进行。\nPage Cache 最后一个缺陷是在某些应用场景下比 Direct I/O 多一次磁盘读 I/O 以及磁盘写 I/O。\nDirect I/O 即直接 I/O。其名字中的”直接”二字用于区分使用 page cache 机制的缓存 I/O。\n缓存文件 I/O：用户空间要读写一个文件并不直接与磁盘交互，而是中间夹了一层缓存，即 page cache； 直接文件 I/O：用户空间读取的文件直接与磁盘交互，没有中间 page cache 层； “直接”在这里还有另一层语义：其他所有技术中，数据至少需要在内核空间存储一份，但是在 Direct I/O 技术中，数据直接存储在用户空间中，绕过了内核。\nDirect I/O 的读写非常有特点：\nWrite 操作：由于其不使用 page cache，所以其进行写文件，如果返回成功，数据就真的落盘了（不考虑磁盘自带的缓存）； Read 操作：由于其不使用 page cache，每次读操作是真的从磁盘中读取，不会从文件系统的缓存中读取。 六、设备管理 8.1 键盘敲入 A 字母时，操作系统期间发生了什么？ 1.设备控制器 为了屏蔽设备之间的差异，每个设备都有一个叫设备控制器（Device Control） 的组件，比如硬盘有硬盘控制器、显示器有视频控制器等。\n设备控制器里有芯片，它可执行自己的逻辑，也有自己的寄存器，用来与 CPU 进行通信，比如：\n通过写入这些寄存器，操作系统可以命令设备发送数据、接收数据、开启或关闭，或者执行某些其他操作。 通过读取这些寄存器，操作系统可以了解设备的状态，是否准备好接收一个新的命令等。 实际上，控制器是有三类寄存器，它们分别是状态寄存器（Status Register）、 命令寄存器（Command Register）以及数据寄存器（Data Register）\n三个寄存器的作用：\n数据寄存器，CPU 向 I/O 设备写入需要传输的数据，比如要打印的内容是「Hello」，CPU 就要先发送一个 H 字符给到对应的 I/O 设备。 命令寄存器，CPU 发送一个命令，告诉 I/O 设备，要进行输入/输出操作，于是就会交给 I/O 设备去工作，任务完成后，会把状态寄存器里面的状态标记为完成。 状态寄存器，目的是告诉 CPU ，现在已经在工作或工作已经完成，如果已经在工作状态，CPU 再发送数据或者命令过来，都是没有用的，直到前面的工作已经完成，状态寄存标记成已完成，CPU 才能发送下一个字符和命令。 CPU 通过读写设备控制器中的寄存器控制设备，这可比 CPU 直接控制输入输出设备，要方便和标准很多。\n输入输出设备可分为两大类 ：块设备（Block Device）和字符设备（Character Device）。\n块设备，把数据存储在固定大小的块中，每个块有自己的地址，硬盘、USB 是常见的块设备。 字符设备，以字符为单位发送或接收一个字符流，字符设备是不可寻址的，也没有任何寻道操作，鼠标是常见的字符设备。 块设备通常传输的数据量会非常大，于是控制器设立了一个可读写的数据缓冲区。\nCPU 写入数据到控制器的缓冲区时，当缓冲区的数据囤够了一部分，才会发给设备。 CPU 从控制器的缓冲区读取数据时，也需要缓冲区囤够了一部分，才拷贝到内存。 这样做是为了，减少对设备的频繁操作。\n那 CPU 是如何与设备的控制寄存器和数据缓冲区进行通信的？存在两个方法：\n端口 I/O，每个控制寄存器被分配一个 I/O 端口，可以通过特殊的汇编指令操作这些寄存器，比如 in/out 类似的指令。 内存映射 I/O，将所有控制寄存器映射到内存空间中，这样就可以像读写内存一样读写数据缓冲区。 2. I/O 控制方式 当 CPU 给设备发送了一个指令，让设备控制器去读设备的数据，它读完的时候，要怎么通知 CPU 呢？\n控制器的寄存器一般会有状态标记位，用来标识输入或输出操作是否完成。\n第一种轮询等待的方法，让 CPU 一直查寄存器的状态，直到状态标记为完成，很明显，这种方式非常的傻瓜，它会占用 CPU 的全部时间。\n第二种方法 —— 中断，通知操作系统数据已经准备好了。我们一般会有一个硬件的中断控制器，当设备完成任务后触发中断到中断控制器，中断控制器就通知 CPU，一个中断产生了，CPU 需要停下当前手里的事情来处理中断。\n另外，中断有两种，一种软中断，例如代码调用 INT 指令触发，一种是硬件中断，就是硬件通过中断控制器触发的。 中断的方式对于频繁读写数据的磁盘，并不友好，这样 CPU 容易经常被打断，会占用 CPU 大量的时间。对于这一类设备的问题的解决方法是使用 DMA（Direct Memory Access） 功能，它可以使得设备在 CPU 不参与的情况下，能够自行完成把设备 I/O 数据放入到内存。\nDMA 的工作方式如下：\nCPU 需对 DMA 控制器下发指令，告诉它想读取多少数据，读完的数据放在内存的某个地方就可以了； 接下来，DMA 控制器会向磁盘控制器发出指令，通知它从磁盘读数据到其内部的缓冲区中，接着磁盘控制器将缓冲区的数据传输到内存； 当磁盘控制器把数据传输到内存的操作完成后，磁盘控制器在总线上发出一个确认成功的信号到 DMA 控制器； DMA 控制器收到信号后，DMA 控制器发中断通知 CPU 指令完成，CPU 就可以直接用内存里面现成的数据了； 可以看到， CPU 当要读取磁盘数据的时候，只需给 DMA 控制器发送指令，然后返回去做其他事情，当磁盘数据拷贝到内存后，DMA 控制机器通过中断的方式，告诉 CPU 数据已经准备好了，可以从内存读数据了。仅仅在传送开始和结束时需要 CPU 干预。\n3. 设备驱动程序 虽然设备控制器屏蔽了设备的众多细节，但每种设备的控制器的寄存器、缓冲区等使用模式都是不同的，所以为了屏蔽「设备控制器」的差异，引入了设备驱动程序。\n设备控制器属于属于硬件，而设备驱动程序属于操作系统的一部分，操作系统的内核代码可以像本地调用代码一样使用设备驱动程序的接口，而设备驱动程序是面向设备控制器的代码，它发出操控设备控制器的指令后，才可以操作设备控制器。\n不同的设备控制器虽然功能不同，但是设备驱动程序会提供统一的接口给操作系统，这样不同的设备驱动程序，就可以以相同的方式接入操作系统。\n设备完成了事情，则会发送中断来通知操作系统。那操作系统就需要有一个地方来处理这个中断，这个地方也就是在设备驱动程序里，它会及时响应控制器发来的中断请求，并根据这个中断的类型调用响应的中断处理程序进行处理。\n通常，设备驱动程序初始化的时候，要先注册一个该设备的中断处理函数。\n中断处理程序的处理流程：\n在 I/O 时，设备控制器如果已经准备好数据，则会通过中断控制器向 CPU 发送中断请求； 保护被中断进程的 CPU 上下文； 转入相应的设备中断处理函数； 进行中断处理； 恢复被中断进程的上下文； 4. 通用块层 对于块设备，为了减少不同块设备的差异带来的影响，Linux 通过一个统一的通用块层，来管理不同的块设备。\n通用块层是处于文件系统和磁盘驱动中间的一个块设备抽象层，它主要有两个功能：\n第一个功能，向上为文件系统和应用程序，提供访问块设备的标准接口，向下把各种不同的磁盘设备抽象为统一的块设备，并在内核层面，提供一个框架来管理这些设备的驱动程序； 第二功能，通用层还会给文件系统和应用程序发来的 I/O 请求排队，接着会对队列重新排序、请求合并等方式，也就是 I/O 调度，主要目的是为了提高磁盘读写的效率。 5. 存储系统 I/O 软件分层 前面说到了不少东西，设备、设备控制器、驱动程序、通用块层，现在再结合文件系统原理，我们来看看 Linux 存储系统的 I/O 软件分层。\n可以把 Linux 存储系统的 I/O 由上到下可以分为三个层次，分别是文件系统层、通用块层、设备层。他们整个的层次关系如下图：\n这三个层次的作用是：\n文件系统层，包括虚拟文件系统和其他文件系统的具体实现，它向上为应用程序统一提供了标准的文件访问接口，向下会通过通用块层来存储和管理磁盘数据。 通用块层，包括块设备的 I/O 队列和 I/O 调度器，它会对文件系统的 I/O 请求进行排队，再通过 I/O 调度器，选择一个 I/O 发给下一层的设备层。 设备层，包括硬件设备、设备控制器和驱动程序，负责最终物理设备的 I/O 操作。 有了文件系统接口之后，不但可以通过文件系统的命令行操作设备，也可以通过应用程序，调用 read、write 函数，就像读写文件一样操作设备，所以说设备在 Linux 下，也只是一个特殊的文件。\n但是，除了读写操作，还需要有检查特定于设备的功能和属性。于是，需要 ioctl 接口，它表示输入输出控制接口，是用于配置和修改特定设备属性的通用接口。\n另外，存储系统的 I/O 是整个系统最慢的一个环节，所以 Linux 提供了不少缓存机制来提高 I/O 的效率。\n为了提高文件访问的效率，会使用页缓存、索引节点缓存、目录项缓存等多种缓存机制，目的是为了减少对块设备的直接调用。 为了提高块设备的访问效率， 会使用缓冲区，来缓存块设备的数据。 6.键盘敲入字母时，期间发生了什么？ 当用户输入了键盘字符，键盘控制器就会产生扫描码数据，并将其缓冲在键盘控制器的寄存器中，紧接着键盘控制器通过总线给 CPU 发送中断请求。\nCPU 收到中断请求后，操作系统会保存被中断进程的 CPU 上下文，然后调用键盘的中断处理程序。\n键盘的中断处理程序是在键盘驱动程序初始化时注册的，那键盘中断处理函数的功能就是从键盘控制器的寄存器的缓冲区读取扫描码，再根据扫描码找到用户在键盘输入的字符，如果输入的字符是显示字符，那就会把扫描码翻译成对应显示字符的 ASCII 码，\n得到了显示字符的 ASCII 码后，就会把 ASCII 码放到「读缓冲区队列」，接下来就是要把显示字符显示屏幕了，显示设备的驱动程序会定时从「读缓冲区队列」读取数据放到「写缓冲区队列」，最后把「写缓冲区队列」的数据一个一个写入到显示设备的控制器的寄存器中的数据缓冲区，最后将这些数据显示在屏幕里。\n显示出结果后，恢复被中断进程的上下文。\n七、网络系统 7.1 什么是零拷贝？ 1.为什么要有 DMA 技术? 在没有 DMA 技术前，I/O 的过程是这样的：\nCPU 发出对应的指令给磁盘控制器，然后返回； 磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个中断； CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。 整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程。\n简单的搬运几个字符数据那没问题，但是如果我们用千兆网卡或者硬盘传输大量数据的时候，都用 CPU 来搬运的话，肯定忙不过来。\n于是就发明了 DMA 技术，也就是直接内存访问（Direct Memory Access） 技术。\nDMA 技术简单理解就是，在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务。\nDMA 控制器进行数据传输的过程：\n具体过程：\n用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态； 操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务； DMA 进一步将 I/O 请求发送给磁盘； 磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满； DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务； 当 DMA 读取了足够多的数据，就会发送中断信号给 CPU； CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回； 可以看到， CPU 不再参与「将数据从磁盘控制器缓冲区搬运到内核空间」的工作，这部分工作全程由 DMA 完成。但是 CPU 在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要 CPU 来告诉 DMA 控制器。\n早期 DMA 只存在在主板上，如今由于 I/O 设备越来越多，数据传输的需求也不尽相同，所以每个 I/O 设备里面都有自己的 DMA 控制器。\n2.传统的文件传输有多糟糕？ 传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。\n期间共发生了 4 次用户态与内核态的上下文切换，因为发生了两次系统调用，一次是 read() ，一次是 write()，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。\n上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。\n其次，还发生了 4 次数据拷贝，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：\n只是搬运一份数据，结果却搬运了 4 次，过多的数据拷贝无疑会消耗 CPU 资源，大大降低了系统性能。\n这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。\n所以，要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数。\n3.如何优化文件传输的性能？ 减少「用户态与内核态的上下文切换」的次数\n一次系统调用必然会发生 2 次上下文切换：首先从用户态切换到内核态，当内核执行完任务后，再切换回用户态交由进程代码执行。\n所以，要想减少上下文切换到次数，就要减少系统调用的次数。\n减少「数据拷贝」的次数\n因为文件传输的应用场景中，在用户空间我们并不会对数据「再加工」，所以数据实际上可以不用搬运到用户空间，因此用户的缓冲区是没有必要存在的。\nmmap + write 用 mmap() 替换 read() 系统调用。mmap() 系统调用函数会直接把内核缓冲区里的数据「映射」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。\n使用 mmap() 来代替 read()， 可以减少一次数据拷贝的过程。\n但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。\nsendfile 在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 sendfile()\n可以替代前面的 read() 和 write() 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。\n其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。\nSG-DMA 如果网卡支持 SG-DMA（The Scatter-Gather Direct Memory Access）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。\n从 Linux 内核 2.4 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， sendfile() 系统调用的过程发生了点变化。\n第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里； 第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝； 这个过程之中，只进行了 2 次数据拷贝\n这就是所谓的零拷贝（Zero-copy）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。。\n零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。\n所以，总体来看，零拷贝技术可以把文件传输的性能提高至少一倍以上。\n4.PageCache 有什么作用？ 文件传输过程，第一步都是先需要先把磁盘文件数据拷贝「内核缓冲区」里，这个「内核缓冲区」实际上是磁盘高速缓存（*PageCache*）。\n由于零拷贝使用了 PageCache 技术，可以使得零拷贝进一步提升了性能。\n读写磁盘相比读写内存的速度慢太多了，所以我们应该想办法把「读写磁盘」替换成「读写内存」。内存空间远比磁盘要小，内存注定只能拷贝磁盘里的一小部分数据。\n程序运行的时候，具有「局部性」，所以通常，刚被访问的数据在短时间内再次被访问的概率很高，于是我们可以用 PageCache 来缓存最近被访问的数据，当空间不足时淘汰最久未被访问的缓存。\n所以，读磁盘数据的时候，优先在 PageCache 找，如果数据存在则可以直接返回；如果没有，则从磁盘中读取，然后缓存 PageCache 中。\n还有一点，读取磁盘数据的时候，需要找到数据所在的位置，但是对于机械磁盘来说，就是通过磁头旋转到数据所在的扇区，再开始「顺序」读取数据，但是旋转磁头这个物理动作是非常耗时的，为了降低它的影响，PageCache 使用了「预读功能」。\nPageCache 的优点主要是两个：\n缓存最近被访问的数据； 预读功能； 这两个做法，将大大提高读写磁盘的性能。\n但是，在传输大文件（GB 级别的文件）的时候，PageCache 会不起作用，那就白白浪费 DMA 多做的一次数据拷贝，造成性能的降低，即使使用了 PageCache 的零拷贝也会损失性能\n当用户访问这些大文件的时候，内核就会把它们载入 PageCache 中，于是 PageCache 空间很快被这些大文件占满。 由于文件太大，可能某些部分的文件数据被再次访问的概率比较低，这样就会带来 2 个问题：\nPageCache 由于长时间被大文件占据，其他「热点」的小文件可能就无法充分使用到 PageCache，于是这样磁盘读写的性能就会下降了； PageCache 中的大文件数据，由于没有享受到缓存带来的好处，但却耗费 DMA 多拷贝到 PageCache 一次； 5.大文件传输用什么方式实现？ 当调用 read 方法读取文件时，进程实际上会阻塞在 read 方法调用，因为要等待磁盘数据的返回，如下图：\n对于阻塞的问题，可以用异步 I/O 来解决，它工作方式如下图：\n异步 I/O 并没有涉及到 PageCache，所以使用异步 I/O 就意味着要绕开 PageCache。\n绕开 PageCache 的 I/O 叫直接 I/O，使用 PageCache 的 I/O 则叫缓存 I/O。通常，对于磁盘，异步 I/O 只支持直接 I/O。\n大文件的传输不应该使用 PageCache，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache。\n于是，在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I/O + 直接 I/O」来替代零拷贝技术。\n直接 I/O 应用场景常见的两种：\n应用程序已经实现了磁盘数据的缓存，那么可以不需要 PageCache 再次缓存，减少额外的性能损耗。在 MySQL 数据库中，可以通过参数设置开启直接 I/O，默认是不开启； 传输大文件的时候，由于大文件难以命中 PageCache 缓存，而且会占满 PageCache 导致「热点」文件无法充分利用缓存，从而增大了性能开销，因此，这时应该使用直接 I/O。 另外，由于直接 I/O 绕过了 PageCache，就无法享受内核的这两点的优化：\n内核的 I/O 调度算法会缓存尽可能多的 I/O 请求在 PageCache 中，最后「合并」成一个更大的 I/O 请求再发给磁盘，这样做是为了减少磁盘的寻址操作； 内核也会「预读」后续的 I/O 请求放在 PageCache 中，一样是为了减少对磁盘的操作； 于是，传输大文件的时候，使用「异步 I/O + 直接 I/O」了，就可以无阻塞地读取文件了。\n所以，传输文件的时候，我们要根据文件的大小来使用不同的方式：\n传输大文件的时候，使用「异步 I/O + 直接 I/O」； 传输小文件的时候，则使用「零拷贝技术」； 7.2 I/O 多路复用：select/poll/epoll 1.基本的 Socket 模型 创建 Socket 的时候，可以指定网络层使用的是 IPv4 还是 IPv6，传输层使用的是 TCP 还是 UDP。\n服务器的程序要先跑起来，然后等待客户端的连接和数据，我们先来看看服务端的 Socket 编程过程是怎样的。\n服务端首先调用 socket() 函数，创建网络协议为 IPv4，以及传输协议为 TCP 的 Socket ，接着调用 bind() 函数，给这个 Socket 绑定一个 IP 地址和端口。\n绑定端口的目的：当内核收到 TCP 报文，通过 TCP 头里面的端口号，来找到我们的应用程序，然后把数据传递给我们。 绑定 IP 地址的目的：一台机器是可以有多个网卡的，每个网卡都有对应的 IP 地址，当绑定一个网卡时，内核在收到该网卡上的包，才会发给我们； 绑定完 IP 地址和端口后，就可以调用 listen() 函数进行监听，此时对应 TCP 状态图中的 listen，如果我们要判定服务器中一个网络程序有没有启动，可以通过 netstat 命令查看对应的端口号是否有被监听。\n服务端进入了监听状态后，通过调用 accept() 函数，来从内核获取客户端的连接，如果没有客户端连接，则会阻塞等待客户端连接的到来。\n那客户端是怎么发起连接的呢？客户端在创建好 Socket 后，调用 connect() 函数发起连接，该函数的参数要指明服务端的 IP 地址和端口号，然后万众期待的 TCP 三次握手就开始了。\n在 TCP 连接的过程中，服务器的内核实际上为每个 Socket 维护了两个队列：\n一个是「还没完全建立」连接的队列，称为 TCP 半连接队列，这个队列都是没有完成三次握手的连接，此时服务端处于 syn_rcvd 的状态； 一个是「已经建立」连接的队列，称为 TCP 全连接队列，这个队列都是完成了三次握手的连接，此时服务端处于 established 状态； 当 TCP 全连接队列不为空后，服务端的 accept() 函数，就会从内核中的 TCP 全连接队列里拿出一个已经完成连接的 Socket 返回应用程序，后续数据传输都用这个 Socket。\n监听的 Socket 和真正用来传数据的 Socket 是两个：\n一个叫作监听 Socket； 一个叫作已连接 Socket； 连接建立后，客户端和服务端就开始相互传输数据了，双方都可以通过 read() 和 write() 函数来读写数据。\n整个过程如下图：\n2.如何服务更多的用户？ 前面提到的 TCP Socket 调用流程是最简单、最基本的，它基本只能一对一通信，因为使用的是同步阻塞的方式，当服务端在还没处理完一个客户端的网络 I/O 时，或者 读写操作发生阻塞时，其他客户端是无法与服务端连接的。\n可如果我们服务器只能服务一个客户，那这样就太浪费资源了，于是我们要改进这个网络 I/O 模型，以支持更多的客户端。\n服务器单机理论最大能连接多少个客户端？\n相信你知道 TCP 连接是由四元组唯一确认的，这个四元组就是：本机IP, 本机端口, 对端IP, 对端端口。\n服务器作为服务方，通常会在本地固定监听一个端口，等待客户端的连接。因此服务器的本地 IP 和端口是固定的，于是对于服务端 TCP 连接的四元组只有对端 IP 和端口是会变化的，所以最大 TCP 连接数 = 客户端 IP 数×客户端端口数。\n对于 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是服务端单机最大 TCP 连接数约为 2 的 48 次方。\n这个理论值相当“丰满”，但是服务器肯定承载不了那么大的连接数，主要会受两个方面的限制：\n文件描述符，Socket 实际上是一个文件，也就会对应一个文件描述符。在 Linux 下，单个进程打开的文件描述符数是有限制的，没有经过修改的值一般都是 1024，不过我们可以通过 ulimit 增大文件描述符的数目； 系统内存，每个 TCP 连接在内核中都有对应的数据结构，意味着每个连接都是会占用一定内存的； 那如果服务器的内存只有 2 GB，网卡是千兆的，能支持并发 1 万请求吗？\n并发 1 万请求，也就是经典的 C10K 问题 ，C 是 Client 单词首字母缩写，C10K 就是单机同时处理 1 万个请求的问题。\n从硬件资源角度看，对于 2GB 内存千兆网卡的服务器，如果每个请求处理占用不到 200KB 的内存和 100Kbit 的网络带宽就可以满足并发 1 万个请求。\n不过，要想真正实现 C10K 的服务器，要考虑的地方在于服务器的网络 I/O 模型，效率低的模型，会加重系统开销，从而会离 C10K 的目标越来越远。\n3.多进程模型 基于最原始的阻塞网络 I/O， 如果服务器要支持多个客户端，其中比较传统的方式，就是使用多进程模型，也就是为每个客户端分配一个进程来处理请求。\n服务器的主进程负责监听客户的连接，一旦与客户端连接完成，accept() 函数就会返回一个「已连接 Socket」，这时就通过 fork() 函数创建一个子进程，实际上就把父进程所有相关的东西都复制一份，包括文件描述符、内存地址空间、程序计数器、执行的代码等。\n这两个进程刚复制完的时候，几乎一模一样。不过，会根据返回值来区分是父进程还是子进程，如果返回值是 0，则是子进程；如果返回值是其他的整数，就是父进程。\n正因为子进程会复制父进程的文件描述符，于是就可以直接使用「已连接 Socket 」和客户端通信了，\n可以发现，子进程不需要关心「监听 Socket」，只需要关心「已连接 Socket」；父进程则相反，将客户服务交给子进程来处理，因此父进程不需要关心「已连接 Socket」，只需要关心「监听 Socket」。\n另外，当「子进程」退出时，实际上内核里还会保留该进程的一些信息，也是会占用内存的，如果不做好“回收”工作，就会变成僵尸进程，随着僵尸进程越多，会慢慢耗尽我们的系统资源。\n因此，父进程要“善后”好自己的孩子，怎么善后呢？那么有两种方式可以在子进程退出后回收资源，分别是调用 wait() 和 waitpid() 函数。\n这种用多个进程来应付多个客户端的方式，在应对 100 个客户端还是可行的，但是当客户端数量高达一万时，肯定扛不住的，因为每产生一个进程，必会占据一定的系统资源，而且进程间上下文切换的“包袱”是很重的，性能会大打折扣。\n进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。\n4.多线程模型 既然进程间上下文切换的“包袱”很重，那我们就搞个比较轻量级的模型来应对多用户的请求 —— 多线程模型。\n单进程中可以运行多个线程，同进程里的线程可以共享进程的部分资源，比如文件描述符列表、进程空间、代码、全局数据、堆、共享库等，这些共享些资源在上下文切换时不需要切换，而只需要切换线程的私有数据、寄存器等不共享的数据，因此同一个进程下的线程上下文切换的开销要比进程小得多。\n当服务器与客户端 TCP 完成连接后，通过 pthread_create() 函数创建线程，然后将「已连接 Socket」的文件描述符传递给线程函数，接着在线程里和客户端进行通信，从而达到并发处理的目的。\n如果每来一个连接就创建一个线程，线程运行完后，还得操作系统还得销毁线程，虽说线程切换的上写文开销不大，但是如果频繁创建和销毁线程，系统开销也是不小的。\n那么，我们可以使用线程池的方式来避免线程的频繁创建和销毁，所谓的线程池，就是提前创建若干个线程，这样当由新连接建立时，将这个已连接的 Socket 放入到一个队列里，然后线程池里的线程负责从队列中取出「已连接 Socket 」进行处理。\n需要注意的是，这个队列是全局的，每个线程都会操作，为了避免多线程竞争，线程在操作这个队列前要加锁。\n上面基于进程或者线程模型的，其实还是有问题的。新到来一个 TCP 连接，就需要分配一个进程或者线程，那么如果要达到 C10K，意味着要一台机器维护 1 万个连接，相当于要维护 1 万个进程/线程，操作系统就算死扛也是扛不住的。\n5.I/O 多路复用 既然为每个请求分配一个进程/线程的方式不合适，那有没有可能只使用一个进程来维护多个 Socket 呢？答案是有的，那就是 I/O 多路复用技术。\n一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用，这种思想很类似一个 CPU 并发多个进程，所以也叫做时分多路复用。\n我们熟悉的 select/poll/epoll 内核提供给用户态的多路复用系统调用，进程可以通过一个系统调用函数从内核中获取多个事件。\nselect/poll/epoll 是如何获取网络事件的呢？在获取事件时，先把所有连接（文件描述符）传给内核，再由内核返回产生了事件的连接，然后在用户态中再处理这些连接对应的请求即可。\n6.select/poll select 实现多路复用的方式是，将已连接的 Socket 都放到一个文件描述符集合，然后调用 select 函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过遍历文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合拷贝回用户态里，然后用户态还需要再通过遍历的方法找到可读或可写的 Socket，然后再对其处理。\n所以，对于 select 这种方式，需要进行 2 次「遍历」文件描述符集合，一次是在内核态里，一个次是在用户态里 ，而且还会发生 2 次「拷贝」文件描述符集合，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。\nselect 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 1024，只能监听 0~1023 的文件描述符。\npoll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。\n但是 poll 和 select 并没有太大的本质区别，都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合，这种方式随着并发数上来，性能的损耗会呈指数级增长。\nepoll 先复习下 epoll 的用法。如下的代码中，先用e poll_create 创建一个 epol l对象 epfd，再通过 epoll_ctl 将需要监视的 socket 添加到epfd中，最后调用 epoll_wait 等待数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 int s = socket(AF_INET, SOCK_STREAM, 0); bind(s, ...); listen(s, ...) int epfd = epoll_create(...); epoll_ctl(epfd, ...); //将所有需要监听的socket添加到epfd中 while(1) { int n = epoll_wait(...); for(接收到数据的socket){ //处理 } } epoll 通过两个方面，很好解决了 select/poll 的问题。\n第一点，epoll 在内核里使用红黑树来跟踪进程所有待检测的文件描述字，把需要监控的 socket 通过 epoll_ctl() 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)。而 select/poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以 select/poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。\n第二点， epoll 使用事件驱动的机制，内核里维护了一个链表来记录就绪事件，当某个 socket 有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中，当用户调用 epoll_wait() 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。\nepoll 的方式即使监听的 Socket 数量越多的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常的多了，上限就为系统定义的进程打开的最大文件描述符个数。因而，epoll 被称为解决 C10K 问题的利器。\n边缘触发和水平触发\nepoll 支持两种事件触发模式，分别是边缘触发（*edge-triggered，ET*）**和**水平触发（*level-triggered，LT*）。\n这两个术语还挺抽象的，其实它们的区别还是很好理解的。\n使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，服务器端只会从 epoll_wait 中苏醒一次，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完； 使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束，目的是告诉我们有数据需要读取； 如果使用边缘触发模式，I/O 事件发生时只会通知一次，而且我们不知道到底能读写多少数据，所以在收到通知后应尽可能地读写数据，以免错失读写的机会。因此，我们会循环从文件描述符读写数据，那么如果文件描述符是阻塞的，没有数据可读写时，进程会阻塞在读写函数那里，程序就没办法继续往下执行。所以，边缘触发模式一般和非阻塞 I/O 搭配使用，程序会一直执行 I/O 操作，直到系统调用（如 read 和 write）返回错误，错误类型为 EAGAIN 或 EWOULDBLOCK。\n一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。\nselect/poll 只有水平触发模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。\n另外，使用 I/O 多路复用时，最好搭配非阻塞 I/O 一起使用，多路复用 API 返回的事件并不一定可读写的，如果使用阻塞 I/O， 那么在调用 read/write 时则会发生程序阻塞，因此最好搭配非阻塞 I/O，以便应对极少数的特殊情况。\n总结 最基础的 TCP 的 Socket 编程，它是阻塞 I/O 模型，基本上只能一对一通信，那为了服务更多的客户端，我们需要改进网络 I/O 模型。\n比较传统的方式是使用多进程/线程模型，每来一个客户端连接，就分配一个进程/线程，然后后续的读写都在对应的进程/线程，这种方式处理 100 个客户端没问题，但是当客户端增大到 10000 个时，10000 个进程/线程的调度、上下文切换以及它们占用的内存，都会成为瓶颈。\n为了解决上面这个问题，就出现了 I/O 的多路复用，可以只在一个进程里处理多个文件的 I/O，Linux 下有三种提供 I/O 多路复用的 API，分别是：select、poll、epoll。\nselect 和 poll 并没有本质区别，它们内部都是使用「线性结构」来存储进程关注的 Socket 集合。\n在使用的时候，首先需要把关注的 Socket 集合通过 select/poll 系统调用从用户态拷贝到内核态，然后由内核检测事件，当有网络事件产生时，内核需要遍历进程关注 Socket 集合，找到对应的 Socket，并设置其状态为可读/可写，然后把整个 Socket 集合从内核态拷贝到用户态，用户态还要继续遍历整个 Socket 集合找到可读/可写的 Socket，然后对其处理。\n很明显发现，select 和 poll 的缺陷在于，当客户端越多，也就是 Socket 集合越大，Socket 集合的遍历和拷贝会带来很大的开销，因此也很难应对 C10K。\nepoll 是解决 C10K 问题的利器，通过两个方面解决了 select/poll 的问题。\nepoll 在内核里使用「红黑树」来关注进程所有待检测的 Socket，红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)，通过对这棵黑红树的管理，不需要像 select/poll 在每次操作时都传入整个 Socket 集合，减少了内核和用户空间大量的数据拷贝和内存分配。 epoll 使用事件驱动的机制，内核里维护了一个「链表」来记录就绪事件，只将有事件发生的 Socket 集合传递给应用程序，不需要像 select/poll 那样轮询扫描整个集合（包含有和无事件的 Socket ），大大提高了检测的效率。 而且，epoll 支持边缘触发和水平触发的方式，而 select/poll 只支持水平触发，一般而言，边缘触发的方式会比水平触发的效率高。\n7.3 高性能网络模式：Reactor 和 Proactor 7.4 什么是一致性哈希？ 一致性哈希是什么，使用场景，解决了什么问题？\n大多数网站背后肯定不是只有一台服务器提供服务，因为单机的并发量和数据量都是有限的，所以都会用多台服务器构成集群来对外提供服务。\n但是问题来了，现在有那么多个节点（后面统称服务器为节点，因为少一个字），要如何分配客户端的请求呢？\n\u0026hellip;\n面经题 信号量和互斥量 信号量和互斥量都是线程同步的工具，主要用于多个线程之间对共享资源的访问控制。它们的区别主要在于对共享资源的控制方式和应用场景的不同。\n互斥量是一种独占式的锁，即只有一个线程能够持有互斥量并访问共享资源，其他线程需要等待该线程释放锁之后才能访问。互斥量主要用于对临界区的保护，即对共享资源的访问需要互斥进行。\n信号量是一种计数器，主要用于控制对有限资源的访问。它可以对共享资源的访问进行控制，但并不是独占的，即多个线程可以同时持有信号量并访问共享资源。信号量的计数器可以增加或减少，当计数器为0时，等待该信号量的线程将被阻塞，直到计数器大于0为止。\n应用场景上，互斥量通常用于对共享资源的独占访问，例如文件访问、共享内存等；而信号量主要用于控制对有限资源的访问，例如进程数、线程数、信号量数量等。\nCPU的轮询和中断模式 CPU的轮询和中断模式是计算机硬件中两种基本的处理器工作方式。\n轮询模式是指CPU不断地查询外设的状态寄存器，以确定是否有新的数据需要处理。CPU会不断地循环查询，直到数据到达才能处理，这种方式通常会占用大量的CPU时间，且效率不高。\n中断模式是指CPU将控制权交给外设，等待外设向CPU发出中断信号，CPU收到中断信号后，立即停止当前任务，跳转到中断服务程序处理中断请求。中断模式通常比轮询模式效率更高，能够使CPU在等待外设数据的过程中，可以处理其他任务。\n在实际应用中，中断模式通常比轮询模式更为常用，因为它能够充分利用CPU的时间，提高系统的响应速度。但是中断模式需要进行上下文切换和中断处理，会增加CPU的负担，因此在一些对实时性要求极高的应用场合，还是会使用轮询模式。\n浅拷贝和深拷贝是指在对象复制时，是否复制对象内部的数据。浅拷贝只复制对象的指针或引用，而不复制对象的数据；深拷贝则会复制对象的所有数据。多态是指同一种操作作用于不同的对象，可以有不同的实现方式。在C++中，多态可以通过虚函数和继承来实现。\nFlash和内存的区别 Flash和内存是两种不同的存储设备，它们之间的区别如下：\n存储介质不同：Flash是一种闪存储存介质，通常用于存储非易失性数据，例如程序代码、数据配置等。而内存是一种易失性存储介质，通常用于暂存数据和程序运行时所需要的临时数据。\n读写方式不同：Flash存储的数据是按块（block）读写的，一般每个块的大小为数十KB到数百KB不等，而内存存储的数据是按字节（byte）读写的。\n速度和容量不同：Flash的读写速度较慢，一般比内存慢几倍或更多，但Flash存储容量较大，可以存储数GB的数据。而内存读写速度较快，但存储容量较小，一般只有数MB或几十MB。\n使用场景不同：Flash适用于需要存储非易失性数据的场合，例如嵌入式设备的程序代码、配置数据等。而内存适用于需要快速读写临时数据的场合，例如计算机运行程序时的临时数据、缓存等。\n总的来说，Flash和内存都是计算机系统中重要的存储设备，各有自己的优势和不同的应用场景。\n多线程之间要传输大量的数据，如何实现？ 多线程之间要传输大量的数据，可以使用共享内存实现。共享内存是指多个进程可以访问同一块内存空间，其中一个进程将数据写入共享内存，其它进程则可以读取这些数据。\n在多线程中，使用共享内存需要注意线程同步和互斥。可以使用互斥锁和条件变量来确保共享内存的同步和互斥访问。同时，需要考虑内存分配和释放的问题，以避免出现内存泄漏和访问非法内存的问题。\n有名管道与匿名管道区别？ 命名方式：有名管道通过在文件系统中创建一个特殊的文件来命名，可以用于任意进程之间的通信；而匿名管道没有文件名，只能用于有亲缘关系的进程之间的通信，如父进程与子进程之间的通信。\n持续性：有名管道是持久化的，直到显示删除文件为止；而匿名管道则是暂时存在的，只在创建的进程关闭后才会被自动删除。\n可以用于通信的进程数量：有名管道可以用于多个进程之间的通信；而匿名管道只能用于两个进程之间的通信。\n文件描述符：有名管道和匿名管道都是文件描述符，可以像操作普通文件一样操作它们，如读写等。\n线程，进程间通信方式？ 线程和进程之间可以通过多种方式进行通信，以下是一些常见的通信方式：\n共享内存：多个进程或线程可以访问同一个内存区域，从而实现数据共享。\n管道：一种半双工的通信方式，可以实现两个进程或线程之间的通信。\n消息队列：可以实现多个进程或线程之间的异步通信。\n信号量：可以用来控制进程或线程的同步和互斥，也可以用来实现进程或线程间的通信。\n信号：进程可以向另一个进程或线程发送信号，通知其发生了某个事件。\n套接字：可以实现不同机器之间的进程或线程通信，也可以实现同一机器上不同进程或线程之间的通信。\n现在多个线程，怎么确定哪一个会先被执行？ 在多线程编程中，不能确保哪个线程会先执行，因为线程的执行顺序是不可预测的。线程的调度是由操作系统内核完成的，操作系统根据调度算法来决定下一个要执行的线程。因此，多个线程之间的执行顺序是不确定的，它取决于线程的优先级、时间片大小以及线程的阻塞和唤醒状态等因素。对于程序员来说，我们只能通过线程的同步和互斥机制来控制线程之间的执行顺序，以达到我们期望的结果。\n多个进程在获取不到锁的时候会进入什么状态？ 当多个进程在获取锁时，如果锁被占用，则进程会进入睡眠状态，等待锁的释放。在Linux中，进程等待锁的时候会进入阻塞状态，此时进程会被挂起，不再被调度器调度，直到锁被释放。进程被阻塞时，会从调度器的活动进程列表中移除，直到进程重新变成可运行状态时，才会再次被加入调度器的活动进程列表，等待被调度器调度。\n假设一个低优先的进程A获取先到锁，高优先级的进程B获取不到锁，那高优先级进程B的进行也会阻塞吗？ 如果高优先级的进程B尝试获取的是阻塞锁（也称为互斥锁），那么B会阻塞直到获取到锁。如果高优先级的进程B尝试获取的是非阻塞锁（例如自旋锁），则B会在获取不到锁的情况下忙等待，而不会阻塞。无论是阻塞还是忙等待，高优先级进程的执行都会被阻塞，直到获取到锁为止。\n在用户态开发中程序跑飞，出现段错误等情况，用通过什么方式去定位？ 使用gdb调试工具：可以使用gdb设置断点，单步执行程序，查看内存、寄存器的值等等。\n使用valgrind工具：valgrind是一种内存调试和性能分析工具，可以检测内存泄漏、使用未初始化的内存、访问越界等问题。使用valgrind可以在程序运行时监视程序的行为，从而检测出一些常见的错误。\n使用coredump文件：当程序出现崩溃时，系统会生成一个coredump文件，其中包含了程序崩溃时的内存状态。可以使用gdb加载这个文件，进行调试。\n使用日志文件：程序可以在运行过程中输出日志信息，包括各种变量的值、函数的调用情况等等。可以根据这些信息定位问题。\n信号量机制怎么实现的？该机制可以用于进程间通信吗？ 信号量机制是一种用于多线程或多进程同步的机制，通常用于控制对共享资源的访问。在Linux中，信号量可以通过semaphore.h头文件中提供的函数来实现。\n具体实现中，使用一个计数器来跟踪共享资源的数量，当需要访问共享资源时，线程或进程会尝试获取一个信号量。如果信号量的计数器大于0，则表示可以访问共享资源，计数器会减1，线程或进程可以访问共享资源；如果计数器等于0，则表示共享资源已经被占用，线程或进程需要等待信号量释放后再尝试获取。\n线程一般是怎么调度的？ Linux中的线程调度是通过调度器（scheduler）来完成的。调度器根据各个线程的优先级和调度策略，选择哪个线程应该在当前时刻运行。Linux中线程调度的主要策略是基于时间片的轮询调度（Round-Robin Scheduling），即每个线程分配一个时间片，当时间片用完后，调度器会将当前运行的线程挂起，然后选择一个新的线程运行。如果线程的时间片还没有用完，但是有更高优先级的线程需要运行，调度器会暂停当前线程，运行优先级更高的线程。这种调度方式可以保证每个线程在有限的时间内得到运行，避免某个线程一直占用CPU导致其他线程无法运行。\n除了时间片轮询调度外，Linux还提供了其他调度策略，如实时调度（Real-Time Scheduling）和优先级调度（Priority Scheduling），可以根据应用场景和需求进行选择。\n信号量互斥锁消息队列具体是怎么实现的 信号量、互斥锁和消息队列都是常用的进程间通信机制，它们的具体实现方式如下：\n信号量（Semaphore）：信号量是一种用于多进程或者多线程编程中的同步原语，用于保护共享资源的访问。在Linux中，信号量可以使用信号量集（Semaphore Set）来实现。具体来说，每个信号量集由一个唯一的键值（Key）、一个信号量计数器以及一些信号量操作（P、V操作）组成。 互斥锁（Mutex）：互斥锁也是用于保护共享资源的访问，但是只能被一个线程或进程持有，其他线程或进程要访问该资源时必须等待当前持有者释放锁。在Linux中，互斥锁可以使用pthread_mutex_t结构体和相关API来实现。 消息队列（Message Queue）：消息队列是一种进程间通信机制，用于在不同进程之间传递数据。在Linux中，消息队列可以通过System V IPC或POSIX IPC API来实现。具体来说，消息队列是一个有名管道，每个消息都包含一个类型和一个数据块，进程可以通过指定类型来读取特定的消息。 条件变量怎么实现？ 条件变量是多线程编程中一种同步机制，它允许线程在满足特定条件之前等待，当满足条件时，线程会被唤醒并执行相应操作。\n在Linux中，条件变量通常使用pthread_cond_t类型来表示，它可以与互斥量（pthread_mutex_t）结合使用。条件变量提供了三个主要的操作：\npthread_cond_init()：初始化条件变量。 pthread_cond_wait()：等待条件变量，如果条件不成立，则线程被阻塞，直到条件变量被唤醒。 pthread_cond_signal()：唤醒等待条件变量的线程。 程序包含两个线程：一个增加计数器的线程和一个等待计数器达到5的线程。增加计数器的线程在每次增加计数器后检查计数器是否等于5，如果是，则发送信号通知等待线程。等待线程在等待条件变量时被阻塞，直到计数器达到5，然后打印消息并退出。\n条件变量可以用于进程间通信，但只能用于在同一进程内创建的线程之间共享数据。如果要在不同进程之间共享数据，则需要使用其他机制，如共享内存或消息队列。\n可执行程序的后缀是什么？它的内存开始地址是什么？空间范围是多少？ 可执行程序的后缀在不同的操作系统中可能会有所不同，比如在Windows中是“.exe”或“.dll”，在Linux中是没有后缀的可执行文件。\n可执行程序的内存开始地址和空间范围则取决于操作系统和程序的具体实现方式。在大多数操作系统中，可执行程序的内存空间是由操作系统分配的，一般从虚拟内存地址的低地址开始分配。对于32位操作系统，可执行程序的内存空间范围通常是从0x08048000到0xFFFFFFFF，而64位操作系统的可执行程序内存空间则更大。\n程序出现挂死的现象，如何进行调试？ 打印日志：在程序中加入打印日志的语句，可以输出程序执行到的位置，以及一些变量的值，有助于定位问题。 使用调试工具：比如GDB、LLDB等调试工具，可以对程序进行单步调试、查看变量的值等操作，可以帮助我们快速定位问题。 模块化设计：程序模块化设计可以将程序拆分成若干个小模块，方便对问题进行定位和排查。 代码静态分析：使用代码静态分析工具可以检测出代码中的潜在问题，比如内存泄漏、空指针等，有助于避免程序出现挂死等问题。 硬件调试：如果程序挂死与硬件有关，可以使用硬件调试工具，比如逻辑分析仪、示波器等，来检测硬件是否正常工作。 计算机网络 一、基础篇 2.1 TCP/IP 网络模型有哪几层？ 应用层 电脑或手机使用的应用软件都是在应用层实现。那么，当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。\n应用层专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。 应用层是不用去关心数据是如何传输的。 应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。 传输层 应用层的数据包会传给传输层，传输层（Transport Layer）是为应用层提供网络支持的。\n在传输层会有两个传输协议，分别是 TCP 和 UDP。\nTCP 的全称叫传输控制协议（Transmission Control Protocol），大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。\nUDP 相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。\n应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个 TCP 段（TCP Segment）。\n当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是端口。\n比如 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。\n由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。\n网络层 不希望传输层协议处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是网络层（Internet Layer）。\n网络层最常使用的是 IP 协议（Internet Protocol），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会再次进行分片，得到一个即将发送到网络的 IP 报文。\n一般用 IP 地址给设备进行编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。只有一个单纯的 IP 地址虽然做到了区分设备，但是寻址起来就特别麻烦，全世界那么多台设备，难道一个一个去匹配？这显然不科学。\n因此，需要将 IP 地址分成两种意义：\n一个是网络号，负责标识该 IP 地址是属于哪个「子网」的； 一个是主机号，负责标识同一「子网」下的不同主机； 怎么分的呢？这需要配合子网掩码才能算出 IP 地址 的网络号和主机号。\n举个例子，比如 10.100.122.0/24，后面的/24表示就是 255.255.255.0 子网掩码，255.255.255.0 二进制是「11111111-11111111-11111111-00000000」，大家数数一共多少个1？不用数了，是 24 个1，为了简化子网掩码的表示，用/24代替255.255.255.0。\n知道了子网掩码，该怎么计算出网络地址和主机地址呢？\n将 10.100.122.2 和 255.255.255.0 进行按位与运算，就可以得到网络号，\n将 255.255.255.0 取反后与IP地址进行进行按位与运算，就可以得到主机号。\nIP 协议还有另一个重要的能力就是路由。实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。\n路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。\nIP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘。\n网络接口层 生成了 IP 头部之后，接下来要交给网络接口层（Link Layer）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。\nIP 头部中的接收方 IP 地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，这个思路是行不通的。\n什么是以太网呢？电脑上的以太网接口，Wi-Fi接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。\n以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在以太网进行通讯要用到 MAC 地址。\nMAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。\n网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。\n总结 综上所述，TCP/IP 网络通常是由上到下分成 4 层，分别是应用层，传输层，网络层和网络接口层。\n再给大家贴一下每一层的封装格式：\n网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。\n2.3 Linux 系统是如何收发网络包的？ 1.网络模型 为了使得多种设备能通过网络相互通信，和为了解决各种不同设备在网络互联中的兼容性问题，国际标准化组织制定了开放式系统互联通信参考模型（Open System Interconnection Reference Model），也就是 OSI 网络模型。\n该模型主要有 7 层：\n应用层，负责给应用程序提供统一的接口； 表示层，负责把数据转换成兼容另一个系统能识别的格式； 会话层，负责建立、管理和终止表示层实体之间的通信会话； 传输层，负责端到端的数据传输； 网络层，负责数据的路由、转发、分片； 数据链路层，负责数据的封帧和差错检测，以及 MAC 寻址； 物理层，负责在物理网络中传输数据帧； 由于 OSI 模型实在太复杂，提出的也只是概念理论上的分层，并没有提供具体的实现方案。\n事实上，我们比较常见，也比较实用的是四层模型，即 TCP/IP 网络模型，Linux 系统正是按照这套网络模型来实现网络协议栈的。\nTCP/IP 网络模型共有 4 层：\n应用层，负责向用户提供一组应用程序，比如 HTTP、DNS、FTP 等; 传输层，负责端到端的通信，比如 TCP、UDP 等； 网络层，负责网络包的封装、分片、路由、转发，比如 IP、ICMP 等； 网络接口层，负责网络包在物理网络中的传输，比如网络包的封帧、 MAC 寻址、差错检测，以及通过网卡传输网络帧等； TCP/IP 网络模型相比 OSI 网络模型简化了不少，也更加易记，它们之间的关系如下图：\n不过，我们常说的七层和四层负载均衡，是用 OSI 网络模型来描述的，七层对应的是应用层，四层对应的是传输层。\n2.Linux 网络协议栈 应用层数据在每一层的封装格式。\n其中：\n传输层，给应用数据前面增加了 TCP 头； 网络层，给 TCP 数据包前面增加了 IP 头； 网络接口层，给 IP 数据包前后分别增加了帧头和帧尾； 这些新增的头部和尾部，都有各自的作用，也都是按照特定的协议格式填充，这每一层都增加了各自的协议头，那自然网络包的大小就增大了，但物理链路并不能传输任意大小的数据包，所以在以太网中，规定了最大传输单元（MTU）是 1500 字节，也就是规定了单次传输的最大 IP 包大小。\n当网络包超过 MTU 的大小，就会在网络层分片，以确保分片后的 IP 包不会超过 MTU 大小，如果 MTU 越小，需要的分包就越多，那么网络吞吐能力就越差，相反的，如果 MTU 越大，需要的分包就越少，那么网络吞吐能力就越好。\nLinux 网络协议栈的样子，类似于 TCP/IP 的四层结构：\n从上图的的网络协议栈，你可以看到：\n应用程序需要通过系统调用，来跟 Socket 层进行数据交互； Socket 层的下面就是传输层、网络层和网络接口层； 最下面的一层，则是网卡驱动程序和硬件网卡设备； 3.Linux 接收网络包的流程 网卡是计算机里的一个硬件，专门负责接收和发送网络包，当网卡接收到一个网络包后，会通过 DMA 技术，将网络包写入到指定的内存地址，也就是写入到 Ring Buffer ，这个是一个环形缓冲区，接着就会告诉操作系统这个网络包已经到达。\n那应该怎么告诉操作系统这个网络包已经到达了呢？\n最简单的一种方式就是触发中断，也就是每当网卡收到一个网络包，就触发一个中断告诉操作系统。\n但是，这存在一个问题，在高性能网络场景下，网络包的数量会非常多，那么就会触发非常多的中断，要知道当 CPU 收到了中断，就会停下手里的事情，而去处理这些网络包，处理完毕后，才会回去继续其他事情，那么频繁地触发中断，则会导致 CPU 一直没完没了的处理中断，而导致其他任务可能无法继续前进，从而影响系统的整体效率。\n所以为了解决频繁中断带来的性能开销，Linux 内核在 2.6 版本中引入了 NAPI 机制，它是混合「中断和轮询」的方式来接收网络包，它的核心概念就是不采用中断的方式读取数据，而是首先采用中断唤醒数据接收的服务程序，然后 poll 的方法来轮询数据。\n因此，当有网络包到达时，会通过 DMA 技术，将网络包写入到指定的内存地址，接着网卡向 CPU 发起硬件中断，当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数。\n硬件中断处理函数会做如下的事情：\n需要先「暂时屏蔽中断」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。 接着，发起「软中断」，然后恢复刚才屏蔽的中断。 至此，硬件中断处理函数的工作就已经完成。\n硬件中断处理函数做的事情很少，主要耗时的工作都交给软中断处理函数了。\n软中断的处理\n内核中的 ksoftirqd 线程专门负责软中断的处理，当 ksoftirqd 内核线程收到软中断后，就会来轮询处理数据。\nksoftirqd 线程会从 Ring Buffer 中获取一个数据帧，用 sk_buff 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。\n网络协议栈\n首先，会先进入到网络接口层，在这一层会检查报文的合法性，如果不合法则丢弃，合法则会找出该网络包的上层协议的类型，比如是 IPv4，还是 IPv6，接着再去掉帧头和帧尾，然后交给网络层。\n到了网络层，则取出 IP 包，判断网络包下一步的走向，比如是交给上层处理还是转发出去。当确认这个网络包要发送给本机后，就会从 IP 头里看看上一层协议的类型是 TCP 还是 UDP，接着去掉 IP 头，然后交给传输层。\n传输层取出 TCP 头或 UDP 头，根据四元组「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的 Socket，并把数据放到 Socket 的接收缓冲区。\n最后，应用层程序调用 Socket 接口，将内核的 Socket 接收缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。\n至此，一个网络包的接收过程就已经结束了，你也可以从下图左边部分看到网络包接收的流程，右边部分刚好反过来，它是网络包发送的流程。\n二、TCP篇 2.1 TCP 三次握手与四次挥手 1.TCP 头格式有哪些？ TCP 头的格式\n序列号：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决网络包乱序问题。\n确认应答号：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题。\n**控制位：**ACK、RST、SYN、FIN\n2.为什么需要 TCP 协议？ TCP 工作在哪一层？ IP 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。\n如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责。\n因为 TCP 是一个工作在传输层的可靠数据传输的服务，它能确保接收端接收的网络包是无损坏、无间隔、非冗余和按序的。\n3.什么是 TCP ？ TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。\n面向连接：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的； 可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端； 字节流：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。 4.TCP 连接？ 用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。\n所以我们可以知道，建立一个 TCP 连接是需要客户端与服务端达成上述三个信息的共识。\nSocket：由 IP 地址和端口号组成 序列号：用来解决乱序问题等 窗口大小：用来做流量控制 5.如何唯一确定一个 TCP 连接呢？ TCP 四元组可以唯一的确定一个连接，四元组包括如下：\n源地址 源端口 目的地址 目的端口 6.UDP 和 TCP 有什么区别呢？分别的应用场景是？ UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。\nUDP 协议真的非常简，头部只有 8 个字节（64 位），UDP 的头部格式如下：\n目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。 包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。 校验和：校验和是为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP 包。 TCP 和 UDP 区别：\n1. 连接\nTCP 是面向连接的传输层协议，传输数据前先要建立连接。 UDP 是不需要连接，即刻传输数据。 2. 服务对象\nTCP 是一对一的两点服务，即一条连接只有两个端点。 UDP 支持一对一、一对多、多对多的交互通信 3. 可靠性\nTCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。 UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：如何基于 UDP 协议实现可靠传输？(opens new window) 4. 拥塞控制、流量控制\nTCP 有拥塞控制和流量控制机制，保证数据传输的安全性。 UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。 5. 首部开销\nTCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。 UDP 首部只有 8 个字节，并且是固定不变的，开销较小。 6. 传输方式\nTCP 是流式传输，没有边界，但保证顺序和可靠。 UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。 7. 分片不同\nTCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。 UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。 TCP 和 UDP 应用场景：\n由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：\nFTP 文件传输； HTTP / HTTPS； 由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：\n包总量较少的通信，如 DNS 、SNMP 等； 视频、音频等多媒体通信； 广播通信； 为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？\n原因是 TCP 有可变长的「选项」字段，而 UDP 头部长度则是不会变化的，无需多一个字段去记录 UDP 的首部长度。\nTCP 连接建立\n7.TCP 三次握手过程是怎样的？ TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而建立连接是通过三次握手来进行的。三次握手的过程如下图：\n一开始，客户端和服务端都处于 CLOSE 状态。先是服务端主动监听某个端口，处于 LISTEN 状态 客户端会随机初始化序号（client_isn），将此序号置于 TCP 首部的「序号」字段中，同时把 SYN 标志位置为 1，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态。 服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（server_isn），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1, 接着把 SYN 和 ACK 标志位置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态。 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 server_isn + 1 ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 ESTABLISHED 状态。 服务端收到客户端的应答报文后，也进入 ESTABLISHED 状态。 从上面的过程可以发现第三次握手是可以携带数据的，前两次握手是不可以携带数据的，这也是面试常问的题。\n一旦完成三次握手，双方都处于 ESTABLISHED 状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了。\n为什么是三次握手？不是两次、四次？\nTCP 连接：用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。\n所以，重要的是为什么三次握手才可以初始化 Socket、序列号和窗口大小并建立 TCP 连接。\n接下来，以三个方面分析三次握手的原因：\n三次握手才可以阻止重复历史连接的初始化（主要原因） 三次握手才可以同步双方的初始序列号 三次握手才可以避免资源浪费 TCP 建立连接时，通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号。序列号能够保证数据包不重复、不丢弃和按序传输。\n不使用「两次握手」和「四次握手」的原因：\n「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号； 「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。 为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？\n主要原因有两个方面：\n为了防止历史报文被下一个相同四元组的连接接收（主要方面）； 为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收； TCP 连接断开\n8.TCP 四次挥手过程是怎样的？ 天下没有不散的宴席，对于 TCP 连接也是这样， TCP 断开连接是通过四次挥手方式。\n双方都可以主动断开连接，断开连接后主机中的「资源」将被释放，四次挥手的过程如下图：\n客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。 服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSE_WAIT 状态。 客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。 等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。 客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态 服务端收到了 ACK 应答报文后，就进入了 CLOSE 状态，至此服务端已经完成连接的关闭。 客户端在经过 2MSL 一段时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭。 你可以看到，每个方向都需要一个 FIN 和一个 ACK，因此通常被称为四次挥手。\n这里一点需要注意是：主动关闭连接的，才有 TIME_WAIT 状态。\n为什么挥手需要四次为什么挥手需要四次？\n再来回顾下四次挥手双方发 FIN 包的过程，就能理解为什么需要四次了。\n关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。 服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。 从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，因此是需要四次挥手。\n嵌入式单片机/RTOS STM32的哪些功能 STM32是一款由意法半导体（STMicroelectronics）公司推出的32位微控制器，具有以下功能：\n内置ARM Cortex-M处理器核，提供高性能和低功耗。\n集成了多个模块，例如模数转换器、通用定时器、串行通信接口、中断控制器等。\n支持多种外设接口，例如USB、CAN、Ethernet、SDIO等。\n可编程性强，支持多种编程语言，例如C、C++、汇编语言等。\n提供了多种包装形式和引脚数量，以适应不同的应用需求。\n提供了丰富的开发工具和支持，例如开发板、编译器、调试器、软件库等，方便开发人员进行开发和调试。\n总之，STM32是一款功能强大、灵活多样、易于开发和部署的微控制器。\n中断服务函数和普通函数的区别 中断服务函数和普通函数之间有很大的区别，主要体现在以下几个方面：\n触发条件不同：中断服务函数是由硬件中断触发执行的，而普通函数是由代码中的函数调用语句触发执行的。\n执行环境不同：中断服务函数在中断发生时在中断上下文中执行，因此其执行环境与普通函数不同，需要遵循一定的编程规范。比如，中断服务函数不能访问用户空间的数据，不能进行堆栈分配等操作。\n执行时间限制：中断服务函数需要尽快完成处理，以便尽快返回中断处理，因为中断服务函数的执行会阻塞其他中断的处理。而普通函数没有时间限制，可以根据需要执行任意长的时间。\n参数传递方式不同：中断服务函数的参数一般都是通过全局变量或者寄存器来传递的，而普通函数的参数是通过堆栈传递的。\n数据如何在单片机上计算？从哪里取出，放到哪里？ 从外部存储器中读取数据，并将计算结果存储到内部存储器或外部存储器中。具体的操作流程如下：\n数据读取：单片机中的数据通常来源于外部设备，例如传感器、存储卡等，或者是通过串口、网络等方式接收到的数据。通过单片机的外设模块，可以将这些数据读取到单片机内部的缓冲区中。\n数据处理：读取到的数据需要进行处理，例如进行滤波、转换等操作。这些操作可以在单片机的中央处理器（CPU）中进行，或者通过专门的硬件模块实现，例如模数转换器（ADC）。\n数据存储：处理完的数据可以存储到内部存储器（例如RAM）或者外部存储器（例如闪存、EEPROM）中。存储的方式可以是直接写入存储器地址，也可以使用文件系统等高级接口进行管理。\n常用的位操作 按位与（\u0026amp;）、按位或（|）、按位异或（^）【相同为0，不同为1】、按位取反（~）、左移（\u0026laquo;）、右移（\u0026raquo;）\nUART UART是一种串行通信协议，它使用两条线（TX和RX）进行全双工通信，其中TX是发送端线路，RX是接收端线路。\nUART的技术要点包括：\n波特率：UART通信的速率是由波特率决定的，波特率指的是每秒钟传输的位数。波特率越高，传输速率越快。在UART通信中，发送端和接收端必须设置相同的波特率才能正常通信。\n数据位数：UART通信中，数据位数指的是每个字符中包含的数据位数，通常为5、6、7或8位。不同的数据位数会影响通信的数据传输范围和精度。\n停止位数：UART通信中，停止位数指的是每个字符传输结束后，发送端在TX线上保持的停止位数。通常为1或2个停止位，它们用于指示接收端此时可以进行下一次接收。\n校验位：UART通信中，校验位用于检测数据传输中的错误。常见的校验方式包括奇偶校验、偶偶校验、和校验等。\n数据传输：UART通信中，每个字符由起始位、数据位、校验位和停止位组成，这些位的顺序和长度是固定的，发送端和接收端必须按照相同的顺序和长度传输数据。\n中断处理：UART通信中，可以使用中断方式来处理数据的接收和发送，当数据接收或发送完成时，系统会产生一个中断信号，通知处理器进行相应的处理。\n数据流控制：UART通信中，为了避免数据的丢失或错误，可以使用数据流控制机制来控制数据的传输。常见的数据流控制方式包括硬件流控制和软件流控制。\n数据格式\nUART是一种通用异步收发传输技术，常用于串口通信。UART的数据格式包括数据位、停止位、奇偶校验位等，常用的数据格式有以下几种：\n8N1：8位数据位、无奇偶校验、1位停止位； 7E1：7位数据位、偶校验、1位停止位； 8O2：8位数据位、奇校验、2位停止位。 如何保证在侦听UART时不会一直判断接收到0？\n在侦听UART时，为了避免一直判断接收到0，可以使用一些技巧和策略来保证数据的正确接收。以下是一些常用的方法：\n设置接收超时：可以设置一个超时时间，在规定的时间内未接收到数据则认为接收完成，避免一直等待。例如，可以使用 select 或 poll 等系统调用来实现超时等待； 定义特殊字符：可以定义一个特殊字符，例如 ETX（End of Text），表示数据传输结束。当接收到这个特殊字符时，即可认为数据接收完成； 使用帧头和帧尾：可以在传输数据时添加帧头和帧尾，来标识数据的开始和结束。例如，可以使用 STX（Start of Text）作为帧头，ETX作为帧尾； 定时接收：可以定时接收数据，在规定的时间内接收尽可能多的数据。例如，可以设置一个计数器，定时从接收缓冲区读取数据，直到计数器到达预设值。 UART的奇偶校验\nUART通信中的奇偶校验是一种检错方式，用于检查数据传输过程中是否出现了位错误。在UART中，发送端在传输每个数据字节时，都会附加一个奇偶校验位。奇偶校验位的值由该数据字节的二进制中1的个数决定，如果1的个数是偶数，则奇偶校验位为0，否则为1。接收端接收到数据后，会再次计算数据字节中1的个数，并与接收到的奇偶校验位进行比较，如果不一致，则说明传输过程中发生了位错误。\nUART通信中奇偶校验可以分为以下几种：\n奇校验（Odd Parity）：让数据中1的个数加上校验位等于奇数，校验位为1。 偶校验（Even Parity）：让数据中1的个数加上校验位等于偶数，校验位为0。 无校验（No Parity）：不对数据进行校验，不加校验位。 奇偶校验可以提高数据传输的可靠性，但会占用一个数据位的空间，因此在数据量较大的情况下，可能会影响数据传输速率。\narm和x86区别 ARM和x86都是计算机处理器的架构，它们的设计思路和目标用户不同，因而具有一些不同的特点和优势。\n指令集：ARM架构采用的是精简指令集（RISC）的设计思路，指令集较为简单，指令长度一般为32位，指令的执行速度快，能够适应低功耗、低成本和高效率等应用场景；而x86架构采用的是复杂指令集（CISC）的设计思路，指令集较为复杂，指令长度一般为16位或32位，具有较强的兼容性和灵活性，但指令的执行速度相对较慢。 处理器核心：ARM架构的处理器核心通常比x86的处理器核心更加简单，功耗更低。ARM处理器常常被应用于嵌入式系统和移动设备等对功耗和体积有较高要求的领域；而x86处理器的核心通常比较复杂，能够更好地处理大量的运算和数据传输，因此被广泛应用于个人电脑和服务器等领域。 ARM的多核某一核出现多载的现象，如何处理？ ARM的多核系统中，某一核出现多载的现象可能会导致系统性能下降，需要进行处理。以下是可能的处理方式：\n程序优化：如果出现多载现象是因为某个程序在该核上的运行负载过重导致的，可以对该程序进行优化，减少其运行负载。\n进程迁移：将某些运行负载较重的进程迁移到其他核上运行，可以减轻某一核的负载。\n功耗调节：如果出现多载现象是因为某一核功耗过高导致的，可以通过调节功耗来解决。\n动态频率调节：如果出现多载现象是因为某一核运行频率过低导致的，可以通过动态调节该核的运行频率来提高其性能。\n多核同步：如果出现多载现象是因为多个核之间存在同步问题导致的，可以通过加入同步机制来解决。\nFreeRTOS操作系统的底层实现原理，比如任务调度的底层实现 FreeRTOS 是一个基于实时操作系统内核的开源软件，可以用于嵌入式系统的开发，主要特点是小巧、高效、灵活和可移植。FreeRTOS 采用了时间片轮询调度算法，支持多任务调度、任务优先级、信号量、消息队列、互斥锁等特性。\nFreeRTOS 的任务调度采用了时间片轮询调度算法，它把时间片均分给各个任务，每个任务运行一个时间片后，就会被挂起，然后调度器再挑选一个优先级更高的任务继续运行。FreeRTOS 支持任务优先级，任务的优先级越高，它们获取 CPU 时间片的机会就越多。在多任务环境下，任务之间的切换是由调度器负责的，它会根据任务的优先级和时间片轮询算法来决定哪个任务先执行。\nFreeRTOS 还提供了多种同步和通信机制，包括信号量、消息队列、互斥锁等。它们可以用于实现线程间同步和通信，保证数据的正确性和一致性。FreeRTOS 还支持定时器、软件定时器等特性，可以用于实现定时任务和周期性任务。\n在底层实现方面，FreeRTOS 主要是通过中断实现任务调度和同步机制。FreeRTOS 会使用定时器中断来触发任务切换，使用信号量、消息队列等机制来实现线程间同步和通信。同时，FreeRTOS 还会使用互斥锁来保护共享资源，避免多任务环境下的竞态条件。\nIIC IIC（Inter-Integrated Circuit）是一种由飞利浦公司开发的双线串行总线，可以连接多个设备，每个设备都有一个唯一的地址。以下是IIC相关技术要点的解释：\n数据线和时钟线 IIC通信协议使用两根线：数据线（SDA）和时钟线（SCL）。数据线和时钟线都是双向的，都需要由主设备控制，数据传输是同步的，由主设备产生时钟信号。主设备通过时钟信号来同步数据的传输。\nIIC地址 每个IIC设备都需要有一个唯一的地址，IIC设备可以是芯片、模块或其他外设。设备地址是7位或10位二进制数，其中前7位是设备地址，最高位指示读写操作，0表示写操作，1表示读操作。\n数据传输格式 IIC通信协议中数据的传输是以字节为单位进行的，每个字节由8位二进制数组成，包括一个起始位（Start）、8位数据、一个确认位（Acknowledge）和一个停止位（Stop）。通信的过程如下：\n主设备发送起始位（Start）信号 主设备发送设备地址和读写标志 从设备返回应答位（Acknowledge）信号 主设备发送数据 从设备返回应答位（Acknowledge）信号 重复以上步骤，直到通信结束 主设备发送停止位（Stop）信号 数据传输速度 IIC通信协议的传输速度可以通过改变时钟信号的频率来调节，通常的IIC传输速率为100kbps、400kbps或1Mbps，根据实际需求选择合适的传输速率。\n总的来说，IIC通信协议使用简单，传输效率高，传输距离远，可靠性强，因此广泛应用于嵌入式系统中的外设连接和通信。\nIIC协议是一种串行通信协议，常用于连接芯片和外设，具有高速传输、多设备共享等特点。中断是一种硬件机制，可以在特定条件下打断CPU的正常执行流程，执行中断服务程序。中断可以用于处理外部事件，如定时器、IO口、串口等，提高系统的实时性和响应速度。\nIIC协议最多能挂载的从设备个数\nI2C（IIC）协议可以连接多个从设备，但具体能挂载的从设备个数取决于总线的负载容量和总线传输速率。每个从设备都会占用一定的总线带宽和电流负载，如果挂载过多的从设备可能会导致总线通信失败或数据传输出错。\n一般情况下，I2C总线上的从设备个数建议不要超过8个，这可以保证通信的稳定性和可靠性。如果需要连接更多的从设备，可以考虑使用I2C总线分支器（I2C multiplexer）或者I2C扩展芯片（I2C expander）等辅助器件来增加总线带宽和扩展设备数量。\nSPI SPI（Serial Peripheral Interface）是一种同步串行通信协议，它用于在芯片之间传输数据。SPI通常在低速设备之间使用，例如传感器、LCD显示屏、ADC和DAC等设备。下面是SPI的一些技术要点：\n通信方式：SPI是一种同步通信协议，通信双方通过共享时钟线（SCLK）来同步数据传输。一个设备发送数据到另一个设备，数据通过MOSI（Master Output Slave Input）线发送，而另一个设备通过MISO（Master Input Slave Output）线接收数据。\n主从模式：SPI支持主从模式，主设备控制通信并发送时钟信号，从设备接受时钟信号和数据。主设备通过片选（CS）线选择从设备，每个从设备都有一个独特的片选线。\n时序：SPI通信时序包括CPOL和CPHA两个参数，这两个参数控制时钟线的极性和相位。CPOL控制时钟线的空闲状态（高电平或低电平），而CPHA控制数据的采样时间。SPI支持四种时序模式，每种模式的CPOL和CPHA值不同，可以根据实际需求选择合适的模式。\n传输速度：SPI通信速度取决于时钟频率和数据位数。通常情况下，SPI的时钟频率可以达到几十MHz，传输速度较快。\n数据传输：SPI通常使用全双工模式传输数据，数据可以在主设备和从设备之间双向传输。SPI可以传输不同大小的数据，从8位到16位或更高位。\n硬件要求：SPI需要四根线进行通信，包括时钟线（SCLK）、主设备输出从设备输入线（MOSI）、主设备输入从设备输出线（MISO）和片选线（CS）。SPI还需要一个外部时钟源，可以是晶振或其他时钟源。\n总的来说，SPI是一种简单、高效的串行通信协议，具有快速传输速度和灵活的数据传输方式。它适用于短距离、高速数据传输，是许多微控制器和外设芯片之间常用的通信方式之一。\nSPI有4种模式你知道是那4种模式吗？\nIIC和SPI区别 IIC和SPI都是常用的串行通信接口，但是它们有以下几个主要区别：\n通信方式：IIC是基于两根线（数据线和时钟线）进行通信的，而SPI是基于四根线（数据线、时钟线、片选线和从设备发出的数据有效标志线）进行通信的。 设备数量：IIC可以连接多个从设备，而SPI连接多个从设备需要使用多路复用器或芯片选择器。 传输速率：SPI通信速度比IIC快，因为SPI的时钟频率可以高达几十MHz，而IIC通常只能达到几百KHz。 通信协议：IIC通常使用标准的I2C协议，而SPI通常没有标准协议，其通信协议可以根据具体的应用自定义。 硬件复杂度：SPI通常需要更多的硬件支持，例如从设备芯片选择器等，而IIC只需要两根线就可以进行通信。 比较一下串口、IIC、SPI通信的特点 串口、IIC、SPI通信是常用的嵌入式通信协议，它们各有特点：\n串口通信： 串口通信使用串行传输方式，只需要两根线即可实现通信。它的优点是可靠性高、使用成本低、传输距离远，可以实现双向通信。缺点是速度较慢，一般用于低速数据传输。\nIIC通信： IIC通信是一种基于双线串行总线的通信协议。它使用两条线（时钟线和数据线）来传输数据，可以实现多个设备共享同一条总线。IIC通信的优点是速度快，占用的IO口少，传输距离较短，可以实现双向通信。缺点是只能在短距离内传输数据。\nSPI通信： SPI通信是一种基于同步串行总线的通信协议。它使用四条线（时钟线、数据输入线、数据输出线、片选线）来传输数据，可以实现多个设备共享同一条总线。SPI通信的优点是速度快，传输距离较长，可以实现高速数据传输。缺点是占用的IO口多。\nstm32如何进入中断？ STM32系列的微控制器使用ARM Cortex-M系列内核，其中包括Cortex-M0、Cortex-M3、Cortex-M4和Cortex-M7等不同的型号。这些内核都具有类似的中断控制器和中断服务机制，下面简要介绍STM32进入中断的流程。\n首先，在STM32中，需要使用NVIC寄存器配置和控制中断。在编写程序时，需要先使能中断控制器，即开启全局中断控制，使用如下代码可以实现：\n1 __enable_irq(); //开启全局中断控制 接着，需要定义中断服务函数，即处理中断事件的函数。在STM32中，每个中断对应着一个中断服务函数，这个函数需要以void function_name(void)的形式定义，其中function_name是对应中断的名称。在函数内部，需要实现处理中断事件的代码。例如，下面是一个简单的定时器中断服务函数的示例代码：\n1 2 3 4 5 6 7 8 9 void TIM2_IRQHandler(void) { if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET) { /* 处理中断事件 */ // ... TIM_ClearITPendingBit(TIM2, TIM_IT_Update); //清除中断标志位 } } 在中断服务函数中，需要先检查中断标志位是否被触发，如果是则执行相应的代码。最后需要清除中断标志位，以使下一次中断能够被正确处理。\n最后，需要在主函数中配置中断向量表，即将中断向量表的地址设置为中断服务函数的地址。在STM32中，中断向量表是存储在内存的第一个地址处的一组函数指针，每个指针对应着一个中断服务函数。当发生中断时，中断向量表会自动跳转到对应中断服务函数的地址处执行相应的代码。在STM32中，可以使用如下代码配置中断向量表：\n1 2 3 4 5 6 7 8 9 10 11 /* 定义中断向量表 */ void (* const g_pfnVectors[])(void) = { (void (*)(void))((uint32_t)\u0026amp;g_pfnStack[STACK_SIZE - 1]), // 其他中断服务函数的地址 TIM2_IRQHandler, // TIM2中断服务函数的地址 // ... }; /* 将中断向量表地址设置为g_pfnVectors的地址 */ SCB-\u0026gt;VTOR = (uint32_t)g_pfnVectors; 在上述代码中，g_pfnVectors是一个函数指针数组，其中存储着中断服务函数的地址。SCB-\u0026gt;VTOR是System Control Block（SCB）寄存器中的一个位域，用于指定中断向量表的地址。通过将SCB-\u0026gt;VTOR设置为g_pfnVectors的地址，即可将中断向量表设置为g_pfnVectors所指向的地址。\nRS232和RS485的区别是什么 RS232和RS485都是串口通信协议，但是有以下几个区别：\n差分信号传输方式不同：RS232使用单向传输方式，即发送方和接收方之间只有一个信号线路，而RS485使用差分传输方式，即同时有一条正线和一条负线传输数据。\n网络拓扑结构不同：RS232只能实现点对点通信，而RS485可以实现多点通信，支持半双工或全双工通信方式。\n电平信号电压和电流不同：RS232标准的电平信号电压范围为+/- 3V至+/- 15V，电流范围为+/- 3mA至+/- 30mA，而RS485标准的电平信号电压范围为+/- 1.5V至+/- 6V，电流范围为+/- 5mA。\n数据传输距离不同：RS232一般只能传输几米以内的距离，而RS485可以传输1000米以上的距离。\n数据传输速率不同：RS232的最高数据传输速率一般为115200bps，而RS485的最高数据传输速率一般为10Mbps。\nRS485支持多主机通信，也就是多个主机可以同时访问同一个设备，而RS232只能支持一主一从的通信方式。\n总的来说，RS232适用于点对点通信，距离较近、速率较低的场景，而RS485适用于多点通信、距离较远、速率较高的场景。\nRS485如果是差分的方式，那么是如何进行传输方向判定的？ RS485差分信号中，传输方向是通过控制芯片的RE（Receive Enable）和DE（Drive Enable）引脚来实现的。RE和DE引脚一般由控制芯片内部的逻辑控制电路控制，用于控制芯片的发送和接收状态。\n在发送数据时，RE和DE两个引脚被控制芯片同时拉高，表示芯片处于发送状态；在接收数据时，RE和DE两个引脚被控制芯片分别拉高和拉低，表示芯片处于接收状态。由此，接收端能够根据差分信号的电平变化来判断发送端的传输方向。当RE和DE引脚被控制芯片分别拉低和拉高时，表示芯片处于半双工模式，既可以发送数据也可以接收数据。\nTCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是两种互联网传输协议。\nTCP是一种面向连接的、可靠的协议。它在传输数据之前要先建立连接，确保数据能够安全、可靠地传输。TCP协议提供了数据传输的可靠性，具有流量控制、拥塞控制、数据完整性校验等机制，能够保证数据的可靠性和完整性。但是，由于要建立连接，因此TCP协议的传输速度相对较慢，占用资源也较多。\nUDP是一种无连接的、不可靠的协议。它不需要事先建立连接，直接向目标主机发送数据报。UDP协议不提供数据传输的可靠性，也不具备流量控制、拥塞控制等机制，数据报可能会丢失或重复，但是它的传输速度较快，资源占用较少，适合于一些实时性要求较高、数据传输量较大的场合。\n总的来说，TCP适合于要求可靠性较高的数据传输场合，如文件传输、邮件传输、网页浏览等；而UDP适合于对实时性要求较高，但对数据传输的可靠性要求不高的场合，如视频直播、在线游戏等。\n中断是如何产生的，具体的工作原理 中断是一种计算机处理器在执行程序时，接收到来自外部设备或其他软件的异步信号时，暂停正在执行的程序转而处理该信号的一种机制。\n当外设或其他软件需要向处理器发出中断请求时，会向处理器发送一个中断请求信号，处理器接收到信号后会停止正在执行的程序，并保存当前执行上下文（包括程序计数器、寄存器等状态）到栈中，接着跳转到中断处理程序的入口地址。中断处理程序执行完毕后，处理器再从栈中恢复上下文，继续执行被中断的程序。\n在计算机中，中断被实现为硬件中断和软件中断两种类型。硬件中断是由外部设备通过向处理器的中断控制器发送信号来触发的，而软件中断则是由程序在执行过程中通过系统调用等方式主动触发的。\n什么是DMA？ DMA（Direct Memory Access，直接内存访问）是计算机系统中用于实现高速数据传输的一种技术。传统的数据传输需要由CPU通过读取外设的寄存器等方式来完成，这样CPU的时间和资源就会被浪费。而DMA技术则可以通过使用专门的DMA控制器，直接将数据从外设传输到内存，或者从内存传输到外设，从而减轻CPU的负担，提高数据传输的效率。\nDMA的实现方式大致可以分为以下几个步骤：\n设置DMA控制器：首先需要通过编程的方式设置DMA控制器的相关寄存器，如DMA控制器的工作模式、传输数据的源地址和目的地址、传输数据的长度等。 请求DMA传输：外设需要向DMA控制器发送DMA请求信号，请求DMA传输。此时，DMA控制器会检查是否有优先级更高的DMA请求，如果有，则会暂停当前的DMA传输，优先执行更高优先级的DMA传输。 执行DMA传输：DMA控制器在完成以上设置后，开始执行DMA传输操作。DMA传输过程中，DMA控制器负责管理数据的传输，并在传输结束后向外设发送传输完成的信号。 DMA传输结束：当DMA传输结束后，DMA控制器会向CPU发送中断请求信号，通知CPU数据传输已经完成。 uboot的启动流程 根文件系统的启动和挂载流程，用的哪种文件系统 三个线程循环打印abc怎么同步 rtos和linux的区别，各自的优点 单片机main函数执行前会执行什么\nLINUX 面经题 常用linux指令 常用的 Linux 指令可以分为以下几类：\n文件操作类：包括 ls、cp、mv、rm、mkdir、rmdir、touch 等； 文本编辑类：包括 vi、nano、emacs 等； 系统信息类：包括 uname、hostname、top、free、df、du、ps 等； 进程管理类：包括 ps、kill、pkill、pgrep、jobs、bg、fg 等； 网络管理类：包括 ping、netstat、ifconfig、route 等； 用户管理类：包括 useradd、userdel、passwd、groupadd、groupdel、chgrp、chown 等； 权限管理类：包括 chmod、chown、chgrp 等； 压缩解压类：包括 tar、gzip、gunzip、bzip2、bunzip2、zip、unzip 等； 软件包管理类：包括 apt、yum、dpkg、rpm 等。 除了以上常用指令外，Linux 还有很多其他实用的指令，如 sed、awk、find、grep、cut、sort、uniq、awk 等，可以根据需要进行使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 man shutdown #命令说明 su\t#切换用户 #目录 cd ls mkdir rm mv cp find /bin -name \u0026#39;a*\u0026#39; #查找/bin目录下的所有以a开头的文件或者目录 pwd #显示当前位置路径 #文件 touch rm vi/vim cat more\t#可以逐页查看文件的内容，适用于查看大型日志文件，避免一次性加载整个文件 less #比more加了几个功能 tail -100 a.txt #查看文件的后100行 head #文件权限 chmod #压缩解压 tar unzip free\t#显示系统当前内存的使用情况 df -h #显示文件系统的磁盘使用情况 mount #挂载 uname -a\t#显示一些重要的系统信息 whoami\t#显示用户名 #网络 ifconfig\t#查看网络 ping IP #查看与此IP地址的连接情况 netstat\t#查看网络连接、路由表、网络接口统计信息 #进程 ps -ef #查看所有正在运行的进程 top #显示当前系统中占用资源最多的一些进程 kill pid #杀死该pid的进程 Git的base rebase merge的使用场景 Git中的base、rebase和merge都是用于合并分支的命令，它们的使用场景和效果略有不同。\nmerge merge是将两个分支的修改合并到一起。\n使用场景：\n将一个分支的修改合并到另一个分支； 多个人同时开发同一分支，需要将多个分支的修改合并到一起。 rebase rebase是将一条分支的修改“移植”到另一条分支上，使得两条分支看起来像是连续的提交。在使用rebase命令时，Git会找到两条分支的共同祖先，然后将要移植的分支的修改按照提交顺序依次应用到目标分支上，并创建一个新的commit来保存这次移植的结果。rebase的优点是不会产生无用的合并提交，但是操作比较复杂，需要注意冲突的处理。\n使用场景：\n将自己的修改“移植”到另一个分支上； 保持自己的修改与主干分支同步。 base base是指两条分支的最近公共祖先。\n总的来说，merge适用于一般的分支合并场景，rebase适用于将自己的修改与主干分支同步的场景，而base是用于理解分支关系的概念。具体使用哪种命令，需要根据具体情况进行判断。\n获取Linux的根目录如何操作？ 在Linux中获取根目录可以使用以下两种方式：\n使用根目录的绝对路径 根目录在Linux中的绝对路径为“/”，可以直接使用该路径来获取根目录，例如：\n1 char* root_dir = \u0026#34;/\u0026#34;; 使用系统调用获取根目录 可以使用系统调用getcwd()来获取当前工作目录的路径，然后在该路径上不断向上查找父目录，直到找到根目录为止。例如：\n1 2 3 4 5 6 7 char root_dir[PATH_MAX]; if (getcwd(root_dir, PATH_MAX) != NULL) { while (strcmp(root_dir, \u0026#34;/\u0026#34;) != 0) { chdir(\u0026#34;..\u0026#34;); getcwd(root_dir, PATH_MAX); } } 上述代码会在当前工作目录中不断向上查找，直到找到根目录为止，并将根目录路径保存在root_dir中。注意，该方法需要依赖系统调用，且在权限限制较高的情况下可能无法执行。\nLinux文件系统 Linux文件系统是Linux操作系统中文件存储和管理的一种方式，它是操作系统内核中的一个子系统，主要用于管理计算机中的文件、目录、设备、链接等，以及提供对这些资源的访问和保护。Linux文件系统主要由以下几个部分组成：\n虚拟文件系统（Virtual File System，VFS）：它是Linux文件系统的核心组件，提供了统一的接口来访问不同类型的文件系统，如ext4、NTFS、FAT等。VFS将底层的文件系统抽象为一组通用操作，例如读、写、打开、关闭等，这些操作通过VFS接口来实现。 硬盘分区：硬盘是Linux文件系统中最常用的存储介质之一，它通常会被分为多个分区，每个分区可以挂载到一个目录上。Linux支持多种分区格式，如MBR、GPT等。 文件系统：文件系统是Linux文件系统的基本组成部分，它定义了文件和目录的存储方式、访问权限、索引方式等。Linux支持多种文件系统，如ext4、NTFS、FAT等。 目录：目录是文件系统中的一种特殊文件，用于组织和管理其他文件和目录。Linux中的目录可以通过绝对路径或相对路径来访问。 文件：文件是Linux文件系统中的基本单元，它可以包含文本、二进制数据、程序代码等。Linux中的文件可以分为普通文件、目录、设备文件、链接文件等多种类型。 挂载：Linux中的挂载是将一个文件系统关联到一个目录上的过程，这样就可以通过该目录来访问该文件系统中的文件和目录。 访问权限：Linux文件系统提供了丰富的访问权限控制机制，可以通过设置文件和目录的权限来控制用户对这些资源的访问和操作。 shell怎么获得上一条命令执行结果 美元符号$加上括号\nshell命令怎么在后台执行\n使用\u0026amp;符号 使用nohup命令 使用ctrl+z和bg命令\nlinux下：VSS RSS PSS的区别 在 Linux 操作系统中，VSS（Virtual Set Size）、RSS（Resident Set Size）和 PSS（Proportional Set Size）都是用来表示进程占用内存的指标，它们之间的区别如下：\nVSS：进程的虚拟内存大小，包括代码、数据、共享库、栈和堆等等，它反映了进程最大的地址空间大小，但不代表进程实际使用的内存大小。\nRSS：进程实际占用的物理内存大小，即进程的常驻集大小，包括进程使用的所有物理内存（包括共享库和代码段）以及匿名内存（进程栈和堆等）的大小。\nPSS：根据进程占用的物理内存大小和进程所使用的共享内存大小来计算出来的一个指标，即“比例集大小”，它将共享内存按照使用比例分配到每个进程上，如果多个进程使用相同的共享内存，它们的 PSS 就会相等，相比 RSS 更加公平和精确。\n需要注意的是，RSS 包括共享内存的大小，而 PSS 则将共享内存按比例分配到每个进程上，因此 PSS 始终小于等于 RSS。另外，VSS 包含了所有映射到进程地址空间的虚拟地址，包括进程未使用的部分，因此 VSS 通常比 RSS 和 PSS 要大。\nLinux驱动 面经题 1、Linux驱动程序的功能是什么 Linux驱动程序是Linux内核中的一种特殊类型的程序，它的主要功能是将Linux内核与硬件设备之间进行交互，为用户空间的应用程序提供对硬件的访问和控制。\n硬件初始化：Linux驱动程序需要完成硬件设备的初始化，包括设备的寄存器设置、内存映射、中断初始化等工作，以保证硬件设备能够正确地工作。\n提供设备接口：Linux驱动程序需要实现设备的接口，为用户空间的应用程序提供对硬件设备的访问和控制。例如，设备驱动程序可以提供设备文件接口，通过打开、读写、关闭等操作实现对硬件设备的访问。\n处理硬件中断：许多硬件设备都支持中断机制，Linux驱动程序需要正确地处理硬件中断，例如响应硬件中断、处理中断请求、清除中断标志等工作。\n管理硬件资源：许多硬件设备具有资源竞争的问题，例如同一时刻只能有一个进程使用设备。Linux驱动程序需要管理硬件资源，以保证多个进程之间能够正确地共享硬件资源。\n实现特定的功能：一些设备驱动程序还需要实现特定的功能，例如网络驱动程序需要实现网络协议栈、文件系统驱动程序需要实现文件系统操作等。\n2、内核程序中申请内存使用什么函数 在Linux内核中，申请内存一般使用 kmalloc() 或者 kzalloc() 函数。\nkmalloc() 函数：kmalloc() 函数用于在内核中申请一块指定大小的内存空间，其函数原型为：\n1 void *kmalloc(size_t size, gfp_t flags); size 参数表示需要申请的内存大小，flags 参数表示内存分配时的标志。该函数返回一个指向申请到的内存块的指针。\nkzalloc() 函数：kzalloc() 函数与 kmalloc() 函数相似，但会将申请到的内存空间清零，其函数原型为：\n1 void *kzalloc(size_t size, gfp_t flags); size 和 flags 参数的含义与 kmalloc() 函数相同。该函数返回一个指向申请到的内存块的指针，同时该内存块的所有字节都被初始化为0。\n这两个函数都属于动态内存分配函数，其申请的内存块是位于内核空间中的，因此不能直接被用户空间的应用程序访问。在使用完这些内存块后，应该使用 kfree() 函数将其释放，以避免内存泄漏。\n3、内核程序中申请内存和应用程序时申请内存有什么区别？ 内存的地址空间不同：应用程序中申请的内存位于用户空间，而内核程序中申请的内存位于内核空间。 内存分配的方式不同：应用程序中通常使用 malloc()、calloc() 等函数动态地分配内存，而内核程序中通常使用 kmalloc()、kzalloc() 等函数动态地分配内存。 内存管理的机制不同：在应用程序中，操作系统会使用虚拟内存管理机制对内存进行管理和保护，以保证不同进程之间不会相互干扰。而在内核程序中，操作系统直接管理物理内存，没有虚拟内存的保护机制，需要自己手动管理和保护内存，避免内存泄漏、内存溢出等问题。 内存访问的权限不同：在应用程序中，一般只有用户空间的代码可以直接访问用户空间的内存，而内核程序可以直接访问内核空间的内存。另外，在内核空间中，还有访问硬件资源的权限，例如访问 I/O 端口、中断等。 4、自旋锁和信号量在互斥使用时需要注意什么？在中断服务程序里面的互斥是使用自旋锁还是信号量？ 自旋锁和信号量在互斥使用时需要注意以下几点：\n自旋锁是基于忙等待的锁机制，当资源被占用时，其他线程会一直循环等待直到获取到锁为止，这可能会导致死锁。因此，自旋锁的使用需要考虑锁的粒度和等待时间，避免死锁和长时间的忙等待。\n信号量是基于阻塞的锁机制，当资源被占用时，其他线程会被阻塞，等待锁释放后才能继续执行。因此，信号量的使用需要考虑锁的粒度和阻塞时间，避免死锁和长时间的阻塞。\n在中断服务程序里面的互斥一般使用自旋锁，因为中断服务程序是在中断上下文中运行的，不能被阻塞，也不能访问用户空间的内存。自旋锁适用于短时间内等待锁的情况，因此在中断服务程序中使用自旋锁可以获得更好的性能。但需要注意，在中断服务程序中获取自旋锁时不能调用可能会引起阻塞的函数，否则会导致死锁或系统崩溃。\n5、驱动卸载异常可能是由什么原因引起的？ 设备被卸载前未释放占用的资源：驱动程序在设备卸载前应该释放所有占用的资源，例如打开的文件描述符、内存、I/O 端口等。如果驱动程序未正确释放这些资源，可能会导致卸载异常。 卸载操作被其他进程或模块阻塞：在进行驱动卸载操作时，如果其他进程或模块正在使用该驱动或设备，卸载操作可能会被阻塞，导致卸载异常。为了避免这种情况，驱动程序在卸载前应该先检查是否有其他进程或模块正在使用该设备，如果有，则应该等待其完成操作后再进行卸载。 6 Linux中引入模块机制有什么好处？ 灵活性：使用模块机制可以动态地向内核中添加或删除功能，而不需要重新编译整个内核。这使得内核的定制和升级变得更加灵活和方便。\n功能扩展：使用模块机制可以为内核添加新的功能或设备支持，例如网络驱动程序、文件系统、USB 设备等。这使得内核能够更好地适应各种硬件和应用场景。\n资源共享：模块机制可以允许多个模块共享内核资源，例如设备驱动程序可以通过模块机制实现共享同一设备的数据结构或函数接口。\n系统稳定性：模块机制可以使内核中的功能更加模块化，减少内核的复杂性，从而提高系统的稳定性和可靠性。\n调试和维护：使用模块机制可以方便地对内核模块进行调试和维护，例如可以通过调试工具动态地加载、卸载和调试内核模块，而不需要重启系统。\n熟悉MCU或者SOC常见驱动(CAN、以太网、存储驱动、USB、SPI、IIC、UART、DMA、中断等)\n如何将驱动部署到树莓派上 将驱动部署到树莓派上，大致的步骤如下：\n确定需要部署的驱动和驱动源码，以及树莓派的操作系统版本和内核版本。 在树莓派上安装编译工具链和内核头文件，这些工具和头文件可以通过apt-get命令安装。 下载驱动源码，解压缩，进入源码目录，运行make命令编译驱动模块。编译生成的驱动模块文件通常位于源码目录下的“*.ko”文件中。 加载驱动模块，可以通过insmod命令加载模块。如果需要在系统启动时自动加载模块，可以将模块名添加到/etc/modules文件中。 卸载驱动模块，可以通过rmmod命令卸载模块。 Linux增加驱动的过程 在Linux系统中增加一个驱动通常需要以下步骤：\n写驱动代码：驱动代码主要包括两部分，一是驱动程序，二是对应的设备节点。驱动程序是实现设备的读写和控制逻辑，设备节点则是用于用户空间和内核空间进行通信的接口。\n编译驱动代码：将驱动代码编译成内核模块（.ko文件），需要用到Linux内核源码中的Makefile文件和Kconfig文件。\n加载驱动模块：使用insmod命令加载驱动模块，将模块插入内核并执行模块的初始化函数。\n卸载驱动模块：使用rmmod命令卸载驱动模块，将模块从内核中移除并执行模块的清理函数。\n测试驱动：使用测试程序或者应用程序通过设备节点进行读写或控制设备，测试驱动是否正常工作。\n在增加驱动的过程中需要注意以下几点：\n写驱动代码需要遵守Linux内核开发规范，包括驱动程序和设备节点的命名、内核数据结构的使用等方面。\n驱动模块需要编译成内核模块，不能直接编译成可执行文件。\n加载驱动模块需要具有root权限或者使用sudo命令。\n测试驱动时需要注意数据的正确性和边界条件，防止出现内存泄漏、死锁等问题。\n驱动代码需要经过充分的测试和验证，确保其稳定性和可靠性。\n嵌入式linux驱动是怎么写的？ 嵌入式 Linux 驱动程序通常采用字符设备驱动、块设备驱动、网络设备驱动等类型，编写步骤如下：\n确定驱动类型和设备名称：确定驱动类型，选择设备名称和驱动程序的主设备号，这是在驱动注册和设备文件节点创建时需要用到的。\n编写设备文件操作函数：包括 open、release、read、write、ioctl 等函数，这些函数实现了对设备的控制和数据交互。\n实现驱动初始化和注销函数：init 和 exit 函数，init 函数初始化驱动，register_chrdev 和 cdev_add 函数完成驱动注册和设备节点创建，exit 函数注销驱动，释放驱动资源。\n实现中断处理函数：针对硬件中断，需要实现对应的中断处理函数，处理中断事件。\n编写 Makefile 文件：编写 Makefile 文件，描述编译、链接、安装等过程，方便编译和部署。\n编译、链接、部署：使用交叉编译器编译、链接，将生成的驱动模块和相关文件部署到目标系统中，完成驱动程序的加载和运行。\n说说Linux多线程编程 Linux多线程编程指在Linux操作系统下使用多线程进行程序开发。Linux下的多线程编程主要是基于POSIX标准的pthread库来实现的。下面是Linux多线程编程的一些基本知识：\n线程创建：使用pthread_create()函数可以创建一个线程，该函数需要传入一个线程标识符、线程属性、线程函数和线程函数参数。\n线程同步：Linux下线程同步主要包括互斥锁、条件变量和信号量。互斥锁用于保护临界区，条件变量用于线程等待某些条件满足，信号量用于控制并发访问资源。\n线程退出：线程可以通过pthread_exit()函数来退出，也可以通过return语句退出。主线程可以通过pthread_join()函数等待其他线程退出。\n线程取消：线程可以通过pthread_cancel()函数来取消，被取消的线程可以通过pthread_testcancel()函数来检测是否被取消。\n线程调度：Linux下的线程调度采用抢占式调度策略，优先级高的线程会抢占CPU资源，优先级低的线程会被挂起。\n在进行Linux多线程编程时，需要注意以下几点：\n线程同步：多线程编程中需要考虑线程之间的同步问题，以避免数据竞争和死锁等问题。\n内存管理：多线程编程需要考虑内存的分配和释放，避免出现内存泄漏和野指针等问题。\n线程安全：多线程编程需要考虑线程安全问题，以避免出现数据竞争和线程不安全的情况。\n调试和排错：多线程编程中调试和排错比较困难，需要使用一些调试工具和技术，以便及时发现和解决问题。\n说说Linux网络编程过程 Linux网络编程主要涉及到以下过程：\n创建 socket 创建一个 socket 句柄用于后续操作。可以使用 socket 系统调用创建 socket 句柄，根据协议类型和传输方式，选择合适的参数来调用该系统调用。 绑定 IP 地址和端口号 如果要接收来自网络的连接请求，需要使用 bind 系统调用将 socket 句柄与 IP 地址和端口号绑定。 监听端口 使用 listen 系统调用让 socket 句柄进入监听状态，等待来自客户端的连接请求。 接受连接请求 当有客户端连接请求到来时，使用 accept 系统调用接受连接请求并返回一个新的 socket 句柄，该句柄用于后续与客户端的通信。 与客户端通信 使用 send 和 recv 等系统调用进行数据传输，其中 send 系统调用用于将数据发送到网络，recv 系统调用用于从网络中接收数据。 断开连接 当通信结束后，使用 close 系统调用关闭与客户端的连接，释放相应的资源。 gcc和armcc编译出来的程序有什么差异么？ GCC和ARMCC是两种不同的编译器，GCC是开源的C/C++编译器，而ARMCC是由ARM公司开发的商业编译器。它们在编译出来的程序上会有一些差异。\n一些差异点如下：\n编译速度：ARMCC编译速度相对较快，GCC编译速度相对较慢。 代码优化：ARMCC编译器在代码优化方面较强，能够生成更高效的代码，而GCC编译器在某些情况下可能会生成相对较差的代码。 编译选项：ARMCC编译器提供了一些独特的编译选项，能够进行更为精细的控制，而GCC的编译选项相对简单。 库的支持：GCC编译器可以使用开源的库，而ARMCC只能使用ARM提供的库。 代码移植性：使用GCC编译的代码可以很方便地在不同的平台上移植，而使用ARMCC编译的代码则可能会存在一些平台兼容性问题。 ROS操作系统是什么 ROS（Robot Operating System）是一个开源的机器人操作系统，旨在为机器人软件开发提供一种灵活、可重用的框架。从技术角度来说，ROS并不是一个完整的操作系统，而是一个构建在现有操作系统之上的中间件层，提供了一系列的工具、库和约定，使得机器人软件开发更加容易、快速和可靠。\nROS的主要特点包括：\n1.分布式系统：ROS支持多台计算机上的节点通信，允许用户通过网络在不同的机器人上运行节点。\n2.模块化设计：ROS采用模块化设计，可以将不同的功能模块打包为独立的节点，方便用户自定义构建机器人应用程序。\n3.语言支持：ROS支持多种编程语言，包括C++、Python等，方便用户根据自己的需求选择不同的编程语言。\n4.强大的工具和库：ROS提供了丰富的工具和库，如可视化工具、运动规划库、机器人模拟器等，可以大大提高机器人软件开发的效率。\nROS操作系统和其它操作系统的区别？ ROS（Robot Operating System）是一款机器人操作系统，而Linux是一款通用的计算机操作系统。虽然ROS是基于Linux开发的，但是它们之间有一些区别：\n目标用户不同：Linux是通用的计算机操作系统，面向的用户是广泛的计算机用户，而ROS主要面向机器人应用领域的开发者和研究人员。 应用场景不同：Linux可以应用于各种领域，包括服务器、桌面、移动设备等，而ROS主要用于机器人的控制、导航、感知等方面。 软件架构不同：Linux的软件架构是通用的，而ROS则提供了一套专门为机器人开发的软件架构。ROS中的软件组件被称为“节点”（nodes），节点之间通过消息传递机制通信，方便实现分布式控制和处理。 应用开发方式不同：Linux应用开发主要是面向进程和线程编程，而ROS应用开发则是基于节点的，需要使用ROS提供的工具和库函数进行开发。 发布和共享代码的方式不同：Linux应用程序可以通过软件包管理工具进行发布和共享，而ROS应用程序则可以通过ROS软件包管理工具进行发布和共享。 Linux应用 面经 项目有什么难点 怎么解决 数组中选择第3大的数字 小顶堆\nunordered_set\ntcp、udp区别、udp怎么变安全 TCP：\n面向连接。在数据传输之前，必须建立一个连接。 可靠的。使用序列号、确认和重传机制来确保数据的正确性和完整性。 面向字节流。将数据分割成小块并以顺序发送，接收端重新组装这些块。 适用于网页浏览、文件传输。 UDP：\n无连接。发送端直接将数据包发送到接收端，而不需要建立连接。 不可靠。数据包可能会在传输过程中丢失或以不同的顺序到达。 数据报协议。将数据分为离散的数据包，每个数据包都是一个独立的单元，没有顺序要求。 适用于视频流、在线协议。 UDP变安全\n加密数据，数据签名，消息认证码，访问控制\n访问www.baidu.com用到了哪些协议 HTTP/HTTPS（超文本传输协议） DNS（域名系统） TCP/IP（传输控制协议/互联网协议） TLS/SSL（传输层安全协议/安全套接字层协议） ICMP（Internet控制消息协议）： IO复用 用于在单个线程或进程中同时监视多个I/O操作，允许程序同时等待多个文件描述符（通常是套接字）上的I/O事件，通常与非阻塞I/O一起使用，以实现高效的异步I/O操作。\n一般步骤如下：\n创建需要监视的套接字或文件描述符。 使用I/O复用函数（如select、poll、epoll等）来等待I/O事件。 当有事件发生时，I/O复用函数将通知应用程序，应用程序可以执行相应的读取或写入操作。 处理完事件后，应用程序继续等待下一个事件。 异步IO和非阻塞IO 异步IO：\n发出I/O请求后不必等待操作完成。\n应用程序继续执行其他任务，而I/O操作完成后，操作系统会通知应用程序。\n事件驱动\n非阻塞IO：\n允许进程或线程在发出I/O请求后不必等待操作完成。\n非阻塞的I/O操作被调用时，它会立即返回。周期性地轮询或使用选择（select）函数来检查I/O操作是否已经完成。\n多线程和多进程优劣 多线程：\n多线程共享同一进程的内存空间，通信更高效 创建销毁线程开销小，切换成本小 适用于IO密集型 多进程：\n每个进程有自己的独立空间，进程之间不会互相干扰 适用于CPU密集型 内核线程和用户线程 内核线程：\n内核直接管理和调度 可以执行系统调用 线程切换开销较高，它需要从用户模式切换到内核模式。 用户线程：\n用户空间的应用程序库管理 无法直接执行系统调用，必须将请求传递给相关的内核线程或进程。 用户线程相对较轻量级且更灵活 用户线程的线程切换开销较低，不涉及内核模式和用户模式之间的切换。线程切换是在用户空间完成的。 静态库是在编译的什么阶段产生的？ 编译阶段\n虚函数存储在哪里？ 虚函数表vtable在Linux/Unix中存放在可执行文件的只读数据段中(rodata)，微软的编译器将虚函数表存放在常量段。\ngdb常用命令 启动和退出： gdb [可执行文件]：启动GDB并加载指定的可执行文件。 quit 或 q：退出GDB。 运行程序： run 或 r：运行被调试的程序。 断点： break [文件名:行号]：在指定的源代码行上设置断点。 break [函数名]：在指定的函数入口处设置断点。 info breakpoints：列出所有断点。 delete [断点号]：删除指定的断点。 继续执行： continue 或 c：继续执行程序，直到遇到下一个断点或程序结束。 next 或 n：执行下一行代码，不进入函数内部。 step 或 s：执行下一行代码，如果有函数调用，则进入函数内部。 查看变量和内存： print [表达式] 或 p [表达式]：打印表达式的值。 info locals：显示当前函数的局部变量。 info args：显示当前函数的参数。 x/[格式] [地址]：以指定格式查看内存中的内容，例如 x/4xw \u0026amp;variable 可以查看变量的四个字（word）。 回溯和堆栈： backtrace 或 bt：显示函数调用堆栈。 frame [帧号]：切换到指定堆栈帧。 info frame：显示当前堆栈帧的信息。 设置断点条件： break [文件名:行号] if [条件]：在满足条件时触发断点。 监视点： watch [表达式]：设置监视点，当表达式的值发生变化时停止程序。 info watchpoints：列出所有监视点。 单步执行汇编指令： si：单步执行一条汇编指令。 ni：单步执行一条汇编指令，不进入函数。 改变变量的值： set variable [变量名]=[新值]：修改变量的值。 加载共享库： sharedlibrary：加载共享库以进行调试。 其他： list 或 l：显示源代码。 help 或 h：获取GDB的帮助。 info [选项]：显示有关程序、线程、源文件等的信息。 memcpy、strcpy区别 memcpy：\n从一个内存地址复制一定数量的字节到另一个内存地址。 不需要包含终止符。但如果没有足够的目标内存空间，可能会导致缓冲区溢出。 没有返回值。 strcpy:\n复制字符串直到遇到字符串终止符。 需要确保源字符串以 null 结尾，否则可能导致未定义的行为。 返回目标字符串的指针。 讲一讲你了解的linux操作系统 开源的、基于Unix的操作系统内核，它是一个典型的多用户、多任务操作系统。\n多样的发行版、命令行界面、开发者友好、网络和服务器、社区支持\n多线程开发需要注意些什么？ 线程安全、死锁、资源管理、考虑性能、避免饥饿和优先级反转\n线程和进程的区别，分别是怎么通信的 线程：\nCPU调度的单位 共享相同的进程内存空间 创建、销毁和切换开销小 并发性较高，可以在同一进程内并发执行，共享数据和资源。 通信：线程之间通信相对容易，因为它们共享相同的地址空间。线程之间通常使用共享内存、互斥锁、条件变量、信号量等同步机制来实现通信和资源共享。 进程：\n资源分配的单位 每个进程都有自己的独立内存空间，通信和资源共享需要特殊的机制。 通信：管道、消息队列、共享内存、套接字等。这些机制允许不同进程之间在不同的地址空间中进行数据传输和通信。 用户空间和内核空间的访问方式 通过系统调用请求内核执行特权操作。\n使用特殊的指令或软件中断（如x86架构上的int 0x80或syscall指令）来触发系统调用。\n当发生中断时，CPU会暂停正在执行的用户空间代码，并跳转到内核空间中断处理程序。\n中断处理程序负责处理中断，保存用户空间的状态、执行必要的操作，然后返回到用户空间。\n在用户空间，通常有一个系统调用库（如glibc），它提供了与系统调用的高级接口，以便用户空间程序更容易地发起系统调用。\n对epoll的理解\n允许程序同时监视多个文件描述符，以确定哪些文件描述符已准备好进行读取或写入，而无需阻塞地等待。提高了程序的并发性能。 与传统的select和poll相比，epoll在大规模并发的情况下表现更出色。它使用了内核事件通知机制，可以有效地管理大量的文件描述符，而不会引入线性扫描的性能问题。 epoll通常与非阻塞I/O一起使用，以确保文件描述符的操作不会阻塞整个程序。 如何避免死锁 按顺序获取锁、使用超时机制、使用尝试锁、资源分级（获取较低级别的资源之后才能请求较高级别的资源）、定期检查死锁、使用自旋锁\n检测死锁 资源申请机制、系统监视（多个进程都在等待某个资源，并且该资源的使用量已经达到或接近上限）、死锁检测算法（可以采用图论、图算法或其他数学方法）\nconst和define区别 const：\n具有作用域，只在定义它们的代码块或函数内可见。 类型安全性，编译器会检查使用 const 常量的地方是否与其类型兼容。 在编译阶段处理。 #define ：\n创建的宏常量是全局的。 没有类型信息，它们只是简单地进行文本替换。 在预处理阶段处理的。 const变量可以用指针改变吗，局部const和全局const都可以吗，在mcu和linux上有什么区别 const 变量是只读的，不能通过直接赋值或指针来修改其值。无论是局部的还是全局的 const 变量都不行。\n局部 const 变量通常存储在栈上，全局范围内定义的 const 变量存储在程序的数据段中。\n在 MCU 上，内存资源通常有限，可能无法轻松支持数据段中的全局 const 变量。不同的 MCU 使用不同的编译器和工具链，这些工具链可能对 const 变量的处理方式有所不同。\n什么时候要注意大小端 跨平台数据交换：不同的计算机架构之间传递时，需要考虑大小端。 文件格式：如果您正在读取或写入二进制文件格式，文件中的数据的字节序可能与您的计算机字节序不同。在这种情况下，您需要进行字节序转换以正确处理文件中的数据。 网络通信：不同的计算机可能使用不同的字节序。 硬件寄存器：某些硬件寄存器的访问可能受到大小端的影响。在与硬件通信时，需要了解硬件的字节序要求。 互斥锁和自旋锁哪个不能递归访问 互斥锁是不支持递归访问的，这意味着同一线程在已经持有互斥锁的情况下再次尝试获取锁会导致死锁。要支持递归访问，需要使用递归互斥锁。\n自旋锁通常支持递归访问，允许同一线程多次获取自旋锁，只要每次获取都有相应的释放操作。\n锁的选择：\n如果临界区的保护时间很短，且锁的竞争不激烈，自旋锁可能是一个更好的选择，因为它减少了线程切换的开销。 如果临界区的保护时间较长，或者锁的竞争较激烈，互斥锁可能更适合，因为它可以有效地释放 CPU 资源并避免浪费。 锁一定会调用系统调用吗 用户态锁：\n用户态锁是在用户空间实现的，它们通常不涉及系统调用。用户态锁的操作是通过用户程序中的代码来完成的，而不需要进入内核态。 例如，普通的互斥锁和自旋锁在低竞争情况下通常会采用忙等（自旋）方式，而不会触发系统调用。 内核态锁：\n内核态锁是在内核空间实现的，它们涉及系统调用。内核态锁的操作需要进入内核态，因为内核负责管理和维护锁的状态。 例如，读写锁、条件变量等通常需要系统调用来进行锁的获取和释放。 uart和spi，如果需要两个芯片间双向通信用哪种协议 通信速度：如果您需要高速通信，SPI 通常具有更高的速度潜力 硬件支持：检查您的芯片和外围设备支持哪种通信协议。 通信距离：SPI 通常用于短距离通信，而UART 可以用于较长的通信距离。 通信复杂性：SPI 通常需要更多的线路和硬件资源。UART 通常较简单。 自动化工具 Shell 脚本 编程语言编写脚本和应用程序，用于自动化各种任务 容器编排工具：容器编排工具如Docker Compose、Kubernetes 任务调度工具：任务调度工具如Apache Airflow、Cron等用于定期执行任务 监控和警报工具：监控和警报工具如Prometheus、Nagios、Zabbix等 linux程序如果访问空指针会出现什么 段错误、未定义行为、程序崩溃或异常终止\nmmu是硬件还是软件 MMU（内存管理单元）是硬件的一部分。实现在CPU中。MMU的主要任务是管理计算机内存的访问，包括虚拟内存到物理内存的映射、内存保护和访问权限等。\n主要功能包括：\n​\t地址映射、内存保护、页面交换、缓存管理\n三级页表是如何寻址的 三级页表：顶级页表、中间页表和底层页表。\n如何寻址的一般过程：\n虚拟地址分解、顶级页表访问、中间页表访问、底层页表访问、偏移量计算、访问物理内存 什么情况下会自己写拷贝构造函数 动态内存分配： 默认的浅拷贝构造函数是浅拷贝。可能导致资源泄漏或悬挂指针。在这种情况下，需要编写自定义的拷贝构造函数来执行深拷贝，即复制指针指向的数据。 资源管理： 如果类负责管理其他资源，如文件句柄、网络连接等，可能需要自定义拷贝构造函数来确保在复制对象时适当地管理这些资源，以避免资源泄漏或重复释放资源。 特殊逻辑： 希望在对象拷贝时执行特殊的逻辑操作，例如记录日志、更新计数器等。 禁止拷贝： 在某些情况下，希望禁止类的对象被拷贝，以确保对象的唯一性。可以定义私有的拷贝构造函数并将其设置为删除，或者声明拷贝构造函数为私有，从而禁止对象的拷贝。 STL库的内存配置 包括一级内存配置和二级内存配置。\n一级内存配置： 一级内存配置使用C++标准库中的new和delete运算符来执行内存分配和释放操作。这些运算符是基本的内存配置工具，它们使用全局的内存池来进行分配和释放操作。一级内存配置相对简单，适用于大多数情况，但可能会受到内存碎片等问题的影响。\n二级内存配置： 二级内存配置是STL库中的高级内存配置机制，它是建立在一级内存配置之上的。STL的二级内存配置机制通过内存分配器（allocator）来实现，它可以更灵活地管理内存池，减少内存碎片和提高性能。二级内存配置的一个主要目标是提供更好的内存管理，以满足STL容器和算法的性能需求。\n线程安全是如何保证的？除了锁还有 互斥锁： 读写锁： 原子操作：原子操作是不可分割的操作，它们可以确保在多线程环境中执行时不会中断。许多编程语言和库提供了原子操作，可以用来保护共享数据。 无锁数据结构：无锁数据结构是一种设计，使用原子操作和非阻塞算法来实现线程安全。 信号量和条件变量：信号量和条件变量可以用来实现更复杂的同步机制。 线程局部存储：线程局部存储允许每个线程拥有自己独立的数据副本。 我的面经 int a:1表示什么\n运行时bug怎么调试\n1. FreeRTOS 音乐播放器 歌曲名记录在listview控件\n优先级\n任务 优先级 IDLE 0 GUI 1 UserIF 2 接口消息处理 LED 3 Start 4 启动任务。最高优先级任务，这里实现按键扫描和触摸检测 MUSIC 5 MP3软解任务 任务状态\n阻塞 就绪 删除 挂起\n使用互斥信号量\n任务通信\n10个存储指针变量的消息队列，同时分配SRAM作为动态内存\n2.比特率和波特率 比特率是每秒钟传送的比特数量。比特率基本单位为bit/s或bps，全称为bit per second\n波特：每秒钟传送的符号（码元）数量，又称为传码率，单位是波特（Baud、B，即symbol/s）。在通信系统中，携带数据信息的信号单元称为码元，也称为符号（symbol）。\n码元状态为N，此码元所需要的比特位数：$log_2N$\n比特率=波特率*$log_2N$\n3.UART 参考\n通用异步收发器（Universal Asynchronous Receiver/Transmitter,UART)，是一种串行、异步、全双工的通信协议\n传输速率：支持多种不同的波特率，最常见的包括9600、115200等。\n传输距离：用于短距离通信，典型的距离范围为几米到数十米。\n信号线上的状态为高电平时代表‘1’，信号线上的状态为低电平时代表‘0’。\n空闲位：\n​\t当总线处于空闲状态时信号线的状态为‘1’即高电平，表示当前线路上没有数据传输。\n起始位：\n每开始一次通信时发送方先发出一个逻辑”0”的信号（低电平），表示传输字符的开始。\n数据位：\n起始位之后就是我们所要传输的数据，数据位可以是5、6、7、8，9位等，构成一个字符（一般都是8位）。先发送最低位，最后发送最高位。\n奇偶校验位：\n无校验（no parity）。 奇校验（odd parity）：如果数据位中“1”的数目是偶数，则校验位为“1”，如果“1”的数目是奇数，校验位为“0”。 偶校验（even parity）：如果数据为中“1”的数目是偶数，则校验位为“0”，如果为奇数，校验位为“1”。 停止位：\n它是一个字符数据的结束标志。可以是1位、1.5位、2位的高电平。\n4.SPI https://blog.csdn.net/as480133937/article/details/105764119\nSPI(Serial Peripheral interface)，串行外围设备接口。高速的，全双工，同步的通信总线。摩托罗拉\n传输速率高，可以达到几十Mbps甚至更高。适用于相对短距离的通信\nSPI主从模式\nSPI分为主、从两种模式。一个主设备，一个或多个从设备。提供时钟的为主设备（Master），接收时钟的设备为从设备（Slave），SPI接口的读写操作，都是由主设备发起。当存在多个从设备时，通过各自的片选信号进行管理。\nSPI信号线 SPI接口一般使用四条信号线通信：\nMISO： 主设备输入/从设备输出引脚。该引脚在从模式下发送数据，在主模式下接收数据。 MOSI： 主设备输出/从设备输入引脚。该引脚在主模式下发送数据，在从模式下接收数据。 SCLK：串行时钟信号，由主设备产生。 NSS：从设备片选信号，由主设备控制。低电平有效，多个从设备多个片选引脚。 设备选择\n当SPI主设备想读/写［从设备］时，它首先拉低［从设备］对应的SS线（SS是低电平有效）\nSPI数据发送接收\nSPI主机和从机都有一个串行移位寄存器，主机通过向它的SPI串行寄存器写入一个字节来发起一次传输。\n首先拉低对应SS信号线，表示与该设备进行通信 主机通过发送SCLK时钟信号，来告诉从机写数据或者读数据 主机将要发送的数据写到发送数据缓存区(Menory)，缓存区经过移位寄存器(0~7)，串行移位寄存器通过MOSI信号线将字节一位一位的移出去传送给从机，同时MISO接口接收到的数据经过移位寄存器一位一位的移到接收缓存区。 从机也将自己的串行移位寄存器(0~7)中的内容通过MISO信号线返回给主机。同时通过MOSI信号线接收主机发送的数据，这样，两个移位寄存器中的内容就被交换。 SPI时钟四种模式\n时钟极性(CPOL)定义了时钟空闲状态电平：\nCPOL=0，表示当SCLK=0时处于空闲态，所以有效状态就是SCLK处于高电平时 CPOL=1，表示当SCLK=1时处于空闲态，所以有效状态就是SCLK处于低电平时 时钟相位(CPHA)定义数据的采集时间。\nCPHA=0，在时钟的第一个跳变沿（上升沿或下降沿）进行数据采样。在第2个边沿发送数据 CPHA=1，在时钟的第二个跳变沿（上升沿或下降沿）进行数据采样。在第1个边沿发送数据 5.IIC https://blog.csdn.net/qq_38410730/article/details/80312357\nhttps://blog.csdn.net/as480133937/article/details/105366932\nIIC（Inter－Integrated Circuit）总线。**半双工通信。**飞利浦公司。\n标准模式的速率为100 kbps，快速模式为400 kbps。 传输距离：I2C也适用于短距离通信，典型的距离范围为几米。 支持多主控(multimastering)， 一个主控能够控制信号的传输和时钟频率。在任何时间点上只能有一个主控。\n两根信号线：\nSDA(Serial data)是数据线 SCL(Serial clock line)是时钟线 传输数据的过程中一共有三种类型信号，分别为：开始信号、结束信号和应答信号。这些信号中，起始信号是必需的。\n空闲状态\nSDA和SCL同时处于高电平时，规定为总线的空闲状态。由两条信号线各自的上拉电阻把电平拉高。 避免总线信号混乱，不会干扰其他设备。\nI2C 总线在传送数据过程中共有三种类型信号， 它们分别是：开始信号、结束信号和应答信号。\n开始信号：SCL 为高电平时，SDA 由高电平向低电平跳变，开始传送数据。 结束信号：SCL 为高电平时，SDA 由低电平向高电平跳变，结束传送数据。 应答信号：发送器每发送一个字节（8个bit），就在时钟脉冲9期间释放数据线，由接收器反馈一个应答信号。 应答信号为低电平时，规定为有效应答位（ACK，简称应答位），表示接收器已经成功地接收了该字节； 应答信号为高电平时，规定为非应答位（NACK），一般表示接收器接收该字节没有成功。 起始信号是必需的，\n数据有效性\nSDA线上的数据在SCL时钟“高”期间必须是稳定的，只有当SCL线上的时钟信号为低时，数据线上的“高”或“低”状态才可以改变。输出到SDA线上的每个字节必须是8位，数据传送时，先传送最高位（MSB），每一个被传送的字节后面都必须跟随一位应答位（即一帧共有9位）。\n当一个字节按数据位从高位到低位的顺序传输完后，紧接着从设备将拉低SDA线，回传给主设备一个应答位ACK， 此时才认为一个字节真正的被传输完成 ，\nIIC总线的数据传送\n多数从设备的地址为7位或者10位，一般都用七位。八位设备地址=7位从机地址+读/写地址，\n再给地址添加一个方向位位用来表示接下来数据传输的方向，\n0表示主设备向从设备(write)写数据，\n1表示主设备向从设备(read)读数据\n主设备往从设备中写数据。数据传输格式如下：\n主机首先产生START信号 然后紧跟着发送一个从机地址，这个地址共有7位，紧接着的第8位是数据方 向位(R/W)，0表示主机发送数据(写)，1表示主机接收数据(读) 主机发送地址时，总线上的每个从机都将这7位地址码与自己的地址进行比较，若相同，则认为自己正在被主机寻址，根据R/T位将自己确定为发送器和接收器 这时候主机等待从机的应答信号(A) 当主机收到应答信号时，发送要访问从机的那个地址， 继续等待从机的应答信号 当主机收到应答信号时，发送N个字节的数据，继续等待从机的N次应答信号， 主机产生停止信号，结束传送过程。 主设备从从设备中读数据。数据传输格式如下： 主机首先产生START信号 然后紧跟着发送一个从机地址，注意此时该地址的第8位为0，表明是向从机写命令， 这时候主机等待从机的应答信号(ACK) 当主机收到应答信号时，发送要访问的地址，继续等待从机的应答信号， 当主机收到应答信号后，主机要改变通信模式(主机将由发送变为接收，从机将由接收变为发送)所以主机重新发送一个开始start信号，然后紧跟着发送一个从机地址，注意此时该地址的第8位为1，表明将主机设 置成接收模式开始读取数据， 这时候主机等待从机的应答信号，当主机收到应答信号时，就可以接收1个字节的数据，当接收完成后，主机发送非应答信号，表示不在接收数据 主机进而产生停止信号，结束传送过程。 6.CAN 参考,参考2,参考3\nCAN总线标准之规定了物理层和数据链路层。物理层和数据链路层：ISO11898；高速\n高速CAN总线。闭环 短距离。最高速率为1Mbps，支持最长距离40m，总线两段安装端接电阻。\n低速CAN。开环 距离远。最高速度125Kbps，最远距离1km。\n差分信号\nCAN_HIGH减去CAN_LOW的到的\n0V\u0026mdash;\u0026mdash;\u0026mdash;逻辑1\u0026mdash;\u0026mdash;隐形电平 2.0V\u0026mdash;\u0026mdash;-逻辑0\u0026mdash;\u0026ndash;显性电平\n特点：\n多路载波侦听：网络上所有节点以多点接入的方式连接在同一根总线上，且发送数据是广播式的。网络上各个节点在发送数据前都要检测总线上是否有数据传输：若网络上有数据，暂时不发送数据，等待网络空闲时再发；若网络上无数据，立即发送已经准备好的数据。 冲突检测：节点在发送数据时，要不停的检测发送的数据，确定是否与其他节点数据发送冲突，如果有冲突，则保证优先级高的报文先发送。 非破坏性仲裁机制：通过ID仲裁，ID数值越小，报文优先级越高。 CAN一共规定了5中类型的帧\n面试问题 STM32参数 外设有哪些 输入输出类型 外设：GPIO、UART、SPI、I2C、USB接口、定时器、ADC\n输入输出：\n输入模式：\n输入上拉模式：引脚被配置为输入，但在未连接到外部信号时会被拉高。这有助于防止输入浮动，通常用于读取开关或按钮状态。 输入下拉模式：引脚被配置为输入，但在未连接到外部信号时会被拉低。这也有助于防止输入浮动，通常用于读取开关或按钮状态。 输入浮空模式：引脚被配置为输入，但不进行上拉或下拉。在这种模式下，引脚的电平状态由外部信号决定。 模拟输入模式：引脚被配置为模拟输入，用于连接模拟传感器或读取模拟信号。 中断模式：引脚被配置为中断输入，以便在引脚状态变化时触发中断处理程序。 输出模式：\n推挽输出模式：引脚被配置为输出，可以输出高电平或低电平。在推挽输出模式下，引脚可以提供较高的驱动电流。 开漏输出模式：引脚被配置为开漏输出，可以输出低电平或者高阻态。通常与外部上拉电阻结合使用，用于连接多个设备共享同一信号线。 复用功能模式：引脚被配置为复用功能模式，用于连接到复用功能的外设，例如UART、SPI、I2C等通信接口，以及定时器、PWM等功能。 模拟输出模式：引脚被配置为模拟输出，用于输出模拟信号 大华二面\n野指针的产生场景 野指针是指 指向已经释放或者无效的内存地址的指针。\n产生场景：\n内存释放后未置空指针 函数返回指针 指向函数内部的局部变量 最好方法是在释放内存后将指针置空，并且确保在超出指针的有效作用域之前不再使用它。\n线程AB交替输出12 用父类A实例化一个对象会不会造成内存泄漏\n","date":"2023-01-01T00:00:00Z","permalink":"https://raff-zeng.github.io/post/reading-notes/notes-at-school/embedinterview/","title":"嵌入式面试"},{"content":" title: \u0026lsquo;Ubuntu配置\u0026rsquo; date: 2024-12-24 draft: false searchHidden: false # 允许被搜索 categories:\ntech-blogs tags: ubuntu ros 1 换国内源 环境：ubuntu22.04, ros noetic\n1.1 ros1 noetic 1.1.1 换linux源 清华源： https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/\n1 2 3 cd /etc/apt/ sudo cp sources.list sources.list.bak sudo vim sources.list /etc/apt/sources.list:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse # 以下安全更新软件源包含了官方源与镜像站配置，如有需要可自行修改注释切换 deb http://security.ubuntu.com/ubuntu/ focal-security main restricted universe multiverse # deb-src http://security.ubuntu.com/ubuntu/ focal-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse # # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse 1 2 sudo apt update sudo apt upgrade 1.1.2 换ros源 安装ROS：https://wiki.ros.org/noetic/Installation/Ubuntu\n/etc/apt/sources.list.d/ros-latest.list:\n1 2 3 4 5 # ROS官方源 sudo sh -c \u0026#39;echo \u0026#34;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\u0026#34; \u0026gt; /etc/apt/sources.list.d/ros-latest.list\u0026#39; # 清华源 sudo sh -c \u0026#39;echo \u0026#34;deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu $(lsb_release -sc) main\u0026#34; \u0026gt; /etc/apt/sources.list.d/ros-latest.list\u0026#39; 1 2 3 4 5 6 7 8 9 10 11 # 使用rosdepc pip3 install rosdepc sudo rosdepc init rosdepc update rosdepc install --from-paths src --ignore-src --rosdistro ${ROS_DISTRO} -r -y # 使用rosdep sudo apt install python3-rosdep sudo rosdep init rosdep update rosdep install --from-paths src --ignore-src --rosdistro ${ROS_DISTRO} -r -y 删除rosdep配置文件\nsudo rm /etc/ros/rosdep/sources.list.d/20-default.list\n1.2 ros2 humble 环境：ubuntu24.04, ros2 humble\n1.2.1 换linux源 清华源： https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/\n1 2 3 cd /etc/apt/ sudo cp sources.list sources.list.bak sudo vim sources.list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse # 以下安全更新软件源包含了官方源与镜像站配置，如有需要可自行修改注释切换 deb http://security.ubuntu.com/ubuntu/ jammy-security main restricted universe multiverse # deb-src http://security.ubuntu.com/ubuntu/ jammy-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse # # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse 1 2 sudo apt update sudo apt upgrade 1.2.2 换ros源 安装ros humble：https://docs.ros.org/en/humble/Installation/Ubuntu-Install-Debs.html\n小鱼一键安装wget http://fishros.com/install -O fishros \u0026amp;\u0026amp; . fishros 1 2 3 4 5 # 官方源 echo \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release \u0026amp;\u0026amp; echo $UBUNTU_CODENAME) main\u0026#34; | sudo tee /etc/apt/sources.list.d/ros2.list \u0026gt; /dev/null # 清华源 echo \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] https://mirrors.tuna.tsinghua.edu.cn/ros2/ubuntu $(. /etc/os-release \u0026amp;\u0026amp; echo $UBUNTU_CODENAME) main\u0026#34; | sudo tee /etc/apt/sources.list.d/ros2.list \u0026gt; /dev/null 1 2 3 4 5 6 7 8 9 10 11 # 使用rosdepc pip3 install rosdepc sudo rosdepc init rosdepc update rosdepc install --from-paths src --ignore-src --rosdistro humble -r -y # 使用rosdep sudo apt install python3-rosdep sudo rosdep init rosdep update rosdep install --from-paths src --ignore-src --rosdistro humble -r -y 删除rosdep配置文件\nsudo rm /etc/ros/rosdep/sources.list.d/20-default.list\n1.3 raw.githubusercontent.com相关错误 到https://www.ipaddress.com/ 查raw.githubusercontent.com的ip\n1 sudo sh -c \u0026#39;echo \u0026#34;185.199.108.133 raw.githubusercontent.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts\u0026#39; 二、虚拟机vmvare17-ubuntu2204 1.1 Ubuntu路径映射到windows的网络盘符 1 2 3 sudo apt install samba sudo cp /etc/samba/smb.conf /etc/samba/smb.conf.bak sudo vim /etc/samba/smb.conf 1 2 3 4 5 6 7 8 9 10 11 12 [global] guest account = raff security = user [public] path = /home/raff public = yes writeable = yes browseable = yes guest ok = yes create mask = 0644 acl allow execute always = yes 重启samba服务\n1 /etc/init.d/smbd restart windows右键此电脑映射网络盘\\\\192.168.0.100\\public 192.168.0.100为到Ubuntu. ifconfig查看的IP地址\n1.2 vmvare配置 1.2.1 关闭hyper-v相关 win+r，输入services.msc(右键此电脑-管理). 禁用所有hyper-v相关服务\n控制面板-程序与功能-取消虚拟化相关的打勾\n关闭内核隔离\ncmd： bcdedit /enum或msinfo32 查看\n1.2.2 vmvare tools安装 sudo apt install open-vm-tools open-vm-tools-desktop\n","date":"0001-01-01T00:00:00Z","permalink":"https://raff-zeng.github.io/post/tech-blogs/linux-start/","title":""}]